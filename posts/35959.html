<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>python信号处理 | がんばろう</title><meta name="author" content="今天睡够了吗"><meta name="copyright" content="今天睡够了吗"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Scipy 是基于 Numpy 的科学计算库，用于数学、科学、工程学等领域 包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算 信号处理12import numpy as npimport matplotlib.pyplot as plt  正弦波表达：$$x(t) = A_1\sin (2\pi f_1t+">
<meta property="og:type" content="article">
<meta property="og:title" content="python信号处理">
<meta property="og:url" content="http://yhblogs.cn/posts/35959.html">
<meta property="og:site_name" content="がんばろう">
<meta property="og:description" content="Scipy 是基于 Numpy 的科学计算库，用于数学、科学、工程学等领域 包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算 信号处理12import numpy as npimport matplotlib.pyplot as plt  正弦波表达：$$x(t) = A_1\sin (2\pi f_1t+">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-pokg2e.webp">
<meta property="article:published_time" content="2025-09-18T13:04:57.000Z">
<meta property="article:modified_time" content="2025-11-01T15:04:06.750Z">
<meta property="article:author" content="今天睡够了吗">
<meta property="article:tag" content="⌨️python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-pokg2e.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yhblogs.cn/posts/35959.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'python信号处理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-01 15:04:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3319458_ks437t3n4r.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/b_2a1aef95f351a5f7ef72eb81e6838fd6.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-rili"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="がんばろう"><img class="site-icon" src="/img/favicon.png"><span class="site-name">がんばろう</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-rili"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">python信号处理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-09-18T13:04:57.000Z" title="发表于 2025-09-18 13:04:57">2025-09-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="python信号处理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>Scipy 是基于 Numpy 的科学计算库，用于数学、科学、工程学等领域</p>
<p>包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算</p>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></tbody></table></figure>

<p>正弦波表达：<br>$$<br>x(t) = A_1\sin (2\pi f_1t+\phi_1)+A_2\sin (2\pi f_2t+\phi_2)<br>$$<br>添加高斯白噪声：noise_signal = signal + noise, 其中noise$\sim N(0,\sigma^2) $</p>
<h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> fft</span><br></pre></td></tr></tbody></table></figure>

<p>傅里叶变换将时域信号变换到频域，分析不同频率分量</p>
<p>计算机处理的是离散采样信号，DFT 是傅里叶变换的离散形式</p>
<p>FFT是DFT的高效算法，将计算复杂度从$O(N^2)$降至$O(N\log N)$，极大提升计算速度</p>
<p>输出结果为复数数组，幅度：频率成分的强度(<code>np.abs(x)</code>)  相位：频率成分的偏移(<code>np.angle(X)</code>)</p>
<blockquote>
<p>numpy也有<code>fft</code>模块，两者的接口相同，但是只能用CPU，不支持并行或GPU，尽量用scipy库内的</p>
</blockquote>
<p>信号参数：采样率$f_s$  信号频率$f$  采样时间$T$  采样点数$N=f_s\cdot T$</p>
<p>频率分辨率：$\Delta f= f_s/N$，当信号频率不是$\Delta f$的整数倍时，能量会“泄露”到相邻频段，详见频谱泄露</p>
<p><font color="Violetred">奈奎斯特采样频率：采样频率至少是信号最高频率的两倍，才能无失真地重建原始信号</font></p>
<p>对于实数输入信号，频域结果具有<strong>共轭对称性</strong>：</p>
<ul>
<li>后一半频率是前一半的镜像(忽略 Nyquist 频率点)</li>
<li>实际分析时通常取前半部分(单侧频谱)</li>
</ul>
<p>可以只计算正频率部分，输出长度减半：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接保留正部分</span></span><br><span class="line">fft.rfft(sig)    </span><br><span class="line">fft.rfftfreq(n,d) </span><br><span class="line"><span class="comment"># 普通写法</span></span><br><span class="line">fft.fft(sig)[:N//<span class="number">2</span>]</span><br><span class="line">fft.fftfreq(n,d)[:N//<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 通过`fftshift`可以换成[-fs/2...fs/2]的对称频率谱</span></span><br></pre></td></tr></tbody></table></figure>

<p>$n$为信号长度，$d$为采样间隔，返回对应傅里叶变换的频率轴</p>
<p>默认的FFT函数只做了求和，所以计算出来的幅值会比实际大<code>N</code>倍</p>
<p>如果只取正频率部分，需要乘上<code>2/N</code>做归一化，归一化是为了保证数值物理意义正确</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnitude = <span class="number">2</span>/N * np.<span class="built_in">abs</span>(signal_fft)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>一维傅里叶变换</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">f1, f2, fs, T= <span class="number">50</span>, <span class="number">200</span>, <span class="number">500</span>, <span class="number">1.0</span></span><br><span class="line">N = <span class="built_in">int</span>(fs*T) <span class="comment"># 采样点数</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, N, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal1 = <span class="number">0.7</span> * np.sin(<span class="number">2</span> * np.pi * f1 * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * f2 * t)</span><br><span class="line"><span class="comment"># 计算傅里叶变换</span></span><br><span class="line">signal_fft = fft.rfft(signal1)</span><br><span class="line"><span class="comment"># 获取频率轴</span></span><br><span class="line">freqs = fft.rfftfreq(N, <span class="number">1</span>/fs)</span><br><span class="line"><span class="comment"># 计算归一化幅度谱</span></span><br><span class="line">magnitude = <span class="number">2</span>/N * np.<span class="built_in">abs</span>(signal_fft)</span><br><span class="line">reconstructed_signal = fft.ifft(signal_fft)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t[:<span class="number">100</span>], signal1[:<span class="number">100</span>], <span class="string">'r'</span>)</span><br><span class="line">plt.title(<span class="string">"Time Domain Signal"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Time [s]"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Time [s]"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Amplitude"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(freqs, magnitude, <span class="string">'g'</span>)</span><br><span class="line">plt.title(<span class="string">"Magnitude Spectrum"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Frequency [Hz]"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Amplitude"</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<p><strong>二维傅里叶</strong>：</p>
<p>在图像处理分析中一般不选择归一化，因为主要目的是「看结构而不是看数值」</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个二维信号(例如图像)</span></span><br><span class="line">image = np.random.random((<span class="number">256</span>, <span class="number">256</span>))  <span class="comment"># 256x256的随机图像</span></span><br><span class="line"><span class="comment"># 对二维信号进行傅里叶变换</span></span><br><span class="line">fft_image = fft.fft2(image)  <span class="comment"># 不用rfft2，无法同时双轴处理</span></span><br><span class="line"><span class="comment"># 移动频率成分，使得零频率部分位于中心</span></span><br><span class="line">fft_image_shifted = fft.fftshift(fft_image)</span><br><span class="line"><span class="comment"># 计算幅度谱(Magnitude Spectrum)</span></span><br><span class="line">magnitude_spectrum = np.<span class="built_in">abs</span>(fft_image_shifted) <span class="comment"># 未归一化</span></span><br><span class="line"><span class="comment"># 计算幅度谱的对数，便于显示</span></span><br><span class="line">log_magnitude_spectrum = np.log(magnitude_spectrum + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 可视化频谱</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">plt.imshow(log_magnitude_spectrum, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">"Magnitude Spectrum (Log Scale)"</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<p>归一化场景分析：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否需要归一化</th>
<th>原因 / 目标</th>
</tr>
</thead>
<tbody><tr>
<td>频谱图展示(图像/信号)</td>
<td>不需要</td>
<td>只看频率分布，不关心绝对幅度<br>未归一化+log 更直观</td>
</tr>
<tr>
<td>信号幅值恢复</td>
<td>需要</td>
<td>FFT默认放大N倍，必须除以N才能得到真实幅度</td>
</tr>
<tr>
<td>功率/能量分析</td>
<td>需要</td>
<td>保证时域能量与频域能量一致</td>
</tr>
<tr>
<td>滤波器设计/频域运算</td>
<td>需要</td>
<td>滤波器幅值必须落在理论范围内，否则滤波结果能量失真</td>
</tr>
<tr>
<td>逆变换恢复图像/信号</td>
<td>看情况</td>
<td>如果正向和逆向保持一致就不必管；如果只做正向归一化，需要注意逆变换对应的系数</td>
</tr>
</tbody></table>
<h3 id="滤波器设计"><a href="#滤波器设计" class="headerlink" title="滤波器设计"></a>滤波器设计</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br></pre></td></tr></tbody></table></figure>

<p>以巴特沃斯滤波器的函数举例，各个滤波器之间的参数设置基本一致</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">butter(N, Wn, btype=<span class="string">'low'</span>, analog=<span class="literal">False</span>, output=<span class="string">'ba'</span>, fs=<span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>N</code>：滤波器阶数，阶数越高，滤波越陡峭</li>
<li><code>Wn</code>：截止频率，是一个长度为2的序列，单个或区间上下限</li>
<li><code>btype</code>：滤波器类型，包括低通滤波器(low)、高通滤波器(high)、带通滤波器(band)、带阻滤波器(bandstop)，默认为low</li>
<li><code> analog</code>：默认返回一个数字滤波器，如果为True则返回一个模拟滤波器</li>
<li><code>output</code>：输出，默认<code>'ba'</code>，可选<code>zpk</code>和<code>sos</code></li>
<li><code>fs</code>：系统的采样频率，如果不提供会报错</li>
</ul>
<p>也可以写成：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">butter(N, Wn/fs, btype=<span class="string">'low'</span>, analog=<span class="literal">False</span>, output=<span class="string">'ba'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>IIR滤波器</strong>：</p>
<p>巴特沃斯滤波器：常见的滤波器，它的特点是保持平滑的频率响应，没有波动，适用于那些要求频率响应平稳的应用</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fs = <span class="number">500</span>  <span class="comment"># 采样频率 500Hz</span></span><br><span class="line">lowcut = <span class="number">100.0</span>  <span class="comment"># 截止频率 100Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用巴特沃斯滤波器设计一个4阶低通滤波器</span></span><br><span class="line">b, a = signal.butter(<span class="number">4</span>, lowcut, btype=<span class="string">'low'</span>, fs=fs)</span><br><span class="line"><span class="comment"># 打印滤波器系数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"滤波器系数 b: <span class="subst">{b}</span>"</span>) <span class="comment"># 滤波器的分子系数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"滤波器系数 a: <span class="subst">{a}</span>"</span>) <span class="comment"># 滤波器的分母系数</span></span><br><span class="line"><span class="comment"># 计算频率响应</span></span><br><span class="line">w, h = signal.freqz(b, a, worN=<span class="number">2000</span>, fs=fs)</span><br><span class="line"><span class="comment"># 绘制滤波器频率响应</span></span><br><span class="line">plt.plot(w, <span class="built_in">abs</span>(h), <span class="string">'b'</span>)</span><br><span class="line">plt.title(<span class="string">'巴特沃斯低通滤波器频率响应'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'频率 [Hz]'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'幅度'</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<p>切比雪夫滤波器：能够提供更陡峭的频率响应，但它会引入波动(波纹)，可以用于需要锐利频率选择的场景</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rp = <span class="number">1</span>  <span class="comment"># 通带最大波纹(dB)</span></span><br><span class="line">lowcut = <span class="number">100.0</span>  <span class="comment"># 截止频率 100Hz</span></span><br><span class="line"><span class="comment"># 使用切比雪夫I型滤波器设计一个4阶低通滤波器</span></span><br><span class="line">b, a = signal.cheby1(<span class="number">4</span>, rp, lowcut, fs=fs)</span><br><span class="line"><span class="comment"># 计算频率响应</span></span><br><span class="line">w, h = signal.freqz(b, a, worN=<span class="number">2000</span>, fs=fs)</span><br><span class="line"><span class="comment"># 绘制滤波器频率响应</span></span><br><span class="line">plt.plot(w, <span class="built_in">abs</span>(h), <span class="string">'r'</span>)</span><br><span class="line">plt.title(<span class="string">'切比雪夫I型低通滤波器频率响应'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'频率 [Hz]'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'幅度'</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<p>二阶陷波和谐振滤波器：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs, f0, Q = <span class="number">500</span>, <span class="number">100</span>, <span class="number">30</span> <span class="comment"># f0为陷波/谐振频率</span></span><br><span class="line">b_notch, a_notch = signal.iirnotch(f0, Q, fs=fs)   <span class="comment"># 直接传f0,需要品质因子</span></span><br><span class="line">b_peak, a_peak = signal.iirpeak(f0, Q, fs=fs)</span><br><span class="line"><span class="comment"># 计算频率响应</span></span><br><span class="line">w1, h1 = signal.freqz(b_notch, a_notch, worN=<span class="number">2000</span>, fs=fs)</span><br><span class="line">w2, h2 = signal.freqz(b_peak, a_peak, worN=<span class="number">2000</span>, fs=fs)</span><br><span class="line"><span class="comment"># 绘制滤波器频率响应</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(w1, <span class="built_in">abs</span>(h1), <span class="string">'r'</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(w2, <span class="built_in">abs</span>(h2), <span class="string">'g'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>FIR 滤波器</strong>：</p>
<p>可以通过选择不同的窗函数来实现低通、高通等滤波效果</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用窗函数法设计一个低通FIR滤波器</span></span><br><span class="line">numtaps = <span class="number">101</span>  <span class="comment"># 滤波器的长度(系数个数)</span></span><br><span class="line">b = signal.firwin(numtaps, lowcut, pass_zero=<span class="literal">True</span>, fs=fs)</span><br><span class="line"><span class="comment"># 计算频率响应</span></span><br><span class="line">w, h = signal.freqz(b, worN=<span class="number">2000</span>, fs=fs)</span><br><span class="line"><span class="comment"># 绘制滤波器频率响应</span></span><br><span class="line">plt.plot(w, <span class="built_in">abs</span>(h), <span class="string">'g'</span>)</span><br><span class="line">plt.title(<span class="string">'FIR低通滤波器频率响应'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'频率 [Hz]'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'幅度'</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="滤波操作"><a href="#滤波操作" class="headerlink" title="滤波操作"></a>滤波操作</h3><p>常见的两个函数：</p>
<ul>
<li><p><code>scipy.signal.lfilter</code>：使用递归公式对输入信号进行滤波</p>
</li>
<li><p><code>scipy.signal.filtfilt</code>：对信号进行零相位滤波，即滤波操作前后都进行一次</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filtered = signal.lfilter(b, a, noise_signal)</span><br><span class="line">filtered = signal.filtfilt(b, a, noise_signal)</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>特性</th>
<th><code>lfilter</code></th>
<th><code>filtfilt</code></th>
</tr>
</thead>
<tbody><tr>
<td>滤波方向</td>
<td>单向滤波(从前到后)</td>
<td>双向滤波(从前到后 + 从后到前)</td>
</tr>
<tr>
<td>相位延迟</td>
<td>引入相位延迟(有延迟)</td>
<td>无相位延迟(零相位)</td>
</tr>
<tr>
<td>输出信号</td>
<td>会有信号的末尾和开始部分的失真</td>
<td>保持原始信号的时域特性，不会有失真</td>
</tr>
<tr>
<td>计算性能</td>
<td>计算速度较快，适用于实时信号处理</td>
<td>需要更多计算，适用于离线处理，较慢</td>
</tr>
<tr>
<td>使用场景</td>
<td>实时滤波，延迟容忍的应用</td>
<td>高精度滤波，要求保持信号时域特性</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">生成信号(1 kHz + 2 Khz + 50 Hz + 噪声)，进行FFT分析，</span></span><br><span class="line"><span class="string">应用带阻(50 Hz)+ 巴特沃斯低通(1.5kHz)滤波，</span></span><br><span class="line"><span class="string">绘制并保存结果</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> scipy.signal <span class="keyword">as</span> signal</span><br><span class="line"><span class="keyword">import</span> scipy.fft <span class="keyword">as</span> fft</span><br><span class="line"></span><br><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">OUTPUT_DIR = <span class="string">"res"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">TimeAndFFT_plot</span>(<span class="params">t_seg, sig, fs, title</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(sig)</span><br><span class="line">    seg_len = <span class="built_in">len</span>(t_seg)</span><br><span class="line">    freq = fft.rfftfreq(N, <span class="number">1</span>/fs)</span><br><span class="line">    magnitude = <span class="number">2</span>/N*np.<span class="built_in">abs</span>(fft.rfft(sig))</span><br><span class="line">    fig, (ax1,ax2) = plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    ax1.plot(t_seg, sig[:seg_len], <span class="string">'r--'</span>)</span><br><span class="line">    ax1.set_title(title+<span class="string">" Time-domain"</span>)</span><br><span class="line">    ax1.set_xlabel(<span class="string">"Time (s)"</span>)</span><br><span class="line">    ax1.set_ylabel(<span class="string">"Amplitude"</span>)</span><br><span class="line">    ax1.grid()</span><br><span class="line"></span><br><span class="line">    ax2.plot(freq, magnitude, <span class="string">'g'</span>)</span><br><span class="line">    ax2.set_title(title+<span class="string">" FFT"</span>)</span><br><span class="line">    ax2.set_xlabel(<span class="string">"Frequency (Hz)"</span>)</span><br><span class="line">    ax2.set_ylabel(<span class="string">"Magnitude"</span>)</span><br><span class="line">    ax2.set_xlim(<span class="number">0</span>,<span class="number">2200</span>)</span><br><span class="line">    ax2.grid()</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    savepath = Path(OUTPUT_DIR)/<span class="string">f"<span class="subst">{title}</span>.png"</span></span><br><span class="line">    plt.savefig(savepath, dpi=<span class="number">300</span>)</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># ==== 参数设置 ====</span></span><br><span class="line">    Path(OUTPUT_DIR).mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    fs = <span class="number">10000</span></span><br><span class="line">    duration = <span class="number">1</span></span><br><span class="line">    N = <span class="built_in">int</span>(fs*duration)</span><br><span class="line">    t = np.arange(N)/fs</span><br><span class="line">    <span class="comment"># ==== 信号组成 ====</span></span><br><span class="line">    f = <span class="number">1000</span></span><br><span class="line">    f_inter = <span class="number">50</span></span><br><span class="line">    amp1 = <span class="number">0.7</span></span><br><span class="line">    amp2 = <span class="number">0.6</span></span><br><span class="line">    amp_inter = <span class="number">0.5</span></span><br><span class="line">    rand_std = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==== 信号产生 ====</span></span><br><span class="line">    signal_clean = amp1*np.sin(<span class="number">2</span>*np.pi*f*t) + amp2*np.sin(<span class="number">2</span>*np.pi*<span class="number">2</span>*f*t)+amp_inter*np.sin(<span class="number">2</span>*np.pi*f_inter*t)</span><br><span class="line">    noise = <span class="number">0.2</span>*rng.normal(<span class="number">0</span>, rand_std, N)</span><br><span class="line">    signal_noise = signal_clean + noise</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于时域可视化的短时段（前0.01秒）</span></span><br><span class="line">    seg_len = <span class="built_in">int</span>(<span class="number">0.01</span>*fs)</span><br><span class="line">    t_seg = t[:seg_len]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==== 绘制时域图和频谱图 ====</span></span><br><span class="line">    TimeAndFFT_plot(t_seg, signal_clean, fs, <span class="string">"original"</span>)</span><br><span class="line">    TimeAndFFT_plot(t_seg, signal_noise, fs, <span class="string">"noisy"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==== 滤波器设计 ====</span></span><br><span class="line">    lowcut = <span class="number">1500</span></span><br><span class="line">    b_lp, a_lp = signal.butter(<span class="number">4</span>, lowcut, btype=<span class="string">'low'</span>, fs=fs) <span class="comment"># 低通滤波器</span></span><br><span class="line">    f0, Q = <span class="number">50.0</span>, <span class="number">30</span></span><br><span class="line">    w0 = f0/(fs/<span class="number">2</span>)</span><br><span class="line">    b_notch, a_notch = signal.iirnotch(w0,Q)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==== 滤波操作 ====</span></span><br><span class="line">    sig_lp = signal.filtfilt(b_lp, a_lp, signal_noise)</span><br><span class="line">    sig_notch = signal.filtfilt(b_notch, a_notch, signal_noise)</span><br><span class="line">    sig_lp_notch = signal.filtfilt(b_notch, a_notch, sig_lp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==== 绘制时域图和频谱图 ====</span></span><br><span class="line">    TimeAndFFT_plot(t_seg, sig_lp, fs, <span class="string">"lowpass"</span>)</span><br><span class="line">    TimeAndFFT_plot(t_seg, sig_notch, fs, <span class="string">"notch"</span>)</span><br><span class="line">    TimeAndFFT_plot(t_seg, sig_lp_notch, fs, <span class="string">"lowpass+notch"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>数学公式：<br>$$<br>y[n]=(x*h)[n]=\sum_{k=-\infty}^\infty x[k]\cdot h[n-k]<br>$$<br>信号$x[n]$和滤波器$h[n]$的“滑动加权叠加”</p>
<p>移动平均滤波器(最简单的滤波器，等价于低通)：<br>$$<br>y[n]=\frac{1}{M}\sum_{k=0}^{M-1}x[n-k]<br>$$<br>本质上就是卷积核 $h[n] = [1/M, 1/M, …, 1/M]$</p>
<p>虽然numpy库内也有卷积函数，但是大部分情况下还是选用scipy库的卷积函数，对比如下：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>np.convolve</code></th>
<th><code>scipy.signal.convolve</code></th>
</tr>
</thead>
<tbody><tr>
<td>支持维度</td>
<td>仅限一维 (1D)</td>
<td>支持任意维度(1D/2D/3D)</td>
</tr>
<tr>
<td>计算速度</td>
<td>小型一维数据较快</td>
<td>大型或多维数据优化更好</td>
</tr>
<tr>
<td>功能扩展</td>
<td>基础功能</td>
<td>支持复数、FFT加速、边界处理等高级选项</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal.convolve(in1, in2, mode=<span class="string">'same'</span>, method=<span class="string">'auto'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><code>mode</code>(输出尺寸)：</p>
<ul>
<li><code>'full'</code>：完整线性卷积[默认]</li>
<li><code>'same'</code>：输出与<code>in1</code>同形，且在<code>full</code>结果中居中对齐</li>
<li><code>'valid'</code>：输出仅包含那些不依赖于零填充的元素(要求<code>in1</code>或<code>in2</code>至少一个在每个维度上必须至少与另一个一样大)</li>
</ul>
<p><code>method</code>(计算方法)：</p>
<ul>
<li><code>'direct'</code>：卷积直接由和来确定，即卷积的定义(适合 kernel 很短或只需少量输出点时)</li>
<li><code>'fft'</code>：通过 FFT 计算(内部调用<code>fftconvolve</code>)</li>
<li><code>'auto'</code>：根据对哪种方法更快进行的估计自动选择直接方法或傅里叶方法[默认]</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = np.ones(M)/M <span class="comment"># M越大平滑效果越好</span></span><br><span class="line">smoothed = signal.convolve(signal1, h, <span class="string">'same'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="频谱泄露"><a href="#频谱泄露" class="headerlink" title="频谱泄露"></a>频谱泄露</h3><p>频谱泄漏是指在进行傅里叶变换时，由于信号截断或周期化造成的频谱畸变现象，是离散傅里叶变换DFT中一个非常常见的现象</p>
<p>简单来说就是原本应该集中在一个频率点上的能量，由于“泄漏”到了其他频率点上，导致频谱变得模糊不清</p>
<ul>
<li>理想频谱：单一频率的冲击函数</li>
<li>泄露后的频谱：主瓣拓宽 + 旁瓣拖尾</li>
</ul>
<p><strong>为什么会发生频谱泄漏？</strong></p>
<p><font color="Violetred">DFT假设信号是周期性的</font>，且采样窗口是信号的精确周期</p>
<p>如果信号的频率刚好是采样频率分辨率的整数倍，那么周期延拓时首尾能够平滑拼接，频谱会集中在对应的频率点上</p>
<p>如果不是整数倍，则首尾无法拼接，周期性假设失效，等效于信号被突然截断，相当于乘了一个矩形窗，而在频域上，乘法相当于卷积</p>
<p>矩形窗的频谱是一个<code>sinc</code>函数，主瓣窄但旁瓣高，在频域里就会产生旁瓣扩展，能量扩散到多个频率点上，这就是频谱泄漏</p>
<p>本质：有限截断信号等效于矩形窗乘积 → 频域产生卷积 → 能量扩散</p>
<p>举个例子：</p>
<p>$f_s=1000Hz,N=1000\rightarrow \Delta f=f_s/N=1Hz$</p>
<p>如果信号频率为50Hz，对齐FFT频点，那么频谱主要集中在50Hz处；</p>
<p>如果信号频率为50.5Hz，不在整数频点，那么频谱主瓣在50.5Hz处，但能量会扩散到周围很多频率点，看起来拖尾 </p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>增加采样点数N：提高频率分辨率$\Delta f= f_s/N$，让频率更接近FFT栅格</li>
<li>加窗函数：用汉宁窗、汉明窗、布莱克曼窗等替代矩形窗，减少旁瓣泄漏，但<font color="Violetred">会增宽主瓣</font></li>
<li><font color="Violetred">零填充</font>：在进行FFT变换之前，在信号末尾添加若干个零，可以提高频谱显示的平滑度(可以提高频谱分辨率，但并不能消除频谱泄漏)</li>
</ul>
<p>实际应用要在“泄漏小”和“分辨率高”之间折中</p>
<p>当采样率不变的情况下，提高频率分辨率的方法就是增加采样时间</p>
<h4 id="窗函数"><a href="#窗函数" class="headerlink" title="窗函数"></a>窗函数</h4><p>窗函数通过在信号两端平滑过渡到零，减少边界不连续性，从而：</p>
<ol>
<li>抑制频谱泄露(降低旁瓣)</li>
<li>提高频率分辨率(窄化主瓣)</li>
</ol>
<p>常用评价指标：</p>
<ul>
<li>主瓣宽度：影响能否分辨紧邻的频率</li>
<li>旁瓣电平：决定泄漏到远处的能量大小(越低越好)</li>
</ul>
<table>
<thead>
<tr>
<th>窗函数</th>
<th>主瓣宽度</th>
<th>旁瓣峰值(dB)</th>
<th>常用场景</th>
</tr>
</thead>
<tbody><tr>
<td>矩形窗</td>
<td>最窄</td>
<td>-13</td>
<td>瞬时分析</td>
</tr>
<tr>
<td>Hann窗(汉宁窗)</td>
<td>中等</td>
<td>-31</td>
<td>通用场景</td>
</tr>
<tr>
<td>Hamming窗(海明窗)</td>
<td>稍窄</td>
<td>-41</td>
<td>音频处理</td>
</tr>
<tr>
<td>Blackman窗(布莱克曼窗)</td>
<td>宽</td>
<td>-58</td>
<td>高精度测量</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> windows</span><br><span class="line"></span><br><span class="line">N = <span class="number">1024</span>  <span class="comment"># 窗长度</span></span><br><span class="line"><span class="comment"># 生成窗函数</span></span><br><span class="line">hanning = windows.hann(N)        <span class="comment"># 汉宁窗</span></span><br><span class="line">hamming = windows.hamming(N)     <span class="comment"># 海明窗</span></span><br><span class="line">blackman = windows.blackman(N)   <span class="comment"># 布莱克曼窗</span></span><br><span class="line">rect = np.ones(N)                <span class="comment"># 矩形窗</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化窗函数</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(hanning, label=<span class="string">'Hann'</span>)</span><br><span class="line">plt.plot(hamming, label=<span class="string">'Hamming'</span>)</span><br><span class="line">plt.plot(blackman, label=<span class="string">'Blackman'</span>)</span><br><span class="line">plt.plot(rect, <span class="string">'--'</span>, label=<span class="string">'Rectangular'</span>)</span><br><span class="line">plt.legend(); plt.title(<span class="string">'常用窗函数'</span>); plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>一个50Hz正弦波，采样率1000，采样215点(周期不再整数倍，出现泄露)</p>
<p>对比不同窗函数的频谱，并采用零填充使得频谱平滑</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> windows</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置中文字体支持</span></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>, <span class="string">'Microsoft YaHei'</span>, <span class="string">'KaiTi'</span>, <span class="string">'SimSun'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br><span class="line">palette = plt.get_cmap(<span class="string">'Set1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 参数设置 ====</span></span><br><span class="line">fs = <span class="number">1000</span>   <span class="comment"># 采样率 Hz</span></span><br><span class="line">f = <span class="number">50</span>      <span class="comment"># 信号频率 Hz</span></span><br><span class="line">N = <span class="number">215</span>     <span class="comment"># 采样点数(故意不匹配) 分辨率为1/T=4.65Hz</span></span><br><span class="line">fft_size = <span class="number">1024</span> <span class="comment"># 零填充，插值让曲线更平滑，建议 4~8 倍且为2的幂次</span></span><br><span class="line">t = np.arange(N) / fs</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 生成信号 ====</span></span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * f * t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 窗函数字典 ====</span></span><br><span class="line">windows_dict = {</span><br><span class="line">    <span class="string">"矩形窗"</span>: np.ones(N),</span><br><span class="line">    <span class="string">"汉宁窗"</span>: windows.hann(N),</span><br><span class="line">    <span class="string">"海明窗"</span>: windows.hamming(N),</span><br><span class="line">    <span class="string">"布莱克曼窗"</span>: windows.blackman(N)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== FFT 计算函数 ====</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_fft</span>(<span class="params">sig, win, fs</span>):</span><br><span class="line">    sig_win = sig * win</span><br><span class="line">    <span class="comment"># 会自动在信号后面补零到fft_size点，再做 FFT，实现零填充</span></span><br><span class="line">    <span class="comment"># 使得输出曲线更平滑，但分辨率不变</span></span><br><span class="line">    fft_vals = np.fft.rfft(sig_win, fft_size)</span><br><span class="line">    freqs = np.fft.rfftfreq(fft_size, <span class="number">1</span>/fs)</span><br><span class="line">    <span class="comment"># 修正幅度：除以窗口均值，保证幅度不会因加窗衰减</span></span><br><span class="line">    magnitude = np.<span class="built_in">abs</span>(fft_vals) / (N * np.mean(win)) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> freqs, magnitude, sig_win</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 存储结果 ====</span></span><br><span class="line">results = {}</span><br><span class="line"><span class="keyword">for</span> name, win <span class="keyword">in</span> windows_dict.items():</span><br><span class="line">    freqs, mag, sig_win = compute_fft(signal, win, fs)</span><br><span class="line">    results[name] = {<span class="string">"freqs"</span>: freqs, <span class="string">"mag"</span>: mag, <span class="string">"sig"</span>: sig_win}</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 绘制时域信号 ====</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.title(<span class="string">"不同窗函数的时域信号"</span>)</span><br><span class="line"><span class="keyword">for</span> name, res <span class="keyword">in</span> results.items():</span><br><span class="line">    plt.plot(t[N//<span class="number">2</span>-<span class="number">50</span>:N//<span class="number">2</span>+<span class="number">50</span>], res[<span class="string">"sig"</span>][N//<span class="number">2</span>-<span class="number">50</span>:N//<span class="number">2</span>+<span class="number">50</span>], label=name)</span><br><span class="line">plt.xlabel(<span class="string">"时间 (s)"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"幅度"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 分图绘制频谱对比(对数 dB) ====</span></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># enumerate(..., 1) 给循环编号</span></span><br><span class="line"><span class="keyword">for</span> i, (name, res) <span class="keyword">in</span> <span class="built_in">enumerate</span>(results.items(), <span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 先归一化，让主瓣的最大值为1，再转到dB(20*log10(...))</span></span><br><span class="line">    mag_db = <span class="number">20</span> * np.log10(res[<span class="string">"mag"</span>] / np.<span class="built_in">max</span>(res[<span class="string">"mag"</span>]) + <span class="number">1e-12</span>)</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i)</span><br><span class="line">    plt.plot(res[<span class="string">"freqs"</span>], mag_db, color=palette(i))</span><br><span class="line">    plt.title(<span class="string">f"<span class="subst">{name}</span> 频谱 (dB)"</span>)</span><br><span class="line">    plt.xlim(<span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line">    plt.ylim(-<span class="number">120</span>, <span class="number">5</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"频率 (Hz)"</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"相对幅度 (dB)"</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 绘制频域对比(对数 dB)====</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.title(<span class="string">"不同窗函数的频谱泄漏对比"</span>)</span><br><span class="line"><span class="keyword">for</span> name, res <span class="keyword">in</span> results.items():</span><br><span class="line">    mag_db = <span class="number">20</span> * np.log10(res[<span class="string">"mag"</span>] / np.<span class="built_in">max</span>(res[<span class="string">"mag"</span>]) + <span class="number">1e-12</span>)</span><br><span class="line">    plt.plot(res[<span class="string">"freqs"</span>], mag_db, label=name)</span><br><span class="line">plt.axvline(x=f, color=<span class="string">'r'</span>, linestyle=<span class="string">'--'</span>, alpha=<span class="number">0.5</span>, label=<span class="string">f"理论频率 <span class="subst">{f}</span>Hz"</span>)</span><br><span class="line">plt.xlim(<span class="number">20</span>, <span class="number">80</span>)</span><br><span class="line">plt.ylim(-<span class="number">80</span>, <span class="number">5</span>)</span><br><span class="line">plt.xlabel(<span class="string">"频率 (Hz)"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"相对幅度 (dB)"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> wavfile</span><br></pre></td></tr></tbody></table></figure>

<p><code>.wav</code> 文件是 PCM 编码的无压缩音频格式</p>
<p>主要信息：</p>
<ul>
<li>采样率(Hz)：每秒采样次数(CD 音质是 44100 Hz)</li>
<li>位深：每个采样点的精度(16 位、32 位)</li>
<li>声道数：单声道 / 双声道</li>
</ul>
<p>读入音频：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs, data = wavfile.read(<span class="string">"audio.wav"</span>)</span><br><span class="line"><span class="keyword">if</span> data.ndim &gt; <span class="number">1</span>:</span><br><span class="line">    data = data[:,<span class="number">0</span>]  <span class="comment"># 单声道</span></span><br></pre></td></tr></tbody></table></figure>

<p>写出音频：</p>
<p>写 16-bit PCM(常见、兼容)，要先归一化并转换</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">int16_data</span>(<span class="params">data</span>):</span><br><span class="line">    data_normalized = data/ np.<span class="built_in">max</span>(np.<span class="built_in">abs</span>(data))</span><br><span class="line">    data_int16 = (data_normalized * <span class="number">32767</span>).astype(np.int16)</span><br><span class="line">    <span class="keyword">return</span> data_int16</span><br><span class="line">pcm16 = int16_data(data)</span><br><span class="line">wavfile.write(<span class="string">'sine_int16.wav'</span>, fs, pcm16)</span><br></pre></td></tr></tbody></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yhblogs.cn">今天睡够了吗</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yhblogs.cn/posts/35959.html">http://yhblogs.cn/posts/35959.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yhblogs.cn" target="_blank">がんばろう</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E2%8C%A8%EF%B8%8Fpython/">⌨️python</a></div><div class="post_share"><div class="social-share" data-image="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-pokg2e.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/12373.html" title="OpenCV基础"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-pok5v9.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">OpenCV基础</div></div></a></div><div class="next-post pull-right"><a href="/posts/22050.html" title="光电探测器基础"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-ml91l9_compressed.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">光电探测器基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/22642.html" title="windows安装ROCm"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/ROCm_logo.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-10</div><div class="title">windows安装ROCm</div></div></a></div><div><a href="/posts/3865533702.html" title="pyqt5简单实践"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071521231.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-28</div><div class="title">pyqt5简单实践</div></div></a></div><div><a href="/posts/12373.html" title="OpenCV基础"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-pok5v9.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-22</div><div class="title">OpenCV基础</div></div></a></div><div><a href="/posts/60233.html" title="python基础"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/Python-Logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="title">python基础</div></div></a></div><div><a href="/posts/21309.html" title="卷积神经网络"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-7jpjzv_1280x720.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-23</div><div class="title">卷积神经网络</div></div></a></div><div><a href="/posts/641887854.html" title="基于图片求体积的算法"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071528374.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-01</div><div class="title">基于图片求体积的算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/b_2a1aef95f351a5f7ef72eb81e6838fd6.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">今天睡够了吗</div><div class="author-info__description">相遇是最小单位的奇迹</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071549233.webp" target="_blank" title="QQ"><i class="iconfont icon-QQ"></i></a><a class="social-icon" href="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071549234.webp" target="_blank" title="微信"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://space.bilibili.com/277953459?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="https://github.com/YaoHui-Wu06022" target="_blank" title="Github"><i class="iconfont icon-GitHub"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">保持理智，相信明天</div><div class="twopeople"><div class="twopeople"><div class="container" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div> <script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script> <script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script> <script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script> <style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">信号处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-number">1.1.</span> <span class="toc-text">快速傅里叶变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">滤波器设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A4%E6%B3%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">滤波操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF"><span class="toc-number">1.4.</span> <span class="toc-text">卷积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%91%E8%B0%B1%E6%B3%84%E9%9C%B2"><span class="toc-number">1.5.</span> <span class="toc-text">频谱泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">窗函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">音频处理</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2022 - 2025 By 今天睡够了吗</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">You must always have faith in who you are！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>