<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>新闻推荐 | がんばろう</title><meta name="author" content="今天睡够了吗"><meta name="copyright" content="今天睡够了吗"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="算法大赛-天池大赛-阿里云的赛制 赛题理解数据该数据来自某新闻APP平台的用户交互数据，包括30万用户，近300万次点击，共36万多篇不同的新闻文章，同时每篇新闻文章有对应的embedding向量表示。为了保证比赛的公平性，从中抽取20万用户的点击日志数据作为训练集，5万用户的点击日志数据作为测试集A，5万用户的点击日志数据作为测试集B 数据表 train_click_log.csv：训练集用户点">
<meta property="og:type" content="article">
<meta property="og:title" content="新闻推荐">
<meta property="og:url" content="http://yhblogs.cn/posts/3893.html">
<meta property="og:site_name" content="がんばろう">
<meta property="og:description" content="算法大赛-天池大赛-阿里云的赛制 赛题理解数据该数据来自某新闻APP平台的用户交互数据，包括30万用户，近300万次点击，共36万多篇不同的新闻文章，同时每篇新闻文章有对应的embedding向量表示。为了保证比赛的公平性，从中抽取20万用户的点击日志数据作为训练集，5万用户的点击日志数据作为测试集A，5万用户的点击日志数据作为测试集B 数据表 train_click_log.csv：训练集用户点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-mlz139_1280x720.webp">
<meta property="article:published_time" content="2026-01-26T16:27:57.000Z">
<meta property="article:modified_time" content="2026-01-31T12:00:30.725Z">
<meta property="article:author" content="今天睡够了吗">
<meta property="article:tag" content="⌨️python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-mlz139_1280x720.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yhblogs.cn/posts/3893.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '新闻推荐',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-01-31 12:00:30'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3319458_ks437t3n4r.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/b_2a1aef95f351a5f7ef72eb81e6838fd6.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-rili"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="がんばろう"><img class="site-icon" src="/img/favicon.png"><span class="site-name">がんばろう</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-rili"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">新闻推荐</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2026-01-26T16:27:57.000Z" title="发表于 2026-01-26 16:27:57">2026-01-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="新闻推荐"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://tianchi.aliyun.com/competition/entrance/531842/information">算法大赛-天池大赛-阿里云的赛制</a></p>
<h2 id="赛题理解"><a href="#赛题理解" class="headerlink" title="赛题理解"></a>赛题理解</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>该数据来自某新闻APP平台的用户交互数据，包括30万用户，近300万次点击，共36万多篇不同的新闻文章，同时每篇新闻文章有对应的embedding向量表示。为了保证比赛的公平性，从中抽取20万用户的点击日志数据作为训练集，5万用户的点击日志数据作为测试集A，5万用户的点击日志数据作为测试集B</p>
<p><strong>数据表</strong></p>
<p><code>train_click_log.csv</code>：训练集用户点击日志</p>
<p><code>testA_click_log.csv</code>：测试集用户点击日志</p>
<p><code>articles.csv</code>：新闻文章信息数据表</p>
<p><code>articles_emb.csv</code>：新闻文章embedding向量表示</p>
<p><code>sample_submit.csv</code>：提交样例文件</p>
<p><strong>字段表</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>Field</strong></th>
<th align="center"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">user_id</td>
<td align="center">用户id</td>
</tr>
<tr>
<td align="center">click_article_id</td>
<td align="center">点击文章id</td>
</tr>
<tr>
<td align="center">click_timestamp</td>
<td align="center">点击时间戳</td>
</tr>
<tr>
<td align="center">click_environment</td>
<td align="center">点击环境</td>
</tr>
<tr>
<td align="center">click_deviceGroup</td>
<td align="center">点击设备组</td>
</tr>
<tr>
<td align="center">click_os</td>
<td align="center">点击操作系统</td>
</tr>
<tr>
<td align="center">click_country</td>
<td align="center">点击城市</td>
</tr>
<tr>
<td align="center">click_region</td>
<td align="center">点击地区</td>
</tr>
<tr>
<td align="center">click_referrer_type</td>
<td align="center">点击来源类型</td>
</tr>
<tr>
<td align="center">article_id</td>
<td align="center">文章id，与click_article_id相对应</td>
</tr>
<tr>
<td align="center">category_id</td>
<td align="center">文章类型id</td>
</tr>
<tr>
<td align="center">created_at_ts</td>
<td align="center">文章创建时间戳</td>
</tr>
<tr>
<td align="center">words_count</td>
<td align="center">文章字数</td>
</tr>
<tr>
<td align="center">emb_1,emb_2,…,emb_249</td>
<td align="center">文章embedding向量表示</td>
</tr>
</tbody></table>
<h3 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h3><p>根据<code>sample_submit.csv</code>可知最后需要针对每个用户，给出五篇文章的推荐结果，按照点击概率从前往后排序</p>
<p>真实的每个用户最后一次点击的文章只会有一篇的真实答案，所以就看推荐的这五篇里面是否有命中真实答案的</p>
<p>提交结果：user1, article1, article2, article3, article4, article5</p>
<p>评价指标为MRR(Mean Reciprocal Rank)，公式如下：<br>$$<br>score(\text{user}) = \sum_{k=1}^5 \frac{s(\text{user}, k)}{k}<br>$$<br>如果article1是用户点击文章，也就是article1命中，则$s(\text{user1},1)=1, s(\text{user1},2-4)$都是0</p>
<p>如果article2是用户点击的文章，则$s(\text{user},2)=1/2,s(\text{user},1,3,4,5)$都是0</p>
<p>如果都没命中，则$score(\text{user1})=0$</p>
<p>所以目标就是希望命中的结果尽量靠前，分数比较高</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>给到的数据相当于是用户日志，不是那种特征+标签的数据</p>
<p>需要把问题变为一个监督学习的问题(特征+标签)</p>
<p>由于需要预测用户最后一次点击的新闻文章，简单来看是多分类问题，但是文章数有36万，过于庞大，需要将问题转化一下</p>
<p>转化为预测出某个用户最后一次对于某一篇文章会进行点击的概率，变为软分类，分类的标签就是用户是否会点击某篇文章</p>
<p>但接下来的问题是</p>
<ul>
<li>如何转成监督学习问题？ </li>
<li>训练集和测试集怎么制作？ </li>
<li>能利用哪些特征？</li>
<li>可以尝试哪些模型？</li>
</ul>
<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>数据分析的价值主要在于熟悉了解整个数据集的基本情况包括每个文件里有哪些数据，具体的文件中的每个字段表示什么实际含义，以及数据集中特征之间的相关性，在推荐场景下主要就是分析用户本身的基本属性，文章基本属性，以及用户和文章交互的一些分布，这些都有利于后面的召回策略的选择，以及特征工程</p>
<h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">plt.rc(<span class="string">'font'</span>, size=<span class="number">13</span>)</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line"></span><br><span class="line">data_path = Path(<span class="string">"tcdata"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练集</span></span><br><span class="line">trn_click = pd.read_csv(data_path / <span class="string">'train_click_log.csv'</span>)</span><br><span class="line">item_df = pd.read_csv(data_path / <span class="string">'articles.csv'</span>)</span><br><span class="line">item_df = item_df.rename(columns={<span class="string">'article_id'</span>: <span class="string">'click_article_id'</span>})  <span class="comment">#重命名，方便后续match</span></span><br><span class="line">item_emb_df = pd.read_csv(data_path / <span class="string">'articles_emb.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line">tst_click = pd.read_csv(data_path / <span class="string">'testA_click_log.csv'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>计算用户点击rank</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对每个用户的点击时间戳进行排序</span></span><br><span class="line"><span class="comment"># 降序，最新的时间在前</span></span><br><span class="line">trn_click[<span class="string">'rank'</span>] = trn_click.groupby([<span class="string">'user_id'</span>])[<span class="string">'click_timestamp'</span>].rank(</span><br><span class="line">    ascending=<span class="literal">False</span>).astype(<span class="built_in">int</span>)</span><br><span class="line">tst_click[<span class="string">'rank'</span>] = tst_click.groupby([<span class="string">'user_id'</span>])[<span class="string">'click_timestamp'</span>].rank(ascending=<span class="literal">False</span>).astype(<span class="built_in">int</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>为了统计点击次数，需要选择一列不会为NaN的，时间戳比较合适</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算用户点击文章的次数，并添加新的一列</span></span><br><span class="line">trn_click[<span class="string">'click_cnts'</span>] = trn_click.groupby([<span class="string">'user_id'</span>])[<span class="string">'click_timestamp'</span>].transform(<span class="string">'count'</span>)</span><br><span class="line">tst_click[<span class="string">'click_cnts'</span>] = tst_click.groupby([<span class="string">'user_id'</span>])[<span class="string">'click_timestamp'</span>].transform(<span class="string">'count'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="数据浏览"><a href="#数据浏览" class="headerlink" title="数据浏览"></a>数据浏览</h3><p><strong>训练集用户点击日志</strong></p>
<p>将<code>item_df</code>中匹配<code>click_article_id</code>的信息合并</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trn_click = trn_click.merge(item_df, how=<span class="string">'left'</span>, on=[<span class="string">'click_article_id'</span>])</span><br><span class="line"><span class="comment"># left: 左连接，trn_click 的每一行一定保留</span></span><br></pre></td></tr></tbody></table></figure>

<p>查看合并后的情况</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trn_click.info()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;class 'pandas.core.frame.DataFrame'&gt;</span><br><span class="line">RangeIndex: 1112623 entries, 0 to 1112622</span><br><span class="line">Data columns (total 20 columns):</span><br><span class="line"> #   Column               Non-Null Count    Dtype</span><br><span class="line">---  ------               --------------    -----</span><br><span class="line"> 0   user_id              1112623 non-null  int64</span><br><span class="line"> 1   click_article_id     1112623 non-null  int64</span><br><span class="line"> 2   click_timestamp      1112623 non-null  int64</span><br><span class="line"> 3   click_environment    1112623 non-null  int64</span><br><span class="line"> 4   click_deviceGroup    1112623 non-null  int64</span><br><span class="line"> 5   click_os             1112623 non-null  int64</span><br><span class="line"> 6   click_country        1112623 non-null  int64</span><br><span class="line"> 7   click_region         1112623 non-null  int64</span><br><span class="line"> 8   click_referrer_type  1112623 non-null  int64</span><br><span class="line"> 9   rank                 1112623 non-null  int64</span><br><span class="line"> 10  click_cnts           1112623 non-null  int64</span><br><span class="line"> 11  category_id_x        1112623 non-null  int64</span><br><span class="line"> 12  created_at_ts_x      1112623 non-null  int64</span><br><span class="line"> 13  words_count_x        1112623 non-null  int64</span><br><span class="line"> 14  category_id_y        1112623 non-null  int64</span><br><span class="line"> 15  created_at_ts_y      1112623 non-null  int64</span><br><span class="line"> 16  words_count_y        1112623 non-null  int64</span><br><span class="line"> 17  category_id          1112623 non-null  int64</span><br><span class="line"> 18  created_at_ts        1112623 non-null  int64</span><br><span class="line"> 19  words_count          1112623 non-null  int64</span><br><span class="line">dtypes: int64(20)</span><br><span class="line">memory usage: 169.8 MB</span><br></pre></td></tr></tbody></table></figure>

<p>统计数据集中用户数量</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trn_click.user_id.nunique()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200000</span><br></pre></td></tr></tbody></table></figure>

<p>查看最少点击量</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trn_click.groupby(<span class="string">'user_id'</span>)[<span class="string">'click_article_id'</span>].count().<span class="built_in">min</span>()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></tbody></table></figure>

<p>画直方图大体看一下基本的属性分布</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">20</span>))</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> [<span class="string">'click_article_id'</span>, <span class="string">'click_timestamp'</span>, <span class="string">'click_environment'</span>, <span class="string">'click_deviceGroup'</span>, <span class="string">'click_os'</span>, <span class="string">'click_country'</span>,</span><br><span class="line">            <span class="string">'click_region'</span>, <span class="string">'click_referrer_type'</span>, <span class="string">'rank'</span>, <span class="string">'click_cnts'</span>]:</span><br><span class="line">    plot_envs = plt.subplot(<span class="number">5</span>, <span class="number">2</span>, i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    v = trn_click[col].value_counts().reset_index()[:<span class="number">10</span>]</span><br><span class="line">    fig = sns.barplot(x=v.iloc[:, <span class="number">0</span>], y=v.iloc[:, <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> fig.get_xticklabels():</span><br><span class="line">        item.set_rotation(<span class="number">90</span>)</span><br><span class="line">    plt.title(col)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>.reset_index()</code>会很常用，把当前索引还原成默认的 0,1,2,…，原索引可以选择保留成普通列</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(</span><br><span class="line">    {<span class="string">"name"</span>: [<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>]},</span><br><span class="line">    index=[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      name</span><br><span class="line">a    Alice</span><br><span class="line">b      Bob</span><br><span class="line">c  Charlie</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2 = df.reset_index()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  index     name</span><br><span class="line">0     a    Alice</span><br><span class="line">1     b      Bob</span><br><span class="line">2     c  Charlie</span><br></pre></td></tr></tbody></table></figure>

<p>发生了两件事：</p>
<ol>
<li>原来的索引 <code>a b c</code> 变成了一列（列名叫 <code>index</code>）</li>
<li>DataFrame 使用了新的默认整数索引 <code>0,1,2</code></li>
</ol>
<p>常跟在<code>groupby</code>后使用，使得<code>groupby</code>的列回到普通列，而不是成为索引</p>
</blockquote>
<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126204838120.png" alt="image-20260126204838120" style="zoom:67%;">

<p>从点击时间clik_timestamp来看，分布较为平均，可不做特殊处理</p>
<p>从点击环境click_environment来看分布不均匀</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = trn_click[<span class="string">'click_environment'</span>].value_counts().reset_index()</span><br><span class="line">v[<span class="string">'ratio'</span>] = v.iloc[:, <span class="number">1</span>] / v.iloc[:, <span class="number">1</span>].<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(v.loc[:])</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   click_environment    count     ratio</span><br><span class="line">0                  4  1084627  0.974838</span><br><span class="line">1                  2    25894  0.023273</span><br><span class="line">2                  1     2102  0.001889</span><br></pre></td></tr></tbody></table></figure>

<p>从点击设备组click_deviceGroup来看</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = trn_click[<span class="string">'click_deviceGroup'</span>].value_counts().reset_index()</span><br><span class="line">v[<span class="string">'ratio'</span>] = v.iloc[:, <span class="number">1</span>] / v.iloc[:, <span class="number">1</span>].<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(v.loc[:])</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   click_deviceGroup   count     ratio</span><br><span class="line">0                  1  678187  0.609539</span><br><span class="line">1                  3  395558  0.355518</span><br><span class="line">2                  4   38731  0.034811</span><br><span class="line">3                  5     141  0.000127</span><br><span class="line">4                  2       6  0.000005</span><br></pre></td></tr></tbody></table></figure>

<p>训练集的用户ID由<code>0~199999</code>，而测试集A的用户ID由<code>200000~249999</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tst_click.user_id.nunique()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50000</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tst_click.groupby(<span class="string">'user_id'</span>)[<span class="string">'click_article_id'</span>].count().<span class="built_in">min</span>()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></tbody></table></figure>

<p>注意，这里测试集有只点击过一次文章的用户，这里会有一些冷启动问题</p>
<p><strong>新闻文章信息数据表</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item_df[<span class="string">'words_count'</span>].value_counts()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">words_count</span><br><span class="line">176     3485</span><br><span class="line">182     3480</span><br><span class="line">179     3463</span><br><span class="line">178     3458</span><br><span class="line">174     3456</span><br><span class="line">        ... </span><br><span class="line">1040       1</span><br><span class="line">871        1</span><br><span class="line">627        1</span><br><span class="line">473        1</span><br><span class="line">841        1</span><br><span class="line">Name: count, Length: 866, dtype: int64</span><br></pre></td></tr></tbody></table></figure>

<p>统计主题数</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(item_df[<span class="string">'category_id'</span>].nunique())</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">461</span><br></pre></td></tr></tbody></table></figure>

<p>查看不同主体的文章数量</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = item_df[<span class="string">'category_id'</span>].hist(figsize=(<span class="number">5</span>, <span class="number">4</span>),grid=<span class="literal">False</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126210915457.png" alt="image-20260126210915457" style="zoom: 67%;">

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item_df.shape</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(364047, 4)</span><br></pre></td></tr></tbody></table></figure>

<p>一共有364047篇文章</p>
<p>最重要的语义向量给好</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item_emb_df.shape</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(364047, 251)</span><br></pre></td></tr></tbody></table></figure>

<p>每篇文章独立向量，向量维度为251维</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>用户重复点击</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user_click_merge = pd.concat([trn_click, tst_click])</span><br><span class="line"><span class="comment"># 统计“每个用户 × 每篇文章”被点击了多少次</span></span><br><span class="line">user_click_count = (</span><br><span class="line">    user_click_merge</span><br><span class="line">    .groupby([<span class="string">'user_id'</span>, <span class="string">'click_article_id'</span>])[<span class="string">'click_timestamp'</span>]</span><br><span class="line">    .agg({<span class="string">'count'</span>})</span><br><span class="line">    .reset_index()</span><br><span class="line">)</span><br><span class="line">user_click_count.loc[:,<span class="string">'count'</span>].value_counts()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">count</span><br><span class="line">1     1605541</span><br><span class="line">2       11621</span><br><span class="line">3         422</span><br><span class="line">4          77</span><br><span class="line">5          26</span><br><span class="line">6          12</span><br><span class="line">10          4</span><br><span class="line">7           3</span><br><span class="line">13          1</span><br><span class="line">Name: count, dtype: int64</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>agg</code> 可以一次算多个指标</p>
<p>这里虽然只统计count一个量，理论上也可以写成<code>count</code></p>
<p>在推荐 / CTR / 行为建模代码中，<code>groupby + agg</code> 是<strong>模板化写法</strong>，即使只算一个统计量，也会先用 <code>agg</code></p>
</blockquote>
<p>仅有极少数用户重复点击过某篇文章</p>
<p><strong>用户点击环境变化分析</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_envs</span>(<span class="params">df, cols, r, c, figsize=(<span class="params"><span class="number">8</span>, <span class="number">4</span></span>)</span>):</span><br><span class="line">    plt.figure(figsize=figsize)</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">        plt.subplot(r, c, i)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        v = df[col].value_counts().reset_index()</span><br><span class="line">        fig = sns.barplot(x=v.iloc[:, <span class="number">0</span>], y=v.iloc[:, <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> fig.get_xticklabels():</span><br><span class="line">            item.set_rotation(<span class="number">90</span>)</span><br><span class="line">        plt.title(col)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析用户点击环境变化是否明显，这里随机采样10个用户分析这些用户的点击环境分布</span></span><br><span class="line">sample_user_ids = np.random.choice(tst_click[<span class="string">'user_id'</span>].unique(), size=<span class="number">5</span>, replace=<span class="literal">False</span>)</span><br><span class="line">sample_users = user_click_merge[user_click_merge[<span class="string">'user_id'</span>].isin(sample_user_ids)]</span><br><span class="line">cols = [<span class="string">'click_environment'</span>,<span class="string">'click_deviceGroup'</span>, <span class="string">'click_os'</span>, <span class="string">'click_country'</span>, <span class="string">'click_region'</span>,<span class="string">'click_referrer_type'</span>]</span><br><span class="line"><span class="keyword">for</span> _, user_df <span class="keyword">in</span> sample_users.groupby(<span class="string">'user_id'</span>):</span><br><span class="line">    plot_envs(user_df, cols, <span class="number">2</span>, <span class="number">3</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>根据结果图可以发现绝大多数数的用户的点击环境是比较固定的，可以基于这些环境的统计特征来代表该用户本身的属性</p>
<p><strong>用户点击新闻数量的分布</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user_click_item_count = <span class="built_in">sorted</span>(</span><br><span class="line">    user_click_merge</span><br><span class="line">        .groupby(<span class="string">'user_id'</span>)[<span class="string">'click_article_id'</span>]</span><br><span class="line">        .count()</span><br><span class="line">        .value,</span><br><span class="line">    reverse=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ = plt.plot(user_click_item_count)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126212654025.png" alt="image-20260126212654025" style="zoom:80%;">

<p>可以根据用户的点击文章次数看出用户的活跃度</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ = plt.plot(user_click_item_count[:<span class="number">50</span>])</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126212733873.png" alt="image-20260126212733873" style="zoom:80%;">

<p>点击次数排前50的用户的点击次数都在100次以上</p>
<p>思路：可以定义点击次数大于等于100次的用户为活跃用户，这是一种简单的处理思路，判断用户活跃度，更加全面的是再结合上点击时间，会基于点击次数和点击时间两个方面来判断用户活跃度</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ = plt.plot(user_click_item_count[<span class="number">150000</span>:<span class="number">170000</span>])</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126213153392.png" alt="image-20260126213153392" style="zoom:80%;">

<p>点击数少于等于2的用户非常多，这些用户可以认为是非活跃用户</p>
<p><strong>新闻点击次数分析</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">item_click_count = <span class="built_in">sorted</span>(</span><br><span class="line">    user_click_merge</span><br><span class="line">        .groupby(<span class="string">'click_article_id'</span>)[<span class="string">'user_id'</span>]</span><br><span class="line">        .count(), </span><br><span class="line">    reverse=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ = plt.plot(item_click_count)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126213358753.png" alt="image-20260126213358753" style="zoom:80%;">

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(item_click_count[<span class="number">300</span>],item_click_count[<span class="number">100</span>], item_click_count[<span class="number">50</span>])</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1195 3164 5659</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ = plt.plot(item_click_count[<span class="number">10000</span>:])</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126213900615.png" alt="image-20260126213900615" style="zoom: 80%;">

<p>可以定义点击次数超过一定量的为热门新闻，很多新闻只被点击过一两次，可以被定义为冷门新闻</p>
<p><strong>新闻共现频次：两篇新闻连续出现的次数</strong></p>
<p>统计“文章 i 后面紧跟文章 j”出现了多少次</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tmp = user_click_merge.sort_values(<span class="string">'click_timestamp'</span>)</span><br><span class="line">tmp[<span class="string">'next_item'</span>] = (</span><br><span class="line">    tmp</span><br><span class="line">    .groupby([<span class="string">'user_id'</span>])[<span class="string">'click_article_id'</span>]</span><br><span class="line">    .transform(<span class="keyword">lambda</span> x: x.shift(-<span class="number">1</span>))</span><br><span class="line">)</span><br><span class="line">union_item = (</span><br><span class="line">    tmp</span><br><span class="line">    .groupby([<span class="string">'click_article_id'</span>, <span class="string">'next_item'</span>])[<span class="string">'click_timestamp'</span>]</span><br><span class="line">    .agg({<span class="string">'count'</span>})</span><br><span class="line">    .reset_index()</span><br><span class="line">    .sort_values(<span class="string">'count'</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">)</span><br><span class="line">union_item[[<span class="string">'count'</span>]].describe()</span><br></pre></td></tr></tbody></table></figure>

<p>统计 item → next_item 的共现次数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count,433596.000000</span><br><span class="line">mean,3.184146</span><br><span class="line">std,18.851689</span><br><span class="line">min,1.000000</span><br><span class="line">25%,1.000000</span><br><span class="line">50%,1.000000</span><br><span class="line">75%,2.000000</span><br><span class="line">max,2202.000000</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = union_item[<span class="string">'click_article_id'</span>]</span><br><span class="line">y = union_item[<span class="string">'count'</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ = plt.scatter(x, y)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126214808386.png" alt="image-20260126214808386" style="zoom: 80%;">

<p>说明用户看的新闻，相关性是比较强的</p>
<p><strong>用户点击的新闻类型的偏好</strong></p>
<p>此特征可以用于度量用户的兴趣是否广泛</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ = plt.plot(<span class="built_in">sorted</span>(</span><br><span class="line">    user_click_merge</span><br><span class="line">        .groupby(<span class="string">'user_id'</span>)[<span class="string">'category_id'</span>]</span><br><span class="line">        .nunique(), </span><br><span class="line">    reverse=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126214933195.png" alt="image-20260126214933195" style="zoom:80%;">

<p>有一小部分用户阅读类型是极其广泛的，大部分人都处在20个新闻类型以下</p>
<p><strong>用户查看文章的长度的分布</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ =plt.plot(<span class="built_in">sorted</span>(</span><br><span class="line">    user_click_merge</span><br><span class="line">        .groupby(<span class="string">'user_id'</span>)[<span class="string">'words_count'</span>]</span><br><span class="line">        .mean(),</span><br><span class="line">    reverse=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126215128705.png" alt="image-20260126215128705" style="zoom:80%;">

<p>从上图中可以发现有一小部分人看的文章平均词数非常高，也有一小部分人看的平均文章次数非常低</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ = plt.plot(<span class="built_in">sorted</span>(user_click_merge.groupby(<span class="string">'user_id'</span>)[<span class="string">'words_count'</span>].mean(), reverse=<span class="literal">True</span>)[<span class="number">1000</span>:<span class="number">45000</span>])</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20260126215329591.png" alt="image-20260126215329591" style="zoom:80%;">

<p>大部分人看的文章小于250字</p>
<p><strong>用户点击新闻的时间分析</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为了更好的可视化，这里把时间进行归一化操作</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">mm = MinMaxScaler()</span><br><span class="line">user_click_merge[<span class="string">'click_timestamp'</span>] = mm.fit_transform(</span><br><span class="line">    user_click_merge[[<span class="string">'click_timestamp'</span>]]</span><br><span class="line">) <span class="comment"># 用户点击时间</span></span><br><span class="line"></span><br><span class="line">user_click_merge[<span class="string">'created_at_ts'</span>] = mm.fit_transform(</span><br><span class="line">    user_click_merge[[<span class="string">'created_at_ts'</span>]]</span><br><span class="line">) <span class="comment"># 文章创建时间</span></span><br><span class="line"></span><br><span class="line">user_click_merge = user_click_merge.sort_values(<span class="string">'click_timestamp'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>建立时间差函数</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mean_diff_time_func</span>(<span class="params">df, col</span>):</span><br><span class="line">    df = pd.DataFrame(df, columns=[col])</span><br><span class="line">    df[<span class="string">'time_shift1'</span>] = df[col].shift(<span class="number">1</span>).fillna(<span class="number">0</span>)</span><br><span class="line">    df[<span class="string">'diff_time'</span>] = <span class="built_in">abs</span>(df[col] - df[<span class="string">'time_shift1'</span>])</span><br><span class="line">    <span class="keyword">return</span> df[<span class="string">'diff_time'</span>].mean()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mean_diff_click_time = (</span><br><span class="line">    user_click_merge</span><br><span class="line">    .sort_values(<span class="string">'click_timestamp'</span>)</span><br><span class="line">    .groupby(<span class="string">'user_id'</span>)[<span class="string">'click_timestamp'</span>]</span><br><span class="line">    .apply(<span class="keyword">lambda</span> x: mean_diff_time_func(x, <span class="string">'click_timestamp'</span>))</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ = plt.plot(<span class="built_in">sorted</span>(mean_diff_click_time.values, reverse=<span class="literal">True</span>))</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/output_3.analysis_183fda_77_0.png" style="zoom:80%;">

<p>从上图可以发现不同用户点击文章的时间差是有差异的</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mean_diff_created_time = (</span><br><span class="line">    user_click_merge</span><br><span class="line">    .groupby(<span class="string">'user_id'</span>)[[<span class="string">'created_at_ts'</span>]]</span><br><span class="line">    .apply(mean_diff_time_func, col=<span class="string">'created_at_ts'</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">_ = plt.plot(<span class="built_in">sorted</span>(mean_diff_created_time.values, reverse=<span class="literal">True</span>))</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/output_3.analysis_183fda_80_0.png" style="zoom:80%;">

<p>从图中可以发现用户先后点击文章，文章的创建时间也是有差异的</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户前后点击文章的相似性分布</span></span><br><span class="line">item_idx_2_rawid_dict = <span class="built_in">dict</span>(</span><br><span class="line">    <span class="built_in">zip</span>(item_emb_df[<span class="string">'article_id'</span>], item_emb_df.index)</span><br><span class="line">) <span class="comment"># 匹配'article_id'和emb文件中的行号</span></span><br><span class="line"><span class="keyword">del</span> item_emb_df[<span class="string">'article_id'</span>] <span class="comment"># 删除id数值，后面不需要了</span></span><br><span class="line">item_emb_np = np.ascontiguousarray(</span><br><span class="line">    item_emb_df.values,</span><br><span class="line">    dtype=np.float32</span><br><span class="line">) <span class="comment"># 转成连续内存的 numpy 数组</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机选择5个用户，查看这些用户前后查看文章的相似性</span></span><br><span class="line">sub_user_ids = np.random.choice(user_click_merge.user_id.unique(), size=<span class="number">15</span>, replace=<span class="literal">False</span>)</span><br><span class="line">sub_user_info = user_click_merge[user_click_merge[<span class="string">'user_id'</span>].isin(sub_user_ids)]</span><br><span class="line"></span><br><span class="line">sub_user_info.head()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_item_sim_list</span>(<span class="params">df</span>):</span><br><span class="line">    sim_list = []</span><br><span class="line">    item_list = df[<span class="string">'click_article_id'</span>].values</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(item_list)-<span class="number">1</span>):</span><br><span class="line">        emb1 = item_emb_np[item_idx_2_rawid_dict[item_list[i]]]</span><br><span class="line">        emb2 = item_emb_np[item_idx_2_rawid_dict[item_list[i+<span class="number">1</span>]]]</span><br><span class="line">        sim_list.append(np.dot(emb1,emb2)/(np.linalg.norm(emb1)*(np.linalg.norm(emb2))))</span><br><span class="line">    sim_list.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> sim_list</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> _, user_df <span class="keyword">in</span> sub_user_info.groupby(<span class="string">'user_id'</span>):</span><br><span class="line">    item_sim_list = get_item_sim_list(user_df)</span><br><span class="line">    plt.plot(item_sim_list)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202601262238.webp" alt="202601262238" style="zoom:80%;">

<p>从图中可以看出有些用户前后看的商品的相似度波动比较大，有些波动比较小，也是有一定的区分度的</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>训练集和测试集的用户id没有重复，也就是测试集里面的用户没有模型是没有见过的</li>
<li>训练集中用户最少的点击文章数是2， 而测试集里面用户最少的点击文章数是1</li>
<li>用户对于文章存在重复点击的情况，但这个都存在于训练集里面</li>
<li>同一用户的点击环境存在不唯一的情况，后面做这部分特征的时候可以采用统计特征</li>
<li>用户点击文章的次数有很大的区分度，后面可以根据这个制作衡量用户活跃度的特征</li>
<li>文章被用户点击的次数也有很大的区分度，后面可以根据这个制作衡量文章热度的特征</li>
<li>用户看的新闻，相关性是比较强的，所以往往判断用户是否对某篇文章感兴趣的时候，在很大程度上会和历史点击过的文章有关</li>
<li>用户点击的文章字数有比较大的区别，这个可以反映用户对于文章字数的区别</li>
<li>用户点击过的文章主题也有很大的区别，这个可以反映用户的主题偏好</li>
<li>不同用户点击文章的时间差也会有所区别，这个可以反映用户对于文章时效性的偏好</li>
</ol>
<h2 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h2><p>baseline以ItemCF（基于物品的协同过滤）算法作为召回策略，这是工业界广泛使用的经典方法，具有可解释性强、效果稳定的特点</p>
<h3 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据路径</span></span><br><span class="line">data_path = Path(<span class="string">"tcdata"</span>)</span><br><span class="line">save_path = Path(<span class="string">"user_data"</span>)</span><br><span class="line">result_path = Path(<span class="string">"prediction_result"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_path):</span><br><span class="line">    os.makedirs(save_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(result_path):</span><br><span class="line">    os.makedirs(result_path)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="df节省内存函数"><a href="#df节省内存函数" class="headerlink" title="df节省内存函数"></a>df节省内存函数</h3><p>在不改变数据含义的前提下，把 DataFrame 的数值列转成“能用的最小 dtype”，从而节约内存</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 节约内存的一个标配函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reduce_mem</span>(<span class="params">df</span>):</span><br><span class="line">    starttime = time.time()</span><br><span class="line">    <span class="comment"># 只对 整数型 / 浮点型列 做压缩</span></span><br><span class="line">    numerics = [<span class="string">'int16'</span>, <span class="string">'int32'</span>, <span class="string">'int64'</span>, <span class="string">'float16'</span>, <span class="string">'float32'</span>, <span class="string">'float64'</span>]</span><br><span class="line">    <span class="comment"># 计算原始内存占用</span></span><br><span class="line">    <span class="comment"># /1024**2 转为MB</span></span><br><span class="line">    start_mem = df.memory_usage().<span class="built_in">sum</span>() / <span class="number">1024</span>**<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">        col_type = df[col].dtypes</span><br><span class="line">        <span class="keyword">if</span> col_type <span class="keyword">in</span> numerics:</span><br><span class="line">            c_min = df[col].<span class="built_in">min</span>()</span><br><span class="line">            c_max = df[col].<span class="built_in">max</span>()</span><br><span class="line">            <span class="comment"># 跳过全空列</span></span><br><span class="line">            <span class="keyword">if</span> pd.isnull(c_min) <span class="keyword">or</span> pd.isnull(c_max):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果是int类型</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(col_type)[:<span class="number">3</span>] == <span class="string">'int'</span>:</span><br><span class="line">                <span class="comment"># 根据数值大小判断放到哪种类型</span></span><br><span class="line">                <span class="keyword">if</span> c_min &gt; np.iinfo(np.int8).<span class="built_in">min</span> <span class="keyword">and</span> c_max &lt; np.iinfo(np.int8).<span class="built_in">max</span>:</span><br><span class="line">                    df[col] = df[col].astype(np.int8)</span><br><span class="line">                <span class="keyword">elif</span> c_min &gt; np.iinfo(np.int16).<span class="built_in">min</span> <span class="keyword">and</span> c_max &lt; np.iinfo(np.int16).<span class="built_in">max</span>:</span><br><span class="line">                    df[col] = df[col].astype(np.int16)</span><br><span class="line">                <span class="keyword">elif</span> c_min &gt; np.iinfo(np.int32).<span class="built_in">min</span> <span class="keyword">and</span> c_max &lt; np.iinfo(np.int32).<span class="built_in">max</span>:</span><br><span class="line">                    df[col] = df[col].astype(np.int32)</span><br><span class="line">                <span class="keyword">elif</span> c_min &gt; np.iinfo(np.int64).<span class="built_in">min</span> <span class="keyword">and</span> c_max &lt; np.iinfo(np.int64).<span class="built_in">max</span>:</span><br><span class="line">                    df[col] = df[col].astype(np.int64)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> c_min &gt; np.finfo(np.float16).<span class="built_in">min</span> <span class="keyword">and</span> c_max &lt; np.finfo(np.float16).<span class="built_in">max</span>:</span><br><span class="line">                    df[col] = df[col].astype(np.float16)</span><br><span class="line">                <span class="keyword">elif</span> c_min &gt; np.finfo(np.float32).<span class="built_in">min</span> <span class="keyword">and</span> c_max &lt; np.finfo(np.float32).<span class="built_in">max</span>:</span><br><span class="line">                    df[col] = df[col].astype(np.float32)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    df[col] = df[col].astype(np.float64)</span><br><span class="line">    end_mem = df.memory_usage().<span class="built_in">sum</span>() / <span class="number">1024</span>**<span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f'-- Mem. usage decreased to <span class="subst">{end_mem:<span class="number">.2</span>f}</span> Mb '</span></span><br><span class="line">        <span class="string">f'(<span class="subst">{<span class="number">100</span>*(start_mem-end_mem)/start_mem:<span class="number">.1</span>f}</span>% reduction), '</span></span><br><span class="line">        <span class="string">f'time spend:<span class="subst">{(time.time()-starttime)/<span class="number">60</span>:<span class="number">.2</span>f}</span> min'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></tbody></table></figure>

<h3 id="采样函数"><a href="#采样函数" class="headerlink" title="采样函数"></a>采样函数</h3><p><strong>按用户采样</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_all_click_sample</span>(<span class="params">data_path, sample_nums=<span class="number">10000</span></span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        训练集中采样一部分数据调试</span></span><br><span class="line"><span class="string">        data_path: 原数据的存储路径</span></span><br><span class="line"><span class="string">        sample_nums: 采样数目（这里由于机器的内存限制，可以采样用户做）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    all_click = pd.read_csv(data_path / <span class="string">'train_click_log.csv'</span>)</span><br><span class="line">    all_user_ids = all_click.user_id.unique()</span><br><span class="line"></span><br><span class="line">    sample_user_ids = np.random.choice(all_user_ids, size=sample_nums, replace=<span class="literal">False</span>)</span><br><span class="line">    all_click = all_click[all_click[<span class="string">'user_id'</span>].isin(sample_user_ids)]</span><br><span class="line">    <span class="comment"># 去重三列相同的数据</span></span><br><span class="line">    all_click = all_click.drop_duplicates(([<span class="string">'user_id'</span>, <span class="string">'click_article_id'</span>, <span class="string">'click_timestamp'</span>]))</span><br><span class="line">    <span class="keyword">return</span> all_click</span><br></pre></td></tr></tbody></table></figure>

<p><strong>按行采样</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_all_click_df</span>(<span class="params">data_path, offline=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">if</span> offline:</span><br><span class="line">        all_click = pd.read_csv(data_path / <span class="string">'train_click_log.csv'</span>)[:<span class="number">20000</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        trn_click = pd.read_csv(data_path / <span class="string">'train_click_log.csv'</span>)[:<span class="number">10000</span>]</span><br><span class="line">        tst_click = pd.read_csv(data_path / <span class="string">'testA_click_log.csv'</span>)[:<span class="number">10000</span>]</span><br><span class="line"></span><br><span class="line">        all_click = pd.concat([trn_click, tst_click])</span><br><span class="line">	<span class="comment"># .reset_index(drop=True)是防御性措施</span></span><br><span class="line">    all_click = all_click.drop_duplicates(([<span class="string">'user_id'</span>, <span class="string">'click_article_id'</span>, <span class="string">'click_timestamp'</span>])).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> all_click</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_click_df = get_all_click_df(data_path, offline=<span class="literal">False</span>) <span class="comment"># 训练集和测试集都采</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="用户-文章-点击时间"><a href="#用户-文章-点击时间" class="headerlink" title="用户-文章-点击时间"></a>用户-文章-点击时间</h3><p>获取 用户 - 文章 - 点击时间字典</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据点击时间获取用户的点击文章序列 {user1: {item1: time1, item2: time2..}...}</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_item_time</span>(<span class="params">click_df</span>):</span><br><span class="line">    <span class="comment"># 先排序保证组内是时间顺序，就不用多次排了</span></span><br><span class="line">    click_df = click_df.sort_values(<span class="string">'click_timestamp'</span>)</span><br><span class="line">    <span class="comment"># 把某个用户的点击记录从两列 → 变成一个列表的 (文章id, 点击时间) 元组</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_item_time_pair</span>(<span class="params">df</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(df[<span class="string">'click_article_id'</span>], df[<span class="string">'click_timestamp'</span>]))</span><br><span class="line"></span><br><span class="line">    user_item_time_df = (</span><br><span class="line">        click_df.groupby(<span class="string">'user_id'</span>)[[<span class="string">'click_article_id'</span>, <span class="string">'click_timestamp'</span>]]</span><br><span class="line">        .apply(<span class="keyword">lambda</span> x: make_item_time_pair(x))</span><br><span class="line">        .reset_index().rename(columns={<span class="number">0</span>: <span class="string">'item_time_list'</span>}) <span class="comment"># 给组合列重命名</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 转成 dict</span></span><br><span class="line">    user_item_time_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(</span><br><span class="line">            user_item_time_df[<span class="string">'user_id'</span>],</span><br><span class="line">            user_item_time_df[<span class="string">'item_time_list'</span>]</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> user_item_time_dict</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Topk热门文章"><a href="#Topk热门文章" class="headerlink" title="Topk热门文章"></a>Topk热门文章</h3><p>获取点击最多的Topk个文章</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取近期点击最多的文章</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_item_topk_click</span>(<span class="params">click_df, k</span>):</span><br><span class="line">    topk_click = click_df[<span class="string">'click_article_id'</span>].value_counts().index[:k]</span><br><span class="line">    <span class="keyword">return</span> topk_click</span><br></pre></td></tr></tbody></table></figure>

<h3 id="ItemCF相似度"><a href="#ItemCF相似度" class="headerlink" title="ItemCF相似度"></a>ItemCF相似度</h3><p>itemCF的物品相似度计算</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">itemcf_sim</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        文章与文章之间的相似性矩阵计算</span></span><br><span class="line"><span class="string">        :param df: 数据表</span></span><br><span class="line"><span class="string">        :item_created_time_dict:  文章创建时间的字典</span></span><br><span class="line"><span class="string">        return : 文章与文章的相似性矩阵</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    user_item_time_dict = get_user_item_time(df)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算物品相似度</span></span><br><span class="line">    i2i_sim = {} <span class="comment"># 存放物品两两之间的共现权重</span></span><br><span class="line">    item_cnt = defaultdict(<span class="built_in">int</span>) <span class="comment"># 被多少个用户点过，用于归一化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> user, item_time_list <span class="keyword">in</span> tqdm(</span><br><span class="line">            user_item_time_dict.items(),</span><br><span class="line">            disable=<span class="keyword">not</span> logger.isEnabledFor(logging.DEBUG)</span><br><span class="line">    ): <span class="comment"># 只有在 DEBUG 模式下，才显示 tqdm 进度条；生产 / 正常运行时不显示</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在基于商品的协同过滤优化的时候可以考虑时间因素</span></span><br><span class="line">        <span class="comment"># 遍历</span></span><br><span class="line">        <span class="keyword">for</span> i, i_click_time <span class="keyword">in</span> item_time_list:</span><br><span class="line">            item_cnt[i] += <span class="number">1</span> <span class="comment"># 统计文章 i 的点击次数</span></span><br><span class="line">            i2i_sim.setdefault(i, {}) <span class="comment"># 给文章i准备一个空字典</span></span><br><span class="line">            <span class="comment"># 同样遍历，但是跳过自身</span></span><br><span class="line">            <span class="keyword">for</span> j, j_click_time <span class="keyword">in</span> item_time_list:</span><br><span class="line">                <span class="keyword">if</span>(i == j):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                i2i_sim[i].setdefault(j, <span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 累加共现次数 i2i_sim[i][j] += 1</span></span><br><span class="line">                <span class="comment"># 这里用的加权共现</span></span><br><span class="line">                i2i_sim[i][j] += <span class="number">1</span> / math.log(<span class="built_in">len</span>(item_time_list) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    i2i_sim_ = i2i_sim.copy()</span><br><span class="line">    <span class="keyword">for</span> i, related_items <span class="keyword">in</span> i2i_sim.items():</span><br><span class="line">        <span class="keyword">for</span> j, wij <span class="keyword">in</span> related_items.items():</span><br><span class="line">            <span class="comment"># \frac{C[i][j]}{\sqrt{|N(i)| \cdot |N(j)|}}</span></span><br><span class="line">            i2i_sim_[i][j] = wij / math.sqrt(item_cnt[i] * item_cnt[j])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将得到的相似性矩阵保存到本地</span></span><br><span class="line">    save_dir = save_path / <span class="string">'tmp_data'</span></span><br><span class="line">    save_dir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    pickle.dump(</span><br><span class="line">        i2i_sim_,</span><br><span class="line">        <span class="built_in">open</span>(save_dir / <span class="string">'itemcf_i2i_sim.pkl'</span>, <span class="string">'wb'</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i2i_sim_</span><br><span class="line"></span><br><span class="line">i2i_sim = itemcf_sim(all_click_df)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">i = 101，j=102</span><br><span class="line">---</span><br><span class="line">i2i_sim.setdefault(i, {})</span><br><span class="line">i2i_sim = {</span><br><span class="line">    101: {}</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">i2i_sim[i].setdefault(j, 0)</span><br><span class="line">i2i_sim = {</span><br><span class="line">    101: {</span><br><span class="line">        102: Cij</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="itemCF推荐"><a href="#itemCF推荐" class="headerlink" title="itemCF推荐"></a>itemCF推荐</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于商品的召回i2i</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">item_based_recommend</span>(<span class="params">user_id, user_item_time_dict, i2i_sim, sim_item_topk, recall_item_num, item_topk_click</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        基于文章协同过滤的召回</span></span><br><span class="line"><span class="string">        :param user_id: 用户id</span></span><br><span class="line"><span class="string">        :param user_item_time_dict: 字典, 根据点击时间获取用户的点击文章序列   {user1: {item1: time1, item2: time2..}...}</span></span><br><span class="line"><span class="string">        :param i2i_sim: 字典，文章相似性矩阵</span></span><br><span class="line"><span class="string">        :param sim_item_topk: 整数， 选择与当前文章最相似的前k篇文章</span></span><br><span class="line"><span class="string">        :param recall_item_num: 整数， 最后的召回文章数量</span></span><br><span class="line"><span class="string">        :param item_topk_click: 列表，点击次数最多的文章列表，用户召回补全</span></span><br><span class="line"><span class="string">        return: 召回的文章列表 {item1:score1, item2: score2...}</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取用户历史交互的文章</span></span><br><span class="line">    user_hist_items = user_item_time_dict[user_id]</span><br><span class="line">    user_hist_item_set = {item <span class="keyword">for</span> item, _ <span class="keyword">in</span> user_hist_items}</span><br><span class="line"></span><br><span class="line">    item_rank = {} <span class="comment"># 打分字典</span></span><br><span class="line">    <span class="comment"># loc为第几次点击，i为文章id</span></span><br><span class="line">    <span class="keyword">for</span> loc, (i, click_time) <span class="keyword">in</span> <span class="built_in">enumerate</span>(user_hist_items):</span><br><span class="line">        <span class="keyword">for</span> j, wij <span class="keyword">in</span> <span class="built_in">sorted</span>(</span><br><span class="line">            i2i_sim[i].items(),</span><br><span class="line">            key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>],</span><br><span class="line">            reverse=<span class="literal">True</span></span><br><span class="line">        )[:sim_item_topk]: <span class="comment"># 取和文章i最相似的前k篇</span></span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> user_hist_item_set:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment"># 用户已经点过的就不推荐了</span></span><br><span class="line"></span><br><span class="line">            item_rank.setdefault(j, <span class="number">0</span>)</span><br><span class="line">            item_rank[j] +=  wij  <span class="comment"># 给候选文章累加分</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不足10个，用热门文章补全</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(item_rank) &lt; recall_item_num:</span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(item_topk_click):</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> item_rank: <span class="comment"># 填充的item应该不在原来的列表中</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            item_rank[item] = - i - <span class="number">100</span> <span class="comment"># 给个负数让排名靠后，不影响真实</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(item_rank) == recall_item_num:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    item_rank = <span class="built_in">sorted</span>(</span><br><span class="line">        item_rank.items(),</span><br><span class="line">        key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>],</span><br><span class="line">        reverse=<span class="literal">True</span></span><br><span class="line">    )[:recall_item_num]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item_rank</span><br></pre></td></tr></tbody></table></figure>

<p>给每个用户根据物品的协同过滤推荐文章</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义结果字典</span></span><br><span class="line">user_recall_items_dict = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 用户 - 文章 - 点击时间的字典</span></span><br><span class="line">user_item_time_dict = get_user_item_time(all_click_df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去取文章相似度</span></span><br><span class="line">i2i_sim = pickle.load(<span class="built_in">open</span>(save_path / <span class="string">'tmp_data/itemcf_i2i_sim.pkl'</span>, <span class="string">'rb'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相似文章的数量</span></span><br><span class="line">sim_item_topk = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 召回文章数量</span></span><br><span class="line">recall_item_num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户热度补全</span></span><br><span class="line">item_topk_click = get_item_topk_click(all_click_df, k=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> tqdm(all_click_df[<span class="string">'user_id'</span>].unique(), disable=<span class="keyword">not</span> logger.isEnabledFor(logging.DEBUG)):</span><br><span class="line">    user_recall_items_dict[user] = item_based_recommend(</span><br><span class="line">        user,</span><br><span class="line">        user_item_time_dict,</span><br><span class="line">        i2i_sim,</span><br><span class="line">        sim_item_topk,</span><br><span class="line">        recall_item_num,</span><br><span class="line">        item_topk_click</span><br><span class="line">    )</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user_recall_items_dict = {</span><br><span class="line">    user1: [(item1, score1)...],</span><br><span class="line">    user2: [(item2, score2)...],</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>召回字典转换成df</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将字典的形式转换成df</span></span><br><span class="line">user_item_score_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user, items <span class="keyword">in</span> tqdm(user_recall_items_dict.items(), disable=<span class="keyword">not</span> logger.isEnabledFor(logging.DEBUG)):</span><br><span class="line">    <span class="keyword">for</span> item, score <span class="keyword">in</span> items:</span><br><span class="line">        user_item_score_list.append([user, item, score])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">user_item_score_list = </span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    [user1, itemA, scoreA],</span></span><br><span class="line"><span class="string">    [user1, itemB, scoreB],</span></span><br><span class="line"><span class="string">    [user2, itemC, scoreC],</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">          </span><br><span class="line">recall_df = pd.DataFrame(user_item_score_list, columns=[<span class="string">'user_id'</span>, <span class="string">'click_article_id'</span>, <span class="string">'pred_score'</span>])</span><br><span class="line">recall_df.head()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="提交函数"><a href="#提交函数" class="headerlink" title="提交函数"></a><font color="Violetred">提交函数</font></h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成提交文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">recall_df, topk=<span class="number">5</span>, model_name=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 按用户和预测分做一个排序</span></span><br><span class="line">    recall_df = recall_df.sort_values(by=[<span class="string">'user_id'</span>, <span class="string">'pred_score'</span>])</span><br><span class="line">    <span class="comment"># 打上名次</span></span><br><span class="line">    recall_df[<span class="string">'rank'</span>] = (</span><br><span class="line">        recall_df</span><br><span class="line">        .groupby([<span class="string">'user_id'</span>])[<span class="string">'pred_score'</span>]</span><br><span class="line">        .rank(ascending=<span class="literal">False</span>, method=<span class="string">'first'</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是不是每个用户都有5篇文章及以上</span></span><br><span class="line">    tmp = recall_df.groupby(<span class="string">'user_id'</span>).apply(<span class="keyword">lambda</span> x: x[<span class="string">'rank'</span>].<span class="built_in">max</span>())</span><br><span class="line">    <span class="keyword">assert</span> tmp.<span class="built_in">min</span>() &gt;= topk</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> recall_df[<span class="string">'pred_score'</span>] <span class="comment"># 删除预测分数列</span></span><br><span class="line">    submit = (</span><br><span class="line">        recall_df[recall_df[<span class="string">'rank'</span>] &lt;= topk]</span><br><span class="line">        .set_index([<span class="string">'user_id'</span>, <span class="string">'rank'</span>]) <span class="comment"># 设置多重索引</span></span><br><span class="line">        .unstack(-<span class="number">1</span>) <span class="comment"># 把 rank 展开成列</span></span><br><span class="line">        .reset_index() <span class="comment"># 把 user_id 从 index 拉回普通列</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    submit.columns = [</span><br><span class="line">        <span class="built_in">int</span>(col) <span class="keyword">if</span> <span class="built_in">isinstance</span>(col, <span class="built_in">int</span>) <span class="keyword">else</span> col</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> submit.columns.droplevel(<span class="number">0</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照提交格式定义列名</span></span><br><span class="line">    submit = submit.rename(columns={</span><br><span class="line">        <span class="string">''</span>: <span class="string">'user_id'</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">'article_1'</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">'article_2'</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">'article_3'</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">'article_4'</span>,</span><br><span class="line">        <span class="number">5</span>: <span class="string">'article_5'</span></span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    save_name = save_path / (</span><br><span class="line">        model_name + <span class="string">'_'</span> + datetime.today().strftime(<span class="string">'%m-%d'</span>) + <span class="string">'.csv'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    submit.to_csv(save_name, index=<span class="literal">False</span>, header=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取测试集</span></span><br><span class="line">tst_click = pd.read_csv(data_path / <span class="string">'testA_click_log.csv'</span>)</span><br><span class="line">tst_users = tst_click[<span class="string">'user_id'</span>].unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从所有的召回数据中将测试集中的用户选出来</span></span><br><span class="line"><span class="comment"># 因为只用到了行为，没有用到标签，所以混杂测试集进去没有问题</span></span><br><span class="line">tst_recall = recall_df[recall_df[<span class="string">'user_id'</span>].isin(tst_users)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成提交文件</span></span><br><span class="line">submit(tst_recall, topk=<span class="number">5</span>, model_name=<span class="string">'itemcf_baseline'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>这种简单的ItemCF提交得分为 0.1026</p>
<h2 id="多路召回"><a href="#多路召回" class="headerlink" title="多路召回"></a>多路召回</h2><p>多路召回策略是指使用多种不同的简单策略、特征或轻量模型，分别召回一部分候选集，再将这些候选集合并，供后续排序模型使用</p>
<p>这种策略本质上是在计算速度与召回率之间的权衡：</p>
<ul>
<li>各类简单策略保证召回过程足够快</li>
<li>从不同角度设计的召回规则共同提升整体召回率，避免影响最终排序效果</li>
</ul>
<p>在多路召回中，各个召回策略彼此独立，通常可以并行执行（如多线程），从而提升整体效率</p>
<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/3_multi_channel_recall.webp" alt="3_multi_channel_recall" style="zoom: 50%;">

<p>需要注意的是，具体采用哪些召回策略高度依赖业务场景</p>
<p>不同任务对应不同的真实需求，因此召回规则也会有所差异，例如在新闻或视频推荐中，常见的召回方式包括：热门内容、导演召回、演员召回、近期上映、流行趋势、类型召回等</p>
<h3 id="导包-2"><a href="#导包-2" class="headerlink" title="导包"></a>导包</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, math, warnings, math, pickle, random</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"><span class="comment"># 限制线程数：防止 faiss / numpy 抢 CPU，线上或多进程时很常见</span></span><br><span class="line">os.environ[<span class="string">'OMP_NUM_THREADS'</span>] = <span class="string">'1'</span></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> faiss <span class="comment"># Facebook 开源的 高性能向量检索库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.sequence <span class="keyword">import</span> pad_sequences</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据路径</span></span><br><span class="line">data_path = Path(<span class="string">'tcdata'</span>) <span class="comment"># 存放数据集位置</span></span><br><span class="line">temp_path = Path(<span class="string">"user_data/tmp_data"</span>) <span class="comment"># 存放中间缓存</span></span><br><span class="line">result_path = Path(<span class="string">"prediction_result"</span>) <span class="comment"># 存放结果</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(temp_path):</span><br><span class="line">    os.makedirs(temp_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(result_path):</span><br><span class="line">    os.makedirs(result_path)</span><br><span class="line"><span class="comment"># 做召回评估的一个标志, 如果不进行评估就是直接使用全量数据进行召回</span></span><br><span class="line">metric_recall = <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="读取数据-1"><a href="#读取数据-1" class="headerlink" title="读取数据"></a>读取数据</h3><p>在推荐系统比赛中，数据读取通常分为三种模式，对应不同阶段与数据集使用方式</p>
<ol>
<li><p>Debug 模式：用于快速搭建并跑通 baseline，验证整体代码流程是否正确</p>
<p>在该阶段一般从训练集中随机抽取一小部分样本（如 <code>train_click_log_sample</code>）进行调试，确保逻辑无误即可</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_all_click_sample</span>(<span class="params">data_path, sample_nums=<span class="number">10000</span></span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        训练集中采样一部分数据调试</span></span><br><span class="line"><span class="string">        data_path: 原数据的存储路径</span></span><br><span class="line"><span class="string">        sample_nums: 采样数目（这里由于机器的内存限制，可以采样用户做）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    all_click = pd.read_csv(data_path / <span class="string">'train_click_log.csv'</span>)</span><br><span class="line">    all_user_ids = all_click.user_id.unique()</span><br><span class="line"></span><br><span class="line">    sample_user_ids = np.random.choice(all_user_ids, size=sample_nums, replace=<span class="literal">False</span>)</span><br><span class="line">    all_click = all_click[all_click[<span class="string">'user_id'</span>].isin(sample_user_ids)]</span><br><span class="line">    <span class="comment"># 去重三列相同的数据</span></span><br><span class="line">    all_click = all_click.drop_duplicates(([<span class="string">'user_id'</span>, <span class="string">'click_article_id'</span>, <span class="string">'click_timestamp'</span>]))</span><br><span class="line">    <span class="keyword">return</span> all_click</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>线下验证模式：用于模型选择与超参数调优</p>
<p>此阶段加载完整训练集（<code>train_click_log</code>），并将其划分为训练集和验证集：训练集用于模型训练，验证集用于评估效果并调整模型与参数</p>
</li>
<li><p>线上模式：在 baseline 已跑通、模型与参数已确定后，进入最终预测阶段</p>
<p>该模式使用全量数据进行训练，即 <code>train_click_log + test_click_log</code>，对测试集生成预测结果并提交线上评测</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取点击数据，这里分成线上和线下，如果是为了获取线上提交结果应该讲测试集中的点击数据合并到总的数据中</span></span><br><span class="line"><span class="comment"># 如果是为了线下验证模型的有效性或者特征的有效性，可以只使用训练集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_all_click_df</span>(<span class="params">data_path, offline=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">if</span> offline:</span><br><span class="line">        all_click = pd.read_csv(data_path / <span class="string">'train_click_log.csv'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        trn_click = pd.read_csv(data_path / <span class="string">'train_click_log.csv'</span>)</span><br><span class="line">        tst_click = pd.read_csv(data_path / <span class="string">'testA_click_log.csv'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># all_click = trn_click.append(tst_click)</span></span><br><span class="line">        all_click = pd.concat([trn_click, tst_click]).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    all_click = all_click.drop_duplicates(([<span class="string">'user_id'</span>, <span class="string">'click_article_id'</span>, <span class="string">'click_timestamp'</span>]))</span><br><span class="line">    <span class="keyword">return</span> all_click</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文章的基本属性</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_item_info_df</span>(<span class="params">data_path</span>):</span><br><span class="line">    item_info_df = pd.read_csv(data_path / <span class="string">'articles.csv'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了方便与训练集中的click_article_id拼接，需要把article_id修改成click_article_id</span></span><br><span class="line">    item_info_df = item_info_df.rename(columns={<span class="string">'article_id'</span>: <span class="string">'click_article_id'</span>})</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item_info_df</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文章的Embedding数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_item_emb_dict</span>(<span class="params">data_path</span>):</span><br><span class="line">    item_emb_df = pd.read_csv(data_path / <span class="string">'articles_emb.csv'</span>)</span><br><span class="line"></span><br><span class="line">    item_emb_cols = [x <span class="keyword">for</span> x <span class="keyword">in</span> item_emb_df.columns <span class="keyword">if</span> <span class="string">'emb'</span> <span class="keyword">in</span> x]</span><br><span class="line">    <span class="comment"># 将 embedding 转成 NumPy 数组，并保证内存连续。</span></span><br><span class="line">    item_emb_np = np.ascontiguousarray(item_emb_df[item_emb_cols])</span><br><span class="line">    <span class="comment"># 对每个文章向量做 L2 归一化，向量点积 ≈ 余弦相似度</span></span><br><span class="line">    item_emb_np = item_emb_np / np.linalg.norm(item_emb_np, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 构建 article_id → embedding 的映射字典</span></span><br><span class="line">    item_emb_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(item_emb_df[<span class="string">'article_id'</span>], item_emb_np))</span><br><span class="line">    pickle.dump(item_emb_dict, <span class="built_in">open</span>(temp_path / <span class="string">'item_content_emb.pkl'</span>, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item_emb_dict</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">max_min_scaler = <span class="keyword">lambda</span> x : (x-np.<span class="built_in">min</span>(x))/(np.<span class="built_in">max</span>(x)-np.<span class="built_in">min</span>(x))</span><br><span class="line"><span class="comment"># 采样数据</span></span><br><span class="line">all_click_df = get_all_click_sample(data_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全量训练集</span></span><br><span class="line"><span class="comment"># all_click_df = get_all_click_df(data_path, offline=False)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对时间戳进行归一化,用于在关联规则的时候计算权重</span></span><br><span class="line">all_click_df[<span class="string">'click_timestamp'</span>] = all_click_df[[<span class="string">'click_timestamp'</span>]].apply(max_min_scaler)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item_info_df = get_item_info_df(data_path)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item_emb_dict = get_item_emb_dict(data_path)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><p><strong>获取用户-文章-时间函数</strong></p>
<p>常用于</p>
<ul>
<li>基于序列的协同过滤</li>
<li>关联规则挖掘（A → B）</li>
<li>Item-Item 相似度</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据点击时间获取用户的点击文章序列 {user1: {item1: time1, item2: time2..}...}</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_item_time</span>(<span class="params">click_df</span>):</span><br><span class="line">    <span class="comment"># 先排序保证组内是时间顺序，就不用多次排了</span></span><br><span class="line">    click_df = click_df.sort_values(<span class="string">'click_timestamp'</span>)</span><br><span class="line">    <span class="comment"># 把某个用户的点击记录从两列 → 变成一个列表的 (文章id, 点击时间) 元组</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_item_time_pair</span>(<span class="params">df</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(df[<span class="string">'click_article_id'</span>], df[<span class="string">'click_timestamp'</span>]))</span><br><span class="line"></span><br><span class="line">    user_item_time_df = (</span><br><span class="line">        click_df.groupby(<span class="string">'user_id'</span>)[[<span class="string">'click_article_id'</span>, <span class="string">'click_timestamp'</span>]]</span><br><span class="line">        .apply(<span class="keyword">lambda</span> x: make_item_time_pair(x))</span><br><span class="line">        .reset_index().rename(columns={<span class="number">0</span>: <span class="string">'item_time_list'</span>}) <span class="comment"># 给组合列重命名</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 转成 dict</span></span><br><span class="line">    user_item_time_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(</span><br><span class="line">            user_item_time_df[<span class="string">'user_id'</span>],</span><br><span class="line">            user_item_time_df[<span class="string">'item_time_list'</span>]</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> user_item_time_dict</span><br></pre></td></tr></tbody></table></figure>

<p><strong>获取文章-用户-时间函数</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据时间获取商品被点击的用户序列  {item1: {user1: time1, user2: time2...}...}</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_item_user_time_dict</span>(<span class="params">click_df</span>):</span><br><span class="line">    <span class="comment"># 先排序保证组内是时间顺序，就不用多次排了</span></span><br><span class="line">    click_df = click_df.sort_values(<span class="string">'click_timestamp'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_user_time_pair</span>(<span class="params">df</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(df[<span class="string">'user_id'</span>], df[<span class="string">'click_timestamp'</span>]))</span><br><span class="line"></span><br><span class="line">    item_user_time_df = (</span><br><span class="line">        click_df.groupby(<span class="string">'click_article_id'</span>)[[<span class="string">'user_id'</span>, <span class="string">'click_timestamp'</span>]]</span><br><span class="line">        .apply(<span class="keyword">lambda</span> x: make_user_time_pair(x))</span><br><span class="line">    	.reset_index()</span><br><span class="line">        .rename(columns={<span class="number">0</span>: <span class="string">'user_time_list'</span>})</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 转成 dict</span></span><br><span class="line">    item_user_time_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(</span><br><span class="line">            item_user_time_df[<span class="string">'click_article_id'</span>],</span><br><span class="line">            item_user_time_df[<span class="string">'user_time_list'</span>]</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> item_user_time_dict</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font color="Violetred">获取历史和最后一次点击</font></strong></p>
<p>在评估召回结果，特征工程和制作标签转成监督学习测试集时用到</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前数据的历史点击和最后一次点击</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_hist_and_last_click</span>(<span class="params">all_click</span>):</span><br><span class="line"></span><br><span class="line">    all_click = all_click.sort_values(by=[<span class="string">'user_id'</span>, <span class="string">'click_timestamp'</span>])</span><br><span class="line">    click_last_df = all_click.groupby(<span class="string">'user_id'</span>).tail(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义历史点击提取函数，去掉最后一次点击剩下的就是历史点击</span></span><br><span class="line">    <span class="comment"># 如果用户只有一条，hist 为空，此时默认泄露</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hist_func</span>(<span class="params">user_df</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(user_df) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> user_df</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> user_df[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    click_hist_df = (</span><br><span class="line">        all_click.groupby(<span class="string">'user_id'</span>)</span><br><span class="line">        .apply(hist_func)</span><br><span class="line">        .reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> click_hist_df, click_last_df</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font color="DarkViolet">获取文章属性特征</font></strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取文章id对应的基本属性，保存成字典的形式，方便后面召回阶段，冷启动阶段直接使用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_item_info_dict</span>(<span class="params">item_info_df</span>):</span><br><span class="line">    <span class="comment"># 定义最大最小归一化</span></span><br><span class="line">    max_min_scaler = <span class="keyword">lambda</span> x : (x-np.<span class="built_in">min</span>(x))/(np.<span class="built_in">max</span>(x)-np.<span class="built_in">min</span>(x))</span><br><span class="line">    <span class="comment"># 对文章的发布时间做归一化</span></span><br><span class="line">    item_info_df[<span class="string">'created_at_ts'</span>] = item_info_df[[<span class="string">'created_at_ts'</span>]].apply(max_min_scaler)</span><br><span class="line">    <span class="comment"># 文章 → 类别字典</span></span><br><span class="line">    item_type_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(item_info_df[<span class="string">'click_article_id'</span>], item_info_df[<span class="string">'category_id'</span>])</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 文章 → 字数字典</span></span><br><span class="line">    item_words_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(item_info_df[<span class="string">'click_article_id'</span>], item_info_df[<span class="string">'words_count'</span>])</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 文章 → 发布时间字典</span></span><br><span class="line">    item_created_time_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(item_info_df[<span class="string">'click_article_id'</span>], item_info_df[<span class="string">'created_at_ts'</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item_type_dict, item_words_dict, item_created_time_dict</span><br></pre></td></tr></tbody></table></figure>

<p><strong>获取用户历史点击的文章信息</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_hist_item_info_dict</span>(<span class="params">all_click</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取user_id对应的用户历史点击文章类型的集合字典</span></span><br><span class="line">    user_hist_item_typs = all_click.groupby(<span class="string">'user_id'</span>)[<span class="string">'category_id'</span>].agg(<span class="built_in">set</span>).reset_index()</span><br><span class="line">    user_hist_item_typs_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(user_hist_item_typs[<span class="string">'user_id'</span>],</span><br><span class="line">            user_hist_item_typs[<span class="string">'category_id'</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取user_id对应的用户点击文章的集合</span></span><br><span class="line">    user_hist_item_ids_dict = all_click.groupby(<span class="string">'user_id'</span>)[<span class="string">'click_article_id'</span>].agg(<span class="built_in">set</span>).reset_index()</span><br><span class="line">    user_hist_item_ids_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(user_hist_item_ids_dict[<span class="string">'user_id'</span>],</span><br><span class="line">            user_hist_item_ids_dict[<span class="string">'click_article_id'</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取user_id对应的用户历史点击的文章的平均字数字典</span></span><br><span class="line">    user_hist_item_words = all_click.groupby(<span class="string">'user_id'</span>)[<span class="string">'words_count'</span>].agg(<span class="string">'mean'</span>).reset_index()</span><br><span class="line">    user_hist_item_words_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(user_hist_item_words[<span class="string">'user_id'</span>], user_hist_item_words[<span class="string">'words_count'</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取user_id对应的用户最后一次点击的文章的创建时间</span></span><br><span class="line">    all_click_ = all_click.sort_values(<span class="string">'click_timestamp'</span>)</span><br><span class="line">    user_last_item_created_time = (all_click_.groupby(<span class="string">'user_id'</span>)[<span class="string">'created_at_ts'</span>]</span><br><span class="line">                                   .apply(<span class="keyword">lambda</span> x: x.iloc[-<span class="number">1</span>])</span><br><span class="line">                                   .reset_index())</span><br><span class="line"></span><br><span class="line">    max_min_scaler = <span class="keyword">lambda</span> x : (x-np.<span class="built_in">min</span>(x))/(np.<span class="built_in">max</span>(x)-np.<span class="built_in">min</span>(x))</span><br><span class="line">    user_last_item_created_time[<span class="string">'created_at_ts'</span>] = user_last_item_created_time[[<span class="string">'created_at_ts'</span>]].apply(max_min_scaler)</span><br><span class="line"></span><br><span class="line">    user_last_item_created_time_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(user_last_item_created_time[<span class="string">'user_id'</span>],</span><br><span class="line">            user_last_item_created_time[<span class="string">'created_at_ts'</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user_hist_item_typs_dict, user_hist_item_ids_dict, user_hist_item_words_dict, user_last_item_created_time_dict</span><br></pre></td></tr></tbody></table></figure>

<p><strong>获取点击次数最多的Top-k个文章</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取近期点击最多的文章</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_item_topk_click</span>(<span class="params">click_df, k</span>):</span><br><span class="line">    topk_click = click_df[<span class="string">'click_article_id'</span>].value_counts().index[:k]</span><br><span class="line">    <span class="keyword">return</span> topk_click</span><br></pre></td></tr></tbody></table></figure>

<h4 id="定义多路召回字典"><a href="#定义多路召回字典" class="headerlink" title="定义多路召回字典"></a>定义多路召回字典</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取文章的属性信息，保存成字典的形式方便查询</span></span><br><span class="line">item_type_dict, item_words_dict, item_created_time_dict = get_item_info_dict(item_info_df)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个多路召回的字典，将各路召回的结果都保存在这个字典当中</span></span><br><span class="line">user_multi_recall_dict =  {<span class="string">'itemcf_sim_itemcf_recall'</span>: {},</span><br><span class="line">                           <span class="string">'embedding_sim_item_recall'</span>: {},</span><br><span class="line">                           <span class="string">'youtubednn_recall'</span>: {},</span><br><span class="line">                           <span class="string">'youtubednn_usercf_recall'</span>: {},</span><br><span class="line">                           <span class="string">'cold_start_recall'</span>: {}}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取最后一次点击作为召回评估，如果不需要做召回评估直接使用全量的训练集进行召回(线下验证模型)</span></span><br><span class="line"><span class="comment"># 如果不是召回评估，直接使用全量数据进行召回，不用将最后一次提取出来</span></span><br><span class="line">trn_hist_click_df, trn_last_click_df = get_hist_and_last_click(all_click_df)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="召回效果评估"><a href="#召回效果评估" class="headerlink" title="召回效果评估"></a>召回效果评估</h4><p>需要对当前召回进行评价，因为召回的结果决定了最终排序的上限</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依次评估召回的前10, 20, 30, 40, 50个文章中的击中率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">metrics_recall</span>(<span class="params">user_recall_items_dict, trn_last_click_df, topk=<span class="number">5</span></span>):</span><br><span class="line">    <span class="comment"># 从df转为dict结构，O(1)</span></span><br><span class="line">    last_click_item_dict = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">zip</span>(trn_last_click_df[<span class="string">'user_id'</span>],</span><br><span class="line">            trn_last_click_df[<span class="string">'click_article_id'</span>])</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 只评估那些“有召回结果的用户”</span></span><br><span class="line">    user_num = <span class="built_in">len</span>(user_recall_items_dict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, topk+<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        hit_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> user, item_list <span class="keyword">in</span> user_recall_items_dict.items():</span><br><span class="line">            <span class="comment"># 获取前k个召回的结果</span></span><br><span class="line">            tmp_recall_items = [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> user_recall_items_dict[user][:k]]</span><br><span class="line">            <span class="comment"># 用 set 是为了把查找复杂度从 O(K) 降到 O(1)</span></span><br><span class="line">            <span class="keyword">if</span> last_click_item_dict[user] <span class="keyword">in</span> <span class="built_in">set</span>(tmp_recall_items):</span><br><span class="line">                hit_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        hit_rate = <span class="built_in">round</span>(hit_num / user_num, <span class="number">5</span>) <span class="comment"># 保留5位结果</span></span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">' topk: '</span>, k,</span><br><span class="line">            <span class="string">' : '</span>,</span><br><span class="line">            <span class="string">'hit_num: '</span>, hit_num,</span><br><span class="line">            <span class="string">'hit_rate: '</span>, hit_rate,</span><br><span class="line">            <span class="string">'user_num : '</span>, user_num</span><br><span class="line">        )</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user_recall_items_dict:</span><br><span class="line">{</span><br><span class="line">    user_id: [(item_id1, score1), (item_id2, score2), ...]</span><br><span class="line">} # 已按 score 排好序,召回阶段的结果</span><br></pre></td></tr></tbody></table></figure>

<h3 id="计算相似性矩阵"><a href="#计算相似性矩阵" class="headerlink" title="计算相似性矩阵"></a>计算相似性矩阵</h3><p>通过协同过滤以及向量检索得到相似性矩阵</p>
<h4 id="itemCF-i2i-sim"><a href="#itemCF-i2i-sim" class="headerlink" title="itemCF i2i_sim"></a>itemCF i2i_sim</h4><p>借鉴KDD2020的去偏商品推荐，在计算item2item相似性矩阵时，使用关联规则，使得计算的文章的相似性还考虑到了</p>
<ol>
<li>用户点击的时间权重</li>
<li>用户点击的顺序权重</li>
<li>文章创建的时间权重</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">itemcf_sim</span>(<span class="params">df, item_created_time_dict</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        根据用户的点击序列，计算“文章-文章”的相似度矩阵</span></span><br><span class="line"><span class="string">        :param df: 数据表</span></span><br><span class="line"><span class="string">        :item_created_time_dict:  文章创建时间的字典</span></span><br><span class="line"><span class="string">        return : 文章与文章的相似性矩阵</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    user_item_time_dict = get_user_item_time(df)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算物品相似度</span></span><br><span class="line">    i2i_sim = {}</span><br><span class="line">    item_cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> user, item_time_list <span class="keyword">in</span> user_item_time_dict.items():</span><br><span class="line">        <span class="comment"># 在基于商品的协同过滤优化的时候可以考虑时间因素</span></span><br><span class="line">        <span class="keyword">for</span> loc1, (i, i_click_time) <span class="keyword">in</span> <span class="built_in">enumerate</span>(item_time_list):</span><br><span class="line">            item_cnt[i] += <span class="number">1</span></span><br><span class="line">            i2i_sim.setdefault(i, {})</span><br><span class="line">            <span class="comment"># 与同一用户的其它文章 j 计算共现</span></span><br><span class="line">            <span class="keyword">for</span> loc2, (j, j_click_time) <span class="keyword">in</span> <span class="built_in">enumerate</span>(item_time_list):</span><br><span class="line">                <span class="keyword">if</span>(i == j):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 初始化避免 +=报错</span></span><br><span class="line">                i2i_sim[i].setdefault(j, <span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 考虑文章的正向顺序点击和反向顺序点击</span></span><br><span class="line">                <span class="comment"># 顺序方向权重（正向 &gt; 反向）</span></span><br><span class="line">                loc_alpha = <span class="number">1.0</span> <span class="keyword">if</span> loc2 &gt; loc1 <span class="keyword">else</span> <span class="number">0.7</span></span><br><span class="line">                <span class="comment"># 位置信息权重，其中的参数可以调节</span></span><br><span class="line">                <span class="comment"># 点击得越近 → 权重越大，远端指数衰减</span></span><br><span class="line">                loc_weight = loc_alpha * (<span class="number">0.9</span> ** (np.<span class="built_in">abs</span>(loc2 - loc1) - <span class="number">1</span>))</span><br><span class="line">                <span class="comment"># 点击时间权重，其中的参数可以调节</span></span><br><span class="line">                <span class="comment"># 两次点击时间越接近 → 权重越大，时间差大关系弱</span></span><br><span class="line">                click_time_weight = np.exp(<span class="number">0.7</span> ** np.<span class="built_in">abs</span>(i_click_time - j_click_time))</span><br><span class="line">                <span class="comment"># 两篇文章创建时间的权重，其中的参数可以调节</span></span><br><span class="line">                <span class="comment"># 两篇文章发布时间接近 → 更可能是同一热点 / 主题</span></span><br><span class="line">                created_time_weight = np.exp(</span><br><span class="line">                    <span class="number">0.8</span> ** <span class="built_in">abs</span>(item_created_time_dict[i] - item_created_time_dict[j])</span><br><span class="line">                )</span><br><span class="line">                <span class="comment"># 考虑多种因素的权重，而不是简单计算共现次数C[i][j]</span></span><br><span class="line">                <span class="comment"># 加上用户活跃度惩罚，防止重度用户放大权重</span></span><br><span class="line">                <span class="comment"># 累加最终共现贡献</span></span><br><span class="line">                i2i_sim[i][j] += (</span><br><span class="line">                    loc_weight *</span><br><span class="line">                    click_time_weight *</span><br><span class="line">                    created_time_weight /</span><br><span class="line">                    math.log(<span class="built_in">len</span>(item_time_list) + <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    i2i_sim_ = i2i_sim.copy()</span><br><span class="line">    <span class="keyword">for</span> i, related_items <span class="keyword">in</span> i2i_sim.items():</span><br><span class="line">        <span class="keyword">for</span> j, wij <span class="keyword">in</span> related_items.items():</span><br><span class="line">            <span class="comment"># 相似度归一化，防止热门 item 和所有都很像</span></span><br><span class="line">            i2i_sim_[i][j] = wij / math.sqrt(item_cnt[i] * item_cnt[j])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将得到的相似性矩阵保存到本地</span></span><br><span class="line">    pickle.dump(i2i_sim_, <span class="built_in">open</span>(temp_path / <span class="string">'itemcf_i2i_sim.pkl'</span>, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i2i_sim_</span><br></pre></td></tr></tbody></table></figure>

<h4 id="userCF-u2u-sim"><a href="#userCF-u2u-sim" class="headerlink" title="userCF u2u_sim"></a>userCF u2u_sim</h4><p>在计算用户之间的相似度的时候，也可以使用一些简单的关联规则，比如用户活跃度权重，这里将用户的点击次数作为用户活跃度的指标</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_activate_degree_dict</span>(<span class="params">all_click_df</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        用户活跃度计算</span></span><br><span class="line"><span class="string">        :param all_click_df: 数据表</span></span><br><span class="line"><span class="string">        return 用户用户活跃度字典</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># click_article_id 变为 user 点击次数统计</span></span><br><span class="line">    all_click_df_ = all_click_df.groupby(<span class="string">'user_id'</span>)[<span class="string">'click_article_id'</span>].count().reset_index()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用户活跃度归一化</span></span><br><span class="line">    mm = MinMaxScaler()</span><br><span class="line">    all_click_df_[<span class="string">'click_article_id'</span>] = mm.fit_transform(all_click_df_[[<span class="string">'click_article_id'</span>]])</span><br><span class="line">    user_activate_degree_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(all_click_df_[<span class="string">'user_id'</span>], all_click_df_[<span class="string">'click_article_id'</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user_activate_degree_dict </span><br></pre></td></tr></tbody></table></figure>

<p>这个“活跃度分数”用来控制重度用户的影响力，用于共现统计/相似度计算时惩罚活跃用户</p>
<p>根据“哪些用户点过同一篇文章”，计算用户和用户之间的相似度矩阵</p>
<p>和 ItemCF 的差别只在“视角”</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>共现的主体</th>
</tr>
</thead>
<tbody><tr>
<td>ItemCF</td>
<td>同一个用户点过哪些 item</td>
</tr>
<tr>
<td>UserCF</td>
<td>同一个 item 被哪些用户点过</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">usercf_sim</span>(<span class="params">all_click_df, user_activate_degree_dict</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        用户相似性矩阵计算</span></span><br><span class="line"><span class="string">        :param all_click_df: 数据表</span></span><br><span class="line"><span class="string">        :param user_activate_degree_dict: 用户活跃度的字典</span></span><br><span class="line"><span class="string">        return 用户相似性矩阵</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    item_user_time_dict = get_item_user_time_dict(all_click_df)</span><br><span class="line"></span><br><span class="line">    u2u_sim = {}</span><br><span class="line">    user_cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> item, user_time_list <span class="keyword">in</span> tqdm(item_user_time_dict.items()):</span><br><span class="line">        <span class="comment"># 固定一个用户 u</span></span><br><span class="line">        <span class="keyword">for</span> u, click_time <span class="keyword">in</span> user_time_list:</span><br><span class="line">            user_cnt[u] += <span class="number">1</span></span><br><span class="line">            u2u_sim.setdefault(u, {})</span><br><span class="line">            <span class="comment"># 和同一篇文章的其它用户 v 配对</span></span><br><span class="line">            <span class="keyword">for</span> v, click_time <span class="keyword">in</span> user_time_list:</span><br><span class="line">                u2u_sim[u].setdefault(v, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> u == v:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 用户平均活跃度作为活跃度的权重，这里的式子也可以改善</span></span><br><span class="line">                activate_weight = <span class="number">100</span> * <span class="number">0.5</span> * (</span><br><span class="line">                    user_activate_degree_dict[u] +</span><br><span class="line">                    user_activate_degree_dict[v]</span><br><span class="line">                )</span><br><span class="line">                <span class="comment"># 用户活跃度惩罚，防止热门item放大共现</span></span><br><span class="line">                <span class="comment"># 如果不做这个，用户点得越多，和所有人的相似度都越高</span></span><br><span class="line">                u2u_sim[u][v] += activate_weight / math.log(<span class="built_in">len</span>(user_time_list) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    u2u_sim_ = u2u_sim.copy()</span><br><span class="line">    <span class="keyword">for</span> u, related_users <span class="keyword">in</span> u2u_sim.items():</span><br><span class="line">        <span class="keyword">for</span> v, wij <span class="keyword">in</span> related_users.items():</span><br><span class="line">            <span class="comment"># 相似度归一化</span></span><br><span class="line">            u2u_sim_[u][v] = wij / math.sqrt(user_cnt[u] * user_cnt[v])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将得到的相似性矩阵保存到本地</span></span><br><span class="line">    pickle.dump(u2u_sim_, <span class="built_in">open</span>(temp_path / <span class="string">'usercf_u2u_sim.pkl'</span>, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u2u_sim_</span><br></pre></td></tr></tbody></table></figure>

<p>在这里时间戳没有被用到</p>
<blockquote>
<p>UserCF 里常常不加时间，因为用户兴趣变化快，两个人在不同时间点看同一篇文章未必代表兴趣相似</p>
<p>ItemCF 更适合用序列 + 时间，因为它在考虑“用户看了 i 之后，会不会看 j？”</p>
<p>UserCF 只考虑“用户和谁兴趣像？”，是群体相似问题，时间信号没那么直接</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usercf计算时候太耗费内存，全集计算非常爆炸</span></span><br><span class="line"><span class="comment"># user_activate_degree_dict = get_user_activate_degree_dict(all_click_df)</span></span><br><span class="line"><span class="comment"># u2u_sim = usercf_sim(all_click_df, user_activate_degree_dict)</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="item-embedding-sim"><a href="#item-embedding-sim" class="headerlink" title="item embedding sim"></a>item embedding sim</h4><p>使用Embedding计算item之间的相似度是为了后续冷启动的时候可以获取未出现在点击数据中的文章</p>
<p>Faiss 是 Facebook AI 团队开源的一个用于<font color="Violetred">向量聚类和相似性搜索</font>的库，底层由 C++ 实现，常用于推荐系统中的<strong>向量召回阶段</strong></p>
<p>在向量召回中，常见形式包括 u2u、u2i 和 i2i。最直观的做法是通过两层循环遍历用户或物品向量，逐一计算相似度，但在用户和物品规模巨大的实际场景下，这种方式计算成本极高，几乎不可行</p>
<p>Faiss 通过高效的索引结构和近似搜索算法，加速从海量向量中找到与查询向量最相似的 Top-K 向量，从而显著提升召回效率</p>
<p><strong>faiss查询的原理</strong></p>
<p>faiss使用了PCA和PQ(Product quantization乘积量化)两种技术进行向量压缩和编码</p>
<p><strong><font color="DarkViolet">PCA</font></strong></p>
<p>主成分分析（Principal components analysis)是最重要的降维方法之一</p>
<p>目标是在尽量少损失信息的前提下，把高维数据投影到低维空间</p>
<p>保留前几个“主成分”相当于用更少的维度，描述数据中最重要的变化结构</p>
<p>最简单的例子，从2维降到1维，希望找到某一个维度方向，它可以代表这两个维度的数据</p>
<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/1042406-20161231162149992-1521335659.webp" alt="1042406-20161231162149992-1521335659" style="zoom:80%;">

<p>人眼可以看出$u_2$比$u_1$好，因为样本点在这个直线上的投影能尽可能的分开</p>
<p>标准 PCA 流程：</p>
<ol>
<li>原始数据矩阵$X$</li>
<li>去均值（中心化） $X_c = X-\mu$</li>
<li>计算协方差矩阵  </li>
<li>特征值分解 / SVD</li>
<li>按特征值从大到小排序</li>
<li>选前 k 个主成分</li>
<li>投影降维</li>
</ol>
<p>将样本$x^{(i)}$投影到方向$w$上<br>$$<br>z^{(i)} = w^Tx^{(i)} \qquad  Z = Xw<br>$$<br>目标函数：最大化投影后的方差(均值已经是0了)<br>$$<br>\text{Var}(Z) = \frac{1}{n}\sum(w^Tx^{(i)})^22 =\frac{1}{n}||X_cw||^2 =w^T(\frac{1}{n}X_c^TX_c)w<br>$$<br>协方差矩阵写为<br>$$<br>\sum = \frac{1}{n}X_c^TX_c \in \mathbb R^{d\times d}<br>$$</p>
<hr>
<p>用拉格朗日函数算$w$，$w$的约束是$w^Tw = 1$<br>$$<br>\mathcal L(w,\lambda) = w^T \Sigma w - \lambda ( w^T w - 1 )<br>$$<br>对$w$求导并令其为0<br>$$<br>\frac{\partial \mathcal L}{\partial w} = 2 \Sigma w - 2 \lambda w = 0 \rightarrow \Sigma w = \lambda w<br>$$<br>最大方差 ⇒ 取最大特征值对应的特征向量</p>
<p>$\Sigma$是对称正定矩阵，因此存在$d$个正交的特征向量</p>
<p>第一主成分就是最大方差方向，第二主成分是在正交约束下，取次大特征值的特征向量</p>
<hr>
<p>这种用拉格朗日的解法为理论解法，但工程上几乎不用“直接特征分解协方差矩阵”，维度大的时候解复杂度太高，所以用SVD</p>
<p>右奇异向量就是主成分方向，奇异值平方对应方差大小</p>
<p><strong>PQ编码</strong>：通过把向量拆分到多个低维子空间并分别量化，用极少的存储成本近似向量距离，查询时通过查表加法完成距离计算</p>
<p><strong>faiss使用</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向量检索相似度计算</span></span><br><span class="line"><span class="comment"># topk指的是每个item, faiss搜索后返回最相似的topk个item</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">embdding_sim</span>(<span class="params">click_df, item_emb_df, save_path, topk</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        基于内容的文章embedding相似性矩阵计算</span></span><br><span class="line"><span class="string">        :param click_df: 数据表</span></span><br><span class="line"><span class="string">        :param item_emb_df: 文章的embedding</span></span><br><span class="line"><span class="string">        :param save_path: 保存路径</span></span><br><span class="line"><span class="string">        :patam topk: 找最相似的topk篇</span></span><br><span class="line"><span class="string">        return 文章相似性矩阵</span></span><br><span class="line"><span class="string">        思路: 对于每一篇文章， 基于embedding的相似性返回topk个与其最相似的文章，由于文章数量太多，使用faiss进行加速</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 文章索引与文章id的字典映射</span></span><br><span class="line">    <span class="comment"># 因为faiss只认向量在数组里的index，需要保留一个映射表</span></span><br><span class="line">    item_idx_2_rawid_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(item_emb_df.index, item_emb_df[<span class="string">'article_id'</span>]))</span><br><span class="line"></span><br><span class="line">    item_emb_cols = [x <span class="keyword">for</span> x <span class="keyword">in</span> item_emb_df.columns <span class="keyword">if</span> <span class="string">'emb'</span> <span class="keyword">in</span> x]</span><br><span class="line">    item_emb_np = np.ascontiguousarray(</span><br><span class="line">        item_emb_df[item_emb_cols].values,</span><br><span class="line">        dtype=np.float32</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 向量进行单位化</span></span><br><span class="line">    item_emb_np = item_emb_np / np.linalg.norm(item_emb_np, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立faiss索引</span></span><br><span class="line">    item_index = faiss.IndexFlatIP(item_emb_np.shape[<span class="number">1</span>])</span><br><span class="line">    item_index.add(item_emb_np)</span><br><span class="line">    <span class="comment"># 相似度查询，给每个索引位置上的向量返回topk个item以及相似度</span></span><br><span class="line">    sim, idx = item_index.search(item_emb_np, topk) <span class="comment"># 返回的是列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将向量检索的结果保存成原始id的对应关系</span></span><br><span class="line">    item_sim_dict = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">    <span class="keyword">for</span> target_idx, sim_value_list, rele_idx_list <span class="keyword">in</span> tqdm(</span><br><span class="line">            <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(item_emb_np)), sim, idx)</span><br><span class="line">    ):</span><br><span class="line">        <span class="comment"># 取当前 item 的原始 id</span></span><br><span class="line">        target_raw_id = item_idx_2_rawid_dict[target_idx]</span><br><span class="line">        <span class="comment"># 从1开始是为了去掉商品本身, 所以最终获得的相似商品只有topk-1</span></span><br><span class="line">        <span class="keyword">for</span> rele_idx, sim_value <span class="keyword">in</span> <span class="built_in">zip</span>(rele_idx_list[<span class="number">1</span>:], sim_value_list[<span class="number">1</span>:]):</span><br><span class="line">            rele_raw_id = item_idx_2_rawid_dict[rele_idx]</span><br><span class="line">            <span class="comment"># 累加相似度，为后续融合留口子</span></span><br><span class="line">            item_sim_dict[target_raw_id][rele_raw_id] = (</span><br><span class="line">                    item_sim_dict.get(target_raw_id, {}).get(rele_raw_id, <span class="number">0</span>) + sim_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存i2i相似度矩阵</span></span><br><span class="line">    pickle.dump(item_sim_dict, <span class="built_in">open</span>(save_path / <span class="string">'emb_i2i_sim.pkl'</span>, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item_sim_dict</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> 这里需要修改, 因为usercf_sim计算太耗费内存了，暂时先采样</span></span><br><span class="line">item_emb_df = pd.read_csv(data_path / <span class="string">'articles_emb.csv'</span>).sample(<span class="number">10000</span>, random_state=<span class="number">0</span>).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">emb_i2i_sim = embdding_sim(all_click_df, item_emb_df, temp_path, topk=<span class="number">10</span>) <span class="comment"># topk可以自行设置</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="召回"><a href="#召回" class="headerlink" title="召回"></a>召回</h3><p>面对几十万文章、几十万用户的推荐问题，不可能对所有用户和所有文章做全量匹配，所以必须在召回阶段先用多种策略筛出一个小规模候选集，再交给后续排序模型处理</p>
<p>对每个用户，只考虑一小部分“有希望被点击的文章”，这一步就叫<font color="DarkViolet">召回（Recall）</font></p>
<p>召回常用的策略：</p>
<ul>
<li><p>基于文章的召回(i2i)</p>
<p>文章协同过滤(被同一用户点击)、文章 embedding(内容 / 表征向量)</p>
<p>不直接建模用户，只需要用户的历史点击文章，稳定、冷启动友好，</p>
</li>
<li><p>基于用户的召回(u2u)</p>
<p>用户协同过滤(点击行为重合)、用户 embedding(用户向量空间)</p>
<p>更个性化，对用户历史依赖更强，冷启动用户效果差</p>
</li>
<li><p>用户–文章直接匹配(u2i)</p>
<p>先学用户 embedding，再学文章 embedding，直接算用户向量和文章向量的相似度</p>
<p>双塔模型，YouTubeDNN召回</p>
<p>把用户和文章放进同一向量空间，工程复杂，但效果强</p>
</li>
</ul>
<h4 id="YoutubeDNN召回"><a href="#YoutubeDNN召回" class="headerlink" title="YoutubeDNN召回"></a>YoutubeDNN召回</h4><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52169807">重读Youtube深度学习推荐系统论文，字字珠玑，惊为神文 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52504407">YouTube深度学习推荐系统的十大工程问题 - 知乎</a></li>
</ol>
<p>用户塔 + 序列建模：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取双塔召回时的训练验证数据</span></span><br><span class="line"><span class="comment"># negsample指的是通过滑窗构建样本的时候，负样本的数量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_data_set</span>(<span class="params">data, negsample=<span class="number">0</span></span>):</span><br><span class="line">    <span class="comment"># 时间排序，确认因果顺序</span></span><br><span class="line">    data.sort_values(<span class="string">"click_timestamp"</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 用于后续负采样</span></span><br><span class="line">    item_ids = data[<span class="string">'click_article_id'</span>].unique()</span><br><span class="line"></span><br><span class="line">    train_set = []</span><br><span class="line">    test_set = []</span><br><span class="line">    <span class="keyword">for</span> reviewerID, hist <span class="keyword">in</span> tqdm(data.groupby(<span class="string">'user_id'</span>)):</span><br><span class="line">        pos_list = hist[<span class="string">'click_article_id'</span>].tolist()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> negsample &gt; <span class="number">0</span>:</span><br><span class="line">            candidate_set = <span class="built_in">list</span>(<span class="built_in">set</span>(item_ids) - <span class="built_in">set</span>(pos_list))   <span class="comment"># 用户没看过的文章里面选择负样本</span></span><br><span class="line">            neg_list = np.random.choice(candidate_set,size=<span class="built_in">len</span>(pos_list)*negsample,replace=<span class="literal">True</span>)  <span class="comment"># 对于每个正样本，选择n个负样本</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 长度只有一个的时候，需要把这条数据也放到训练集中，不然的话最终学到的embedding就会有缺失</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pos_list) == <span class="number">1</span>:</span><br><span class="line">            train_set.append((reviewerID, [pos_list[<span class="number">0</span>]], pos_list[<span class="number">0</span>],<span class="number">1</span>,<span class="built_in">len</span>(pos_list)))</span><br><span class="line">            test_set.append((reviewerID, [pos_list[<span class="number">0</span>]], pos_list[<span class="number">0</span>],<span class="number">1</span>,<span class="built_in">len</span>(pos_list)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 滑窗构造正负样本</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(pos_list)):</span><br><span class="line">            hist = pos_list[:i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i != <span class="built_in">len</span>(pos_list) - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 反转hist: 最近行为更重要</span></span><br><span class="line">                train_set.append((reviewerID, hist[::-<span class="number">1</span>], pos_list[i], <span class="number">1</span>, <span class="built_in">len</span>(hist[::-<span class="number">1</span>])))  <span class="comment"># 正样本 [user_id, his_item, pos_item, label, len(his_item)]</span></span><br><span class="line">                <span class="keyword">for</span> negi <span class="keyword">in</span> <span class="built_in">range</span>(negsample):</span><br><span class="line">                    train_set.append((reviewerID, hist[::-<span class="number">1</span>], neg_list[i*negsample+negi], <span class="number">0</span>,<span class="built_in">len</span>(hist[::-<span class="number">1</span>]))) <span class="comment"># 负样本 [user_id, his_item, neg_item, label, len(his_item)]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将最长的那一个序列长度作为测试数据</span></span><br><span class="line">                test_set.append((reviewerID, hist[::-<span class="number">1</span>], pos_list[i],<span class="number">1</span>,<span class="built_in">len</span>(hist[::-<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">    random.shuffle(train_set)</span><br><span class="line">    random.shuffle(test_set)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_set, test_set</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入的数据进行padding，使得序列特征的长度都一致</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_model_input</span>(<span class="params">train_set,user_profile,seq_max_len</span>):</span><br><span class="line"></span><br><span class="line">    train_uid = np.array([line[<span class="number">0</span>] <span class="keyword">for</span> line <span class="keyword">in</span> train_set])</span><br><span class="line">    train_seq = [line[<span class="number">1</span>] <span class="keyword">for</span> line <span class="keyword">in</span> train_set]</span><br><span class="line">    train_iid = np.array([line[<span class="number">2</span>] <span class="keyword">for</span> line <span class="keyword">in</span> train_set])</span><br><span class="line">    train_label = np.array([line[<span class="number">3</span>] <span class="keyword">for</span> line <span class="keyword">in</span> train_set])</span><br><span class="line">    train_hist_len = np.array([line[<span class="number">4</span>] <span class="keyword">for</span> line <span class="keyword">in</span> train_set])</span><br><span class="line">    <span class="comment"># 序列 padding 保证输入长度一致</span></span><br><span class="line">    train_seq_pad = pad_sequences(</span><br><span class="line">        train_seq,</span><br><span class="line">        maxlen=seq_max_len,</span><br><span class="line">        padding=<span class="string">'post'</span>,</span><br><span class="line">        truncating=<span class="string">'post'</span>,</span><br><span class="line">        value=<span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">    train_model_input = {</span><br><span class="line">        <span class="string">"user_id"</span>: train_uid,</span><br><span class="line">        <span class="string">"click_article_id"</span>: train_iid,</span><br><span class="line">        <span class="string">"hist_article_id"</span>: train_seq_pad,</span><br><span class="line">        <span class="string">"hist_len"</span>: train_hist_len</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_model_input, train_label</span><br></pre></td></tr></tbody></table></figure>

<p>构建YouTube DNN双塔</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense, Embedding, Input</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.sequence <span class="keyword">import</span> pad_sequences</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> faiss</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_youtubednn_model</span>(<span class="params"></span></span><br><span class="line"><span class="params">    user_vocab_size,</span></span><br><span class="line"><span class="params">    item_vocab_size,</span></span><br><span class="line"><span class="params">    seq_len,</span></span><br><span class="line"><span class="params">    emb_dim=<span class="number">16</span>,</span></span><br><span class="line"><span class="params">    dnn_units=(<span class="params"><span class="number">32</span>,</span>),</span></span><br><span class="line"><span class="params">    neg_sample=<span class="number">20</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="comment"># ---------- 输入 ----------</span></span><br><span class="line">    user_inp = Input(shape=(<span class="number">1</span>,), name=<span class="string">'user_id'</span>)</span><br><span class="line">    item_inp = Input(shape=(<span class="number">1</span>,), name=<span class="string">'click_article_id'</span>)</span><br><span class="line">    hist_inp = Input(shape=(seq_len,), name=<span class="string">'hist_article_id'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- Embedding（item &amp; hist 共享） ----------</span></span><br><span class="line">    user_emb_layer = Embedding(user_vocab_size, emb_dim, name=<span class="string">'user_emb'</span>)</span><br><span class="line">    item_emb_layer = Embedding(item_vocab_size, emb_dim, name=<span class="string">'item_emb'</span>)</span><br><span class="line"></span><br><span class="line">    user_emb = tf.squeeze(user_emb_layer(user_inp), axis=<span class="number">1</span>)      <span class="comment"># [B, D]</span></span><br><span class="line">    item_emb = tf.squeeze(item_emb_layer(item_inp), axis=<span class="number">1</span>)      <span class="comment"># [B, D]</span></span><br><span class="line">    hist_emb = item_emb_layer(hist_inp)                           <span class="comment"># [B, L, D]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- hist mean pooling ----------</span></span><br><span class="line">    hist_mask = tf.cast(hist_inp &gt; <span class="number">0</span>, tf.float32)</span><br><span class="line">    hist_len = tf.reduce_sum(hist_mask, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    hist_len = tf.maximum(hist_len, <span class="number">1.0</span>)</span><br><span class="line">    hist_mask = tf.expand_dims(hist_mask, axis=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    hist_sum = tf.reduce_sum(hist_emb * hist_mask, axis=<span class="number">1</span>)</span><br><span class="line">    hist_mean = hist_sum / hist_len                               <span class="comment"># [B, D]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- User Tower ----------</span></span><br><span class="line">    user_vec = tf.concat([user_emb, hist_mean], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, u <span class="keyword">in</span> <span class="built_in">enumerate</span>(dnn_units):</span><br><span class="line">        user_vec = Dense(u, activation=<span class="string">'relu'</span>, name=<span class="string">f'user_dnn_<span class="subst">{i}</span>'</span>)(user_vec)</span><br><span class="line"></span><br><span class="line">    user_vec = Dense(emb_dim, activation=<span class="literal">None</span>, name=<span class="string">'user_out'</span>)(user_vec)</span><br><span class="line">    user_vec = tf.nn.l2_normalize(user_vec, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- Sampled Softmax ----------</span></span><br><span class="line">    loss = tf.nn.sampled_softmax_loss(</span><br><span class="line">        weights=item_emb_layer.embeddings,</span><br><span class="line">        biases=tf.zeros([item_vocab_size]),</span><br><span class="line">        labels=item_inp,</span><br><span class="line">        inputs=user_vec,</span><br><span class="line">        num_sampled=neg_sample,</span><br><span class="line">        num_classes=item_vocab_size</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    model = Model(</span><br><span class="line">        inputs=[user_inp, item_inp, hist_inp],</span><br><span class="line">        outputs=user_vec</span><br><span class="line">    )</span><br><span class="line">    model.add_loss(tf.reduce_mean(loss))</span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=tf.keras.optimizers.Adam(<span class="number">1e-4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- User / Item Embedding Model ----------</span></span><br><span class="line">    user_model = Model(</span><br><span class="line">        inputs=[user_inp, hist_inp],</span><br><span class="line">        outputs=user_vec</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model, user_model, item_emb_layer</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">youtubednn_u2i_dict</span>(<span class="params">data, topk=<span class="number">20</span></span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    - 标签/目标为正样本采样（sampled softmax 内部使用 item_id 作为 label）</span></span><br><span class="line"><span class="string">    - 通过滑窗构造训练/测试样本，使用最近序列作为测试</span></span><br><span class="line"><span class="string">    - 历史序列长度固定为 SEQ_LEN，并做 post-padding</span></span><br><span class="line"><span class="string">    - 训练完成后提取 user/item embedding，使用 FAISS 基于内积做 TopK 近邻召回</span></span><br><span class="line"><span class="string">    - 返回 {user_raw_id: [(item_raw_id, score), ...]} 的召回结果字典</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 内联配置</span></span><br><span class="line">    seq_len = <span class="number">30</span></span><br><span class="line">    emb_dim = <span class="number">16</span></span><br><span class="line">    neg_sample = <span class="number">20</span></span><br><span class="line">    dnn_units = [<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">    df = data.copy()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类别编码</span></span><br><span class="line">    user_encoder = LabelEncoder()</span><br><span class="line">    item_encoder = LabelEncoder()</span><br><span class="line"></span><br><span class="line">    df[<span class="string">'user_id'</span>] = user_encoder.fit_transform(df[<span class="string">'user_id'</span>])</span><br><span class="line">    df[<span class="string">'click_article_id'</span>] = item_encoder.fit_transform(df[<span class="string">'click_article_id'</span>])</span><br><span class="line"></span><br><span class="line">    user_cnt = df[<span class="string">'user_id'</span>].nunique()</span><br><span class="line">    item_cnt = df[<span class="string">'click_article_id'</span>].nunique()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造训练/测试样本</span></span><br><span class="line">    train_set, test_set = gen_data_set(df, negsample=<span class="number">0</span>)</span><br><span class="line">    train_input = gen_model_input(train_set, seq_len)</span><br><span class="line">    test_input = gen_model_input(test_set, seq_len)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 搭建模型</span></span><br><span class="line">    model, user_model, item_emb_layer = build_youtubednn_model(</span><br><span class="line">        user_vocab_size=user_cnt + <span class="number">1</span>,</span><br><span class="line">        item_vocab_size=item_cnt + <span class="number">1</span>,</span><br><span class="line">        seq_len=seq_len,</span><br><span class="line">        emb_dim=emb_dim,</span><br><span class="line">        dnn_units=dnn_units,</span><br><span class="line">        neg_sample=neg_sample</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    model.fit(</span><br><span class="line">        {</span><br><span class="line">            <span class="string">"user_id"</span>: train_input[<span class="string">"user_id"</span>],</span><br><span class="line">            <span class="string">"click_article_id"</span>: train_input[<span class="string">"click_article_id"</span>],</span><br><span class="line">            <span class="string">"hist_article_id"</span>: train_input[<span class="string">"hist_article_id"</span>]</span><br><span class="line">        },</span><br><span class="line">        batch_size=<span class="number">128</span>,</span><br><span class="line">        epochs=<span class="number">5</span>,</span><br><span class="line">        verbose=<span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- embedding ----------</span></span><br><span class="line">    user_embs = user_model.predict(</span><br><span class="line">        {</span><br><span class="line">            <span class="string">"user_id"</span>: test_input[<span class="string">"user_id"</span>],</span><br><span class="line">            <span class="string">"hist_article_id"</span>: test_input[<span class="string">"hist_article_id"</span>]</span><br><span class="line">        },</span><br><span class="line">        batch_size=<span class="number">4096</span>,</span><br><span class="line">        verbose=<span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    item_embs = item_emb_layer.embeddings.numpy()</span><br><span class="line">    item_embs = item_embs / np.linalg.norm(item_embs, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- faiss ----------</span></span><br><span class="line">    index = faiss.IndexFlatIP(emb_dim)</span><br><span class="line">    index.add(item_embs.astype(np.float32))</span><br><span class="line"></span><br><span class="line">    sim, idx = index.search(user_embs.astype(np.float32), topk)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- id 回退 ----------</span></span><br><span class="line">    user_raw = user_encoder.inverse_transform(test_input[<span class="string">'user_id'</span>])</span><br><span class="line">    item_raw = item_encoder.inverse_transform(</span><br><span class="line">        np.arange(item_embs.shape[<span class="number">0</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    recall = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> u, sims, items <span class="keyword">in</span> <span class="built_in">zip</span>(user_raw, sim, idx):</span><br><span class="line">        <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">zip</span>(items[<span class="number">1</span>:], sims[<span class="number">1</span>:]):</span><br><span class="line">            recall[u].append((item_raw[i], <span class="built_in">float</span>(s)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recall</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要做召回评估，把训练集中的最后一次点击提取出来</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> metric_recall:</span><br><span class="line">    user_multi_recall_dict[<span class="string">'youtubednn_recall'</span>] = youtubednn_u2i_dict(all_click_df, topk=<span class="number">20</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    trn_hist_click_df, trn_last_click_df = get_hist_and_last_click(all_click_df)</span><br><span class="line">    user_multi_recall_dict[<span class="string">'youtubednn_recall'</span>] = youtubednn_u2i_dict(trn_hist_click_df, topk=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 召回效果评估</span></span><br><span class="line">    metrics_recall(user_multi_recall_dict[<span class="string">'youtubednn_recall'</span>], trn_last_click_df, topk=<span class="number">20</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>这里对齐torch</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> faiss</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YouTubeDNN</span>(nn.Module):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对齐 TensorFlow 版本的 YouTubeDNN：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    - user embedding + hist mean pooling</span></span><br><span class="line"><span class="string">    - DNN user tower</span></span><br><span class="line"><span class="string">    - item embedding table</span></span><br><span class="line"><span class="string">    - sampled softmax loss</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        user_vocab_size,</span></span><br><span class="line"><span class="params">        item_vocab_size,</span></span><br><span class="line"><span class="params">        seq_len,</span></span><br><span class="line"><span class="params">        emb_dim=<span class="number">16</span>,</span></span><br><span class="line"><span class="params">        dnn_units=(<span class="params"><span class="number">32</span>,</span>),</span></span><br><span class="line"><span class="params">        neg_sample=<span class="number">20</span></span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.user_emb = nn.Embedding(user_vocab_size, emb_dim)</span><br><span class="line">        <span class="variable language_">self</span>.item_emb = nn.Embedding(item_vocab_size, emb_dim)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.seq_len = seq_len</span><br><span class="line">        <span class="variable language_">self</span>.neg_sample = neg_sample</span><br><span class="line">        <span class="variable language_">self</span>.item_vocab_size = item_vocab_size</span><br><span class="line"></span><br><span class="line">        dnn_layers = []</span><br><span class="line">        input_dim = emb_dim * <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> dnn_units:</span><br><span class="line">            dnn_layers.append(nn.Linear(input_dim, u))</span><br><span class="line">            dnn_layers.append(nn.ReLU())</span><br><span class="line">            input_dim = u</span><br><span class="line">        dnn_layers.append(nn.Linear(input_dim, emb_dim))</span><br><span class="line">        <span class="variable language_">self</span>.user_dnn = nn.Sequential(*dnn_layers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, user_id, hist_item, target_item</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用于训练：</span></span><br><span class="line"><span class="string">        - user_id: [B]</span></span><br><span class="line"><span class="string">        - hist_item: [B, L]</span></span><br><span class="line"><span class="string">        - target_item: [B]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># ---------- embedding ----------</span></span><br><span class="line">        user_emb = <span class="variable language_">self</span>.user_emb(user_id)                 <span class="comment"># [B, D]</span></span><br><span class="line">        hist_emb = <span class="variable language_">self</span>.item_emb(hist_item)               <span class="comment"># [B, L, D]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ---------- hist mean pooling ----------</span></span><br><span class="line">        mask = (hist_item &gt; <span class="number">0</span>).<span class="built_in">float</span>()                     <span class="comment"># [B, L]</span></span><br><span class="line">        hist_len = mask.<span class="built_in">sum</span>(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>).clamp(<span class="built_in">min</span>=<span class="number">1.0</span>)</span><br><span class="line">        hist_emb = hist_emb * mask.unsqueeze(-<span class="number">1</span>)</span><br><span class="line">        hist_mean = hist_emb.<span class="built_in">sum</span>(dim=<span class="number">1</span>) / hist_len         <span class="comment"># [B, D]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ---------- user tower ----------</span></span><br><span class="line">        user_vec = torch.cat([user_emb, hist_mean], dim=<span class="number">1</span>)</span><br><span class="line">        user_vec = <span class="variable language_">self</span>.user_dnn(user_vec)</span><br><span class="line">        user_vec = F.normalize(user_vec, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ---------- sampled softmax ----------</span></span><br><span class="line">        loss = <span class="variable language_">self</span>.sampled_softmax_loss(user_vec, target_item)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sampled_softmax_loss</span>(<span class="params">self, user_vec, target_item</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        手写 sampled softmax（对齐 tf.nn.sampled_softmax_loss 语义）</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        batch_size = user_vec.size(<span class="number">0</span>)</span><br><span class="line">        device = user_vec.device</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 正样本 embedding</span></span><br><span class="line">        pos_emb = <span class="variable language_">self</span>.item_emb(target_item)               <span class="comment"># [B, D]</span></span><br><span class="line">        pos_logits = torch.<span class="built_in">sum</span>(user_vec * pos_emb, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 负采样 item</span></span><br><span class="line">        neg_items = torch.randint(</span><br><span class="line">            low=<span class="number">0</span>,</span><br><span class="line">            high=<span class="variable language_">self</span>.item_vocab_size,</span><br><span class="line">            size=(batch_size, <span class="variable language_">self</span>.neg_sample),</span><br><span class="line">            device=device</span><br><span class="line">        )</span><br><span class="line">        neg_emb = <span class="variable language_">self</span>.item_emb(neg_items)                 <span class="comment"># [B, K, D]</span></span><br><span class="line">        neg_logits = torch.bmm(</span><br><span class="line">            neg_emb, user_vec.unsqueeze(-<span class="number">1</span>)</span><br><span class="line">        ).squeeze(-<span class="number">1</span>)                                      <span class="comment"># [B, K]</span></span><br><span class="line"></span><br><span class="line">        logits = torch.cat([pos_logits, neg_logits], dim=<span class="number">1</span>)</span><br><span class="line">        labels = torch.zeros(batch_size, dtype=torch.long, device=device)</span><br><span class="line"></span><br><span class="line">        loss = F.cross_entropy(logits, labels)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="meta">    @torch.no_grad()</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_user_embedding</span>(<span class="params">self, user_id, hist_item</span>):</span><br><span class="line">        user_emb = <span class="variable language_">self</span>.user_emb(user_id)</span><br><span class="line">        hist_emb = <span class="variable language_">self</span>.item_emb(hist_item)</span><br><span class="line"></span><br><span class="line">        mask = (hist_item &gt; <span class="number">0</span>).<span class="built_in">float</span>()</span><br><span class="line">        hist_len = mask.<span class="built_in">sum</span>(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>).clamp(<span class="built_in">min</span>=<span class="number">1.0</span>)</span><br><span class="line">        hist_emb = hist_emb * mask.unsqueeze(-<span class="number">1</span>)</span><br><span class="line">        hist_mean = hist_emb.<span class="built_in">sum</span>(dim=<span class="number">1</span>) / hist_len</span><br><span class="line"></span><br><span class="line">        user_vec = torch.cat([user_emb, hist_mean], dim=<span class="number">1</span>)</span><br><span class="line">        user_vec = <span class="variable language_">self</span>.user_dnn(user_vec)</span><br><span class="line">        <span class="keyword">return</span> F.normalize(user_vec, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @torch.no_grad()</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_item_embedding</span>(<span class="params">self</span>):</span><br><span class="line">        emb = <span class="variable language_">self</span>.item_emb.weight</span><br><span class="line">        <span class="keyword">return</span> F.normalize(emb, dim=<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">youtubednn_u2i_dict_torch</span>(<span class="params">data, topk=<span class="number">20</span></span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    PyTorch 版本 YouTubeDNN 召回（语义对齐 TF 版）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    seq_len = <span class="number">30</span></span><br><span class="line">    emb_dim = <span class="number">16</span></span><br><span class="line">    neg_sample = <span class="number">20</span></span><br><span class="line">    dnn_units = (<span class="number">32</span>,)</span><br><span class="line"></span><br><span class="line">    df = data.copy()</span><br><span class="line"></span><br><span class="line">    user_encoder = LabelEncoder()</span><br><span class="line">    item_encoder = LabelEncoder()</span><br><span class="line"></span><br><span class="line">    df[<span class="string">'user_id'</span>] = user_encoder.fit_transform(df[<span class="string">'user_id'</span>])</span><br><span class="line">    df[<span class="string">'click_article_id'</span>] = item_encoder.fit_transform(df[<span class="string">'click_article_id'</span>])</span><br><span class="line"></span><br><span class="line">    user_cnt = df[<span class="string">'user_id'</span>].nunique()</span><br><span class="line">    item_cnt = df[<span class="string">'click_article_id'</span>].nunique()</span><br><span class="line"></span><br><span class="line">    train_set, test_set = gen_data_set(df, negsample=<span class="number">0</span>)</span><br><span class="line">    train_input = gen_model_input(train_set, seq_len)</span><br><span class="line">    test_input = gen_model_input(test_set, seq_len)</span><br><span class="line"></span><br><span class="line">    device = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"></span><br><span class="line">    model = YouTubeDNN(</span><br><span class="line">        user_vocab_size=user_cnt + <span class="number">1</span>,</span><br><span class="line">        item_vocab_size=item_cnt + <span class="number">1</span>,</span><br><span class="line">        seq_len=seq_len,</span><br><span class="line">        emb_dim=emb_dim,</span><br><span class="line">        dnn_units=dnn_units,</span><br><span class="line">        neg_sample=neg_sample</span><br><span class="line">    ).to(device)</span><br><span class="line"></span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- training ----------</span></span><br><span class="line">    model.train()</span><br><span class="line">    batch_size = <span class="number">128</span></span><br><span class="line">    n = <span class="built_in">len</span>(train_input[<span class="string">'user_id'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        perm = np.random.permutation(n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n, batch_size):</span><br><span class="line">            idx = perm[i:i+batch_size]</span><br><span class="line"></span><br><span class="line">            user_id = torch.tensor(train_input[<span class="string">'user_id'</span>][idx], device=device)</span><br><span class="line">            hist_item = torch.tensor(train_input[<span class="string">'hist_article_id'</span>][idx], device=device)</span><br><span class="line">            target_item = torch.tensor(train_input[<span class="string">'click_article_id'</span>][idx], device=device)</span><br><span class="line"></span><br><span class="line">            loss = model(user_id, hist_item, target_item)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- embedding ----------</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    user_embs = model.get_user_embedding(</span><br><span class="line">        torch.tensor(test_input[<span class="string">'user_id'</span>], device=device),</span><br><span class="line">        torch.tensor(test_input[<span class="string">'hist_article_id'</span>], device=device)</span><br><span class="line">    ).cpu().numpy()</span><br><span class="line"></span><br><span class="line">    item_embs = model.get_item_embedding().cpu().numpy()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- faiss ----------</span></span><br><span class="line">    index = faiss.IndexFlatIP(emb_dim)</span><br><span class="line">    index.add(item_embs.astype(np.float32))</span><br><span class="line">    sim, idx = index.search(user_embs.astype(np.float32), topk)</span><br><span class="line"></span><br><span class="line">    user_raw = user_encoder.inverse_transform(test_input[<span class="string">'user_id'</span>])</span><br><span class="line">    item_raw = item_encoder.inverse_transform(np.arange(item_embs.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    recall = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> u, sims, items <span class="keyword">in</span> <span class="built_in">zip</span>(user_raw, sim, idx):</span><br><span class="line">        <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">zip</span>(items[<span class="number">1</span>:], sims[<span class="number">1</span>:]):</span><br><span class="line">            recall[u].append((item_raw[i], <span class="built_in">float</span>(s)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recall</span><br></pre></td></tr></tbody></table></figure>

<h4 id="itemCF召回"><a href="#itemCF召回" class="headerlink" title="itemCF召回"></a>itemCF召回</h4><p>已经通过协同过滤，Embedding检索的方式得到了文章的相似度矩阵</p>
<p>使用协同过滤的思想，给用户召回与其历史文章相似的文章</p>
<p>在召回的时候，使用关联规则</p>
<ol>
<li>考虑相似文章与历史点击文章顺序的权重</li>
<li>考虑文章创建时间的权重，也就是考虑相似文章与历史点击文章创建时间差的权重</li>
<li>考虑文章内容相似度权重</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于商品的召回i2i</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">item_based_recommend</span>(<span class="params">user_id, user_item_time_dict, i2i_sim, sim_item_topk, recall_item_num, item_topk_click, item_created_time_dict, emb_i2i_sim</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        基于文章协同过滤的召回</span></span><br><span class="line"><span class="string">        :param user_id: 用户id</span></span><br><span class="line"><span class="string">        :param user_item_time_dict: 字典, 根据点击时间获取用户的点击文章序列   {user1: {item1: time1, item2: time2..}...}</span></span><br><span class="line"><span class="string">        :param i2i_sim: 字典，文章相似性矩阵</span></span><br><span class="line"><span class="string">        :param sim_item_topk: 整数， 选择与当前文章最相似的前k篇文章</span></span><br><span class="line"><span class="string">        :param recall_item_num: 整数， 最后的召回文章数量</span></span><br><span class="line"><span class="string">        :param item_topk_click: 列表，点击次数最多的文章列表，用户召回补全</span></span><br><span class="line"><span class="string">        :param emb_i2i_sim: 字典基于内容embedding算的文章相似矩阵</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return: 召回的文章列表 {item1:score1, item2: score2...}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 获取用户历史交互的文章</span></span><br><span class="line">    user_hist_items = user_item_time_dict[user_id]</span><br><span class="line"></span><br><span class="line">    item_rank = {}</span><br><span class="line">    <span class="keyword">for</span> loc, (i, click_time) <span class="keyword">in</span> <span class="built_in">enumerate</span>(user_hist_items):</span><br><span class="line">        <span class="comment"># 找它最相似的 K 篇文章</span></span><br><span class="line">        <span class="keyword">for</span> j, wij <span class="keyword">in</span> <span class="built_in">sorted</span>(i2i_sim[i].items(),</span><br><span class="line">                     key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>],</span><br><span class="line">                     reverse=<span class="literal">True</span>)[:sim_item_topk]:</span><br><span class="line">            <span class="comment"># 已看过的文章直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> user_hist_items:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 文章创建时间差权重</span></span><br><span class="line">            created_time_weight = np.exp(</span><br><span class="line">                <span class="number">0.8</span> ** np.<span class="built_in">abs</span>(</span><br><span class="line">                    item_created_time_dict[i] - item_created_time_dict[j]</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># 相似文章和历史点击文章序列中历史文章所在的位置权重</span></span><br><span class="line">            loc_weight = (<span class="number">0.9</span> ** (<span class="built_in">len</span>(user_hist_items) - loc))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 内容相似度权重，默认不影响</span></span><br><span class="line">            content_weight = <span class="number">1.0</span></span><br><span class="line">            <span class="comment"># 协同过滤为主，内容相似度为辅</span></span><br><span class="line">            <span class="keyword">if</span> emb_i2i_sim.get(i, {}).get(j, <span class="literal">None</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                content_weight += emb_i2i_sim[i][j]</span><br><span class="line">            <span class="keyword">if</span> emb_i2i_sim.get(j, {}).get(i, <span class="literal">None</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                content_weight += emb_i2i_sim[j][i]</span><br><span class="line"></span><br><span class="line">            item_rank.setdefault(j, <span class="number">0</span>)</span><br><span class="line">            item_rank[j] += (</span><br><span class="line">                created_time_weight *</span><br><span class="line">                loc_weight *</span><br><span class="line">                content_weight *</span><br><span class="line">                wij</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不足10个，用热门商品补全</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(item_rank) &lt; recall_item_num:</span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(item_topk_click):</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> item_rank.items(): <span class="comment"># 填充的item应该不在原来的列表中</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 填充文章永远排在真实推荐后面</span></span><br><span class="line">            item_rank[item] = - i - <span class="number">100</span> <span class="comment"># 随便给个负数就行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(item_rank) == recall_item_num:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    item_rank = <span class="built_in">sorted</span>(</span><br><span class="line">        item_rank.items(),</span><br><span class="line">        key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>],</span><br><span class="line">        reverse=<span class="literal">True</span></span><br><span class="line">    )[:recall_item_num]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item_rank</span><br></pre></td></tr></tbody></table></figure>

<p><font color="Violetred">itemCF sim召回</font></p>
<p>在这里<code>i2i_sim</code>是共现统计</p>
<p>主辅分离(行为相似度 × (1 + 内容相似度))</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先进行itemcf召回, 为了召回评估，所以提取最后一次点击</span></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    trn_hist_click_df, trn_last_click_df = get_hist_and_last_click(all_click_df)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    trn_hist_click_df = all_click_df</span><br><span class="line"></span><br><span class="line">user_recall_items_dict = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">user_item_time_dict = get_user_item_time(trn_hist_click_df)</span><br><span class="line"></span><br><span class="line">i2i_sim = pickle.load(<span class="built_in">open</span>(temp_path / <span class="string">'itemcf_i2i_sim.pkl'</span>, <span class="string">'rb'</span>))</span><br><span class="line">emb_i2i_sim = pickle.load(<span class="built_in">open</span>(temp_path / <span class="string">'emb_i2i_sim.pkl'</span>, <span class="string">'rb'</span>))</span><br><span class="line"></span><br><span class="line">sim_item_topk = <span class="number">20</span></span><br><span class="line">recall_item_num = <span class="number">10</span></span><br><span class="line">item_topk_click = get_item_topk_click(trn_hist_click_df, k=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> tqdm(trn_hist_click_df[<span class="string">'user_id'</span>].unique()):</span><br><span class="line">    user_recall_items_dict[user] = item_based_recommend(</span><br><span class="line">        user, user_item_time_dict,</span><br><span class="line">        i2i_sim, sim_item_topk, recall_item_num,</span><br><span class="line">        item_topk_click, item_created_time_dict, emb_i2i_sim)</span><br><span class="line"></span><br><span class="line">user_multi_recall_dict[<span class="string">'itemcf_sim_itemcf_recall'</span>] = user_recall_items_dict</span><br><span class="line">pickle.dump(user_multi_recall_dict[<span class="string">'itemcf_sim_itemcf_recall'</span>], <span class="built_in">open</span>(temp_path / <span class="string">'itemcf_recall_dict.pkl'</span>, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    <span class="comment"># 召回效果评估</span></span><br><span class="line">    metrics_recall(user_multi_recall_dict[<span class="string">'itemcf_sim_itemcf_recall'</span>], trn_last_click_df, topk=recall_item_num)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk:  10  :  hit_num:  6112 hit_rate:  0.6112 user_num :  10000</span><br></pre></td></tr></tbody></table></figure>

<p><font color="Violetred">embedding sim 召回</font></p>
<p>在这里<code>i2i_sim == emb_i2i_sim</code> </p>
<p>主辅叠加 embedding 相似度 × (1 + embedding 相似度)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里是为了召回评估，所以提取最后一次点击</span></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    trn_hist_click_df, trn_last_click_df = get_hist_and_last_click(all_click_df)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    trn_hist_click_df = all_click_df</span><br><span class="line"></span><br><span class="line">user_recall_items_dict = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">user_item_time_dict = get_user_item_time(trn_hist_click_df)</span><br><span class="line">i2i_sim = pickle.load(<span class="built_in">open</span>(temp_path / <span class="string">'emb_i2i_sim.pkl'</span>,<span class="string">'rb'</span>))</span><br><span class="line"></span><br><span class="line">sim_item_topk = <span class="number">20</span></span><br><span class="line">recall_item_num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">item_topk_click = get_item_topk_click(trn_hist_click_df, k=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> tqdm(trn_hist_click_df[<span class="string">'user_id'</span>].unique()):</span><br><span class="line">    user_recall_items_dict[user] = item_based_recommend(</span><br><span class="line">        user, user_item_time_dict,</span><br><span class="line">        i2i_sim, sim_item_topk, recall_item_num,</span><br><span class="line">        item_topk_click, item_created_time_dict, emb_i2i_sim)</span><br><span class="line"></span><br><span class="line">user_multi_recall_dict[<span class="string">'embedding_sim_item_recall'</span>] = user_recall_items_dict</span><br><span class="line">pickle.dump(user_multi_recall_dict[<span class="string">'embedding_sim_item_recall'</span>], <span class="built_in">open</span>(temp_path / <span class="string">'embedding_sim_item_recall.pkl'</span>, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    <span class="comment"># 召回效果评估</span></span><br><span class="line">    metrics_recall(user_multi_recall_dict[<span class="string">'embedding_sim_item_recall'</span>], trn_last_click_df, topk=recall_item_num)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk:  10  :  hit_num:  781 hit_rate:  0.0781 user_num :  10000</span><br></pre></td></tr></tbody></table></figure>

<h4 id="userCF召回"><a href="#userCF召回" class="headerlink" title="userCF召回"></a>userCF召回</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yhblogs.cn">今天睡够了吗</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yhblogs.cn/posts/3893.html">http://yhblogs.cn/posts/3893.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yhblogs.cn" target="_blank">がんばろう</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E2%8C%A8%EF%B8%8Fpython/">⌨️python</a></div><div class="post_share"><div class="social-share" data-image="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-mlz139_1280x720.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/58676.html" title="Leetcode100记录"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-9ozdyx_1280x720.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Leetcode100记录</div></div></a></div><div class="next-post pull-right"><a href="/posts/31208.html" title="FunRec 推荐系统_精排模型"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-7j931e_1280x720_(1) (1).png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">FunRec 推荐系统_精排模型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/30698.html" title="BERT_Pytorch"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-7jjyd9_2560x1440.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-09</div><div class="title">BERT_Pytorch</div></div></a></div><div><a href="/posts/31208.html" title="FunRec 推荐系统_精排模型"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-7j931e_1280x720_(1) (1).png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="title">FunRec 推荐系统_精排模型</div></div></a></div><div><a href="/posts/24333.html" title="FunRec推荐系统_召回模型"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-vpp725_1280x720_(1).webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-14</div><div class="title">FunRec推荐系统_召回模型</div></div></a></div><div><a href="/posts/58676.html" title="Leetcode100记录"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-9ozdyx_1280x720.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-26</div><div class="title">Leetcode100记录</div></div></a></div><div><a href="/posts/22642.html" title="windows安装ROCm"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/ROCm_logo.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-10</div><div class="title">windows安装ROCm</div></div></a></div><div><a href="/posts/3865533702.html" title="pyqt5简单实践"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071521231.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-28</div><div class="title">pyqt5简单实践</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/b_2a1aef95f351a5f7ef72eb81e6838fd6.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">今天睡够了吗</div><div class="author-info__description">相遇是最小单位的奇迹</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071549233.webp" target="_blank" title="QQ"><i class="iconfont icon-QQ"></i></a><a class="social-icon" href="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071549234.webp" target="_blank" title="微信"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://space.bilibili.com/277953459?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="https://github.com/YaoHui-Wu06022" target="_blank" title="Github"><i class="iconfont icon-GitHub"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">保持理智，相信明天</div><div class="twopeople"><div class="twopeople"><div class="container" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div> <script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script> <script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script> <script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script> <style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%9B%E9%A2%98%E7%90%86%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">赛题理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.</span> <span class="toc-text">数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">评价方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">问题分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">数据分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%8C%85"><span class="toc-number">2.1.</span> <span class="toc-text">导包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.</span> <span class="toc-text">读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">数据预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%8F%E8%A7%88"><span class="toc-number">2.4.</span> <span class="toc-text">数据浏览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Baseline"><span class="toc-number">3.</span> <span class="toc-text">Baseline</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%8C%85-1"><span class="toc-number">3.1.</span> <span class="toc-text">导包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#df%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">df节省内存函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">采样函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7-%E6%96%87%E7%AB%A0-%E7%82%B9%E5%87%BB%E6%97%B6%E9%97%B4"><span class="toc-number">3.4.</span> <span class="toc-text">用户-文章-点击时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topk%E7%83%AD%E9%97%A8%E6%96%87%E7%AB%A0"><span class="toc-number">3.5.</span> <span class="toc-text">Topk热门文章</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ItemCF%E7%9B%B8%E4%BC%BC%E5%BA%A6"><span class="toc-number">3.6.</span> <span class="toc-text">ItemCF相似度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#itemCF%E6%8E%A8%E8%8D%90"><span class="toc-number">3.7.</span> <span class="toc-text">itemCF推荐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%87%BD%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">提交函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%8F%AC%E5%9B%9E"><span class="toc-number">4.</span> <span class="toc-text">多路召回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%8C%85-2"><span class="toc-number">4.1.</span> <span class="toc-text">导包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE-1"><span class="toc-number">4.2.</span> <span class="toc-text">读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">工具函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E8%B7%AF%E5%8F%AC%E5%9B%9E%E5%AD%97%E5%85%B8"><span class="toc-number">4.3.1.</span> <span class="toc-text">定义多路召回字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AC%E5%9B%9E%E6%95%88%E6%9E%9C%E8%AF%84%E4%BC%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">召回效果评估</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%9B%B8%E4%BC%BC%E6%80%A7%E7%9F%A9%E9%98%B5"><span class="toc-number">4.4.</span> <span class="toc-text">计算相似性矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#itemCF-i2i-sim"><span class="toc-number">4.4.1.</span> <span class="toc-text">itemCF i2i_sim</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#userCF-u2u-sim"><span class="toc-number">4.4.2.</span> <span class="toc-text">userCF u2u_sim</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#item-embedding-sim"><span class="toc-number">4.4.3.</span> <span class="toc-text">item embedding sim</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AC%E5%9B%9E"><span class="toc-number">4.5.</span> <span class="toc-text">召回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#YoutubeDNN%E5%8F%AC%E5%9B%9E"><span class="toc-number">4.5.1.</span> <span class="toc-text">YoutubeDNN召回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#itemCF%E5%8F%AC%E5%9B%9E"><span class="toc-number">4.5.2.</span> <span class="toc-text">itemCF召回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#userCF%E5%8F%AC%E5%9B%9E"><span class="toc-number">4.5.3.</span> <span class="toc-text">userCF召回</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2022 - 2026 By 今天睡够了吗</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">You must always have faith in who you are！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>