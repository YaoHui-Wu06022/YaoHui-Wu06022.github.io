<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OpenCV基础 | がんばろう</title><meta name="author" content="今天睡够了吗"><meta name="copyright" content="今天睡够了吗"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OpenCV 是一个功能强大、应用广泛的计算机视觉库，提供了大量的计算机视觉算法和图像处理工具，广泛应用于图像和视频的处理、分析以及机器学习领域 使用pip安装是最简单和直接的方法，只需要在命令行中输入以下命令： 1pip install opencv-python  安装后导入包： 1import cv2  图像理论图像在计算机中本质上是以数字矩阵的形式存储的，其核心概念包括像素网格和颜色通道">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV基础">
<meta property="og:url" content="http://yhblogs.cn/posts/12373.html">
<meta property="og:site_name" content="がんばろう">
<meta property="og:description" content="OpenCV 是一个功能强大、应用广泛的计算机视觉库，提供了大量的计算机视觉算法和图像处理工具，广泛应用于图像和视频的处理、分析以及机器学习领域 使用pip安装是最简单和直接的方法，只需要在命令行中输入以下命令： 1pip install opencv-python  安装后导入包： 1import cv2  图像理论图像在计算机中本质上是以数字矩阵的形式存储的，其核心概念包括像素网格和颜色通道">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-pok5v9.webp">
<meta property="article:published_time" content="2025-09-22T13:04:57.000Z">
<meta property="article:modified_time" content="2025-11-01T15:04:06.751Z">
<meta property="article:author" content="今天睡够了吗">
<meta property="article:tag" content="⌨️python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-pok5v9.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yhblogs.cn/posts/12373.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OpenCV基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-01 15:04:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3319458_ks437t3n4r.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/b_2a1aef95f351a5f7ef72eb81e6838fd6.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-rili"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="がんばろう"><img class="site-icon" src="/img/favicon.png"><span class="site-name">がんばろう</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-rili"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">OpenCV基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-09-22T13:04:57.000Z" title="发表于 2025-09-22 13:04:57">2025-09-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>82分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OpenCV基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>OpenCV 是一个功能强大、应用广泛的计算机视觉库，提供了大量的计算机视觉算法和图像处理工具，广泛应用于图像和视频的处理、分析以及机器学习领域</p>
<p>使用pip安装是最简单和直接的方法，只需要在命令行中输入以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></tbody></table></figure>

<p>安装后导入包：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br></pre></td></tr></tbody></table></figure>

<h2 id="图像理论"><a href="#图像理论" class="headerlink" title="图像理论"></a>图像理论</h2><p>图像在计算机中本质上是以数字矩阵的形式存储的，其核心概念包括像素网格和颜色通道</p>
<p><strong>像素网格:</strong></p>
<ul>
<li>像素(pixel)：图片的最小单元，每个像素有位置(行、列)和颜色值</li>
<li>分辨率：宽×高(例如1920×1080)，表示像素矩阵的尺寸</li>
<li>像素矩阵：一张图片在内存里通常就是一个二维或三维数组(矩阵)，<font color="Violetred">H行xW列(x3or4通道)</font>，坐标系通常是左上角为原点(行号向下增大)</li>
</ul>
<p><strong>颜色与通道:</strong></p>
<ul>
<li>RGB：最常见，基于人眼感知颜色的方式，每个像素由3个通道(红、绿、蓝)组合成颜色</li>
<li>RGBA：RGB + Alpha(透明度)，Alpha 通道决定像素的透明程度</li>
<li>灰度：只有一个通道(亮度)，常用公式把 RGB 转成灰度：<code>Y = 0.299 R + 0.587 G + 0.114 B</code>(ITU标准) <font color="Violetred">0为黑，255为白</font></li>
<li>CMYK：印刷领域(青、品红、黄、黑)，基于减色法</li>
<li>YCbCr：主要用于JPEG，RGB转YCbCr，再对Cb、Cr下采样(4:2:0常见)，再做DCT压缩</li>
</ul>
<p><code>Pillow/Matplotlib</code>用RGB顺序，<font color="Violetred">OpenCV默认用BGR</font>，注意转换</p>
<p><strong>位深与数据类型:</strong></p>
<ul>
<li><p>常见：8位每通道(uint8)，范围0–255，RGB24(3×8=24 位)是最常见的普通图像</p>
</li>
<li><p>高精度：16位每通道(uint16)，范围0–65535，或32位浮点(float32)用于科学/HDR</p>
</li>
</ul>
<p><strong>常见的存储方式：</strong></p>
<table>
<thead>
<tr>
<th>格式</th>
<th>压缩方式</th>
<th>是否有损</th>
<th>支持透明度</th>
<th>特点与应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>BMP</td>
<td>无</td>
<td>无损</td>
<td>支持</td>
<td>简单直白，文件大</td>
</tr>
<tr>
<td>PNG</td>
<td>DEFLATE</td>
<td>无损</td>
<td>支持 Alpha</td>
<td>体积比BMP小<br>常用于需要透明的图形</td>
</tr>
<tr>
<td>GIF</td>
<td>LZW</td>
<td>无损</td>
<td>1 位透明</td>
<td>支持简单动画，但颜色数少</td>
</tr>
<tr>
<td>SVG</td>
<td>XML，可GZIP</td>
<td>无损</td>
<td>支持 Alpha</td>
<td>无限缩放不失真<br>图标/插画/图表</td>
</tr>
<tr>
<td>JPEG</td>
<td>DCT+量化</td>
<td>有损</td>
<td>不支持</td>
<td>照片最常用格式，高压缩比<br>反复保存会劣化</td>
</tr>
<tr>
<td>TIFF</td>
<td>多种</td>
<td>均可</td>
<td>支持</td>
<td>专业图像格式，高位深<br>摄影、医学、印刷常用</td>
</tr>
<tr>
<td>WebP</td>
<td>VP8/VP8L压缩</td>
<td>均可</td>
<td>支持 Alpha</td>
<td>压缩比优于JPEG/PNG，Web 常见</td>
</tr>
</tbody></table>
<h2 id="代码性能评估"><a href="#代码性能评估" class="headerlink" title="代码性能评估"></a>代码性能评估</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">start = cv2.getTickCount()</span><br><span class="line"><span class="comment"># 这里写测试代码...</span></span><br><span class="line">end = cv2.getTickCount()</span><br><span class="line"><span class="built_in">print</span>((end - start) / cv2.getTickFrequency())</span><br></pre></td></tr></tbody></table></figure>

<p>也可以用 time 模块计时</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.clock()</span><br><span class="line"><span class="comment"># 这里写测试代码...</span></span><br><span class="line">end = time.clock()</span><br><span class="line"><span class="built_in">print</span>(end - start)</span><br></pre></td></tr></tbody></table></figure>

<p>数据元素少时用 Python 语法，数据元素多时用 Numpy</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">z = np.uint8([<span class="number">10</span>])</span><br><span class="line">start = cv2.getTickCount()</span><br><span class="line">y = z*z*z <span class="comment"># 5.46e-05(最慢）</span></span><br><span class="line"><span class="comment"># y = x*x*x # 2.14e-05</span></span><br><span class="line"><span class="comment"># y = x**3 # 4.55e-05</span></span><br><span class="line">end = cv2.getTickCount()</span><br><span class="line"><span class="built_in">print</span>((end - start) / cv2.getTickFrequency())</span><br></pre></td></tr></tbody></table></figure>

<h2 id="图像基础操作"><a href="#图像基础操作" class="headerlink" title="图像基础操作"></a>图像基础操作</h2><p><strong>读取图片</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'Lena.bmp'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 读取保护</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Cannot load image"</span>)</span><br><span class="line">    exit()</span><br></pre></td></tr></tbody></table></figure>

<p>参数1：图片的文件名</p>
<p>参数2：读入方式，省略即采用默认值</p>
<ul>
<li><code>cv2.IMREAD_COLOR</code>：彩色图，默认值(1)</li>
<li><code>cv2.IMREAD_GRAYSCALE</code>：灰度图(0)</li>
<li><code>cv2.IMREAD_UNCHANGED</code>：包含透明通道的彩色图(-1)</li>
</ul>
<p><strong>显示图片</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"Lena"</span>,img) <span class="comment"># 参数1是窗口的名字，参数2是要显示的图片</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  <span class="comment"># 等待键盘输入(毫秒)，0 表示无限等待</span></span><br><span class="line"><span class="comment"># plt.imshow(img, 'gray') # 也可以用plt的imshow</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>保存图片</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"Lena_gray.bmp"</span>,img)</span><br></pre></td></tr></tbody></table></figure>

<p>可以传入第三个参数：</p>
<ul>
<li><code>cv2.IMWRITE_JPEG_QUALITY</code>：jpg 质量控制，取值 0~100，值越大质量越好，默认为 95</li>
<li><code>cv2.IMWRITE_PNG_COMPRESSION</code>：png 质量控制，取值 0~9，值越大压缩比越高，默认为 1</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">'img_jpg20.jpg'</span>,img, [<span class="built_in">int</span>(cv2.IMWRITE_JPEG_QUALITY), <span class="number">20</span>]) <span class="comment"># 9.74kB</span></span><br><span class="line">cv2.imwrite(<span class="string">'img_jpg100.jpg'</span>,img, [<span class="built_in">int</span>(cv2.IMWRITE_JPEG_QUALITY), <span class="number">100</span>]) <span class="comment"># 137kB</span></span><br><span class="line">cv2.imwrite(<span class="string">'img_png.png'</span>,img) <span class="comment"># 134kB</span></span><br><span class="line">cv2.imwrite(<span class="string">'img_png9.png'</span>,img,[<span class="built_in">int</span>(cv2.IMWRITE_PNG_COMPRESSION),<span class="number">9</span>]) <span class="comment"># 132kB</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="图像矩阵"><a href="#图像矩阵" class="headerlink" title="图像矩阵"></a>图像矩阵</h3><p>OpenCV读进来的图像是NumPy数组，shape通常是<code>(H, W, C)</code>，可以通过<code>img.shape</code>输出</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height, width, channels = img.shape</span><br><span class="line"><span class="comment"># img 是灰度图的话：height, width = img.shape</span></span><br></pre></td></tr></tbody></table></figure>

<p>图像是由像素组成的矩阵，每个像素都有一个或多个值，表示颜色或灰度</p>
<p><font color="Violetred">OpenCV默认的颜色空间为BGR</font></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"LenaRGB.bmp"</span>,<span class="number">1</span>)</span><br><span class="line">px = img[<span class="number">99</span>,<span class="number">99</span>]  </span><br><span class="line"><span class="built_in">print</span>(px)  <span class="comment"># 输出BGR[79 59 177]</span></span><br><span class="line">px_blue = img[<span class="number">99</span>,<span class="number">99</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(px_blue) <span class="comment"># 输出B 79</span></span><br></pre></td></tr></tbody></table></figure>

<p>ROI(Region of Interest)：利用<code>:</code>，也就是numpy的切片，将图片中的区域裁切出来</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取脸部 ROI</span></span><br><span class="line">face = img[<span class="number">239</span>:<span class="number">388</span>, <span class="number">238</span>:<span class="number">356</span>]</span><br><span class="line">cv2.imshow(<span class="string">"face"</span>,face)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h3><p>OpenCV 支持多种颜色空间的转换，通过<code>cv2.cvtColor(img, code)</code></p>
<p>常用转化<code>code</code>：</p>
<ul>
<li><code>cv2.COLOR_BGR2GRAY</code>: BGR彩色 -&gt; 灰度</li>
<li><code>cv2.COLOR_BGR2RGB</code>: BGR彩色 -&gt; RGB彩色(用于Matplotlib等显示)</li>
<li><code>cv2.COLOR_BGR2HSV</code>: BGR彩色 -&gt; HSV(色相、饱和度、亮度)</li>
<li><code>cv2.COLOR_GRAY2BGR</code>: 灰度 -&gt; BGR彩色 (单通道转三通道)</li>
</ul>
<p>颜色通道的分离与合并：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分离通道</span></span><br><span class="line">b, g, r = cv2.split(image)</span><br><span class="line"><span class="comment"># 合并通道</span></span><br><span class="line">merged_image = cv2.merge([b, g, r])</span><br></pre></td></tr></tbody></table></figure>

<p>单通道显示：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"LenaRGB.bmp"</span>,<span class="number">1</span>)</span><br><span class="line">b, g, r = cv2.split(img)</span><br><span class="line"><span class="comment"># 单通道保留，其他置零</span></span><br><span class="line">zeros = np.zeros_like(b)</span><br><span class="line">blue_img = cv2.merge([b, zeros, zeros])   <span class="comment"># 蓝色图</span></span><br><span class="line">green_img = cv2.merge([zeros, g, zeros])  <span class="comment"># 绿色图</span></span><br><span class="line">red_img = cv2.merge([zeros, zeros, r])    <span class="comment"># 红色图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(blue_img)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">plt.imshow(green_img)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">plt.imshow(red_img)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509241324.webp" alt="202509241324" style="zoom:67%;">

<h4 id="RGB-调色板"><a href="#RGB-调色板" class="headerlink" title="RGB 调色板"></a>RGB 调色板</h4><p>首先需要知道如何创建滑动条(滑块最小值固定为0)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(trackbarName, windowName, value, max_value ,call_back)</span><br></pre></td></tr></tbody></table></figure>

<p>实现一个 RGB 的调色板：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 创建一个黑色的画布</span></span><br><span class="line">img = np.zeros((<span class="number">300</span>,<span class="number">500</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">"RGB Palette"</span>)</span><br><span class="line"><span class="comment"># 创建三个滑动条，分别对应 R/G/B</span></span><br><span class="line">cv2.createTrackbar(<span class="string">"R"</span>,<span class="string">"RGB Palette"</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">"G"</span>,<span class="string">"RGB Palette"</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">"B"</span>,<span class="string">"RGB Palette"</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 读取滑动条的值</span></span><br><span class="line">    r = cv2.getTrackbarPos(<span class="string">"R"</span>, <span class="string">"RGB Palette"</span>)</span><br><span class="line">    g = cv2.getTrackbarPos(<span class="string">"G"</span>, <span class="string">"RGB Palette"</span>)</span><br><span class="line">    b = cv2.getTrackbarPos(<span class="string">"B"</span>, <span class="string">"RGB Palette"</span>)</span><br><span class="line">    <span class="comment"># 更新画布颜色(注意 OpenCV 是 BGR 顺序)</span></span><br><span class="line">    img[:] = [b, g, r]</span><br><span class="line">    <span class="comment"># 显示结果</span></span><br><span class="line">    cv2.imshow(<span class="string">"RGB Palette"</span>, img)</span><br><span class="line">    <span class="comment"># 按下 ESC 键退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p><font color="Violetred">在cv2的函数中输入的一般是(w,h)，虽然在numpy输出的shape是(h,w)</font></p>
<h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><p><code>cv2.warpAffine()</code>：仿射变换是一种保持直线和比例关系的线性几何变换</p>
<p>长度/角度可能变化，但相对位置关系不变</p>
<p>常见的仿射变换包括：缩放、翻转、平移、旋转</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.warpAffine(img, M, dsize)</span><br></pre></td></tr></tbody></table></figure>

<p>其中<code>M</code>是变换矩阵，<code>dsize</code>是输出图像大小<code>(width, height)</code></p>
<p>变换矩阵可以通过<code>cv2.getAffineTransform()</code>求得，只需要知道变换前后对应三个点的坐标即可</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"Lena.bmp"</span>)</span><br><span class="line">rows, cols = img.shape[:<span class="number">2</span>] <span class="comment"># 获取原图(height, width)</span></span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>, <span class="number">50</span>], [<span class="number">100</span>, <span class="number">50</span>], [<span class="number">50</span>, <span class="number">200</span>]])  <span class="comment"># 原图 3 点</span></span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">150</span>, <span class="number">50</span>], [<span class="number">100</span>, <span class="number">250</span>]]) <span class="comment"># 目标 3 点</span></span><br><span class="line"><span class="comment"># 生成变换矩阵</span></span><br><span class="line">M = cv2.getAffineTransform(pts1, pts2)</span><br><span class="line">dst = cv2.warpAffine(img, M, (cols*<span class="number">2</span>, rows*<span class="number">2</span>)) <span class="comment"># 输入(width,height)</span></span><br><span class="line">plt.imshow(dst,<span class="string">'gray'</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/20259242130.webp" alt="20259242130" style="zoom: 67%;">

<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p><code>cv2.resize()</code>：调整图像大小(放大或缩小)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定尺寸(width,height)</span></span><br><span class="line">resized_img = cv2.resize(img, (new_width,new_height))</span><br><span class="line"><span class="comment"># 按比例缩小</span></span><br><span class="line">scale_factor = <span class="number">0.5</span></span><br><span class="line">resized_img = cv2.resize(img, <span class="literal">None</span>, fx=scale_factor, fy=scale_factor, interpolation=cv2.INTER_AREA)</span><br></pre></td></tr></tbody></table></figure>

<p><code>interpolation</code>(插值方法)：</p>
<ul>
<li><code>cv2.INTER_LINEAR</code> 双线性(默认，放大推荐)</li>
<li><code>cv2.INTER_AREA</code> 区域插值(缩小推荐)</li>
<li><code>cv2.INTER_CUBIC</code> 三次插值(更平滑，慢)</li>
<li><code>cv2.INTER_NEAREST</code> 最近邻(最快，但可能马赛克)</li>
</ul>
<h4 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h4><p><code>cv2.flip()</code>：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flipped_img = cv2.flip(image, flip_code)  </span><br><span class="line"><span class="comment"># flip_code: 0 (垂直翻转), 1 (水平翻转), -1 (双向翻转)</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p>使用仿射变换函数<code>cv2.warpAffine()</code></p>
<p>需要定义一个变换矩阵，$tx ,ty$是向$x$和$y$方向平移的距离，$M=[[1,0,t_x],[0,1,t_y]]$</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(h, w) = img.shape[:<span class="number">2</span>]  <span class="comment"># 输出高与宽</span></span><br><span class="line"><span class="comment"># 向右移100像素，向下移50像素</span></span><br><span class="line">translation_matrix = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>]])  </span><br><span class="line">shifted_img = cv2.warpAffine(img, translation_matrix, (w, h))</span><br></pre></td></tr></tbody></table></figure>

<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>使用仿射变换函数<code>cv2.warpAffine()</code></p>
<p>绕某个点旋转，可伴随缩放，也需要定义一个变换矩阵</p>
<p>通过<code>cv2.getRotationMatrix2D()</code>函数来生成这个矩阵，该函数有三个参数</p>
<ul>
<li>参数1：图片的旋转中心(一般是<code>(w//2,h//2)</code>)</li>
<li>参数2：旋转角度(正：逆时针，负：顺时针)</li>
<li>参数3：缩放比例，0.5 表示缩小一半</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">center = (w//<span class="number">2</span>, h//<span class="number">2</span>)</span><br><span class="line">rotation_matrix = cv2.getRotationMatrix2D(center, <span class="number">45</span>, <span class="number">0.5</span>)</span><br><span class="line">rotated_img = cv2.warpAffine(img, rotation_matrix, (w, h))</span><br></pre></td></tr></tbody></table></figure>

<h3 id="图像加减法"><a href="#图像加减法" class="headerlink" title="图像加减法"></a>图像加减法</h3><p>相加减两幅图片的形状(高度/宽度/通道数)必须相同</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = cv2.add(img1, img2) <span class="comment"># 相加</span></span><br><span class="line">result = cv2.subtract(img1, img2)  <span class="comment"># 相减</span></span><br></pre></td></tr></tbody></table></figure>

<p>numpy中可以直接用 <code>res = img + img1</code> 相加，但这两者的结果并不相同</p>
<p>如果像素值相加后超过255，OpenCV 会自动将其截断为255(注意，必须是二维矩阵)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.uint8([[<span class="number">250</span>]]) <span class="comment"># 注意是 2D</span></span><br><span class="line">y = np.uint8([[<span class="number">10</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"cv2.add:"</span>, cv2.add(x, y))  <span class="comment"># [[255]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"numpy + :"</span>, x + y)  <span class="comment"># [[4]]</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="图像位运算"><a href="#图像位运算" class="headerlink" title="图像位运算"></a>图像位运算</h3><p>图像位运算是将两幅图像的每个像素值转为二进制以后进行位操作</p>
<p><font color="Violetred">图像必须是相同大小和通道数，否则不能直接做按位运算</font></p>
<p>主要用于<strong>二值图像处理</strong>以及<strong>掩膜运算</strong>(掩膜mask是对一幅图片进行局部的遮挡)</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">功能</th>
<th align="left">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>cv2.bitwise_and(img1,img2)</code></td>
<td align="left">按位与操作</td>
<td align="left">掩膜交集</td>
</tr>
<tr>
<td align="left"><code>cv2.bitwise_or(img1,img2)</code></td>
<td align="left">按位或操作</td>
<td align="left">掩膜并集</td>
</tr>
<tr>
<td align="left"><code>cv2.bitwise_not(img)</code></td>
<td align="left">按位取反操作</td>
<td align="left">反转掩膜</td>
</tr>
<tr>
<td align="left"><code>cv2.bitwise_xor(img1,img2)</code></td>
<td align="left">按位异或操作</td>
<td align="left">掩膜并集-交集</td>
</tr>
</tbody></table>
<p>利用<strong>图片自身按位与</strong>，<font color="Violetred">掩膜上为255的保留原值，为0的区域置0</font></p>
<h4 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">"LenaRGB.bmp"</span>, <span class="number">1</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">"OpenCV_logo_no_text.png"</span>, <span class="number">1</span>)</span><br><span class="line">img2 = cv2.resize(img2,(img1.shape[<span class="number">1</span>],img1.shape[<span class="number">0</span>])) <span class="comment"># 匹配大小</span></span><br><span class="line"><span class="comment"># 转灰度图好创建掩膜</span></span><br><span class="line">img2_gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)</span><br><span class="line">plt.imshow(img2_gray, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509241712.webp" alt="202509241712" style="zoom: 67%;">

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建掩膜</span></span><br><span class="line"><span class="comment"># 主体掩膜，背景全0，主体255，保留主体</span></span><br><span class="line">_, mask = cv2.threshold(img2_gray, <span class="number">10</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 反转，背景掩膜，主体为0，背景255，保留背景</span></span><br><span class="line">mask_inv = cv2.bitwise_not(mask)</span><br><span class="line"><span class="comment"># 保留img1的背景</span></span><br><span class="line">img1_bg = cv2.bitwise_and(img1, img1, mask=mask_inv) <span class="comment"># 自身取与</span></span><br><span class="line"><span class="comment"># 提取img2主体</span></span><br><span class="line">img2_fg = cv2.bitwise_and(img2, img2, mask=mask) <span class="comment"># 自身取与</span></span><br><span class="line">res = cv2.add(img1_bg,img2_fg)  <span class="comment"># 加法融合</span></span><br><span class="line"><span class="comment"># cv2.imshow("result", res)</span></span><br><span class="line"><span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">res = cv2.cvtColor(res, cv2.COLOR_BGR2RGB)</span><br><span class="line">plt.imshow(res)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509241257.webp" alt="202509241257" style="zoom: 67%;">

<h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h4><p><font color="Violetred">按位或并不等同于图像叠加</font></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">"Lena.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">"OpenCV_logo_no_text.png"</span>, <span class="number">0</span>)</span><br><span class="line">img2 = cv2.resize(img2,(img1.shape[<span class="number">1</span>],img1.shape[<span class="number">0</span>])) <span class="comment"># 匹配大小</span></span><br><span class="line">res1 = cv2.bitwise_or(img1, img2) <span class="comment"># 无法形成透明效果</span></span><br><span class="line">res2 = cv2.addWeighted(img1, <span class="number">0.5</span>, img2, <span class="number">0.5</span>, <span class="number">0</span>) <span class="comment"># 产生自然的图像融合</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.imshow(res1, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(res2,cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509241733.webp" alt="202509241733" style="zoom: 80%;">

<h2 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h2><h3 id="阿尔法混合-加权混合"><a href="#阿尔法混合-加权混合" class="headerlink" title="阿尔法混合(加权混合)"></a>阿尔法混合(加权混合)</h3><p>图像混合就是把两张图像的像素值按照一定比例组合<br>$$<br>dst(x,y) = \alpha \cdot img1(x,y) + \beta \cdot img2(x,y) + \gamma<br>$$<br>$\gamma$ 为一个偏移量(调亮/调暗整体效果用)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">"Barbara.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">"Baboon.bmp"</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># # 调整两张图大小一致</span></span><br><span class="line">img2 = cv2.resize(img2,(img1.shape[<span class="number">1</span>],img1.shape[<span class="number">0</span>])) </span><br><span class="line"><span class="comment"># 做一个淡入淡出</span></span><br><span class="line"><span class="keyword">for</span> alpha <span class="keyword">in</span> np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>):</span><br><span class="line">    beta = <span class="number">1</span> - alpha</span><br><span class="line">    blended = cv2.addWeighted(img1, alpha, img2, beta, <span class="number">0</span>)</span><br><span class="line">    cv2.imshow(<span class="string">"Blending"</span>, blended)</span><br><span class="line">    cv2.waitKey(<span class="number">200</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="拉普拉斯金字塔融合"><a href="#拉普拉斯金字塔融合" class="headerlink" title="拉普拉斯金字塔融合"></a>拉普拉斯金字塔融合</h3><p>如果直接把两张图拼接，边界很明显：</p>
<ul>
<li>颜色/亮度突变</li>
<li>纹理不连续</li>
</ul>
<p>即使用线性渐变(alpha blending)，仍可能出现模糊边界或鬼影</p>
<p>金字塔融合的核心思想：在不同的尺度(分辨率)上融合图像</p>
<p><font color="Violetred">适合那些既要平滑过渡，又要细节自然的场景，但是会损失细节</font></p>
<p>图像金字塔有两种：<strong>高斯金字塔</strong>和<strong>拉普拉斯金字塔</strong></p>
<p>高斯金字塔中较高层中的每个像素都是由其下一层中的5个像素以高斯权重贡献形成的</p>
<p>对于$M\times N$的图像，通过<code>cv.pyrDown()</code>[下采样]变成$M/2\times N/2$，获得金字塔的上层<br>$$<br>G_0,G_1,G_2,\cdots,G_n<br>$$</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建高斯金字塔</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_gaussian_pyramid</span>(<span class="params">img, level=<span class="number">6</span></span>): <span class="comment"># 这里level=最高层数</span></span><br><span class="line">    G = img.copy()</span><br><span class="line">    gp = [G]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level):</span><br><span class="line">        G = cv2.pyrDown(G)</span><br><span class="line">        gp.append(G)</span><br><span class="line">    <span class="comment"># gp: G0,G1...Gn </span></span><br><span class="line">    <span class="keyword">return</span> gp</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/funingna.png"</span>, <span class="number">0</span>)</span><br><span class="line">gp = generate_gaussian_pyramid(img, level=<span class="number">5</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gp)):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>)</span><br><span class="line">    plt.imshow(gp[i], cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">f"G<span class="subst">{i}</span>"</span>)</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509261408.webp" alt="202509261408" style="zoom: 67%;">

<p>拉普拉斯金字塔由高斯金字塔该层与上层<code>cv.pyrUp()</code>[上采样]之间的差值形成<br>$$<br>L_i = G_i - \mathrm{Expand}(G_{i+1})<br>$$</p>
<p>也可以写成(代码循环常这么写)<br>$$<br>L_{i-1} = G_{i-1}-\mathrm{Expand}(G_{i})<br>$$<br>循环到高斯金字塔的最后一层时，没有更小的高斯层了，无法继续计算，就直接保留高斯金字塔的最小层图像(将$G_n$放到$L_n$的位置)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建拉普拉斯金字塔</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_laplacian_pyramid</span>(<span class="params">gp</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(gp)</span><br><span class="line">    lp = [gp[N-<span class="number">1</span>]] <span class="comment"># 最高层直接放入，没有上层了</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span> ,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        GE = cv2.pyrUp(gp[i])</span><br><span class="line">        <span class="comment"># resize 这步是因为如果图像的size不是偶数，上填充或下填充后尺寸不匹配</span></span><br><span class="line">        GE = cv2.resize(GE,(gp[i-<span class="number">1</span>].shape[<span class="number">1</span>],gp[i-<span class="number">1</span>].shape[<span class="number">0</span>]))</span><br><span class="line">        L = cv2.subtract(gp[i-<span class="number">1</span>], GE)</span><br><span class="line">        lp.append(L)</span><br><span class="line">    <span class="comment"># lp: Gn,Ln-1,...L0    </span></span><br><span class="line">    <span class="keyword">return</span> lp </span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是，由于计算的时候是从Gn开始计算，所以生成的拉普拉斯金字塔列表是反转过来的</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lp = generate_laplacian_pyramid(gp)</span><br><span class="line">lp = lp[::-<span class="number">1</span>] <span class="comment"># 反转，最高层放在末尾</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lp)):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>)</span><br><span class="line">    plt.imshow(lp[i],cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">f"L<span class="subst">{i}</span>"</span>)</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509261409.webp" alt="202509261409" style="zoom: 67%;">

<p>融合两张图片的拉普拉斯金字塔，获得最终图的拉普拉斯金字塔</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 融合两个拉普拉斯金字塔(简单拼接，各取一半)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">blend_half</span>(<span class="params">lpA, lpB</span>):</span><br><span class="line">    LS = []</span><br><span class="line">    <span class="keyword">for</span> la, lb <span class="keyword">in</span> <span class="built_in">zip</span>(lpA, lpB):</span><br><span class="line">        rows, cols, dpt = la.shape</span><br><span class="line">        ls = np.hstack((la[:,:cols//<span class="number">2</span>], lb[:, cols//<span class="number">2</span>:]))</span><br><span class="line">        LS.append(ls)</span><br><span class="line">    <span class="keyword">return</span> LS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 融合两个拉普拉斯金字塔(渐变拼接)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">blend_gradient</span>(<span class="params">lpA, lpB</span>):</span><br><span class="line">    LS = []</span><br><span class="line">    <span class="keyword">for</span> la, lb <span class="keyword">in</span> <span class="built_in">zip</span>(lpA, lpB):</span><br><span class="line">        rows, cols, dpt = la.shape</span><br><span class="line">        <span class="comment"># 维度大小为3, 维度1为1，维度2自动计算，维度3为1</span></span><br><span class="line">        mask = np.linspace(<span class="number">1</span>, <span class="number">0</span>, cols).reshape(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 从左到右渐变</span></span><br><span class="line">        mask = np.repeat(mask, rows, axis=<span class="number">0</span>)</span><br><span class="line">        ls = la * mask + lb * (<span class="number">1</span>-mask)</span><br><span class="line">        LS.append(ls.astype(np.uint8))</span><br><span class="line">    <span class="keyword">return</span> LS</span><br></pre></td></tr></tbody></table></figure>

<p>重建图样<strong>从最小的高斯图(最高层)开始，逐层往大推</strong><br>$$<br>G_i = L_i+\mathrm{Expand}(G_{i+1})<br>$$</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从拉普拉斯金字塔重建图像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reconstruct_from_laplacian</span>(<span class="params">LS</span>):</span><br><span class="line">    G = LS[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(LS)):</span><br><span class="line">        GE = cv2.pyrUp(G)</span><br><span class="line">        GE = cv2.resize(GE,(LS[i].shape[<span class="number">1</span>],LS[i].shape[<span class="number">0</span>])) <span class="comment"># 匹配尺寸</span></span><br><span class="line">        G = cv2.add(GE, LS[i])</span><br><span class="line">    <span class="keyword">return</span> G</span><br></pre></td></tr></tbody></table></figure>

<p>因为在生成拉普拉斯金字塔时把Gn放在了列表头部，所以就不需要反转了！</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = reconstruct_from_laplacian(lp[::-<span class="number">1</span>]) <span class="comment"># 反转回来，叠加从最高层开始</span></span><br><span class="line">plt.imshow(res, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/2025092614010.webp" alt="2025092614010" style="zoom: 67%;">

<p>官方demo：苹果+橘子</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apple = cv2.imread(<span class="string">"imgs/apple.jpg"</span>, <span class="number">1</span>)</span><br><span class="line">orange = cv2.imread(<span class="string">"imgs/orange.jpg"</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 创建高斯金字塔</span></span><br><span class="line">gpA = generate_gaussian_pyramid(apple)</span><br><span class="line">gpB = generate_gaussian_pyramid(orange)</span><br><span class="line"><span class="comment"># 创建拉普拉斯金字塔</span></span><br><span class="line">lpA = generate_laplacian_pyramid(gpA)</span><br><span class="line">lpB = generate_laplacian_pyramid(gpB)</span><br><span class="line"><span class="comment"># 融合拉普拉斯金字塔</span></span><br><span class="line">LS = blend_half(lpA, lpB)</span><br><span class="line"><span class="comment"># LS = blend_gradient(lpA, lpB)</span></span><br><span class="line"><span class="comment"># 从拉普拉斯金字塔重建图像(从最小图样开始)</span></span><br><span class="line">blended = reconstruct_from_laplacian(LS)</span><br><span class="line"><span class="comment"># 直接拼接图样</span></span><br><span class="line">direct = np.hstack((apple[:, :apple.shape[<span class="number">1</span>]//<span class="number">2</span>],</span><br><span class="line">                    orange[:, orange.shape[<span class="number">1</span>]//<span class="number">2</span>:]))</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509261401.webp" alt="202509261401" style="zoom:67%;">

<h2 id="图像平滑"><a href="#图像平滑" class="headerlink" title="图像平滑"></a>图像平滑</h2><p>首先讲一下图像噪声，常见噪声如下：</p>
<ul>
<li>高斯噪声：常见于传感器噪声，整幅图像像素轻微抖动、模糊，$n\sim N(\mu,\sigma^2)$，高斯滤波效果最好</li>
<li>椒盐噪声：像素随机变成黑点(0)或白点(255)，常见于图像传输干扰，数据丢包，中值滤波效果最好</li>
</ul>
<h3 id="卷积填充"><a href="#卷积填充" class="headerlink" title="卷积填充"></a>卷积填充</h3><p>用3×3的核对6×6的图像进行卷积，得到的是4×4的图，图片缩小了</p>
<p>可以把原图扩充一圈，再卷积，这个操作叫填充padding</p>
<p>OpenCV中有好几种填充方式，都使用<code>cv2.copyMakeBorder()</code>函数实现</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.copyMakeBorder(</span><br><span class="line">    src,                  <span class="comment"># 输入图像</span></span><br><span class="line">    top,                  <span class="comment"># 上边界填充像素数</span></span><br><span class="line">    bottom,               <span class="comment"># 下边界填充像素数</span></span><br><span class="line">    left,                 <span class="comment"># 左边界填充像素数</span></span><br><span class="line">    right,                <span class="comment"># 右边界填充像素数</span></span><br><span class="line">    borderType,           <span class="comment"># 边界填充类型</span></span><br><span class="line">    [, value]             <span class="comment"># CONSTANT类型使用的颜色值</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<p>其中固定值填充和<font color="Violetred">默认填充(镜像填充)</font>最常用</p>
<table>
<thead>
<tr>
<th>填充类型 (borderType)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>cv2.BORDER_REFLECT_101</code><br>(<code>cv2.BORDER_DEFAULT</code>)</td>
<td>镜像填充(不包含边界像素)</td>
</tr>
<tr>
<td><code>cv2.BORDER_CONSTANT</code></td>
<td>固定值填充，用 <code>value</code> 指定颜色</td>
</tr>
<tr>
<td><code>cv2.BORDER_REPLICATE</code></td>
<td>复制边缘像素，边界处像素往外扩展</td>
</tr>
<tr>
<td><code>cv2.BORDER_REFLECT</code></td>
<td>镜像反射边界(包含边界像素)</td>
</tr>
<tr>
<td><code>cv2.BORDER_WRAP</code></td>
<td>环绕填充，从另一边取值</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建3x3测试矩阵(使用ASCII值)</span></span><br><span class="line">matrix = np.array([</span><br><span class="line">    [<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>],    <span class="comment"># a,b,c</span></span><br><span class="line">    [<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>], <span class="comment"># d,e,f</span></span><br><span class="line">    [<span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>]  <span class="comment"># g,h,i</span></span><br><span class="line">], dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_border</span>(<span class="params">matrix, border_type, name</span>):</span><br><span class="line">    padded = cv2.copyMakeBorder(matrix, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, border_type)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"\n<span class="subst">{name}</span>:"</span>)</span><br><span class="line">    rows, cols = padded.shape</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        row_chars = []  <span class="comment"># 存储打印字符</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            ch = <span class="built_in">chr</span>(padded[i, j])  <span class="comment"># 将数字转为chr类型</span></span><br><span class="line">            <span class="comment"># 判断是否属于原矩阵区域</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> &lt;= i &lt; <span class="number">2</span> + matrix.shape[<span class="number">0</span>] <span class="keyword">and</span> <span class="number">2</span> &lt;= j &lt; <span class="number">2</span> + matrix.shape[<span class="number">1</span>]:</span><br><span class="line">                row_chars.append(<span class="string">f"\033[31m<span class="subst">{ch}</span>\033[0m"</span>)  <span class="comment"># 红色</span></span><br><span class="line">                <span class="comment"># \033[31m → 设置红色  \033[0m → 重置回默认颜色</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row_chars.append(ch)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">" "</span>.join(row_chars))  <span class="comment"># 把 row_chars 里的字符用空格拼接成一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试不同填充方式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"原始矩阵:"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a b c\nd e f\ng h i"</span>)</span><br><span class="line"></span><br><span class="line">print_border(matrix, cv2.BORDER_CONSTANT, <span class="string">"BORDER_CONSTANT"</span>)</span><br><span class="line">print_border(matrix, cv2.BORDER_REPLICATE, <span class="string">"BORDER_REPLICATE"</span>)</span><br><span class="line">print_border(matrix, cv2.BORDER_REFLECT, <span class="string">"BORDER_REFLECT"</span>)</span><br><span class="line">print_border(matrix, cv2.BORDER_REFLECT_101, <span class="string">"BORDER_REFLECT_101 (DEFAULT)"</span>)</span><br><span class="line">print_border(matrix, cv2.BORDER_WRAP, <span class="string">"BORDER_WRAP"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="卷积滤波"><a href="#卷积滤波" class="headerlink" title="卷积滤波"></a>卷积滤波</h3><p>卷积滤波就是用一个核(kernel, mask, filter)在图像上滑动，对每个位置进行加权求和，生成新的像素值<br>$$<br>g(x,y)=\sum_{i=-k}^k\sum_{j=-k}^kf(x+i,y+j)\cdot h(i,j)<br>$$<br>通用卷积函数<code>cv2.filter2D()</code>,可以用任意核</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.filter2D(img, ddepth, kernel)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>ddepth</code>：输出图像深度(<code>-1</code>表示和输入一样)</li>
</ul>
<p>常用于图像锐化操作：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.array([[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                   [-<span class="number">1</span>,<span class="number">5</span>,-<span class="number">1</span>],</span><br><span class="line">                   [<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>]], np.float32)</span><br><span class="line">sharpened = cv2.filter2D(img, -<span class="number">1</span>, kernel)</span><br></pre></td></tr></tbody></table></figure>

<p>均值滤波、高斯滤波、中值滤波、双边滤波都属于卷积滤波，不过python都有对应的函数，不使用<code>filter2D</code>来实现</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>特点</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>均值滤波</td>
<td>平均邻域</td>
<td>简单</td>
<td>模糊边缘严重</td>
</tr>
<tr>
<td>高斯滤波</td>
<td>高斯加权</td>
<td>平滑自然</td>
<td>仍有模糊</td>
</tr>
<tr>
<td>中值滤波</td>
<td>取中值</td>
<td>对椒盐噪声好</td>
<td>模糊细节</td>
</tr>
<tr>
<td>双边滤波</td>
<td>空间+像素相似度</td>
<td>边缘保留最好</td>
<td>计算量大</td>
</tr>
</tbody></table>
<h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>均值滤波是一种最简单的滤波处理，将图像中每个像素的值替换为其周围像素的平均值，可以有效地去除噪声，但可能会导致图像变得模糊</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>)) <span class="comment"># (5,5)为滤波核的大小</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="高斯滤波🔥"><a href="#高斯滤波🔥" class="headerlink" title="高斯滤波🔥"></a>高斯滤波🔥</h3><p>卷积核是一个二维高斯函数，邻域中心权重大，越远权重越小</p>
<p>对随机噪声(高斯噪声)效果比较好，边缘比均值滤波保留得更自然</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>) </span><br><span class="line"><span class="comment"># 第三个参数为高斯核的标准差，如果为0，则根据核大小自动计算</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="中值滤波🔥"><a href="#中值滤波🔥" class="headerlink" title="中值滤波🔥"></a>中值滤波🔥</h3><p>中值滤波是一种非线性平滑处理方法，将图像中每个像素的值替换为其周围像素的中值</p>
<p>中值滤波在去除椒盐噪声(即图像中随机出现的黑白点)时非常有效</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.medianBlur(img, <span class="number">5</span>)  </span><br><span class="line"><span class="comment"># 第二个参数为滤波核大小，必须为奇数</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>双边滤波是一种非线性的平滑处理方法，结合了空间邻近度和像素值相似度</p>
<p>考虑空间距离 + 像素值差异，既能平滑噪声，又能保留边缘</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.bilateralFilter(img, <span class="number">9</span>, <span class="number">75</span>, <span class="number">75</span>)</span><br><span class="line"><span class="comment"># 第二个参数为滤波核大小，不一定奇数</span></span><br><span class="line"><span class="comment"># 第三个参数为颜色空间的标准差，控制像素值相似度的权重</span></span><br><span class="line"><span class="comment"># 第四个参数为坐标空间的标准差，控制空间距离的权重</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="噪声添加与消除"><a href="#噪声添加与消除" class="headerlink" title="噪声添加与消除"></a>噪声添加与消除</h3><p><code>skimage.util.random_noise</code>是一个方便函数，可以直接给图像添加多种常见噪声</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.util <span class="keyword">import</span> random_noise</span><br><span class="line">gaussian_noise = random_noise(img, mode=<span class="string">'gaussian'</span>, mean=<span class="number">0</span>, var=<span class="number">0.01</span>) <span class="comment"># 高斯噪声</span></span><br><span class="line">sp_noise = random_noise(img, mode=<span class="string">'s&amp;p'</span>, amount=<span class="number">0.02</span>) <span class="comment"># 椒盐噪声</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>random_noise</code> 返回的图像是 浮点型，范围在 [0,1]，所以需要转回OpenCV常用的<code>uint8</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gaussian_noise = (gaussian_noise * <span class="number">255</span>).astype(np.uint8)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.util <span class="keyword">import</span> random_noise</span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">"LenaRGB.bmp"</span>,<span class="number">1</span>)</span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line"><span class="comment"># 添加高斯噪声</span></span><br><span class="line">gaussian_noise = random_noise(img, mode=<span class="string">'gaussian'</span>, var=<span class="number">0.01</span>)  <span class="comment"># var 控制噪声强度</span></span><br><span class="line">gaussian_noise = (gaussian_noise * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"><span class="comment"># 添加椒盐噪声</span></span><br><span class="line">sp_noise = random_noise(img, mode=<span class="string">'s&amp;p'</span>, amount=<span class="number">0.02</span>)  <span class="comment"># amount 控制噪声比例</span></span><br><span class="line">sp_noise = (sp_noise * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"><span class="comment"># 显示带噪声图样</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(gaussian_noise)</span><br><span class="line">plt.title(<span class="string">"Gaussian Noise"</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(sp_noise)</span><br><span class="line">plt.title(<span class="string">"S&amp;P Noise"</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509252044.webp" alt="202509252044" style="zoom: 50%;">

<p>通过各种滤波方式可以对噪声进行去除</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高斯噪声处理</span></span><br><span class="line">gauss_mean = cv2.blur(gaussian_noise, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">gauss_gaussian = cv2.GaussianBlur(gaussian_noise, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">gauss_median = cv2.medianBlur(gaussian_noise, <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509252045.webp" alt="202509252045" style="zoom:50%;">

<p>均值滤波会平滑图像，使得图像稍微模糊一些，高斯滤波并不能完全去除高斯噪声</p>
<p>这是因为它只是一个低通滤波器，主要削弱高频分量，高斯噪声的高频部分会被削弱，但低频部分的噪声依然保留，所以它不能“专门去掉高斯噪声”，而只是做了一次模糊平均</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 椒盐噪声处理</span></span><br><span class="line">sp_mean = cv2.blur(sp_noise, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">sp_gaussian = cv2.GaussianBlur(sp_noise, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">sp_median = cv2.medianBlur(sp_noise, <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509252046.webp" alt="202509252046" style="zoom: 50%;">

<p>可以看到中值滤波对椒盐噪声的处理非常好，基本恢复原图的状态了</p>
<h2 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h2><h3 id="固定阈值分割"><a href="#固定阈值分割" class="headerlink" title="固定阈值分割"></a>固定阈值分割</h3><p>将灰度图像二值化或多阈值化，通过<code>cv2.threshold()</code>来实现阈值分割</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.threshold(img, thresh, maxval, <span class="built_in">type</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><code>thresh</code>: 阈值</p>
<p><code>maxval</code>: 当像素值超过阈值时赋予的新值[用于<code>THRESH_BINARY</code>]，一般为255</p>
<p><code>type</code>：阈值类型(最重要)</p>
<table>
<thead>
<tr>
<th>阈值类型</th>
<th>高于阈值</th>
<th>低于阈值</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td><code>cv2.THRESH_BINARY</code>(二值化)</td>
<td>赋值为 <code>maxval</code></td>
<td>赋值为 0</td>
<td>前景白、背景黑</td>
</tr>
<tr>
<td><code>cv2.THRESH_BINARY_INV</code>(反二值化)</td>
<td>赋值为 0</td>
<td>赋值为 <code>maxval</code></td>
<td>背景白、前景黑</td>
</tr>
<tr>
<td><code>cv2.THRESH_TRUNC</code>(截断)</td>
<td>截断成阈值</td>
<td>保持原值</td>
<td>限制高光</td>
</tr>
<tr>
<td><code>cv2.THRESH_TOZERO</code></td>
<td>保持原值</td>
<td>赋值为 0</td>
<td>滤掉低强度背景</td>
</tr>
<tr>
<td><code>cv2.THRESH_TOZERO_INV</code></td>
<td>赋值为 0</td>
<td>保持原值</td>
<td>滤掉高亮区域</td>
</tr>
</tbody></table>
<p>返回<code>retval</code>, <code>dst</code></p>
<ul>
<li><code>retval</code>: 实际使用的阈值(在使用 <code>THRESH_OTSU</code> 或 <code>THRESH_TRIANGLE</code> 时特别有用)</li>
<li><code>dst</code>: 阈值化后的图像</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv2.imread(<span class="string">"gradient_gray.png"</span>, <span class="number">0</span>)</span><br><span class="line">_, dst1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">_, dst2 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">_, dst3 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TRUNC)</span><br><span class="line">_, dst4 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO)</span><br><span class="line">_, dst5 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO_INV)</span><br><span class="line">titles = [<span class="string">'Original'</span>, <span class="string">'BINARY'</span>, <span class="string">'BINARY_INV'</span>, <span class="string">'TRUNC'</span>, <span class="string">'TOZERO'</span>, <span class="string">'TOZERO_INV'</span>]</span><br><span class="line">images = [img, dst1, dst2, dst3, dst4, dst5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(images[i], <span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i], fontsize=<span class="number">8</span>)</span><br><span class="line">    plt.xticks([]), plt.yticks([])  <span class="comment"># 隐藏坐标轴</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20250922215427237.png" alt="image-20250922215427237" style="zoom: 80%;">

<h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><p><code>cv2.adaptiveThreshold()</code>自适应阈值会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thresholded_image = cv2.adaptiveThreshold(img, maxval, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, block_size, C)</span><br></pre></td></tr></tbody></table></figure>

<p><code>maxval</code>：最大阈值，一般为 255</p>
<ul>
<li>参数3：小区域阈值的计算方式<ul>
<li><code>ADAPTIVE_THRESH_MEAN_C</code>：小区域内取均值</li>
<li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：小区域内加权求和，权重是个高斯核</li>
</ul>
</li>
<li>参数4：阈值方法，只能使用<code>THRESH_BINARY</code>、<code>THRESH_BINARY_INV</code></li>
<li>参数5：小区域的面积(正方形)，输入边长(像素)</li>
<li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"Cameraman.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">_, dst1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">dst2 = cv2.adaptiveThreshold(img,<span class="number">255</span>,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">4</span>)</span><br><span class="line">dst3 = cv2.adaptiveThreshold(img,<span class="number">255</span>,cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">4</span>)</span><br><span class="line">titles = [<span class="string">'Original'</span>, <span class="string">'BINARY(127)'</span>, <span class="string">'Adaptive Mean'</span>, <span class="string">'Adaptive Gaussian'</span>]</span><br><span class="line">images = [img, dst1, dst2, dst3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(images[i], <span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i], fontsize=<span class="number">8</span>)</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/autothreshold.png" alt="autothreshold" style="zoom: 80%;">

<h3 id="Otsu’s阈值"><a href="#Otsu’s阈值" class="headerlink" title="Otsu’s阈值"></a>Otsu’s阈值</h3><p>在前面<code>cv2.threshold()</code> 用的是固定阈值，比如<code>thresh=127</code></p>
<p>在很多场景下，图像亮度分布不均匀，固定阈值效果不好</p>
<p>Otsu’s方法是一种<font color="Violetred">自适应阈值选择算法</font>，通过分析图像灰度直方图，自动确定最佳分割阈值</p>
<p>核心思想是最大化前景(目标)与背景之间的类间方差</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thresh_val, otsu_img = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU) </span><br><span class="line"><span class="comment"># 写法基本固定，第2个参数必须设为0，真正的阈值由算法计算</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"Cameraman.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">_, dst1 = cv2.threshold(img , <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">_, dst2 = cv2.threshold(img, <span class="number">0</span> , <span class="number">255</span>, cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><br><span class="line">imgs = [img, dst1, dst2]</span><br><span class="line">titles = [<span class="string">"Original"</span>, <span class="string">"BINARY(127)"</span>, <span class="string">"OTSU"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(imgs[i], cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509252101.webp" alt="202509252101" style="zoom:67%;">

<h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>图像边缘检测是计算机视觉和图像处理中的一项基本任务，它用于识别图像中亮度变化明显的区域，这些区域通常对应于物体的边界</p>
<p>边缘检测通常基于<strong>梯度</strong>(Gradient)，它表示图像强度变化的方向和大小</p>
<ul>
<li><p>一维情况下：边缘 = 信号一阶导数极大值位置</p>
</li>
<li><p>二维情况下<br>$$<br>\nabla f(x,y)=\left[\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}\right]<br>$$<br>梯度幅值(边缘强度)<br>$$<br>G=\sqrt{\left(\frac{\partial f}{\partial x}\right)^2+\left(\frac{\partial f}{\partial y}\right)^2}<br>$$<br>梯度方向<br>$$<br>\theta = \arctan\left(\frac{\partial f}{\partial y}/\frac{\partial f}{\partial x}\right)<br>$$</p>
</li>
</ul>
<p>常用的梯度算子如下：</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th>核心</th>
<th align="left">适用场景</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Sobel算子</td>
<td>一阶导数(差分)+平滑</td>
<td align="left">检测水平和垂直边缘</td>
<td>边缘定位精度一般，特别是对斜向边缘不够准确</td>
</tr>
<tr>
<td align="left">Scharr算子</td>
<td>优化的Sobel</td>
<td align="left">检测细微的边缘</td>
<td>计算量略高于Sobel，低分辨率图片差别不大</td>
</tr>
<tr>
<td align="left">Laplacian算子</td>
<td>二阶导数</td>
<td align="left">检测边缘和角点</td>
<td>对噪声非常敏感，检测结果往往是“双边缘”</td>
</tr>
</tbody></table>
<h3 id="数值转化"><a href="#数值转化" class="headerlink" title="数值转化"></a>数值转化</h3><p>常见算子通常用 <code>CV_64F</code> 或 <code>CV_32F</code> 保存结果，计算出来的结果是<code>float</code>类型，包含负数</p>
<p>OpenCV的<code>imshow</code>和Matplotlib的<code>imshow(cmap="gray")</code> 都假定数据范围在<code>[0,255]</code>(或 <code>[0,1]</code>浮点)</p>
<p>如果直接显示<code>float</code>图像，会导致数据被自动线性拉伸，结果和实际数值分布不符</p>
<p>如果为了清晰判断与分析边缘，需要对其进行<code>cv2.convertScaleAbs()</code>处理，这样能保证边缘效果直观可见</p>
<p>如果后续还需要进行一些运算，就不能取<code>cv2.convertScaleAbs()</code>，因为符号信息在一些算法里是有意义的，此时保留<code>float</code> 原始结果更合理</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnitude = cv2.magnitude(sobelx, sobely)  <span class="comment"># 准确梯度幅值</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p>Sobel算子是一种基于梯度的边缘检测算子，它通过计算图像在水平和垂直方向上的梯度来检测边缘，结合了高斯平滑和微分操作，因此对噪声具有一定的抑制作用</p>
<p>水平方向卷积核 [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]</p>
<p>垂直方向卷积核 [[-1, -2, -1], [0, 0, 0], [1, 2, 1]]</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"Lena.bmp"</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># sobel输出的是float64，包含负数</span></span><br><span class="line">sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)  <span class="comment"># x方向</span></span><br><span class="line">sobely = cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)  <span class="comment"># y方向</span></span><br><span class="line"><span class="comment"># 将输出转换为 CV_8U 图像(绝对值)，丢掉“方向信息”</span></span><br><span class="line">sobelx_abs = cv2.convertScaleAbs(sobelx)</span><br><span class="line">sobely_abs = cv2.convertScaleAbs(sobely)</span><br><span class="line"><span class="comment"># 添加两个方向梯度来近似梯度(不是精确的计算)</span></span><br><span class="line">grad = cv2.addWeighted(sobelx_abs, <span class="number">0.5</span>, sobely_abs, <span class="number">0.5</span>, <span class="number">0</span>)  <span class="comment"># 常用</span></span><br><span class="line"><span class="comment"># 准确的梯度幅值</span></span><br><span class="line">sobel = cv2.magnitude(sobelx, sobely)</span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.imshow(sobelx_abs, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Sobelx'</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.imshow(sobely, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Sobely'</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.imshow(grad, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Approx gradient'</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.imshow(sobel_abs, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Amplitude gradient'</span>)</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202592511.webp" alt="202592511" style="zoom:80%;">

<h3 id="Scharr算子"><a href="#Scharr算子" class="headerlink" title="Scharr算子"></a>Scharr算子</h3><p>是Sobel的改进版，权重更大，在小核(3×3)时效果优于 Sobel</p>
<p>水平方向卷积核 [[-3, 0, 3], [-10, 0, 10], [-3, 0, 3]]</p>
<p>垂直方向卷积核 [[-3, -10, -3], [0, 0, 0], [3, 10, 3]]</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scharrx = cv2.Scharr(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>) <span class="comment"># 核大小不可调，只支持3*3</span></span><br><span class="line">scharry = cv2.Scharr(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a>Laplacian算子</h3><p>Laplacian算子是一种二阶微分算子，它通过计算图像的二阶导数来检测边缘，但对噪声比较敏感，因此通常在使用之前会对图像进行高斯平滑处理</p>
<p>卷积核 [[0, 1, 0], [1, -4, 1], [0, 1, 0]]</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laplacian = cv2.Laplacian(img, cv2.CV_64F, ksize=<span class="number">1</span>, scale=<span class="number">1</span>, borderType=cv2.BORDER_DEFAULT)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>ksize</code>：Laplacian核的大小，默认为 1</p>
<p>并不是代表卷积核大小为1，而是最基本的二阶差分算子<br>$$<br>f_{xx}(x,y)=f(x+1,y)+f(x-1,y)-2f(x,y)\<br>f_{yy}(x,y)=f(x,y+1)+f(x,y-1)-2f(x,y)<br>$$<br>Laplacian就变成了一个固定的 3×3 卷积核</p>
</li>
<li><p><code>scale</code>：缩放因子，默认为 1</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"Lena.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">laplacian = cv2.Laplacian(img, cv2.CV_64F,ksize=<span class="number">3</span>)</span><br><span class="line">laplacian_abs = cv2.convertScaleAbs(laplacian)</span><br><span class="line">plt.imshow(laplacian_abs, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509251429.webp" alt="202509251429" style="zoom:80%;">

<h3 id="Canny边缘检测🔥"><a href="#Canny边缘检测🔥" class="headerlink" title="Canny边缘检测🔥"></a>Canny边缘检测🔥</h3><p><font color="Violetred">稳定、精确，最常用</font></p>
<p>由John F. Canny提出，主要包括以下几个步骤：</p>
<ol>
<li>噪声抑制：使用高斯滤波器对图像进行平滑处理，以减少噪声的影响</li>
<li>计算梯度：使用Sobel算子计算图像的梯度幅值和方向</li>
<li>非极大值抑制(NMS)：沿着梯度方向，保留局部梯度最大的像素点，删除不被认为是边缘一部分的像素，只有细线候选边缘将保留</li>
<li>双阈值检测：使用两个阈值(低阈值和高阈值)来确定真正的边缘<ul>
<li>如果像素梯度高于高阈值，则该像素被接受为边缘</li>
<li>如果像素梯度值低于下限阈值，则将其拒绝</li>
<li>如果像素梯度介于两个阈值之间，则只有当它连接到高于上限阈值的像素时，才会被接受</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edges = cv2.Canny(img, threshold1, threshold2, apertureSize=<span class="number">3</span>, L2gradient=<span class="literal">False</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><code>img</code>：必须是单通道的灰度图像</p>
<p><code>threshold1</code>：低阈值越低，检测到的候选点越多，但噪声也会增多</p>
<p><code>threshold2</code>：高阈值越高，检测到的边缘越少，但更可靠，高阈值通常是低阈值的2-3倍</p>
<p><code>apertureSize</code>：Sobel算子的孔径大小，默认为3</p>
<p><code>L2gradient</code>：是否使用 L2 范数计算梯度幅值，默认为 False</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"LEna.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">edges = cv2.Canny(img, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">plt.imshow(edges, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509242233.webp" alt="202509242233" style="zoom:80%;">

<h4 id="创建滑动条"><a href="#创建滑动条" class="headerlink" title="创建滑动条"></a>创建滑动条</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">img = cv2.imread(<span class="string">"Lena.bmp"</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># img = cv2.resize(img,None,fx=0.1, fy=0.1)</span></span><br><span class="line">plt.imshow(img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">"Canny Edge Detection"</span>)</span><br><span class="line"><span class="comment"># 创建滑动条，分别对应 threshold1, threshold2</span></span><br><span class="line">cv2.createTrackbar(<span class="string">"threshold1"</span>,<span class="string">"Canny Edge Detection"</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">"threshold2"</span>,<span class="string">"Canny Edge Detection"</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    threshold1 = cv2.getTrackbarPos(<span class="string">"threshold1"</span>, <span class="string">"Canny Edge Detection"</span>)</span><br><span class="line">    threshold2 = cv2.getTrackbarPos(<span class="string">"threshold2"</span>, <span class="string">"Canny Edge Detection"</span>)</span><br><span class="line">    edges = cv2.Canny(img, threshold1, threshold2)</span><br><span class="line">    cv2.imshow(<span class="string">"Canny Edge Detection"</span>, edges)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>: <span class="comment"># 按esc退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<h4 id="自适应阈值设置"><a href="#自适应阈值设置" class="headerlink" title="自适应阈值设置"></a>自适应阈值设置</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于图像中值自动设置阈值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">auto_canny</span>(<span class="params">img, sigma=<span class="number">0.33</span></span>):</span><br><span class="line">    <span class="comment"># 计算图像中值</span></span><br><span class="line">    v = np.median(img)</span><br><span class="line">    <span class="comment"># 自动设置阈值</span></span><br><span class="line">    lower = <span class="built_in">int</span>(<span class="built_in">max</span>(<span class="number">0</span>, (<span class="number">1.0</span> - sigma) * v))</span><br><span class="line">    upper = <span class="built_in">int</span>(<span class="built_in">min</span>(<span class="number">255</span>, (<span class="number">1.0</span> + sigma) * v))</span><br><span class="line">    edges = cv2.Canny(img, lower, upper)</span><br><span class="line">    <span class="keyword">return</span> edges, lower, upper</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"Lena.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">adaptive_edges, lower, upper = auto_canny(img)</span><br><span class="line">plt.imshow(adaptive_edges, cmap=<span class="string">'gray'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"threshold1: <span class="subst">{lower}</span>, threshold2: <span class="subst">{upper}</span>"</span>)</span><br><span class="line"><span class="comment"># threshold1: 86, threshold2: 171</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Otsu计算最佳阈值"><a href="#Otsu计算最佳阈值" class="headerlink" title="Otsu计算最佳阈值"></a>Otsu计算最佳阈值</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Otsu方法计算最佳阈值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">otsu_canny</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="comment"># 计算Otsu阈值</span></span><br><span class="line">    otsu_thresh, _ = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">    <span class="comment"># 设置Canny阈值</span></span><br><span class="line">    lower = <span class="built_in">int</span>(otsu_thresh * <span class="number">0.5</span>)  <span class="comment"># 确保阈值为整数</span></span><br><span class="line">    upper = <span class="built_in">int</span>(otsu_thresh)        <span class="comment"># 确保阈值为整数</span></span><br><span class="line">    edges = cv2.Canny(img, lower, upper)</span><br><span class="line">    <span class="keyword">return</span> edges, lower, upper</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"Lena.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">otsu_edges, lower, upper = otsu_canny(img)</span><br><span class="line">plt.imshow(otsu_edges, cmap=<span class="string">'gray'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"threshold1: <span class="subst">{lower}</span>, threshold2: <span class="subst">{upper}</span>"</span>)</span><br><span class="line"><span class="comment"># threshold1: 58, threshold2: 117</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="实时边缘检测"><a href="#实时边缘检测" class="headerlink" title="实时边缘检测"></a>实时边缘检测</h3><p>结合滑动条，控制Canny的两个阈值，视频部分后面章节具体讲</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">cv2.namedWindow(<span class="string">"Overlay"</span>) <span class="comment"># 创建窗口</span></span><br><span class="line"><span class="comment"># 创建滑动条，分别对应 threshold1, threshold2</span></span><br><span class="line">cv2.createTrackbar(<span class="string">"threshold1"</span>,<span class="string">"Overlay"</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">"threshold2"</span>,<span class="string">"Overlay"</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line"><span class="comment"># 读取视频</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">"camera_vedio.mp4"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read() </span><br><span class="line">    <span class="comment"># ret: 标识符，表示是否成功读取</span></span><br><span class="line">    <span class="comment"># frame: 当前帧图像</span></span><br><span class="line">    threshold1 = cv2.getTrackbarPos(<span class="string">"threshold1"</span>, <span class="string">"Overlay"</span>)</span><br><span class="line">    threshold2 = cv2.getTrackbarPos(<span class="string">"threshold2"</span>, <span class="string">"Overlay"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret: <span class="comment"># 视频结束</span></span><br><span class="line">        <span class="comment"># break # 结束</span></span><br><span class="line">        cap.<span class="built_in">set</span>(cv2.CAP_PROP_POS_FRAMES, <span class="number">0</span>)  <span class="comment"># 重置到第0帧</span></span><br><span class="line">        <span class="keyword">continue</span>   <span class="comment"># 跳过这次循环，重新读</span></span><br><span class="line">    gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY) <span class="comment"># Canny需要灰度图像</span></span><br><span class="line">    edges = cv2.Canny(gray, threshold1, threshold2)</span><br><span class="line">    edges_color = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR) <span class="comment"># 转到3通道才能叠加</span></span><br><span class="line">    overlay = cv2.addWeighted(frame, <span class="number">0.8</span>, edges_color, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">    cv2.imshow(<span class="string">"Overlay"</span>, overlay)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>: <span class="comment"># 按esc退出，每帧停留30ms</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<p>或者也可以利用edges实现掩膜上色</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="string">"camera_vedio.mp4"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret: <span class="comment"># 视频结束</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    edges = cv2.Canny(gray, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">    mask = edges &gt; <span class="number">0</span></span><br><span class="line">    frame[mask] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>] <span class="comment"># 掩膜上色</span></span><br><span class="line">    cv2.imshow(<span class="string">"Edges on Original"</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<h2 id="形态变换"><a href="#形态变换" class="headerlink" title="形态变换"></a>形态变换</h2><p>形态学变换是一些基于图像形状的简单操作，它通常在二值图像上执行</p>
<p>它需要两个输入，一个是原始图像，第二个称为结构元素或内核，它决定操作的性质</p>
<p>两种基本的形态学算子是<font color="Violetred">腐蚀和膨胀</font></p>
<table>
<thead>
<tr>
<th align="left"><strong>操作</strong></th>
<th align="left"><strong>函数</strong></th>
<th align="left"><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>腐蚀</strong></td>
<td align="left"><code>cv2.erode()</code></td>
<td align="left">去除噪声、分离物体</td>
</tr>
<tr>
<td align="left"><strong>膨胀</strong></td>
<td align="left"><code>cv2.dilate()</code></td>
<td align="left">连接断裂的物体、填充空洞</td>
</tr>
<tr>
<td align="left"><strong>开运算</strong></td>
<td align="left"><code>cv2.morphologyEx()</code></td>
<td align="left">去除小物体、平滑物体边界</td>
</tr>
<tr>
<td align="left"><strong>闭运算</strong></td>
<td align="left"><code>cv2.morphologyEx()</code></td>
<td align="left">填充小孔洞、连接邻近物体</td>
</tr>
<tr>
<td align="left"><strong>形态学梯度</strong></td>
<td align="left"><code>cv2.morphologyEx()</code></td>
<td align="left">提取物体边缘</td>
</tr>
</tbody></table>
<h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><p>腐蚀操作是一种缩小图像中前景对象的过程，其原理是在原图的小区域内取局部最小值，小区域内有一个是0该像素点就为0(用numpy实现就是遍历选一个region取其中min)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.erode(img, kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>kernel</code>: 结构元素，可以自定义或使用 <code>cv2.getStructuringElement()</code> 生成</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 矩形结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 椭圆结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 十字形结构</span></span><br></pre></td></tr></tbody></table></figure>

<img src="https://cos.codec.wang/cv2_morphological_struct_element.jpg" alt="getStructuringElement" style="zoom: 80%;">
</li>
<li><p><code>iterations</code>: 腐蚀操作的次数，默认为1</p>
</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/j.png"</span>,<span class="number">0</span>)</span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 定义结构元素</span></span><br><span class="line">erosion = cv2.erode(img, kernel, iterations=<span class="number">1</span>)</span><br><span class="line">plt.imshow(erosion,cmap=<span class="string">"gray"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>膨胀操作与腐蚀相反，它是一种扩大图像中前景对象的过程</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.dilate(src, kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/j.png"</span>,<span class="number">0</span>)</span><br><span class="line">dilate = cv2.dilate(img, kernel, iterations=<span class="number">1</span>)</span><br><span class="line">plt.imshow(dilate,cmap=<span class="string">"gray"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h3><p>开运算只是<font color="Violetred">先腐蚀后膨胀</font>的另一种说法，用于去除小的白色噪声点</p>
<p><code>cv2.MORPH_OPEN</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.util <span class="keyword">import</span> random_noise</span><br><span class="line">img = cv2.imread(<span class="string">"imgs/j.png"</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建一个黑色背景存放椒盐噪声</span></span><br><span class="line">noise_full = random_noise(np.zeros_like(img), mode=<span class="string">'s&amp;p'</span>, amount=<span class="number">0.01</span>)</span><br><span class="line">noise_full = (noise_full * <span class="number">255</span>).astype(np.uint8)  <span class="comment"># 转回 0-255</span></span><br><span class="line"><span class="comment"># 选取图片中黑色部分产生椒盐噪声</span></span><br><span class="line">mask = (img == <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 生成对应图</span></span><br><span class="line">sp_noise = img.copy()</span><br><span class="line">sp_noise[mask] = noise_full[mask]</span><br><span class="line"><span class="comment"># 开运算</span></span><br><span class="line"><span class="built_in">open</span> = cv2.morphologyEx(sp_noise, cv2.MORPH_OPEN, kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(sp_noise, cmap=<span class="string">"gray"</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(<span class="built_in">open</span>,cmap=<span class="string">"gray"</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509261440.png" alt="202509261440" style="zoom: 67%;">

<h3 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h3><p>闭运算是开运算的逆运算，<font color="Violetred">先膨胀后腐蚀</font>，用于填充白色区域内部的小黑洞</p>
<p><code>cv2.MORPH_CLOSE</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.util <span class="keyword">import</span> random_noise</span><br><span class="line">img = cv2.imread(<span class="string">"imgs/j.png"</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建一个白色背景存放椒盐噪声</span></span><br><span class="line">white_bg = np.ones_like(img, dtype=np.float32)</span><br><span class="line">noise_full = random_noise(white_bg, mode=<span class="string">'s&amp;p'</span>, amount=<span class="number">0.01</span>)</span><br><span class="line">noise_full = (noise_full * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"><span class="comment"># 选取图片中白色部分产生椒盐噪声</span></span><br><span class="line">mask = (img == <span class="number">255</span>)</span><br><span class="line"><span class="comment"># 生成对应图</span></span><br><span class="line">sp_noise = img.copy()</span><br><span class="line">sp_noise[mask] = noise_full[mask]</span><br><span class="line"><span class="comment"># 开运算</span></span><br><span class="line">close = cv2.morphologyEx(sp_noise, cv2.MORPH_CLOSE, kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(sp_noise, cmap=<span class="string">"gray"</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(close,cmap=<span class="string">"gray"</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509261446.png" alt="202509261446" style="zoom:67%;">

<h3 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h3><p>形态学梯度是膨胀图像与腐蚀图像的差值，主要用于提取图像中前景对象的边缘</p>
<p><code>cv2.MORPH_GRADIENT</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/j.png"</span>,<span class="number">0</span>)</span><br><span class="line">gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)</span><br><span class="line">plt.imshow(gradient, cmap=<span class="string">"gray"</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20250926145056930.png" alt="image-20250926145056930" style="zoom: 67%;">

<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>一般常见的图像处理流程：</p>
<ol>
<li><p>读取+灰度化：减少计算量，很多算子只需要单通道；特殊情况保持彩色(比如分割 RGB/HSV特征)</p>
</li>
<li><p>降噪(平滑)：均值滤波/高斯滤波/中值滤波，让后续边缘检测或分割更稳定</p>
</li>
<li><p>增强(对比度提升，锐化)：直方图均衡化/CLAHE → 提升对比度；卷积或Unsharp Mask → 突出细节；[<font color="Violetred">会造成噪声加剧</font>]</p>
</li>
<li><p>阈值分割：固定阈值、Otsu、自适应阈值，得到前景/背景的mask</p>
</li>
<li><p>边缘检测：Canny(最主要)，可直接基于分割结果做轮廓提取</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>结果特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>灰度图做边缘检测</td>
<td>包含更多细节(比如纹理)，但噪声多</td>
<td>需要提取细微边缘(如纹理、阴影)</td>
</tr>
<tr>
<td>阈值图做边缘检测</td>
<td>轮廓更简洁(闭合)，噪声少</td>
<td>需要提取物体轮廓(如零件、数字)</td>
</tr>
</tbody></table>
</li>
<li><p>形态学处理：膨胀/腐蚀：强化结构特征；形态学梯度：得到轮廓；开/闭运算：去小噪点/填小孔洞[<font color="Violetred">针对的是二值图</font>，无论阈值分割还是边缘检测得到的结果都是二值图]</p>
</li>
</ol>
<p>这些步骤并不是固定且必须的</p>
<p><strong>图像增强</strong>：读取 → 灰度化 → 去噪/平滑 → 对比度/亮度增强 → 锐化</p>
<p><strong>图像恢复</strong>：读取 → 灰度化 → 退化模型估计 → 去噪/去模糊 → 恢复图像</p>
<p><strong>图像分割</strong>：读取 → 灰度化 → <font color="Violetred">阈值分割或边缘检测</font> → 形态学处理 → 区域标记</p>
<p><strong>特征提取</strong>：读取 → 灰度化 → 平滑 → 边缘/角点检测 → 特征提取</p>
<h2 id="图像轮廓"><a href="#图像轮廓" class="headerlink" title="图像轮廓"></a>图像轮廓</h2><p>轮廓可以简单地解释为连接所有连续点(沿边界)的曲线，这些点具有相同的颜色或强度</p>
<blockquote>
<p>轮廓和边缘很像，不过<strong>轮廓是连续的，边缘并不全都连续</strong></p>
</blockquote>
<p>轮廓是用于形状分析和对象检测与识别的有用工具</p>
<p>为了获得更高的精度，需要使用二值图像</p>
<p><font color="Violetred">寻找轮廓是针对白色物体的，一定要保证物体是白色，而背景是黑色</font></p>
<p>主要流程及函数：</p>
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>函数</strong></th>
</tr>
</thead>
<tbody><tr>
<td>图像预处理(转灰度)</td>
<td><code>cv2.cvtColor()</code></td>
</tr>
<tr>
<td>二值化处理</td>
<td><code>cv2.threshold()</code></td>
</tr>
<tr>
<td>查找轮廓</td>
<td><code>cv2.findContours()</code></td>
</tr>
<tr>
<td>绘制轮廓</td>
<td><code>cv2.drawContours()</code></td>
</tr>
<tr>
<td>计算轮廓面积</td>
<td><code>cv2.contourArea()</code></td>
</tr>
<tr>
<td>计算轮廓周长</td>
<td><code>cv2.arcLength()</code></td>
</tr>
<tr>
<td>计算边界矩形</td>
<td><code>cv2.boundingRect()</code></td>
</tr>
<tr>
<td>计算最小外接矩形</td>
<td><code>cv2.minAreaRect()</code></td>
</tr>
<tr>
<td>计算最小外接圆</td>
<td><code>cv2.minEnclosingCircle()</code></td>
</tr>
<tr>
<td>多边形逼近</td>
<td><code>cv2.approxPolyDP()</code></td>
</tr>
</tbody></table>
<p>代码框架：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/match_shape.jpg"</span>,<span class="number">1</span>)   <span class="comment"># 存为彩色</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) <span class="comment"># 转灰度，使得灰度和彩色图样都可</span></span><br><span class="line">_, thresh = cv2.threshold(gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY+cv2.THRESH_OTSU) <span class="comment"># 二值化</span></span><br><span class="line">contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)  <span class="comment"># 查找轮廓</span></span><br><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)      <span class="comment"># 在原图上绘制轮廓(绿色)</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="寻找轮廓"><a href="#寻找轮廓" class="headerlink" title="寻找轮廓"></a>寻找轮廓</h3><p><code>cv2.findContours()</code>用于在二值图像中查找轮廓</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contours, hierarchy = cv2.findContours(</span><br><span class="line">    image,             <span class="comment"># 输入图像(必须是二值或边缘图像)</span></span><br><span class="line">    mode,              <span class="comment"># 轮廓检索模式</span></span><br><span class="line">    method             <span class="comment"># 轮廓近似方法</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>mode</code>: 轮廓检索模式，常用的有：</p>
<ul>
<li><code>cv2.RETR_EXTERNAL</code>/1: 只检测最外层轮廓</li>
<li><code>cv2.RETR_LIST</code>/2: 检测所有轮廓，但不建立层次关系</li>
<li><code>cv2.RETR_TREE</code>/3: 检测所有轮廓，并建立完整的层次结构(常用)</li>
<li><code>cv2.RETR_CCOMP</code>：把所有的轮廓只分为2个层级，不是外层的就是里层的</li>
</ul>
</li>
<li><p><code>method</code>: 轮廓近似方法，常用的有：</p>
<ul>
<li><p><code>cv2.CHAIN_APPROX_NONE</code>/1: 存储所有的轮廓点，轮廓很密</p>
</li>
<li><p><code>cv2.CHAIN_APPROX_SIMPLE</code>/2: 压缩水平、垂直和对角线段，只保留端点(常用)</p>
<p>第一张图像显示使用cv.CHAIN_APPROX_NONE获得的点(734)</p>
<p>第二张图像显示了使用cv.CHAIN_APPROX_SIMPLE获得的点(4)</p>
</li>
</ul>
<p><img src="https://docs.opencv.ac.cn/4.11.0/none.jpg"></p>
</li>
</ul>
<p><strong>返回值</strong>:</p>
<ul>
<li><code>contours</code>: 检测到的轮廓列表，以数组形式存储，记录了每条轮廓的所有像素点的坐标</li>
<li><code>hierarchy</code>: 轮廓的层次结构信息</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/2&amp;5.png"</span>,<span class="number">1</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, binary = cv2.threshold(gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><br><span class="line">contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><p><code>cv2.drawContours()</code>用于在图像上绘制检测到的轮廓</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, contourIdx, color, thickness)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>contours</code>: 轮廓列表</li>
<li><code>contourIdx</code>: 要绘制的轮廓索引，如果为负数，则绘制所有轮廓</li>
<li><code>thickness</code>：线宽，设为-1时将填充轮廓</li>
</ul>
<p>无返回值，直接在输入图像上绘制轮廓</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)) <span class="comment"># 绘制所有轮廓	</span></span><br><span class="line">cv2.drawContours(img, contours, <span class="number">3</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)) <span class="comment"># 绘制第四个轮廓</span></span><br></pre></td></tr></tbody></table></figure>

<p>但很多情况下，会以以下方式绘制单个轮廓</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt = contours[<span class="number">3</span>]</span><br><span class="line">cv2.drawContours(img, [cnt], <span class="number">0</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>))  <span class="comment"># 绘制第四个轮廓</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Contours"</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271112.png" alt="202509271112" style="zoom:67%;">

<h3 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h3><p><strong>轮廓属性</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">M = cv2.moments(cnt)</span><br></pre></td></tr></tbody></table></figure>

<p>图像矩可以帮助计算一些特征，例如轮廓的质心：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cx = <span class="built_in">int</span>(M[<span class="string">'m10'</span>]/M[<span class="string">'m00'</span>])</span><br><span class="line">cy = <span class="built_in">int</span>(M[<span class="string">'m01'</span>]/M[<span class="string">'m00'</span>])</span><br><span class="line"><span class="built_in">print</span>(cx,cy) <span class="comment"># 379 445</span></span><br></pre></td></tr></tbody></table></figure>

<p>轮廓的面积：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt) </span><br><span class="line">area = M[<span class="string">'m00'</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>计算轮廓的周长或弧长：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length = cv2.arcLength(cnt, <span class="literal">True</span>)   <span class="comment"># True 表示闭合</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="边界矩形"><a href="#边界矩形" class="headerlink" title="边界矩形"></a>边界矩形</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>) <span class="comment"># 绘制矩形函数，输入两个对角点</span></span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271212.png" alt="202509271212" style="zoom:67%;">

<h4 id="最小外接矩形"><a href="#最小外接矩形" class="headerlink" title="最小外接矩形"></a>最小外接矩形</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rect = cv2.minAreaRect(cnt) <span class="comment"># 返回一个旋转矩形</span></span><br><span class="line">box = cv2.boxPoints(rect)   <span class="comment"># 把旋转矩阵的信息转换成4个角点坐标，即轮廓</span></span><br><span class="line">box = box.astype(<span class="built_in">int</span>)       <span class="comment"># 转回int对象，不然报错</span></span><br><span class="line">cv2.drawContours(img, [box], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>),<span class="number">2</span>) <span class="comment"># 图上绘制轮廓</span></span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271412.png" alt="202509271412" style="zoom:67%;">

<h4 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x,y), radius = cv2.minEnclosingCircle(cnt) <span class="comment"># 返回圆心坐标以及半径</span></span><br><span class="line">center = (<span class="built_in">int</span>(x),<span class="built_in">int</span>(y))  <span class="comment"># 转回int对象，不然报错</span></span><br><span class="line">radius = <span class="built_in">int</span>(radius)      <span class="comment"># 转回int对象，不然报错</span></span><br><span class="line">cv2.circle(img,center,radius,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271442.png" alt="202509271442" style="zoom:67%;">

<h4 id="椭圆拟合"><a href="#椭圆拟合" class="headerlink" title="椭圆拟合"></a>椭圆拟合</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/2&amp;5.png"</span>,<span class="number">1</span>)</span><br><span class="line">ellipse = cv2.fitEllipse(cnt) <span class="comment"># 返回椭圆内切的旋转矩阵</span></span><br><span class="line">cv2.ellipse(img,ellipse,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271513.png" alt="202509271513" style="zoom:67%;">

<h4 id="多边形逼近"><a href="#多边形逼近" class="headerlink" title="多边形逼近"></a>多边形逼近</h4><p>根据指定的精度将轮廓形状逼近到具有较少顶点的另一个形状，这是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">Douglas-Peucker算法</a>的一种实现</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">approx = cv2.approxPolyDP(cnt, epsilon, <span class="literal">True</span>)  <span class="comment"># 返回近似后的多边形点集(轮廓)</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>epsilon</code>：轮廓到逼近轮廓的最大距离，值越小，近似越精确</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/2&amp;5.png"</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    epsilon = <span class="number">0.01</span>*cv2.arcLength(contour,<span class="literal">True</span>) <span class="comment"># 一般取轮廓长度的1/10作为精度</span></span><br><span class="line">    approx = cv2.approxPolyDP(contour,epsilon,<span class="literal">True</span>) <span class="comment"># True表示闭合曲线</span></span><br><span class="line">    cv2.drawContours(img,[approx],<span class="number">0</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271447.png" alt="202509271447" style="zoom:67%;">



<h4 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h4><p>在二维平面里，给定一组点，凸包就是能把这些点“包”起来的最小凸多边形</p>
<p>凸包看起来类似于轮廓逼近，但并非如此(在某些情况下，两者可能提供相同的结果)</p>
<p><font color="Violetred">凸包的边界都是凸的，没有凹进去的部分</font></p>
<p>OpenCV 提供了 <code>cv2.convexHull</code> 来计算凸包</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(points[, hull[, clockwise[, returnPoints]]])</span><br></pre></td></tr></tbody></table></figure>

<p><code>points</code>：输入点集(通常是 <code>contour</code>)</p>
<p><code>hull</code>：输出索引，通常避免使用它</p>
<p><code>clockwise</code>：方向标志，<code>True</code> 表示顺时针，<code>False</code> 表示逆时针</p>
<p><code>returnPoints</code>：<code>True</code>(默认)：返回点坐标;<code>False</code>：返回的是点的索引</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/2&amp;5.png"</span>,<span class="number">1</span>)</span><br><span class="line">hull = cv2.convexHull(cnt)  <span class="comment"># 返回点坐标，即轮廓</span></span><br><span class="line">cv2.drawContours(img,[hull],<span class="number">0</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271512.png" alt="202509271512" style="zoom:67%;">

<p>如果想查找凸性缺陷，则需要将 returnPoints 设置为 <code>False</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># True 返回</span></span><br><span class="line">[[[<span class="number">390</span> <span class="number">289</span>]]</span><br><span class="line"> [[<span class="number">395</span> <span class="number">290</span>]]</span><br><span class="line"> [[<span class="number">399</span> <span class="number">291</span>]]</span><br><span class="line"> ...]</span><br><span class="line"><span class="comment"># False 返回 </span></span><br><span class="line">[[<span class="number">521</span>]</span><br><span class="line"> [<span class="number">519</span>]</span><br><span class="line"> [<span class="number">517</span>]</span><br><span class="line"> ...]</span><br><span class="line"><span class="built_in">print</span>(cnt[hull[:<span class="number">3</span>]])</span><br><span class="line">[[[[<span class="number">390</span> <span class="number">289</span>]]]</span><br><span class="line"> [[[<span class="number">395</span> <span class="number">290</span>]]]</span><br><span class="line"> [[[<span class="number">399</span> <span class="number">291</span>]]]]</span><br></pre></td></tr></tbody></table></figure>

<p>可以通过<code>cv.isContourConvex()</code>判断曲线是否为凸</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_convex = cv2.isContourConvex(cnt)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="轮廓属性"><a href="#轮廓属性" class="headerlink" title="轮廓属性"></a>轮廓属性</h3><p><strong>长宽比</strong>：边界矩形的宽高比</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x,y,w,h = cv.boundingRect(cnt)</span><br><span class="line">aspect_ratio = w/h  <span class="comment"># 宽高比</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>范围</strong>：轮廓面积与边界矩形面积的比值</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">area = cv.contourArea(cnt)</span><br><span class="line">x,y,w,h = cv.boundingRect(cnt)</span><br><span class="line">rect_area = w*h</span><br><span class="line">extent = area/rect_area <span class="comment"># 范围</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>实体度</strong>：轮廓面积与其凸包面积的比值</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(cnt)</span><br><span class="line">hull_area = cv2.contourArea(hull)</span><br><span class="line">solidity = area/hull_area <span class="comment"># 实体度</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>等效直径</strong>：与轮廓面积相同的圆的直径</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equi_diameter = np.sqrt(<span class="number">4</span>*area/np.pi)</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font color="Violetred">掩模</font></strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mask = np.zeros(gray.shape,np.uint8) <span class="comment"># 构建同图片的全0数组</span></span><br><span class="line">cv2.drawContours(mask,[cnt],<span class="number">0</span>,<span class="number">255</span>,-<span class="number">1</span>) <span class="comment"># 在其上绘制轮廓，用白色填充轮廓内容</span></span><br><span class="line"><span class="comment"># 相当于获得了一个二值掩膜</span></span><br><span class="line">pixelpoints = np.transpose(np.nonzero(mask)) <span class="comment"># 记得转置</span></span><br><span class="line"><span class="comment"># pixelpoints = cv2.findNonZero(mask) # 结果相同</span></span><br></pre></td></tr></tbody></table></figure>

<p>Numpy以**(行，列)<strong>格式给出坐标，而OpenCV以</strong>(x,y)**格式给出坐标</p>
<p>获得掩膜以后可以利用它进行一些计算</p>
<p>最大值、最小值及其位置：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_val, max_val, min_loc, max_loc = cv.minMaxLoc(gray, mask = mask) <span class="comment"># 只可以灰度</span></span><br></pre></td></tr></tbody></table></figure>

<p>平均颜色或平均强度：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean_val = cv.mean(img, mask = mask) <span class="comment"># 可输入三通道图样</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>极值点</strong>:</p>
<p>极值点是指对象的最高点、最低点、最右点和最左点</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">leftmost   = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">0</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">rightmost  = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">0</span>].argmax()][<span class="number">0</span>])</span><br><span class="line">topmost    = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">1</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">bottommost = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">1</span>].argmax()][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">cv2.circle(img, leftmost,   <span class="number">8</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), -<span class="number">1</span>)   <span class="comment"># 红色</span></span><br><span class="line">cv2.circle(img, rightmost,  <span class="number">8</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), -<span class="number">1</span>)   <span class="comment"># 绿色</span></span><br><span class="line">cv2.circle(img, topmost,    <span class="number">8</span>, (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), -<span class="number">1</span>)   <span class="comment"># 蓝色</span></span><br><span class="line">cv2.circle(img, bottommost, <span class="number">8</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>), -<span class="number">1</span>) <span class="comment"># 黄色</span></span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271613.png" alt="202509271613" style="zoom:67%;">

<h3 id="简单案例-数硬币"><a href="#简单案例-数硬币" class="headerlink" title="简单案例(数硬币)"></a>简单案例(数硬币)</h3><p>写一个函数，统计图像中“物体的数量和面积分布”（比如数硬币）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_objects</span>(<span class="params">img_path, show = <span class="literal">False</span>, min_area=<span class="number">100</span></span>):</span><br><span class="line">    img = cv2.imread(img_path)</span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 阈值分割</span></span><br><span class="line">    _ , thresh = cv2.threshold(gray, <span class="number">20</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">    <span class="comment"># 开运算去除噪声点</span></span><br><span class="line">    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">7</span>, <span class="number">7</span>))</span><br><span class="line">    <span class="built_in">open</span> = cv2.morphologyEx(thresh, cv2.MORPH_OPEN,kernel)</span><br><span class="line">    <span class="comment"># 找轮廓</span></span><br><span class="line">    contours, _ = cv2.findContours(<span class="built_in">open</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 统计面积和数量</span></span><br><span class="line">    areas = []</span><br><span class="line">    valid_contours = []</span><br><span class="line">    <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:</span><br><span class="line">        area = cv2.contourArea(cnt)</span><br><span class="line">        <span class="keyword">if</span> area &gt;= min_area:</span><br><span class="line">            areas.append(area)</span><br><span class="line">            valid_contours.append(cnt)</span><br><span class="line"></span><br><span class="line">    object_num = <span class="built_in">len</span>(valid_contours)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> show:</span><br><span class="line">        cv2.drawContours(img, valid_contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line">        cv2.imshow(<span class="string">'Objects'</span>, img)</span><br><span class="line">        <span class="comment"># 创建空白画布画轮廓</span></span><br><span class="line">        contour_img = np.zeros_like(img)</span><br><span class="line">        cv2.drawContours(contour_img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line">        cv2.imshow(<span class="string">'Contours'</span>, contour_img)</span><br><span class="line"></span><br><span class="line">        cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object_num, areas</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    object_num, areas = count_objects(<span class="string">'imgs/coins.webp'</span>,<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"The num of coins: <span class="subst">{object_num}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"The area of each coin: <span class="subst">{areas}</span> "</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h3><p><code>cv2.matchShapes()</code>可以检测两个形状之间的相似度，返回值越小，越相似</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/match_shape.jpg"</span>,<span class="number">1</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, thresh = cv2.threshold(gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><br><span class="line">contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">cnt_a, cnt_b, cnt_c = contours[<span class="number">0</span>], contours[<span class="number">1</span>], contours[<span class="number">2</span>]</span><br><span class="line">cv2.drawContours(img, [cnt_a], <span class="number">0</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">cv2.drawContours(img, [cnt_b], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">cv2.drawContours(img, [cnt_c], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_a, cnt_b, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.4185301853277106</span></span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_a, cnt_c, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.41705272670009474</span></span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_c, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.0014774586276158352</span></span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20250927161329110.png" alt="image-20250927161329110" style="zoom:67%;">

<p>bc的输出最低，根据颜色，bc对应绿色和红色，符合预期</p>
<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>在图像处理中，直方图是一种非常重要的工具，它可以帮助我们了解图像的像素分布情况</p>
<p>三个主要概念：</p>
<ul>
<li><p><strong>BIN（区间）</strong>: 如果统计<code>0~255</code>每个像素值，BIN=256；如果划分区间，比如<code>0~15,16~31...</code>，那么BIN=16，BIN在OpenCV文档中由<code>histSize</code>表示</p>
</li>
<li><p><strong>DIMS（维度）</strong>: 要计算的通道数，对于灰度图为1，普通彩色图为3</p>
</li>
<li><p><strong>RANGE（范围）</strong>: 要计算的像素值范围，一般为[0,256]，即所有强度值</p>
</li>
</ul>
<h3 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h3><p>使用 <code>cv2.calcHist()</code> 函数来计算图像的直方图</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.calcHist(imgs, channels, mask, histSize, ranges)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>imgs</code>: 输入的图像列表，通常是一个包含单通道或多通道图像的列表，通常输入<code>[img]</code></p>
</li>
<li><p><code>channels</code>：需要计算直方图的通道索引，灰度图像为<code>[0]</code>，彩色图像选择<code>[0/1/2]</code>|(BGR)</p>
</li>
<li><p><code>mask</code>: 掩膜，指定掩膜后只计算掩膜内的像素，如果没有输入<code>None</code></p>
<p>可以用阈值分割后的二值图也可以自己创建，比如</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask = np.zeros(img.shape[:<span class="number">2</span>], np.uint8)</span><br><span class="line">mask[<span class="number">100</span>:<span class="number">300</span>, <span class="number">100</span>:<span class="number">300</span>] = <span class="number">255</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>histSize</code>：直方图的BIN数量，灰度图像通常输入<code>[256]</code></p>
</li>
<li><p><code>ranges</code>: 像素值的范围，对于灰度图像，通常设置为<code>[0, 256]</code></p>
</li>
</ul>
<p>灰度：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/Lena.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>]) <span class="comment"># 运行时间 0.0001872</span></span><br><span class="line">plt.plot(hist)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291122.png" alt="202509291122" style="zoom:67%;">

<p>彩色：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/LenaRGB.bmp"</span>, <span class="number">1</span>)</span><br><span class="line">colors = (<span class="string">'b'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">for</span> i, colors <span class="keyword">in</span> <span class="built_in">enumerate</span>(colors): <span class="comment"># 遍历序列返回索引和值</span></span><br><span class="line">    hist = cv2.calcHist([img],[i],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    plt.plot(hist, color = colors)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/20250929.webp" alt="20250929" style="zoom: 67%;">

<p>Numpy还提供了一个函数<code>np.histogram()</code>，在这里还要将将多维数组展平(<code>np.ravel()</code>)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist,bins = np.histogram(img.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])  <span class="comment"># 运行时间0.0025162</span></span><br></pre></td></tr></tbody></table></figure>

<p>还有一种针对灰度图的更高效方式：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist = np.bincount(img.ravel(), minlength=<span class="number">256</span>)  <span class="comment"># 运行时间 0.0007413</span></span><br></pre></td></tr></tbody></table></figure>

<p><font color="Violetred">但其实还是cv2的性能高</font></p>
<h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><p>刚刚直接用的plot将数据以曲线的形式绘制出来，但这并不是常见直方图的模样</p>
<p>Matplotlib 带有一个直方图绘图函数：<code>matplotlib.pyplot.hist()</code></p>
<p>可以直接输入图像，不需要先<code>cv2.calcHist()</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/Lena.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291123.png" alt="202509291123" style="zoom:67%;">

<p>但对于彩色图样，选择普通绘图反而是更好的选择，因为这样可以很容易看出不同颜色的成分</p>
<h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>直方图均衡化是一种增强图像对比度的方法，通过重新分配像素强度值，使直方图更加均匀，改善图像的全局亮度和对比度</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq_img = cv2.equalizeHist(img)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/Lena.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">eq_img = cv2.equalizeHist(img)</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.imshow(img,<span class="string">'gray'</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.imshow(eq_img,<span class="string">'gray'</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.hist(eq_img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291145.webp" alt="202509291145" style="zoom: 67%;">

<h3 id="自适应均衡化"><a href="#自适应均衡化" class="headerlink" title="自适应均衡化"></a>自适应均衡化</h3><p>直方图均衡化是应用于整幅图片的，但是这可能导致局部细节丢失，自适应均衡化就是用来解决这一问题的，它在每一个小区域内(默认 8×8)进行直方图均衡化</p>
<p>当然，如果有噪声的话也会被放大，所以需要对对比度进行限制，所以这个算法全称叫<font color="Violetred">对比度受限的自适应直方图均衡化CLAHE</font></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clahe = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>))</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291505~1.webp" alt="202509291505~1" style="zoom:67%;">

<p>可以看到不会有过曝区域</p>
<h3 id="直方图比较"><a href="#直方图比较" class="headerlink" title="直方图比较"></a>直方图比较</h3><p> <code>cv2.compareHist() </code>函数，用于比较两个直方图的相似度</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">similarity = cv2.compareHist(hist1, hist2, method)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>method</code>: 比较方法</li>
</ul>
<p>比较方法主要有四种：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>代码标识</th>
<th>范围</th>
<th>相似性判断</th>
<th>衡量目标</th>
</tr>
</thead>
<tbody><tr>
<td>相关性</td>
<td><code>cv2.HISTCMP_CORREL</code>|0</td>
<td>[-1,1]</td>
<td>越大越相似</td>
<td>直方图形状相似性</td>
</tr>
<tr>
<td>卡方</td>
<td><code>cv2.HISTCMP_CHISQR</code>|1</td>
<td>[0,+∞]</td>
<td>越小越相似</td>
<td>概率分布差异</td>
</tr>
<tr>
<td>相交</td>
<td><code>cv2.HISTCMP_INTERSECT</code>|2</td>
<td>[0,sum]</td>
<td>越大越相似</td>
<td>重叠部分</td>
</tr>
<tr>
<td>巴氏距离</td>
<td><code>cv2.HISTCMP_BHATTACHARYYA</code>|3</td>
<td>[0,1]</td>
<td>越小越相似</td>
<td>概率分布相似性</td>
</tr>
</tbody></table>
<blockquote>
<p>举例，直方图A = <code>[1, 2, 3]</code>，直方图 B = <code>[3, 2, 1]</code></p>
<p>Correlation: -0.999999999999998 (负相关)<br>Chi-Square: 0.8888887630568671<br>Intersection: 0.6666666865348816<br>Bhattacharyya: 0.298858482412642</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>常见场景</th>
</tr>
</thead>
<tbody><tr>
<td>相关性</td>
<td>检测线性相关性(亮度/对比度变化)，找风格相似的图片</td>
</tr>
<tr>
<td>卡方</td>
<td>目标识别时发现差异</td>
</tr>
<tr>
<td>相交</td>
<td>直方图快速匹配</td>
</tr>
<tr>
<td>巴氏距离</td>
<td>目标跟踪，适合高精度相似性度量</td>
</tr>
</tbody></table>
<p>在进行比较之前，一般都要进行归一化</p>
<p>使用<code>cv2.normalize()</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.normalize(src, dst=<span class="literal">None</span>, alpha=<span class="number">1</span>, beta=<span class="number">0</span>, norm_type)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>src</code>：输入数组，可以是图像/直方图</p>
</li>
<li><p><code>dst</code>：输出数组，如果写入None则覆盖输入</p>
</li>
<li><p><code>alpha</code>：L1，L2归一化需设为1，beta为无作用冗余参数</p>
<p><code>beta</code>：最大最小归一化时使用，归一化数值最大值</p>
</li>
<li><p><code>norm_type</code>：归一化方式</p>
</li>
</ul>
<p>归一化常见方式：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>目的</th>
<th>常见用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>cv2.NORM_MINMAX</code></td>
<td>把数据线性拉伸到<code>[alpha, beta]</code>区间</td>
<td>图像对比度拉伸</td>
</tr>
<tr>
<td><code>cv2.NORM_L1</code>|2</td>
<td>所有值除以绝对值和</td>
<td>直方图归一化为概率分布</td>
</tr>
<tr>
<td><code>cv2.NORM_L2</code>(默认)|4</td>
<td>所有值除以平方和的平方根</td>
<td>把向量长度归一到 1</td>
</tr>
</tbody></table>
<p>匹配比较方法和归一化方式</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>归一化方式</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>相关性</td>
<td>无需</td>
<td>相关性看趋势，线性缩放不影响结果</td>
</tr>
<tr>
<td>卡方</td>
<td>L1</td>
<td><font color="Violetred">通常用于比较概率分布，需要归一化到概率分布</font></td>
</tr>
<tr>
<td>交集</td>
<td>不归一化/L1</td>
<td>不归一化为绝对重叠数量；<br>归一化后为“重叠比例”含义</td>
</tr>
<tr>
<td>巴氏距离</td>
<td>L1</td>
<td><font color="Violetred">定义基于概率分布，需要归一化到概率分布</font></td>
</tr>
</tbody></table>
<p>对于直方图均衡化后的图片，这四个方法其实都不太能看出是一张图</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/Lena.bmp"</span>, <span class="number">0</span>)</span><br><span class="line">eq_img = cv2.equalizeHist(img)</span><br><span class="line">hist_img = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">cv2.normalize(hist_img, hist_img, alpha=<span class="number">1</span>, beta=<span class="number">0</span>, norm_type=cv2.NORM_L1)</span><br><span class="line">hist_eq = cv2.calcHist([eq_img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">cv2.normalize(hist_eq, hist_eq, alpha=<span class="number">1</span>, beta=<span class="number">0</span>, norm_type=cv2.NORM_L1)</span><br><span class="line"><span class="comment"># 四种相似性计算</span></span><br><span class="line">methods = {</span><br><span class="line">    <span class="string">"Correlation"</span>: cv2.HISTCMP_CORREL,</span><br><span class="line">    <span class="string">"Chi-Square"</span>: cv2.HISTCMP_CHISQR,</span><br><span class="line">    <span class="string">"Intersection"</span>: cv2.HISTCMP_INTERSECT,</span><br><span class="line">    <span class="string">"Bhattacharyya"</span>: cv2.HISTCMP_BHATTACHARYYA</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> name, method <span class="keyword">in</span> methods.items():</span><br><span class="line">    score = cv2.compareHist(hist_img, hist_eq, method)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"<span class="subst">{name}</span>: <span class="subst">{score}</span>"</span>)</span><br><span class="line"><span class="comment"># Correlation: 0.007809369904676664  均衡化后拉伸平铺，相关性基本消失</span></span><br><span class="line"><span class="comment"># Chi-Square: 40.33161269091677      不同BIN的差异很大</span></span><br><span class="line"><span class="comment"># Intersection: 0.5334510803222656   还有大约一半的直方图“重叠部分”</span></span><br><span class="line"><span class="comment"># Bhattacharyya: 0.5778464606235761  两个分布整体重叠度不高</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h2><p>模板匹配是一种在较大的图像中搜索和查找模板图像位置的方法</p>
<p>用<code>cv2.matchTemplate()</code>实现模板匹配，返回的是一副灰度图，最白的地方表示最大的匹配</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.matchTemplate(img, templ, method)</span><br></pre></td></tr></tbody></table></figure>

<p><code>method</code>：匹配方法，有几种不同的计算方式</p>
<ul>
<li><p><code>cv2.TM_CCOEFF</code> / <code>cv2.TM_CCOEFF_NORMED</code> (相关系数，常用，越大越像)</p>
</li>
<li><p><code>cv2.TM_CCORR</code> / <code>cv2.TM_CCORR_NORMED</code> (相关匹配，越大越像，效果不好，用的少)</p>
</li>
<li><p><code>cv2.TM_SQDIFF</code> / <code>cv2.TM_SQDIFF_NORMED</code> (平方差，数值越小越像)</p>
</li>
</ul>
<p>使用<code>cv2.minMaxLoc()</code>函数可以得到匹配值极值的坐标，以这个点为左上角角点，模板的宽和高画矩形就是匹配的位置了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)</span><br></pre></td></tr></tbody></table></figure>

<p>如果用的是平方差类方法<code>TM_SQDIFF</code>，数值越小越好，所以取<code>min_loc</code>，其他方法数值越大越好，所以取 <code>max_loc</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'imgs/Lena.bmp'</span>, <span class="number">0</span>)</span><br><span class="line">template = cv2.imread(<span class="string">'imgs/face.bmp'</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>] <span class="comment"># rows-&gt;h, cols-&gt;w</span></span><br><span class="line"><span class="comment"># 相关系数匹配方法：cv2.TM_CCOEFF</span></span><br><span class="line">res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line">left_top = max_loc  <span class="comment"># 左上角</span></span><br><span class="line">right_bottom = (left_top[<span class="number">0</span>] + w, left_top[<span class="number">1</span>] + h)  <span class="comment"># 右下角</span></span><br><span class="line">cv2.rectangle(img, left_top, right_bottom, <span class="number">255</span>, <span class="number">2</span>)  <span class="comment"># 画出矩形位置</span></span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.imshow(template, <span class="string">'gray'</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.imshow(res, <span class="string">'gray'</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.imshow(img, <span class="string">'gray'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291525.webp" alt="202509291525" style="zoom:80%;">

<h3 id="多物体匹配"><a href="#多物体匹配" class="headerlink" title="多物体匹配"></a>多物体匹配</h3><p>在这个例子中，将使用著名游戏马里奥的截图，并在其中找到金币</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/mario.jpg"</span>,<span class="number">1</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">template = cv2.imread(<span class="string">"imgs/mario_coin.jpg"</span>, <span class="number">0</span>)</span><br><span class="line">w, h = template.shape[::-<span class="number">1</span>]</span><br><span class="line">res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">threshold = <span class="number">0.8</span></span><br><span class="line">loc= np.where(res&gt;=threshold)</span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> <span class="built_in">zip</span>(*loc[::-<span class="number">1</span>]):</span><br><span class="line">    cv2.rectangle(img, pt, (pt[<span class="number">0</span>]+w,pt[<span class="number">1</span>]+h), (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291538.webp" alt="202509291538" style="zoom: 80%;">

<h2 id="图像拼接"><a href="#图像拼接" class="headerlink" title="图像拼接"></a>图像拼接</h2><p>图像拼接的基本流程可以分为以下几个步骤：</p>
<ol>
<li><strong>图像读取</strong>：读取需要拼接的图像</li>
<li><strong>特征点检测</strong>：在每张图像中检测出关键点（特征点）</li>
<li><strong>特征点匹配</strong>：在不同图像之间匹配这些特征点</li>
<li><strong>计算变换矩阵</strong>：根据匹配的特征点计算图像之间的变换矩阵</li>
<li><strong>图像融合</strong>：将图像按照变换矩阵进行拼接，并进行融合处理以消除拼接痕迹</li>
</ol>
<p>特征点检测是图像拼接的关键步骤，OpenCV 提供了多种特征点检测算法，如SIFT、SURF、ORB 等，其中<font color="Violetred">SIFT和SURF是浮点描述子，ORB是二进制描述子 </font></p>
<p>SIFT长期被认为鲁棒性最好</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创造SIFT检测器</span></span><br><span class="line">sift = cv2.SIFT_create()</span><br><span class="line">kps1, des1 = sift.detectAndCompute(img1, <span class="literal">None</span>)</span><br><span class="line">kps2, des2 = sift.detectAndCompute(img2, <span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><code>detectAndCompute()</code> 函数会返回两个值：关键点(keypoints)和描述符(descriptors)，关键点是图像中的显著点，描述符是对这些关键点的描述，用于后续的匹配</p>
<p>OpenCV 提供了 <code>BFMatcher</code> 或 <code>FlannBasedMatcher</code> 来进行特征点匹配</p>
<table>
<thead>
<tr>
<th>匹配方法</th>
<th>描述</th>
<th>SIFT/SURF</th>
<th>ORB/BRIEF</th>
</tr>
</thead>
<tbody><tr>
<td>BFMatcher</td>
<td>暴力匹配，逐个对比计算距离</td>
<td>欧式距离(L2范数)</td>
<td>汉明距离(二进制取与)</td>
</tr>
<tr>
<td>FlannBasedMatcher</td>
<td>近似快速匹配，使用ANN(近似最相邻)搜索算法</td>
<td>KD-Tree(K维树)</td>
<td>LSH(局部敏感哈希)</td>
</tr>
</tbody></table>
<p>BFMatcher简单直接，但计算量大，速度慢；</p>
<p>FlannBasedMatcher匹配速度更快，更适合大规模特征点匹配，虽然结果近似最近邻，但是在实际应用中几乎不影响效果</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- BFMatcher ---</span></span><br><span class="line">bf = cv2.BFMatcher() <span class="comment"># L2范数</span></span><br><span class="line">matches_bf = bf.knnMatch(des1, des2, k=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># --- FLANN ---</span></span><br><span class="line">index_params = <span class="built_in">dict</span>(algorithm=<span class="number">1</span>, trees=<span class="number">5</span>)   <span class="comment"># KDTree</span></span><br><span class="line">search_params = <span class="built_in">dict</span>(checks=<span class="number">50</span>)</span><br><span class="line">flann = cv2.FlannBasedMatcher(index_params, search_params)</span><br><span class="line">matches_flann = flann.knnMatch(des1, des2, k=<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>FLANN的创建需要输入参数</p>
<ul>
<li><p>SIFT/SURF → <code>algorithm=1, trees=5</code> （KDTree）</p>
</li>
<li><p>ORB → <code>algorithm=6, table_number=6, key_size=12, multi_probe_level=1</code> （LSH）</p>
</li>
<li><p>checks=50 → 表示搜索时在多少个叶节点里查找候选(常用 32~128 之间)</p>
</li>
</ul>
<p><code>knnMatch()</code> 函数会返回每个特征点的两个最佳匹配，通过比率测试(Lowe’s ratio test)来筛选出好的匹配点</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">good_matches = []</span><br><span class="line"><span class="keyword">for</span> m, n <span class="keyword">in</span> matches_flann:</span><br><span class="line">    <span class="keyword">if</span> m.distance &lt; <span class="number">0.75</span> * n.distance:</span><br><span class="line">        good_matches.append(m)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(good_matches) &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"匹配点太少，无法拼接"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>在得到好的匹配点后，可以使用这些点来计算图像之间的变换矩阵</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取匹配点的坐标</span></span><br><span class="line">src_pts = np.float32([kps1[m.queryIdx].pt <span class="keyword">for</span> m <span class="keyword">in</span> good_matches]).reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">dst_pts = np.float32([kps2[m.trainIdx].pt <span class="keyword">for</span> m <span class="keyword">in</span> good_matches]).reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 计算单应性矩阵</span></span><br><span class="line">H, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, <span class="number">5.0</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>最后使用计算出的单应性矩阵将图像进行拼接，并进行融合处理以消除拼接痕迹</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透视变换 + 融合</span></span><br><span class="line">h1, w1 = img1.shape[:<span class="number">2</span>]</span><br><span class="line">h2, w2 = img2.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 计算输出画布</span></span><br><span class="line">pts_img1 = np.float32([[<span class="number">0</span>,<span class="number">0</span>], [<span class="number">0</span>,h1], [w1,h1], [w1,<span class="number">0</span>]]).reshape(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># OpenCV要求数组是N×1×2的格式</span></span><br><span class="line"><span class="comment"># 用单应矩阵 H 把角点 投影到 img2 的坐标系里</span></span><br><span class="line">pts_img1_trans = cv2.perspectiveTransform(pts_img1, H)</span><br><span class="line"><span class="comment"># 把变换后的 img1 的四个角点和原始 img2 的四个角点拼在一起</span></span><br><span class="line">pts_all = np.concatenate((pts_img1_trans, np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,h2],[w2,h2],[w2,<span class="number">0</span>]]).reshape(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)), axis=<span class="number">0</span>)</span><br><span class="line">[xmin, ymin] = np.int32(pts_all.<span class="built_in">min</span>(axis=<span class="number">0</span>).ravel() - <span class="number">0.5</span>)</span><br><span class="line">[xmax, ymax] = np.int32(pts_all.<span class="built_in">max</span>(axis=<span class="number">0</span>).ravel() + <span class="number">0.5</span>)</span><br><span class="line"> <span class="comment"># 平移变换，确保坐标正值</span></span><br><span class="line">t = [-xmin, -ymin] <span class="comment"># 定义平移向量，因为xmin和ymin可能是负数</span></span><br><span class="line">H_trans = np.array([[<span class="number">1</span>,<span class="number">0</span>,t[<span class="number">0</span>]], [<span class="number">0</span>,<span class="number">1</span>,t[<span class="number">1</span>]], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]) <span class="comment"># 把所有点整体平移(tx, ty)</span></span><br><span class="line"><span class="comment"># warp</span></span><br><span class="line">result = cv2.warpPerspective(img1, H_trans.dot(H), (xmax-xmin, ymax-ymin))</span><br><span class="line">result[t[<span class="number">1</span>]:h2+t[<span class="number">1</span>], t[<span class="number">0</span>]:w2+t[<span class="number">0</span>]] = img2 <span class="comment"># 把 img2 直接贴到大画布的正确位置</span></span><br><span class="line"><span class="comment"># 因为整个画布已经被平移过，所以 img2 也要偏移</span></span><br></pre></td></tr></tbody></table></figure>

<p>拼接效果可能不是特别好</p>
<h2 id="简单滤镜"><a href="#简单滤镜" class="headerlink" title="简单滤镜"></a>简单滤镜</h2><p>主要滤镜效果：</p>
<table>
<thead>
<tr>
<th align="left"><strong>滤镜效果</strong></th>
<th align="left"><strong>实现方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">灰度滤镜</td>
<td align="left"><code>cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</code></td>
</tr>
<tr>
<td align="left">模糊滤镜</td>
<td align="left"><code>cv2.GaussianBlur(image, (15, 15), 0)</code></td>
</tr>
<tr>
<td align="left">怀旧滤镜</td>
<td align="left">通过调整色彩通道的权重，模拟老照片效果</td>
</tr>
<tr>
<td align="left">浮雕滤镜</td>
<td align="left">使用卷积核 <code>[[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]</code> 进行卷积操作</td>
</tr>
<tr>
<td align="left">锐化滤镜</td>
<td align="left">使用卷积核 <code>[[0, -1, 0], [-1, 5, -1], [0, -1, 0]]</code> 进行卷积操作</td>
</tr>
<tr>
<td align="left">边缘检测滤镜</td>
<td align="left"><code>cv2.Canny(gray_image, 100, 200)</code></td>
</tr>
</tbody></table>
<h3 id="怀旧滤镜"><a href="#怀旧滤镜" class="headerlink" title="怀旧滤镜"></a>怀旧滤镜</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/LenaRGB.bmp"</span>)</span><br><span class="line"><span class="comment"># 分离 BGR 通道</span></span><br><span class="line">b,g,r = cv2.split(img)</span><br><span class="line"><span class="comment"># 调整通道强度</span></span><br><span class="line">r = np.clip(r*<span class="number">0.393</span>+g*<span class="number">0.769</span>+b*<span class="number">0.189</span>,<span class="number">0</span>,<span class="number">255</span>).astype(np.uint8)</span><br><span class="line">g = np.clip(r*<span class="number">0.349</span>+g*<span class="number">0.686</span>+b*<span class="number">0.168</span>,<span class="number">0</span>,<span class="number">255</span>).astype(np.uint8)</span><br><span class="line">b = np.clip(r*<span class="number">0.272</span>+g*<span class="number">0.534</span>+b*<span class="number">0.131</span>,<span class="number">0</span>,<span class="number">255</span>).astype(np.uint8)</span><br><span class="line"><span class="comment"># 合并通道</span></span><br><span class="line">img = cv2.merge([b,g,r])</span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041051.webp" alt="202510041051" style="zoom:67%;">

<h3 id="浮雕滤镜"><a href="#浮雕滤镜" class="headerlink" title="浮雕滤镜"></a>浮雕滤镜</h3><p>浮雕滤镜通过计算图像中相邻像素的差值，生成一种类似于浮雕的效果，这种滤镜通常用于增强图像的边缘和纹理</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/LenaRGB.bmp"</span>)</span><br><span class="line"><span class="comment"># 转换为灰度图像</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 定义卷积核</span></span><br><span class="line">kernel = np.array([[-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                   [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                   [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="comment"># 应用卷积核</span></span><br><span class="line">emboss_img = cv2.filter2D(gray, -<span class="number">1</span>, kernel)</span><br><span class="line">plt.imshow(cv2.cvtColor(emboss_img, cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041056.webp" alt="202510041056" style="zoom: 67%;">

<h2 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h2><p>霍夫变换常用来在图像中提取直线和圆等几何形状</p>
<h3 id="霍夫直线变换"><a href="#霍夫直线变换" class="headerlink" title="霍夫直线变换"></a>霍夫直线变换</h3><p>直线的参数方程：$y=kx+b$</p>
<p>但是在 $k\rightarrow \infty$ 时将无效，霍夫变换用极坐标的形式<br>$$<br>\rho = x\cos \theta +y\sin \theta<br>$$<br>任何一条直线都能用一对$(\rho ,\theta)$唯一表示</p>
<p>用<code>cv2.HoughLines()</code>在二值图上实现霍夫变换，函数返回的是一组直线的$(\rho ,\theta)$数据</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines = cv2.HoughLines(edges, <span class="number">1</span>, np.pi / <span class="number">180</span>, threshold)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>参数1：一般是边缘检测后的二值图</li>
<li>参数2：距离$\rho$的精度，值越大，考虑越多的线，一般使用1像素</li>
<li>参数3：角度$\theta $的精度，值越小，考虑越多的线，一般使用1度</li>
<li>参数4：累加数阈值，值越小，考虑越多的线</li>
</ul>
<p><strong>标准霍夫变换</strong>会检测到整条无穷延伸的直线，而实际中更想要<strong>线段</strong></p>
<p>OpenCV 提供 <code>cv2.HoughLinesP</code>(统计概率霍夫直线变换)，这是一种改进算法，输出线段的起止点</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linesP = cv2.HoughLinesP(edges, <span class="number">1</span>, np.pi/<span class="number">180</span>, threshold, minLineLength=<span class="number">50</span>, maxLineGap=<span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>前面几个参数跟之前的一样，有两个可选参数，最短长度阈值以及同一直线两点间的最大距离</p>
<p>读取 → 转灰度 → Canny检测 → 霍夫变换</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">"imgs/hough_test.jpg"</span>)</span><br><span class="line"><span class="comment"># 绘制黑背景用于显示</span></span><br><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line">linesP = cv2.HoughLinesP(edges, <span class="number">1</span>, np.pi/<span class="number">180</span>, <span class="number">80</span>, minLineLength=<span class="number">50</span>, maxLineGap=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 遍历，linesP.shape = (N, 1, 4)</span></span><br><span class="line"><span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> linesP[:,<span class="number">0</span>]: <span class="comment"># 选出所有线段的第一个数组，压缩为(N,4) </span></span><br><span class="line">    cv2.line(drawing, (x1,y1), (x2,y2), (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">plt.imshow(drawing)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041328.png" alt="202510041328" style="zoom:67%;">

<h3 id="霍夫圆变换"><a href="#霍夫圆变换" class="headerlink" title="霍夫圆变换"></a>霍夫圆变换</h3><p>同理，霍夫变换也可以用于检测圆<br>$$<br>(x-a)^2+(y-b)^2 = r^2<br>$$<br>参数空间变成$(a, b, r)$</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cv2.HoughCircles(</span><br><span class="line">    image,            <span class="comment"># 输入图像（必须是灰度图）</span></span><br><span class="line">    method,           <span class="comment"># 检测方法（通常用 cv2.HOUGH_GRADIENT）</span></span><br><span class="line">    dp,               <span class="comment"># 累加器分辨率的反比，1为等尺寸，2为图像的一半</span></span><br><span class="line">    minDist,          <span class="comment"># 检测到的圆之间的最小距离，通常为图像高度的若干份之一</span></span><br><span class="line">    param1=<span class="number">100</span>,       <span class="comment"># Canny 边缘检测的高阈值，低阈值自动为其一半</span></span><br><span class="line">    param2=<span class="number">30</span>,        <span class="comment"># 圆心累加器阈值（越小越容易检测到假圆）</span></span><br><span class="line">    minRadius=<span class="number">0</span>,      <span class="comment"># 圆的最小半径，0自动搜索，已知物体建议精确设定</span></span><br><span class="line">    maxRadius=<span class="number">0</span>       <span class="comment"># 圆的最大半径，同理</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imgs/hough_test.jpg"</span>)</span><br><span class="line"><span class="comment"># 绘制黑背景用于显示</span></span><br><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape <span class="comment"># 图像尺寸</span></span><br><span class="line">circles = cv2.HoughCircles(gray, cv2.HOUGH_GRADIENT, dp = <span class="number">1</span>, minDist= h/<span class="number">8</span>, param2=<span class="number">30</span>)</span><br><span class="line">circles = np.uint16(np.around(circles)) <span class="comment"># 检测到的圆心坐标和半径从浮点数转换成无符号整数</span></span><br><span class="line"><span class="keyword">for</span> (x, y, r) <span class="keyword">in</span> circles[<span class="number">0</span>, :]:</span><br><span class="line">    cv2.circle(drawing, (x, y), r, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">plt.imshow(drawing)</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041338.png" alt="202510041338" style="zoom:67%;">

<h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><p>视频是由一系列连续的图像帧组成的，每一帧都是一幅静态图像，核心就是对这些图像帧进行处理</p>
<h3 id="视频读取"><a href="#视频读取" class="headerlink" title="视频读取"></a>视频读取</h3><p>要读取视频文件，首先需要创建一个 <code>cv2.VideoCapture</code> 对象，并指定视频文件的路径</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="string">"imgs/camera_vedio.mp4"</span>)</span><br><span class="line"><span class="comment"># 检查视频是否成功打开</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error: Could not open video."</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># ret: 标识符，表示是否成功读取</span></span><br><span class="line">    <span class="comment"># frame: 当前帧图像</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cv2.imshow(<span class="string">'Video'</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<p>除了读取视频文件，OpenCV 还可以直接从摄像头读取视频，只需要将 <code>cv2.VideoCapture</code> 的参数设置为摄像头的索引(通常为0)即可：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 检查摄像头是否成功打开</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error: Could not open camera."</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="comment"># 读取视频帧</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># 如果读取到最后一帧，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 显示当前帧</span></span><br><span class="line">    cv2.imshow(<span class="string">'Camera'</span>, frame)</span><br><span class="line">    <span class="comment"># 按下esc 退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<p>电脑没有摄像头的话可以参考这篇内容：<a href="/posts/29316.html" title="虚拟摄像头构建">虚拟摄像头构建</a></p>
<p>之后就可以对视频画面进行一些实时操作了</p>
<h3 id="视频帧处理"><a href="#视频帧处理" class="headerlink" title="视频帧处理"></a>视频帧处理</h3><p>在读取视频帧后，可以对每一帧进行各种图像处理操作，并进行保存</p>
<p>在读取后需要利用<code>.get()</code>获取视频的属性(如宽度、高度、帧率等)，方便创建保存对象</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fps = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FPS)) <span class="comment"># 帧率</span></span><br><span class="line">width = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH)) <span class="comment"># 宽度</span></span><br><span class="line">height = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)) <span class="comment"># 高度</span></span><br></pre></td></tr></tbody></table></figure>

<p>视频如果分辨率和帧率过高输出可能会出现掉帧，根据性能量力而行</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">input_path = <span class="string">"imgs/tree.mp4"</span></span><br><span class="line">output_path = <span class="string">"tree.avi"</span></span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(input_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error: Could not open camera."</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="comment"># 获取视频的帧率和尺寸</span></span><br><span class="line">fps = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FPS))</span><br><span class="line"><span class="comment"># width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span></span><br><span class="line"><span class="comment"># height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span></span><br><span class="line"><span class="comment"># 创建 VideoWriter 对象，保存处理后的视频</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'XVID'</span>) <span class="comment"># 常见编码: "XVID", "MJPG", "mp4v"</span></span><br><span class="line">out = cv2.VideoWriter(output_path, fourcc, fps, (<span class="number">1080</span>, <span class="number">720</span>))</span><br><span class="line"><span class="comment"># out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    frame = cv2.resize(frame, (<span class="number">1080</span>,<span class="number">720</span>)) <span class="comment"># 改尺寸了要加上</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    blur = cv2.GaussianBlur(gray, (<span class="number">5</span>,<span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">    edges = cv2.Canny(blur, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line">    edges = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)</span><br><span class="line">    out.write(edges)</span><br><span class="line">    <span class="comment"># cv2.imshow('Video', edges)</span></span><br><span class="line">    <span class="comment"># if cv2.waitKey(25) &amp; 0xFF == 27:</span></span><br><span class="line">    <span class="comment">#     break</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"视频处理完毕"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>摄像头实时处理读出：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">output_path = <span class="string">"res/camera_output.mp4"</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error: Could not open camera."</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="comment"># 获取摄像头参数</span></span><br><span class="line">fps = <span class="number">30.0</span>  <span class="comment"># 摄像头一般不一定能准确取到帧率，可以手动设定</span></span><br><span class="line">width = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">height = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line"><span class="comment"># 创建 VideoWriter</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'mp4v'</span>)</span><br><span class="line">out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"按 ESC 退出录制..."</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 图像处理：灰度化 + 边缘检测</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    edges = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line">    edges = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)</span><br><span class="line">    <span class="comment"># 写入文件</span></span><br><span class="line">    out.write(edges)</span><br><span class="line">    cv2.imshow(<span class="string">"Camera Processed"</span>, edges)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"录制结束，视频保存为:"</span>, output_path)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="物体检测"><a href="#物体检测" class="headerlink" title="物体检测"></a>物体检测</h3><p>OpenCV提供了多种物体检测算法，如 Haar 特征分类器、HOG + SVM 等</p>
<h4 id="Haar特征分类器"><a href="#Haar特征分类器" class="headerlink" title="Haar特征分类器"></a>Haar特征分类器</h4><p>Haar 特征分类器是一种基于 Haar-like 特征的机器学习方法，用于检测图像中的目标</p>
<p>OpenCV 提供了预训练的 Haar 特征分类器，<code>cv2.CascadeClassifier</code>用于加载分类器，参数是分类器文件的路径</p>
<table>
<thead>
<tr>
<th>模型文件</th>
<th>检测目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>haarcascade_frontalface_default.xml</code></td>
<td>正面人脸</td>
<td>最常用</td>
</tr>
<tr>
<td><code>haarcascade_profileface.xml</code></td>
<td>侧面人脸</td>
<td></td>
</tr>
<tr>
<td><code>haarcascade_eye.xml</code></td>
<td>眼睛检测</td>
<td>需要配合人脸使用</td>
</tr>
<tr>
<td><code>haarcascade_smile.xml</code></td>
<td>微笑检测</td>
<td></td>
</tr>
</tbody></table>
<p>进行人脸检测：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 加载 Haar 特征分类器</span></span><br><span class="line">face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + <span class="string">'haarcascade_frontalface_default.xml'</span>)</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 将帧转换为灰度图像</span></span><br><span class="line">    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 检测人脸</span></span><br><span class="line">    faces = face_cascade.detectMultiScale(</span><br><span class="line">        gray_frame, </span><br><span class="line">        scaleFactor=<span class="number">1.1</span>, </span><br><span class="line">        minNeighbors=<span class="number">5</span>, </span><br><span class="line">        minSize=(<span class="number">30</span>, <span class="number">30</span>))</span><br><span class="line">    <span class="comment"># 在帧上绘制矩形框标记人脸</span></span><br><span class="line">    <span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">        cv2.rectangle(frame, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 显示带有人脸标记的帧</span></span><br><span class="line">    cv2.imshow(<span class="string">'Face Detection'</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<p><code>detectMultiScale</code>会返回所有检测到的矩形框 <code>(x, y, w, h)</code></p>
<ul>
<li><p><code>scaleFactor</code>：表示图像尺寸的缩小比例，&gt;1缩小图像，<font color="Violetred">常用1.1</font></p>
<p>计算方法：缩小比例 = 1 - (1/<code>scaleFactor</code>) </p>
<p><code>scaleFactor=1.1</code> 时，每次缩放后的新尺寸 = 原尺寸×(1/1.1) ≈ 原尺寸×0.909</p>
</li>
<li><p><code>minNeighbors</code>：表示在当前强度中心周围有多少个目标同时检测到才算有效，值越高越严格</p>
</li>
<li><p><code>minSize</code>：最小检测窗口，表示目标的最小尺寸</p>
</li>
</ul>
<p>Haar属于传统CV算法，速度快，适合实时，但检测精度不如深度学习模型，对光照、角度变化不鲁棒</p>
<h4 id="YOLOv5"><a href="#YOLOv5" class="headerlink" title="YOLOv5"></a>YOLOv5</h4><p>相比Haar，Yolov5可同时检测80+类别物体，输出带类别标签的边界框，对部分遮挡、光照变化、背景杂乱有较强鲁棒性，训练后的代码简洁</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="comment"># torch 更新导致会出一些warming，眼不见为净</span></span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>, category=FutureWarning, message=<span class="string">".*torch.cuda.amp.autocast.*"</span>)</span><br><span class="line"><span class="comment"># 加载YOLOv5模型(采用官方训练权重)</span></span><br><span class="line">model = torch.hub.load(<span class="string">'ultralytics/yolov5'</span>, <span class="string">'yolov5s'</span>)</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    results = model(frame)</span><br><span class="line">    <span class="comment">#  渲染结果（模型自带的画框函数）</span></span><br><span class="line">    annotated_frame = results.render()[<span class="number">0</span>]</span><br><span class="line">    cv2.imshow(<span class="string">"YOLOv5 Real Time Detection"</span>, annotated_frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="运动检测"><a href="#运动检测" class="headerlink" title="运动检测"></a>运动检测</h3><h4 id="帧差法"><a href="#帧差法" class="headerlink" title="帧差法"></a>帧差法</h4><p>通过计算帧之间的差异来检测运动物体，最直观</p>
<p>特点：简单，适合物体比较大、背景稳定的场景</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 读取第一帧</span></span><br><span class="line">ret, prev_frame = cap.read()</span><br><span class="line">prev_gray = cv2.cvtColor(prev_frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">prev_gray = cv2.GaussianBlur(prev_gray, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = cv2.GaussianBlur(gray, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 帧差</span></span><br><span class="line">    diff = cv2.absdiff(prev_gray, gray)</span><br><span class="line">    <span class="comment"># 对差异图像进行二值化处理</span></span><br><span class="line">    _, thresh = cv2.threshold(diff, <span class="number">25</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">    <span class="comment"># 膨胀操作，去除噪声</span></span><br><span class="line">    dilated = cv2.dilate(thresh, <span class="literal">None</span>, iterations=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 找轮廓</span></span><br><span class="line">    contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    <span class="comment"># 遍历轮廓进行挑选</span></span><br><span class="line">    <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:</span><br><span class="line">        <span class="keyword">if</span> cv2.contourArea(cnt) &lt; <span class="number">500</span>:  <span class="comment"># 忽略太小的移动</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">        cv2.rectangle(frame, (x, y), (x+w, y+h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    cv2.imshow(<span class="string">"motion detection"</span>, frame)</span><br><span class="line">    prev_gray = gray <span class="comment"># 更新前一帧</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:  <span class="comment"># 按 ESC 退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<h4 id="背景减除法"><a href="#背景减除法" class="headerlink" title="背景减除法"></a>背景减除法</h4><p>背景减除法是一种更为精准和鲁棒的运动检测技术，通过学习视频的静态背景，然后将当前帧与背景模型进行比较，从而识别出前景（即运动的物体），它比帧差法稳定，对光照变化更鲁棒</p>
<p>其基本流程如下：</p>
<ol>
<li>背景建模：通过分析视频序列中的多帧图像，建立一个背景模型</li>
<li>前景检测：将当前帧与背景模型进行比较，找出与背景差异较大的区域，这些区域即为前景对象。</li>
<li>背景更新：随着时间的推移，背景可能会发生变化（如光照变化、背景物体的移动等），因此需要不断更新背景模型</li>
</ol>
<p>OpenCV 提供了多种背景减除算法，其中MOG和MOG2是最常用的两种方法</p>
<p>MOG2是MOG的改进版本，主要区别在于它能够自动选择高斯分布的数量，并且能够更好地适应背景的变化</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgbg = cv2.createBackgroundSubtractorMOG2(history=<span class="number">500</span>, varThreshold=<span class="number">16</span>, detectShadows=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>history</code>：训练的帧数(默认500)，值大表示模型记忆更久，适合稳定场景；值小更灵敏，适合背景经常变化的环境</p>
</li>
<li><p><code>varThreshold</code>：像素和背景模型的阈值(默认 16)</p>
<p>值小 → 更容易检测出前景，但噪声也多；值大 → 只检测明显运动的物体</p>
</li>
<li><p><code>detectShadows</code>：是否检测阴影，默认True，如果只想要前景物体，可以关掉它</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgmask = fgbg.apply(frame)</span><br></pre></td></tr></tbody></table></figure>

<p>输入一帧图像，输出前景掩码(mask)，掩码是单通道图像：背景0，前景255，阴影127</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建背景减除器</span></span><br><span class="line">fgbg = cv2.createBackgroundSubtractorMOG2(history=<span class="number">500</span>, varThreshold=<span class="number">50</span>, detectShadows=<span class="literal">False</span>) <span class="comment"># 这里不要阴影</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 应用背景减除，获得前景掩码</span></span><br><span class="line">    fgmask = fgbg.apply(frame)</span><br><span class="line">    <span class="comment"># 对掩码进行形态学操作，以消除噪声</span></span><br><span class="line">    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">    fgmask = cv2.morphologyEx(fgmask, cv2.MORPH_OPEN, kernel)</span><br><span class="line">    <span class="comment"># 膨胀操作</span></span><br><span class="line">    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">7</span>, <span class="number">7</span>))</span><br><span class="line">    fgmask = cv2.dilate(fgmask, kernel)</span><br><span class="line">    <span class="comment"># 查找轮廓</span></span><br><span class="line">    contours, hierarchy = cv2.findContours(fgmask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    <span class="comment"># 遍历所有轮廓</span></span><br><span class="line">    <span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">        <span class="comment"># 忽略面积过小的轮廓，以减少误报</span></span><br><span class="line">        <span class="keyword">if</span> cv2.contourArea(contour) &lt; <span class="number">500</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 获取轮廓的边界框</span></span><br><span class="line">        (x, y, w, h) = cv2.boundingRect(contour)</span><br><span class="line">        <span class="comment"># 在原始帧上绘制边界框</span></span><br><span class="line">        cv2.rectangle(frame, (x, y), (x+w, y+h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 显示结果</span></span><br><span class="line">    cv2.imshow(<span class="string">'Original Frame'</span>, frame)</span><br><span class="line">    cv2.imshow(<span class="string">'Foreground Mask'</span>, fgmask)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>: <span class="comment"># 按esc退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<p>卷积核大小不同是为了先用最小的代价去除噪声，再用足够的强度来恢复和增强目标</p>
<p>会发现在检测时一个人可能出现多个框，是因为这个算法并不会把人当作一个整体来看待</p>
<p>相比YOLO这只是一种比较简单的低级检测，只会发现哪里在动，不关心这是不是一个整体</p>
<h2 id="车道检测"><a href="#车道检测" class="headerlink" title="车道检测"></a>车道检测</h2><p>无人车上的相机拍摄的视频中，车道线的位置应该基本固定在某一个范围内</p>
<p>手动把这部分 ROI 区域抠出来，就会排除掉大部分干扰</p>
<p>利用霍夫变换检测直线，但 ROI 区域内的边缘直线信息还是很多。考虑到只有左右两条车道线，一条斜率为正，一条为负，可将所有的线分为两组，每组再通过均值或最小二乘法拟合的方式确定唯一一条线就可以完成检测</p>
<p>总体步骤如下：</p>
<ol>
<li>读取视频帧（逐帧处理）</li>
<li>灰度化 + 高斯滤波（降噪）</li>
<li>Canny边缘检测（提取边缘）</li>
<li>定义ROI（只保留车道区域）</li>
<li>霍夫直线变换（检测车道线）</li>
<li>线段拟合与绘制（平滑显示结果）</li>
</ol>
<h3 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义参数</span></span><br><span class="line">blur_ksize = <span class="number">5</span></span><br><span class="line">canny_low = <span class="number">50</span></span><br><span class="line">canny_high = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_img</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="comment"># 灰度化</span></span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    blur = cv2.GaussianBlur(gray, (blur_ksize,blur_ksize), <span class="number">0</span>)</span><br><span class="line">    edges = cv2.Canny(blur, canny_low, canny_high)</span><br><span class="line">    <span class="keyword">return</span> edges</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041350.png" alt="202510041350" style="zoom: 80%;">

<h3 id="ROI截取"><a href="#ROI截取" class="headerlink" title="ROI截取"></a>ROI截取</h3><p>创建一个梯形的 mask 掩膜，然后与边缘检测结果图混合运算</p>
<p>掩膜中白色的部分保留，黑色的部分舍弃</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">roi_mask</span>(<span class="params">img, vertices</span>):</span><br><span class="line">    <span class="comment"># 创建掩膜</span></span><br><span class="line">    mask = np.zeros_like(img)</span><br><span class="line">    cv2.fillPoly(mask, vertices, <span class="number">255</span>)</span><br><span class="line">    masked_image = cv2.bitwise_and(img, mask)</span><br><span class="line">    <span class="keyword">return</span> masked_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义ROI</span></span><br><span class="line">h, w = edges.shape[:<span class="number">2</span>]</span><br><span class="line">roi_vertices = np.array([[(<span class="number">0</span>,h),(<span class="number">460</span>, <span class="number">325</span>), (<span class="number">520</span>, <span class="number">325</span>),(w,h)]])</span><br><span class="line">roi = roi_mask(edges, roi_vertices)</span><br></pre></td></tr></tbody></table></figure>

<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041408.png" alt="202510041408" style="zoom:80%;">

<h3 id="霍夫直线提取"><a href="#霍夫直线提取" class="headerlink" title="霍夫直线提取"></a>霍夫直线提取</h3><p>使用统计概率霍夫直线变换，因为后续还需要处理</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_lines</span>(<span class="params">img, lines, color=[<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>], thickness=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> lines[:,<span class="number">0</span>]:</span><br><span class="line">        cv2.line(img, (x1, y1), (x2, y2), color, thickness)</span><br><span class="line"><span class="comment"># 霍夫变换参数</span></span><br><span class="line">rho = <span class="number">1</span></span><br><span class="line">theta = np.pi / <span class="number">180</span></span><br><span class="line">threshold = <span class="number">15</span></span><br><span class="line">min_line_len = <span class="number">40</span></span><br><span class="line">max_line_gap = <span class="number">20</span></span><br><span class="line">lines = cv2.HoughLinesP(roi, rho, theta, threshold, minLineLength=min_line_len, maxLineGap=max_line_gap)</span><br><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line">draw_lines(drawing, lines)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="车道计算"><a href="#车道计算" class="headerlink" title="车道计算"></a>车道计算</h3><p>前面通过霍夫变换得到了多条直线的起点和终点</p>
<p>目的是通过某种算法只得到左右两条车道线</p>
<ol>
<li><p>根据斜率正负划分某条线是左车道还是右车道<br>$$<br>k = \frac{y_2-y_1}{x_2-x_1}<br>$$<br>左车道斜率小于0，右车道斜率大于0</p>
</li>
<li><p>迭代计算各直线斜率与斜率均值的差，排除掉差值过大的异常数据</p>
</li>
<li><p>最小二乘法拟合左右车道线</p>
<p>Python 中可以直接使用<code>np.polyfit()</code>进行最小二乘法拟合</p>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clean_lines</span>(<span class="params">lines, threshold</span>):</span><br><span class="line">    <span class="comment"># 迭代计算斜率均值，排除掉与差值差异较大的数据</span></span><br><span class="line">    slopes = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="comment"># 规范为一维 4 元素数组</span></span><br><span class="line">        arr = np.array(line).reshape(<span class="number">4</span>)</span><br><span class="line">        x1, y1, x2, y2 = arr</span><br><span class="line">        <span class="keyword">if</span> x2 == x1:</span><br><span class="line">            <span class="comment"># 垂直线略过（避免除零）</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        slope = (y2 - y1) / (x2 - x1)</span><br><span class="line">        slopes.append(slope)</span><br><span class="line">    slopes = np.array(slopes)</span><br><span class="line">    mean_slope = np.mean(slopes)</span><br><span class="line">    mask = np.<span class="built_in">abs</span>(slopes - mean_slope) &lt; threshold</span><br><span class="line">    <span class="comment"># 返回剔除异常值的lines</span></span><br><span class="line">    <span class="keyword">return</span> [line <span class="keyword">for</span> line, sign <span class="keyword">in</span> <span class="built_in">zip</span>(lines, mask) <span class="keyword">if</span> sign]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">least_squares_fit</span>(<span class="params">point_list, ymin, ymax</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> point_list <span class="keyword">or</span> <span class="built_in">len</span>(point_list) &lt; <span class="number">2</span>:   <span class="comment"># 没点或点数太少</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 最小二乘法拟合</span></span><br><span class="line">    x = [p[<span class="number">0</span>] <span class="keyword">for</span> p <span class="keyword">in</span> point_list]</span><br><span class="line">    y = [p[<span class="number">1</span>] <span class="keyword">for</span> p <span class="keyword">in</span> point_list]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># polyfit 第三个参数为拟合多项式的阶数，所以 1 代表线性</span></span><br><span class="line">    fit = np.polyfit(y, x, <span class="number">1</span>)</span><br><span class="line">    fit_fn = np.poly1d(fit)  <span class="comment"># 获取拟合的结果</span></span><br><span class="line">    xmin = <span class="built_in">int</span>(fit_fn(ymin))</span><br><span class="line">    xmax = <span class="built_in">int</span>(fit_fn(ymax))</span><br><span class="line">    <span class="keyword">return</span> [(xmin, ymin), (xmax, ymax)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_lanes</span>(<span class="params">img, lines, color=[<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>], thickness=<span class="number">8</span></span>):</span><br><span class="line">    h = img.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 划分左右车道</span></span><br><span class="line">    left_lines, right_lines = [], []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x2 == x1:  <span class="comment"># 避免垂直线</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            k = (y2 - y1) / (x2 - x1)</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                left_lines.append(line)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_lines.append(line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left_lines <span class="keyword">or</span> <span class="keyword">not</span> right_lines:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清理异常数据</span></span><br><span class="line">    left_lines = clean_lines(left_lines, <span class="number">0.1</span>)</span><br><span class="line">    right_lines = clean_lines(right_lines, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到左右车道线点的集合，拟合直线</span></span><br><span class="line">    left_points = []</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> left_lines:</span><br><span class="line">        x1, y1, x2, y2 = l.reshape(<span class="number">4</span>) <span class="comment"># 不会出现元组报错</span></span><br><span class="line">        left_points.append((x1, y1))</span><br><span class="line">        left_points.append((x2, y2))</span><br><span class="line"></span><br><span class="line">    right_points = []</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> right_lines:</span><br><span class="line">        x1, y1, x2, y2 = l.reshape(<span class="number">4</span>)</span><br><span class="line">        right_points.append((x1, y1))</span><br><span class="line">        right_points.append((x2, y2))</span><br><span class="line">    <span class="comment"># 这里写325是因为之前限制325</span></span><br><span class="line">    left_results = least_squares_fit(left_points, <span class="number">325</span>, h)</span><br><span class="line">    right_results = least_squares_fit(right_points, <span class="number">325</span>, h)</span><br><span class="line">    <span class="keyword">if</span> left_results <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> right_results <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 没法画，直接跳过</span></span><br><span class="line">    <span class="comment"># 注意这里点的顺序（左上 → 左下 → 右下 → 右上）</span></span><br><span class="line">    vtxs = np.array([[left_results[<span class="number">0</span>], left_results[<span class="number">1</span>], right_results[<span class="number">1</span>], right_results[<span class="number">0</span>]]])</span><br><span class="line">    <span class="comment"># 填充车道区域</span></span><br><span class="line">    cv2.fillPoly(img, vtxs, color)</span><br><span class="line">    <span class="comment"># 或者只画车道线</span></span><br><span class="line">    <span class="comment"># cv2.line(img, left_results[0], left_results[1], color, thickness)</span></span><br><span class="line">    <span class="comment"># cv2.line(img, right_results[0], right_results[1], color, thickness)</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="视频处理-1"><a href="#视频处理-1" class="headerlink" title="视频处理"></a>视频处理</h3><p>搞定图以后就是视频帧的提取和合成</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理视频</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">"Lane_Detection/cv2_yellow_lane.mp4"</span>)</span><br><span class="line"><span class="comment"># 视频参数</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'mp4v'</span>)</span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">w = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">h = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">out = cv2.VideoWriter(<span class="string">"Lane_Detection/output.mp4"</span>, fourcc, fps, (w, h))</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 处理帧</span></span><br><span class="line">    result = process_img(frame)</span><br><span class="line">    <span class="comment"># 播放</span></span><br><span class="line">    cv2.imshow(<span class="string">"Lane Detection"</span>, result)</span><br><span class="line">    out.write(result)</span><br><span class="line">    <span class="comment"># 按 esc 退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>

<p>也可以利用Python 的视频编辑包<code>moviepy</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output = <span class="string">'Lane_Detection/output.mp4'</span></span><br><span class="line">clip = VideoFileClip(<span class="string">"Lane_Detection/cv2_yellow_lane.mp4"</span>)</span><br><span class="line">out_clip = clip.fl_image(process_img)</span><br><span class="line">out_clip.write_videofile(output, audio=<span class="literal">False</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="全代码"><a href="#全代码" class="headerlink" title="全代码"></a>全代码</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> moviepy.editor <span class="keyword">import</span> VideoFileClip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数</span></span><br><span class="line">blur_ksize = <span class="number">5</span></span><br><span class="line">canny_low = <span class="number">50</span></span><br><span class="line">canny_high = <span class="number">150</span></span><br><span class="line"><span class="comment"># 霍夫变换参数</span></span><br><span class="line">rho = <span class="number">1</span></span><br><span class="line">theta = np.pi / <span class="number">180</span></span><br><span class="line">threshold = <span class="number">15</span></span><br><span class="line">min_line_len = <span class="number">40</span></span><br><span class="line">max_line_gap = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">roi_mask</span>(<span class="params">img, vertices</span>):</span><br><span class="line">    <span class="comment"># 创建掩膜</span></span><br><span class="line">    mask = np.zeros_like(img)</span><br><span class="line">    cv2.fillPoly(mask, vertices, <span class="number">255</span>)</span><br><span class="line">    masked_image = cv2.bitwise_and(img, mask)</span><br><span class="line">    <span class="keyword">return</span> masked_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_lines</span>(<span class="params">img, lines, color=[<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>], thickness=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> lines[:,<span class="number">0</span>]:</span><br><span class="line">        cv2.line(img, (x1, y1), (x2, y2), color, thickness)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_lines</span>(<span class="params">lines, threshold</span>):</span><br><span class="line">    <span class="comment"># 迭代计算斜率均值，排除掉与差值差异较大的数据</span></span><br><span class="line">    slopes = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="comment"># 规范为一维 4 元素数组</span></span><br><span class="line">        arr = np.array(line).reshape(<span class="number">4</span>)</span><br><span class="line">        x1, y1, x2, y2 = arr</span><br><span class="line">        <span class="keyword">if</span> x2 == x1:</span><br><span class="line">            <span class="comment"># 垂直线略过（避免除零）</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        slope = (y2 - y1) / (x2 - x1)</span><br><span class="line">        slopes.append(slope)</span><br><span class="line">    slopes = np.array(slopes)</span><br><span class="line">    mean_slope = np.mean(slopes)</span><br><span class="line">    mask = np.<span class="built_in">abs</span>(slopes - mean_slope) &lt; threshold</span><br><span class="line">    <span class="comment"># 返回剔除异常值的lines</span></span><br><span class="line">    <span class="keyword">return</span> [line <span class="keyword">for</span> line, sign <span class="keyword">in</span> <span class="built_in">zip</span>(lines, mask) <span class="keyword">if</span> sign]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">least_squares_fit</span>(<span class="params">point_list, ymin, ymax</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> point_list <span class="keyword">or</span> <span class="built_in">len</span>(point_list) &lt; <span class="number">2</span>:   <span class="comment"># 没点或点数太少</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 最小二乘法拟合</span></span><br><span class="line">    x = [p[<span class="number">0</span>] <span class="keyword">for</span> p <span class="keyword">in</span> point_list]</span><br><span class="line">    y = [p[<span class="number">1</span>] <span class="keyword">for</span> p <span class="keyword">in</span> point_list]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># polyfit 第三个参数为拟合多项式的阶数，所以 1 代表线性</span></span><br><span class="line">    fit = np.polyfit(y, x, <span class="number">1</span>)</span><br><span class="line">    fit_fn = np.poly1d(fit)  <span class="comment"># 获取拟合的结果</span></span><br><span class="line">    xmin = <span class="built_in">int</span>(fit_fn(ymin))</span><br><span class="line">    xmax = <span class="built_in">int</span>(fit_fn(ymax))</span><br><span class="line">    <span class="keyword">return</span> [(xmin, ymin), (xmax, ymax)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_lanes</span>(<span class="params">img, lines, color=[<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>], thickness=<span class="number">8</span></span>):</span><br><span class="line">    h = img.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 划分左右车道</span></span><br><span class="line">    left_lines, right_lines = [], []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x2 == x1:  <span class="comment"># 避免垂直线</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            k = (y2 - y1) / (x2 - x1)</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                left_lines.append(line)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_lines.append(line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left_lines <span class="keyword">or</span> <span class="keyword">not</span> right_lines:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清理异常数据</span></span><br><span class="line">    left_lines = clean_lines(left_lines, <span class="number">0.1</span>)</span><br><span class="line">    right_lines = clean_lines(right_lines, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到左右车道线点的集合，拟合直线</span></span><br><span class="line">    left_points = []</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> left_lines:</span><br><span class="line">        x1, y1, x2, y2 = l.reshape(<span class="number">4</span>) <span class="comment"># 不会出现元组报错</span></span><br><span class="line">        left_points.append((x1, y1))</span><br><span class="line">        left_points.append((x2, y2))</span><br><span class="line"></span><br><span class="line">    right_points = []</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> right_lines:</span><br><span class="line">        x1, y1, x2, y2 = l.reshape(<span class="number">4</span>)</span><br><span class="line">        right_points.append((x1, y1))</span><br><span class="line">        right_points.append((x2, y2))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里写325是因为之前限制325</span></span><br><span class="line">    left_results = least_squares_fit(left_points, <span class="number">325</span>, h)</span><br><span class="line">    right_results = least_squares_fit(right_points, <span class="number">325</span>, h)</span><br><span class="line">    <span class="keyword">if</span> left_results <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> right_results <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 没法画，直接跳过</span></span><br><span class="line">    <span class="comment"># 注意这里点的顺序（左上 → 左下 → 右下 → 右上）</span></span><br><span class="line">    vtxs = np.array([[left_results[<span class="number">0</span>], left_results[<span class="number">1</span>], right_results[<span class="number">1</span>], right_results[<span class="number">0</span>]]])</span><br><span class="line">    <span class="comment"># 填充车道区域</span></span><br><span class="line">    cv2.fillPoly(img, vtxs, color)</span><br><span class="line">    <span class="comment"># 或者只画车道线</span></span><br><span class="line">    <span class="comment"># cv2.line(img, left_results[0], left_results[1], color, thickness)</span></span><br><span class="line">    <span class="comment"># cv2.line(img, right_results[0], right_results[1], color, thickness)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_img</span>(<span class="params">img</span>):</span><br><span class="line">    h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 灰度化、滤波和Canny</span></span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    blur = cv2.GaussianBlur(gray, (blur_ksize,blur_ksize), <span class="number">0</span>)</span><br><span class="line">    edges = cv2.Canny(blur, canny_low, canny_high)</span><br><span class="line">    <span class="comment"># 提取ROI</span></span><br><span class="line">    roi_vertices = np.array([[(<span class="number">0</span>,h),(<span class="number">460</span>, <span class="number">325</span>), (<span class="number">520</span>, <span class="number">325</span>),(w,h)]])</span><br><span class="line">    roi = roi_mask(edges, roi_vertices)</span><br><span class="line">    <span class="comment"># 霍夫直线提取</span></span><br><span class="line">    lines = cv2.HoughLinesP(roi, rho, theta, threshold, minLineLength=min_line_len, maxLineGap=max_line_gap)</span><br><span class="line">    <span class="comment"># 车道拟合计算</span></span><br><span class="line">    drawing = np.zeros_like(img)</span><br><span class="line">    draw_lanes(drawing, lines)</span><br><span class="line">    <span class="comment"># 最终将结果合在原图上</span></span><br><span class="line">    result = cv2.addWeighted(img, <span class="number">0.9</span>, drawing, <span class="number">0.4</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 处理图片</span></span><br><span class="line">    <span class="comment"># img = cv2.imread("Lane_Detection/img1.jpg",1)</span></span><br><span class="line">    <span class="comment"># res = process_img(img)</span></span><br><span class="line">    <span class="comment"># cv2.imshow("Lane_Detection", res)</span></span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理视频</span></span><br><span class="line">    cap = cv2.VideoCapture(<span class="string">"Lane_Detection/cv2_yellow_lane.mp4"</span>)</span><br><span class="line">    <span class="comment"># 视频参数</span></span><br><span class="line">    fourcc = cv2.VideoWriter_fourcc(*<span class="string">'mp4v'</span>)</span><br><span class="line">    fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">    w = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">    h = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">    out = cv2.VideoWriter(<span class="string">"Lane_Detection/output.mp4"</span>, fourcc, fps, (w, h))</span><br><span class="line">    <span class="keyword">while</span> cap.isOpened():</span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 处理帧</span></span><br><span class="line">        result = process_img(frame)</span><br><span class="line">        <span class="comment"># 播放</span></span><br><span class="line">        cv2.imshow(<span class="string">"Lane Detection"</span>, result)</span><br><span class="line">        out.write(result)</span><br><span class="line">        <span class="comment"># 按 esc 退出</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    cap.release()</span><br><span class="line">    out.release()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        output = 'Lane_Detection/output.mp4'</span></span><br><span class="line"><span class="string">        clip = VideoFileClip("Lane_Detection/cv2_yellow_lane.mp4")</span></span><br><span class="line"><span class="string">        out_clip = clip.fl_image(process_img)</span></span><br><span class="line"><span class="string">        out_clip.write_videofile(output, audio=False)</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></tbody></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yhblogs.cn">今天睡够了吗</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yhblogs.cn/posts/12373.html">http://yhblogs.cn/posts/12373.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yhblogs.cn" target="_blank">がんばろう</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E2%8C%A8%EF%B8%8Fpython/">⌨️python</a></div><div class="post_share"><div class="social-share" data-image="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-pok5v9.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/29316.html" title="虚拟摄像头构建"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-218x7m_1920x1080.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">虚拟摄像头构建</div></div></a></div><div class="next-post pull-right"><a href="/posts/35959.html" title="python信号处理"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-pokg2e.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python信号处理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/22642.html" title="windows安装ROCm"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/ROCm_logo.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-10</div><div class="title">windows安装ROCm</div></div></a></div><div><a href="/posts/3865533702.html" title="pyqt5简单实践"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071521231.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-28</div><div class="title">pyqt5简单实践</div></div></a></div><div><a href="/posts/35959.html" title="python信号处理"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-pokg2e.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-18</div><div class="title">python信号处理</div></div></a></div><div><a href="/posts/60233.html" title="python基础"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/Python-Logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="title">python基础</div></div></a></div><div><a href="/posts/21309.html" title="卷积神经网络"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/wallhaven-7jpjzv_1280x720.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-23</div><div class="title">卷积神经网络</div></div></a></div><div><a href="/posts/641887854.html" title="基于图片求体积的算法"><img class="cover" src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071528374.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-01</div><div class="title">基于图片求体积的算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/b_2a1aef95f351a5f7ef72eb81e6838fd6.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">今天睡够了吗</div><div class="author-info__description">相遇是最小单位的奇迹</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071549233.webp" target="_blank" title="QQ"><i class="iconfont icon-QQ"></i></a><a class="social-icon" href="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/202206071549234.webp" target="_blank" title="微信"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://space.bilibili.com/277953459?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="https://github.com/YaoHui-Wu06022" target="_blank" title="Github"><i class="iconfont icon-GitHub"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">保持理智，相信明天</div><div class="twopeople"><div class="twopeople"><div class="container" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div> <script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script> <script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script> <script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script> <style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%90%86%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">图像理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="toc-number">2.</span> <span class="toc-text">代码性能评估</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">图像基础操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">3.1.</span> <span class="toc-text">图像矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4"><span class="toc-number">3.2.</span> <span class="toc-text">颜色空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RGB-%E8%B0%83%E8%89%B2%E6%9D%BF"><span class="toc-number">3.2.1.</span> <span class="toc-text">RGB 调色板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">几何变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2"><span class="toc-number">3.3.1.</span> <span class="toc-text">仿射变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE"><span class="toc-number">3.3.2.</span> <span class="toc-text">缩放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC"><span class="toc-number">3.3.3.</span> <span class="toc-text">翻转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB"><span class="toc-number">3.3.4.</span> <span class="toc-text">平移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC"><span class="toc-number">3.3.5.</span> <span class="toc-text">旋转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">图像加减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">3.5.</span> <span class="toc-text">图像位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="toc-number">3.5.1.</span> <span class="toc-text">按位与</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%88%96"><span class="toc-number">3.5.2.</span> <span class="toc-text">按位或</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">图像融合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E5%B0%94%E6%B3%95%E6%B7%B7%E5%90%88-%E5%8A%A0%E6%9D%83%E6%B7%B7%E5%90%88"><span class="toc-number">4.1.</span> <span class="toc-text">阿尔法混合(加权混合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94%E8%9E%8D%E5%90%88"><span class="toc-number">4.2.</span> <span class="toc-text">拉普拉斯金字塔融合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91"><span class="toc-number">5.</span> <span class="toc-text">图像平滑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E5%A1%AB%E5%85%85"><span class="toc-number">5.1.</span> <span class="toc-text">卷积填充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E6%BB%A4%E6%B3%A2"><span class="toc-number">5.2.</span> <span class="toc-text">卷积滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">5.3.</span> <span class="toc-text">均值滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2%F0%9F%94%A5"><span class="toc-number">5.4.</span> <span class="toc-text">高斯滤波🔥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%F0%9F%94%A5"><span class="toc-number">5.5.</span> <span class="toc-text">中值滤波🔥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2"><span class="toc-number">5.6.</span> <span class="toc-text">双边滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%99%AA%E5%A3%B0%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%B6%88%E9%99%A4"><span class="toc-number">5.7.</span> <span class="toc-text">噪声添加与消除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2"><span class="toc-number">6.</span> <span class="toc-text">阈值分割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2"><span class="toc-number">6.1.</span> <span class="toc-text">固定阈值分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC"><span class="toc-number">6.2.</span> <span class="toc-text">自适应阈值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Otsu%E2%80%99s%E9%98%88%E5%80%BC"><span class="toc-number">6.3.</span> <span class="toc-text">Otsu’s阈值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">7.</span> <span class="toc-text">边缘检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">数值转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sobel%E7%AE%97%E5%AD%90"><span class="toc-number">7.2.</span> <span class="toc-text">Sobel算子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scharr%E7%AE%97%E5%AD%90"><span class="toc-number">7.3.</span> <span class="toc-text">Scharr算子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Laplacian%E7%AE%97%E5%AD%90"><span class="toc-number">7.4.</span> <span class="toc-text">Laplacian算子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%F0%9F%94%A5"><span class="toc-number">7.5.</span> <span class="toc-text">Canny边缘检测🔥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%BB%91%E5%8A%A8%E6%9D%A1"><span class="toc-number">7.5.1.</span> <span class="toc-text">创建滑动条</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC%E8%AE%BE%E7%BD%AE"><span class="toc-number">7.5.2.</span> <span class="toc-text">自适应阈值设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Otsu%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E9%98%88%E5%80%BC"><span class="toc-number">7.5.3.</span> <span class="toc-text">Otsu计算最佳阈值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">7.6.</span> <span class="toc-text">实时边缘检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E6%80%81%E5%8F%98%E6%8D%A2"><span class="toc-number">8.</span> <span class="toc-text">形态变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%85%90%E8%9A%80"><span class="toc-number">8.1.</span> <span class="toc-text">腐蚀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%86%A8%E8%83%80"><span class="toc-number">8.2.</span> <span class="toc-text">膨胀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E8%BF%90%E7%AE%97"><span class="toc-number">8.3.</span> <span class="toc-text">开运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E8%BF%90%E7%AE%97"><span class="toc-number">8.4.</span> <span class="toc-text">闭运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E6%A2%AF%E5%BA%A6"><span class="toc-number">8.5.</span> <span class="toc-text">形态学梯度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">小总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93"><span class="toc-number">10.</span> <span class="toc-text">图像轮廓</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E8%BD%AE%E5%BB%93"><span class="toc-number">10.1.</span> <span class="toc-text">寻找轮廓</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E8%BD%AE%E5%BB%93"><span class="toc-number">10.2.</span> <span class="toc-text">绘制轮廓</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81"><span class="toc-number">10.3.</span> <span class="toc-text">轮廓特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E7%9F%A9%E5%BD%A2"><span class="toc-number">10.3.1.</span> <span class="toc-text">边界矩形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%A4%96%E6%8E%A5%E7%9F%A9%E5%BD%A2"><span class="toc-number">10.3.2.</span> <span class="toc-text">最小外接矩形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%A4%96%E6%8E%A5%E5%9C%86"><span class="toc-number">10.3.3.</span> <span class="toc-text">最小外接圆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A4%AD%E5%9C%86%E6%8B%9F%E5%90%88"><span class="toc-number">10.3.4.</span> <span class="toc-text">椭圆拟合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%80%BC%E8%BF%91"><span class="toc-number">10.3.5.</span> <span class="toc-text">多边形逼近</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%B8%E5%8C%85"><span class="toc-number">10.3.6.</span> <span class="toc-text">凸包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E5%BB%93%E5%B1%9E%E6%80%A7"><span class="toc-number">10.4.</span> <span class="toc-text">轮廓属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B-%E6%95%B0%E7%A1%AC%E5%B8%81"><span class="toc-number">10.5.</span> <span class="toc-text">简单案例(数硬币)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E7%8A%B6%E5%8C%B9%E9%85%8D"><span class="toc-number">10.6.</span> <span class="toc-text">形状匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE"><span class="toc-number">11.</span> <span class="toc-text">直方图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%9B%B4%E6%96%B9%E5%9B%BE"><span class="toc-number">11.1.</span> <span class="toc-text">计算直方图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E7%9B%B4%E6%96%B9%E5%9B%BE"><span class="toc-number">11.2.</span> <span class="toc-text">绘制直方图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96"><span class="toc-number">11.3.</span> <span class="toc-text">直方图均衡化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%9D%87%E8%A1%A1%E5%8C%96"><span class="toc-number">11.4.</span> <span class="toc-text">自适应均衡化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%AF%94%E8%BE%83"><span class="toc-number">11.5.</span> <span class="toc-text">直方图比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D"><span class="toc-number">12.</span> <span class="toc-text">模板匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%89%A9%E4%BD%93%E5%8C%B9%E9%85%8D"><span class="toc-number">12.1.</span> <span class="toc-text">多物体匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5"><span class="toc-number">13.</span> <span class="toc-text">图像拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%BB%A4%E9%95%9C"><span class="toc-number">14.</span> <span class="toc-text">简单滤镜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%80%E6%97%A7%E6%BB%A4%E9%95%9C"><span class="toc-number">14.1.</span> <span class="toc-text">怀旧滤镜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E9%9B%95%E6%BB%A4%E9%95%9C"><span class="toc-number">14.2.</span> <span class="toc-text">浮雕滤镜</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2"><span class="toc-number">15.</span> <span class="toc-text">霍夫变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2"><span class="toc-number">15.1.</span> <span class="toc-text">霍夫直线变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E5%9C%86%E5%8F%98%E6%8D%A2"><span class="toc-number">15.2.</span> <span class="toc-text">霍夫圆变换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">视频处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E8%AF%BB%E5%8F%96"><span class="toc-number">16.1.</span> <span class="toc-text">视频读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E5%B8%A7%E5%A4%84%E7%90%86"><span class="toc-number">16.2.</span> <span class="toc-text">视频帧处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B"><span class="toc-number">16.3.</span> <span class="toc-text">物体检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Haar%E7%89%B9%E5%BE%81%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-number">16.3.1.</span> <span class="toc-text">Haar特征分类器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#YOLOv5"><span class="toc-number">16.3.2.</span> <span class="toc-text">YOLOv5</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E5%8A%A8%E6%A3%80%E6%B5%8B"><span class="toc-number">16.4.</span> <span class="toc-text">运动检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A7%E5%B7%AE%E6%B3%95"><span class="toc-number">16.4.1.</span> <span class="toc-text">帧差法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E5%87%8F%E9%99%A4%E6%B3%95"><span class="toc-number">16.4.2.</span> <span class="toc-text">背景减除法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%A6%E9%81%93%E6%A3%80%E6%B5%8B"><span class="toc-number">17.</span> <span class="toc-text">车道检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">17.1.</span> <span class="toc-text">图像预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ROI%E6%88%AA%E5%8F%96"><span class="toc-number">17.2.</span> <span class="toc-text">ROI截取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E6%8F%90%E5%8F%96"><span class="toc-number">17.3.</span> <span class="toc-text">霍夫直线提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%A6%E9%81%93%E8%AE%A1%E7%AE%97"><span class="toc-number">17.4.</span> <span class="toc-text">车道计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86-1"><span class="toc-number">17.5.</span> <span class="toc-text">视频处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">17.6.</span> <span class="toc-text">全代码</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2022 - 2025 By 今天睡够了吗</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">You must always have faith in who you are！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>