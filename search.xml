<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机视觉</title>
      <link href="/posts/62963.html"/>
      <url>/posts/62963.html</url>
      
        <content type="html"><![CDATA[<h2 id="图像增广"><a href="#图像增广" class="headerlink" title="图像增广"></a>图像增广</h2><p>在卷积神经网络提到大型数据集是成功应用深度神经网络的先决条件</p><p>图像增广在对训练图像进行一系列的随机变化之后，生成相似但不同的训练样本，从而扩大了训练集的规模</p><p>应用图像增广的原因是，随机改变训练样本可以减少模型对某些属性的依赖，从而提高模型的泛化能力，例如可以以不同的方式裁剪图像，使感兴趣的对象出现在不同的位置，减少模型对于对象出现位置的依赖；还可以调整亮度、颜色等因素来降低模型对颜色的敏感度</p><p><strong>图像增广技术对于AlexNet的成功是必不可少的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision <span class="comment"># 图像数据 + 图像模型 + 图像处理</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms <span class="comment"># 图像数据预处理与增强</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets <span class="comment"># 数据集</span></span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data  <span class="comment"># 数据加载接口</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>在对常用图像增广方法的探索时，将使用下面这个尺寸为400×500的图像作为示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;imgs/cat1.jpg&#x27;</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/cat1.webp" alt="cat1" style="zoom: 50%;" /><p>大多数图像增广方法都具有一定的随机性</p><p>定义辅助函数<code>apply</code>，此函数在输入图像<code>img</code>上多次运行图像增广方法<code>aug</code>并显示所有结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_images</span>(<span class="params">imgs, num_rows, num_cols, titles=<span class="literal">None</span>, scale=<span class="number">1.5</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Plot a list of images.&quot;&quot;&quot;</span></span><br><span class="line">    figsize = (num_cols * scale, num_rows * scale)</span><br><span class="line">    _, axes = plt.subplots(num_rows, num_cols, figsize=figsize)</span><br><span class="line">    axes = axes.flatten()  <span class="comment"># 把子图对象展开成一维列表方便索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, (ax, img) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axes, imgs)):</span><br><span class="line">        <span class="keyword">if</span> torch.is_tensor(img):  <span class="comment"># 如果是张量，就转为numpy</span></span><br><span class="line">            img = img.detach().numpy()</span><br><span class="line">        ax.imshow(img)</span><br><span class="line">        ax.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> titles:</span><br><span class="line">            ax.set_title(titles[i])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply</span>(<span class="params">img, aug, num_rows=<span class="number">2</span>, num_cols=<span class="number">4</span>, scale=<span class="number">1.5</span></span>):</span><br><span class="line">    <span class="comment"># aug: 增强操作对象(transform)</span></span><br><span class="line">    Y = [aug(img) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_rows * num_cols)]</span><br><span class="line">    show_images(Y, num_rows, num_cols, scale=scale)</span><br></pre></td></tr></table></figure><h4 id="翻转和裁剪"><a href="#翻转和裁剪" class="headerlink" title="翻转和裁剪"></a>翻转和裁剪</h4><p>左右翻转图像通常不会改变对象的类别，这是最早且最广泛使用的图像增广方法之一</p><p>使用<code>transforms</code>模块来创建<code>RandomFlipLeftRight</code>实例，这样就各有50%的几率使图像向左或向右翻转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply(img, transforms.RandomHorizontalFlip())</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202511012052.webp" alt="202511012052" style="zoom:80%;" /><p>上下翻转图像不如左右图像翻转那样常用，至少对于这个图像，上下翻转不会妨碍识别</p><p>创建一个<code>RandomFlipTopBottom</code>实例，使图像各有50%的几率向上或向下翻转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply(img, transforms.RandomVerticalFlip())</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202511012056.webp" alt="202511012056" style="zoom:80%;" /><p>示例图片中猫位于图片的中间，但并非所有图片都是这样，汇聚层可以降低卷积层对目标位置的敏感性，另外也可以通过对图像进行随机裁剪，使物体以不同的比例出现在图像的不同位置，也可以降低模型对目标位置的敏感性</p><p>随机裁剪的区域面积占原始面积的10%到100%，该区域的宽高比从0.5～2之间随机取值，然后区域的宽度和高度都被缩放到200像素</p><blockquote><p>正常都是取均匀分布，除非另外说明</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shape_aug = transforms.RandomResizedCrop(</span><br><span class="line">    (<span class="number">200</span>, <span class="number">200</span>), scale=(<span class="number">0.1</span>, <span class="number">1</span>), ratio=(<span class="number">0.5</span>, <span class="number">2</span>))</span><br><span class="line">apply(img, shape_aug)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202511012107.webp" alt="202511012107" style="zoom:80%;" /><h4 id="改变颜色"><a href="#改变颜色" class="headerlink" title="改变颜色"></a>改变颜色</h4><p>另一种增广方法是改变颜色，可以改变图像颜色的四个方面：亮度、对比度、饱和度和色相</p><p>在下面的代码中随机更改图像的亮度，随机值为原始图像的50%-150%</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply(img, transforms.ColorJitter(</span><br><span class="line">    brightness=<span class="number">0.5</span>, contrast=<span class="number">0</span>, saturation=<span class="number">0</span>, hue=<span class="number">0</span></span><br><span class="line">))</span><br><span class="line"><span class="comment"># 范围为[max(0, 1 - x), 1 + x]，或者直接输入元组指定(min, max)</span></span><br><span class="line"><span class="comment"># 四个参数的设定方法都是一样的</span></span><br></pre></td></tr></table></figure><p>但是一般都是处理灰度图片，所以主要调整亮度</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202511012114.webp" alt="202511012114" style="zoom:80%;" /><p>如果同时更改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color_aug = transforms.ColorJitter(</span><br><span class="line">    brightness=<span class="number">0.5</span>, contrast=<span class="number">0.5</span>, saturation=<span class="number">0.5</span>, hue=<span class="number">0.5</span>)</span><br><span class="line">apply(img, color_aug)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202511012115.webp" alt="202511012115" style="zoom:80%;" /><h4 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h4><p>在实践中将结合多种图像增广方法，可以通过使用一个<code>Compose</code>实例来综合上面定义的不同的图像增广方法，并将它们应用到每个图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">augs = transforms.Compose([</span><br><span class="line">    transforms.RandomHorizontalFlip(),</span><br><span class="line">    color_aug,</span><br><span class="line">    shape_aug])</span><br><span class="line">apply(img, augs)</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>使用图像增广来训练模型，这里使用CIFAR-10数据集，而不是之前使用的Fashion-MNIST数据集，这是因为Fashion-MNIST数据集中对象的位置和大小已被规范化，而CIFAR-10数据集中对象的颜色和大小差异更明显</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all_images = datasets.CIFAR10(root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>)</span><br><span class="line">show_images([all_images[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)], <span class="number">4</span>, <span class="number">8</span>, scale=<span class="number">0.8</span>);</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202511012145.webp" alt="202511012145" style="zoom:80%;" /><p>为了保证预测结果稳定，只在训练阶段使用图像增广，预测时不进行随机增广操作</p><p>在这里只使用最简单的随机左右翻转，使用<code>ToTensor</code>实例将一批图像转换为深度学习框架所要求的格式，即形状为（批量大小，通道数，高度，宽度）的32位浮点数，取值范围为0～1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">train_augs = transforms.Compose([</span><br><span class="line">    transforms.RandomHorizontalFlip(),</span><br><span class="line">    transforms.ToTensor()])</span><br><span class="line"></span><br><span class="line">test_augs = transforms.Compose([</span><br><span class="line">    transforms.ToTensor()])</span><br></pre></td></tr></table></figure><p>定义一个辅助函数，以便于读取图像和应用图像增广</p><p>PyTorch数据集提供的<code>transform</code>参数应用图像增广来转化图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_cifar10</span>(<span class="params">is_train, augs, batch_size</span>):</span><br><span class="line">    dataset = datasets.CIFAR10(</span><br><span class="line">        root=<span class="string">&quot;../data&quot;</span>,   <span class="comment"># 数据保存的路径</span></span><br><span class="line">        train=is_train,   <span class="comment"># 是否加载训练集（True）或测试集（False）</span></span><br><span class="line">        transform=augs,   <span class="comment"># 对图像进行的预处理</span></span><br><span class="line">        download=<span class="literal">True</span>     <span class="comment"># 若本地无数据则自动下载</span></span><br><span class="line">    )</span><br><span class="line">    dataloader = data.DataLoader(dataset, batch_size=batch_size,</span><br><span class="line">                    shuffle=is_train, num_workers=get_dataloader_workers())</span><br><span class="line">    <span class="keyword">return</span> dataloader</span><br></pre></td></tr></table></figure><p><code>data.DataLoader</code>：</p><ul><li><code>dataset</code>：加载的数据集</li><li><code>batch_size</code>：每次从数据集中取多少个样本组成一个 batch</li><li><code>shuffle</code>：是否在每个 epoch 开始前随机打乱数据，训练一般True</li><li><code>num_workers</code>：并行加载数据的子进程数</li></ul><h4 id="多GPU训练"><a href="#多GPU训练" class="headerlink" title="多GPU训练"></a>多GPU训练</h4><p>在CIFAR-10数据集上训练ResNet-18模型，需要利用多GPU实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_batch_ch13</span>(<span class="params">net, X, y, loss, trainer, devices</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用多GPU进行小批量训练&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(X, <span class="built_in">list</span>):  <span class="comment"># 如果X是多个张量输入，比如文本</span></span><br><span class="line">        X = [x.to(devices[<span class="number">0</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        X = X.to(devices[<span class="number">0</span>]) <span class="comment"># 普通图像任务：单个张量</span></span><br><span class="line">    y = y.to(devices[<span class="number">0</span>])</span><br><span class="line">    net.train()              <span class="comment"># 切换到训练模式</span></span><br><span class="line">    trainer.zero_grad()      <span class="comment"># 清空上一轮的梯度</span></span><br><span class="line">    pred = net(X)            <span class="comment"># 前向计算，得到预测</span></span><br><span class="line">    l = loss(pred, y)</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()       <span class="comment"># 对所有 GPU 上的损失求和后反向传播</span></span><br><span class="line">    trainer.step()           <span class="comment"># 参数更新</span></span><br><span class="line">    train_loss_sum = l.<span class="built_in">sum</span>()</span><br><span class="line">    train_acc_sum = accuracy(pred, y)</span><br><span class="line">    <span class="keyword">return</span> train_loss_sum, train_acc_sum</span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_ch13</span>(<span class="params">net, train_iter, test_iter, loss, trainer, num_epochs,</span></span><br><span class="line"><span class="params">               devices=try_all_gpus(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用多GPU进行模型训练&quot;&quot;&quot;</span></span><br><span class="line">    timer, num_batches = Timer(), <span class="built_in">len</span>(train_iter)</span><br><span class="line">    animator = Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], ylim=[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                            legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">    <span class="comment"># 把网络包装成多 GPU 模型</span></span><br><span class="line">    net = nn.DataParallel(net, device_ids=devices).to(devices[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="comment"># 4个维度：储存训练损失，训练准确度，实例数，特点数</span></span><br><span class="line">        metric = Accumulator(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> i, (features, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):</span><br><span class="line">            timer.start()</span><br><span class="line">            l, acc = train_batch_ch13(</span><br><span class="line">                net, features, labels, loss, trainer, devices)</span><br><span class="line">            metric.add(l, acc, labels.shape[<span class="number">0</span>], labels.numel())</span><br><span class="line">            timer.stop()</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">                animator.add(epoch + (i + <span class="number">1</span>) / num_batches,</span><br><span class="line">                             (metric[<span class="number">0</span>] / metric[<span class="number">2</span>], metric[<span class="number">1</span>] / metric[<span class="number">3</span>],</span><br><span class="line">                              <span class="literal">None</span>))</span><br><span class="line">        test_acc = evaluate_accuracy_gpu(net, test_iter)</span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, test_acc))</span><br><span class="line">    animator.show()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;loss <span class="subst">&#123;metric[<span class="number">0</span>] / metric[<span class="number">2</span>]:<span class="number">.3</span>f&#125;</span>, train acc &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;<span class="subst">&#123;metric[<span class="number">1</span>] / metric[<span class="number">3</span>]:<span class="number">.3</span>f&#125;</span>, test acc <span class="subst">&#123;test_acc:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;metric[<span class="number">2</span>] * num_epochs / timer.<span class="built_in">sum</span>():<span class="number">.1</span>f&#125;</span> examples/sec on &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(devices)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>自定义resnet18网络，把第一层改为3×3卷积层，因为cifar10的图片不是224，也是32×32，如果保持7×7会出问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本残差块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residual</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels, out_channels, use_1x1conv=<span class="literal">False</span>, stride=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=<span class="number">3</span>,</span><br><span class="line">                               padding=<span class="number">1</span>, stride=stride)</span><br><span class="line">        <span class="variable language_">self</span>.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">3</span>,</span><br><span class="line">                               padding=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            <span class="comment"># 当通道数不匹配时，用 1x1 卷积调整维度</span></span><br><span class="line">            <span class="variable language_">self</span>.conv3 = nn.Conv2d(in_channels, out_channels,</span><br><span class="line">                                   kernel_size=<span class="number">1</span>, stride=stride)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.conv3 = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.bn1 = nn.BatchNorm2d(out_channels)</span><br><span class="line">        <span class="variable language_">self</span>.bn2 = nn.BatchNorm2d(out_channels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        Y = nn.functional.relu(<span class="variable language_">self</span>.bn1(<span class="variable language_">self</span>.conv1(X)))</span><br><span class="line">        Y = <span class="variable language_">self</span>.bn2(<span class="variable language_">self</span>.conv2(Y))</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.conv3:</span><br><span class="line">            X = <span class="variable language_">self</span>.conv3(X)</span><br><span class="line">        Y += X</span><br><span class="line">        <span class="keyword">return</span> nn.functional.relu(Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ResNet-18主体</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resnet_block</span>(<span class="params">in_channels, out_channels, num_residuals, first_block=<span class="literal">False</span></span>):</span><br><span class="line">    blk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block:</span><br><span class="line">            blk.append(Residual(in_channels, out_channels,</span><br><span class="line">                                use_1x1conv=<span class="literal">True</span>, stride=<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            blk.append(Residual(out_channels, out_channels))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resnet18</span>(<span class="params">num_classes, in_channels=<span class="number">3</span></span>):</span><br><span class="line">    <span class="comment"># 输入层</span></span><br><span class="line">    net = nn.Sequential(</span><br><span class="line">        nn.Conv2d(in_channels, <span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">3</span>), <span class="comment"># 这里给改小了，因为图片尺寸小</span></span><br><span class="line">        nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 四个阶段，每个阶段通道数分别是 64, 128, 256, 512</span></span><br><span class="line">    net.add_module(<span class="string">&quot;resnet_block1&quot;</span>, nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>)))</span><br><span class="line">    net.add_module(<span class="string">&quot;resnet_block2&quot;</span>, nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>)))</span><br><span class="line">    net.add_module(<span class="string">&quot;resnet_block3&quot;</span>, nn.Sequential(*resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>)))</span><br><span class="line">    net.add_module(<span class="string">&quot;resnet_block4&quot;</span>, nn.Sequential(*resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局平均池化 + 全连接层</span></span><br><span class="line">    net.add_module(<span class="string">&quot;global_avg_pool&quot;</span>, nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">    net.add_module(<span class="string">&quot;fc&quot;</span>, nn.Sequential(nn.Flatten(), nn.Linear(<span class="number">512</span>, num_classes)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><p>可以定义<code>train_with_data_aug</code>函数，使用图像增广来训练模型</p><p>该函数获取所有的GPU，并使用Adam作为训练的优化算法，将图像增广应用于训练集，最后调用刚刚定义的用于训练和评估模型的<code>train_ch13</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置批量大小、设备列表和网络结构</span></span><br><span class="line">batch_size, devices, net = <span class="number">256</span>, try_all_gpus(), resnet18(<span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 定义权重初始化函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="comment"># 只对线性层和卷积层进行 Xavier 初始化</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) <span class="keyword">in</span> [nn.Linear, nn.Conv2d]:</span><br><span class="line">        nn.init.xavier_uniform_(m.weight)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_with_data_aug</span>(<span class="params">train_augs, test_augs, net, lr=<span class="number">0.001</span></span>):</span><br><span class="line">    <span class="comment"># 加载 CIFAR-10 数据集</span></span><br><span class="line">    train_iter = load_cifar10(<span class="literal">True</span>, train_augs, batch_size)</span><br><span class="line">    test_iter = load_cifar10(<span class="literal">False</span>, test_augs, batch_size)</span><br><span class="line">    <span class="comment"># 定义损失函数（交叉熵损失）</span></span><br><span class="line">    loss = nn.CrossEntropyLoss(reduction=<span class="string">&quot;none&quot;</span>)</span><br><span class="line">    <span class="comment"># 定义优化器，这里使用 Adam，自适应学习率算法</span></span><br><span class="line">    trainer = torch.optim.Adam(net.parameters(), lr=lr)</span><br><span class="line">    train_ch13(net, train_iter, test_iter, loss, trainer, <span class="number">10</span>, devices)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202511012257.webp" alt="202511012257" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.214, train acc 0.926, test acc 0.799</span><br><span class="line">3231.1 examples/sec on [device(type=&#x27;cuda&#x27;, index=0)]</span><br></pre></td></tr></table></figure><p>这里仅使用随机左右翻转的图像增广来训练模型</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>图像增广基于现有的训练数据生成随机图像，来提高模型的泛化能力</li><li>为了在预测过程中得到确切的结果，通常对训练样本只进行图像增广，而在预测过程中不使用带随机操作的图像增广</li><li>深度学习框架提供了许多不同的图像增广方法，这些方法可以被同时应用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环神经网络</title>
      <link href="/posts/7224.html"/>
      <url>/posts/7224.html</url>
      
        <content type="html"><![CDATA[<p>到目前为止遇到过两种类型的数据：表格数据和图像数据</p><p>卷积神经网络可以有效地处理空间信息，**循环神经网络(recurrent neural network，RNN)**则可以更好地处理序列信息，循环神经网络通过引入状态变量存储过去的信息和当前的输入，从而可以确定当前的输出</p><p>许多使用循环网络的例子都是基于文本数据的，因此将在本章中重点介绍语言模型</p><h2 id="序列模型"><a href="#序列模型" class="headerlink" title="序列模型"></a>序列模型</h2><p>**序列模型(Sequence Model)**是一类能够处理序列数据的模型，可以理解“顺序”这个维度的信息</p><p>比如：</p><ul><li>一段文字(词语或字母按顺序组成句子)</li><li>一段语音(声音信号是随时间变化的)</li><li>股票价格(每天的数据有先后关系)</li><li>传感器时间序列(如心率随时间的变化)</li></ul><h3 id="统计工具"><a href="#统计工具" class="headerlink" title="统计工具"></a>统计工具</h3><p>处理序列数据需要统计工具和新的深度神经网络架构，以下图所示的股票价格(富时100指数)为例</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/ftse100.png" alt="ftse100" style="zoom: 50%;" /><p>其中，用$x_t$表示价格，即在<strong>时间步(time step)</strong>$t \in \mathbb{Z}^+$时，观察到的价格</p><p>假设一个交易员想在$t$日的股市中表现良好，于是通过以下途径预测$x_t$<br>$$<br>x_t \sim P(x_t \mid x_{t-1}, \ldots, x_1).<br>$$</p><h4 id="自回归模型"><a href="#自回归模型" class="headerlink" title="自回归模型"></a>自回归模型</h4><p>为了实现这个预测，交易员可以使用回归模型(如线性回归)，但会出现一个问题，输入$x_{t-1}, \ldots, x_1$本身因$t$而异，输入数据的数量会随着时间变化，输入维度不断增加，因此需要一种近似方法来简化计算</p><p>主要两种策略：</p><ul><li><p>策略一，序列考虑最近长度为$\tau$的时间范围，这使得模型的参数量保持不变，便于训练一个类似之前的深度网络，这种模型被称为<strong>自回归模型(autoregressive models)</strong>，因为它是对自身过去的数据进行回归</p></li><li><p>策略二，保留对过去观测的总结$h_t$，在每一步同时更新预测$\hat x_t &#x3D; P(x_t \mid h_t)$和总结$h_t &#x3D; g(h_{t-1}, x_{t-1})$，由于$h_t$不可直接观测，这种模型被称为<strong>隐变量自回归模型(latent autoregressive models)</strong></p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/sequence-model.jpg" alt="sequence-model"></p></li></ul><p>但问题是训练数据如何生成，通常用历史观测来预测下一个时刻的值</p><p>一个常见的假设是：虽然$x_t$会变化，但序列的动力学特性保持不变。这个假设是合理的，因为新的动力学只能由新数据决定，而无法用已有数据预测它</p><p>统计学上，这种动力学不变的性质被称为<strong>平稳性(stationarity)</strong>，因此整个序列的估计值都将通过以下的方式获得：<br>$$<br>P(x_1, \ldots, x_T) &#x3D; \prod_{t&#x3D;1}^T P(x_t \mid x_{t-1}, \ldots, x_1).<br>$$<br>如果处理的是离散的对象(如单词)而不是连续的数字，则上述的考虑仍然有效，唯一的差别是，对于离散的对象需要使用分类器而不是回归模型来估计$P(x_t \mid x_{t-1}, \ldots, x_1)$</p><h4 id="马尔可夫模型"><a href="#马尔可夫模型" class="headerlink" title="马尔可夫模型"></a>马尔可夫模型</h4><p>在自回归模型的近似法中使用$x_{t-1}, \ldots, x_{t-\tau}$而不是$x_{t-1}, \ldots, x_1$来估计$x_t$</p><p><strong>马尔可夫性(Markov condition)</strong>：未来只与现在有关，与过去无关，当前状态包含了预测未来所需的全部信息$P(x_{t+1} \mid x_t, x_{t-1}) &#x3D; P(x_{t+1} \mid x_t)$</p><p>在估计当前状态时，只需要知道前一个状态而不用关心更久以前的状态</p><p>如果$\tau &#x3D; 1$，得到<strong>一阶马尔可夫模型(first-order Markov model)</strong></p><p>序列的联合概率可以写成<br>$$<br>P(x_1, \ldots, x_T) &#x3D; \prod_{t&#x3D;1}^T P(x_t \mid x_{t-1}) \text{ 当 } P(x_1 \mid x_0) &#x3D; P(x_1).<br>$$<br>当$x_t$是离散值时，可以利用动态规划沿着**马尔可夫链(Markov chain)**精确地计算出结果，“链”指的就是状态之间一步步转移的关系</p><p>例如可以高效地计算$P(x_{t+1} \mid x_{t-1})$<br>$$<br>\begin{split}\begin{aligned}<br>P(x_{t+1} \mid x_{t-1})<br>&amp;&#x3D; \frac{\sum_{x_t} P(x_{t+1}, x_t, x_{t-1})}{P(x_{t-1})}\\<br>&amp;&#x3D; \frac{\sum_{x_t} P(x_{t+1} \mid x_t, x_{t-1}) P(x_t, x_{t-1})}{P(x_{t-1})}\\<br>&amp;&#x3D; \sum_{x_t} P(x_{t+1} \mid x_t) P(x_t \mid x_{t-1})<br>\end{aligned}\end{split}<br>$$<br>可以通过中间状态$x_t$把两个相邻状态之间的概率联系起来</p><p>在隐马尔可夫模型中，动态规划能高效地计算这些概率</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>使用正弦函数和一些可加性噪声来生成序列数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T = <span class="number">1000</span>  <span class="comment"># 总共产生1000个点</span></span><br><span class="line">time = torch.arange(<span class="number">1</span>, T + <span class="number">1</span>, dtype=torch.float32)</span><br><span class="line">x = torch.sin(<span class="number">0.01</span> * time) + torch.normal(<span class="number">0</span>, <span class="number">0.2</span>, (T,))</span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">plt.plot(time, x)</span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><p>将这个序列转换为模型的特征－标签对</p><p>将数据映射为数据对$y_t &#x3D; x_t$和$\mathbf{x}<em>t &#x3D; [x</em>{t-\tau}, \ldots, x_{t-1}]$，比提供的数据样本少了$\tau$个</p><p>对于前$\tau$个的解决方案：如果拥有足够长的序列就丢弃这几项；或是用零填充序列</p><p>仅使用前600个“特征－标签”对进行训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tau = <span class="number">4</span></span><br><span class="line">features = torch.zeros((T - tau, tau)) <span class="comment"># 构建特征张量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tau):</span><br><span class="line">    features[:, i] = x[i: T - tau + i] <span class="comment"># 列填充feature</span></span><br><span class="line">labels = x[tau:].reshape((-<span class="number">1</span>, <span class="number">1</span>)) <span class="comment"># 标签从tau开始</span></span><br><span class="line"></span><br><span class="line">batch_size, n_train = <span class="number">16</span>, <span class="number">600</span></span><br><span class="line"><span class="comment"># 只有前n_train个样本用于训练</span></span><br><span class="line">train_iter = load_array((features[:n_train], labels[:n_train]),</span><br><span class="line">                            batch_size, is_train=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>使用一个相当简单的架构训练模型：一个拥有两个全连接层的多层感知机，ReLU激活函数和平方损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化网络权重的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">        nn.init.xavier_uniform_(m.weight)  <span class="comment"># 对应ReLU激活</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个简单的多层感知机</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_net</span>():</span><br><span class="line">    net = nn.Sequential(</span><br><span class="line">        nn.Linear(<span class="number">4</span>,<span class="number">10</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Linear(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    net.apply(init_weights)</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="comment"># MSELoss计算平方误差时不带系数1/2</span></span><br><span class="line">loss = nn.MSELoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure><p>训练代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net, train_iter, loss, epochs, lr</span>):</span><br><span class="line">    trainer = torch.optim.Adam(net.parameters(), lr=lr) <span class="comment"># 这里不再用SGD了</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            trainer.zero_grad()</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            l.<span class="built_in">sum</span>().backward()</span><br><span class="line">            trainer.step()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;epoch <span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>, loss: <span class="subst">&#123;evaluate_loss(net, train_iter, loss):f&#125;</span>&quot;</span>)</span><br><span class="line">net = get_net()</span><br><span class="line">train(net, train_iter, loss, <span class="number">5</span>, <span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Adam比SGD更智能，自动调整学习率步子大小，更适用于自然语言处理</p><p>SGD一般用在图像分类，在后期泛化更好</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epoch 1, loss: 0.072635</span><br><span class="line">epoch 2, loss: 0.060879</span><br><span class="line">epoch 3, loss: 0.056276</span><br><span class="line">epoch 4, loss: 0.059151</span><br><span class="line">epoch 5, loss: 0.053477</span><br></pre></td></tr></table></figure><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>由于训练损失很小，因此期望模型能有很好的工作效果</p><p>首先是检查模型预测下一个时间步的能力，也就是<strong>单步预测(one-step-ahead prediction)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onestep_preds = net(features)</span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">plt.plot(time, x.detach().numpy(), label=<span class="string">&quot;data&quot;</span>)</span><br><span class="line">plt.plot(time[tau:], onestep_preds.detach().numpy(),label=<span class="string">&quot;1-step preds&quot;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510292303.webp" alt="202510292303" style="zoom:80%;" /><p>单步预测效果不错，即使这些预测的时间步超过了600+4(也就是n_train+tau)，其结果看起来仍然是可信的</p><p>但这里有一个问题，后续的迈进需要一步步，必须使用自己的预测(而不是原始数据)来进行多步预测</p><p>对于直到$x_t$的观测序列，其在时间步$t+k$处的预测输出$\hat{x}_{t+k}$称为**$k$步预测(k-step-ahead-prediction)**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multistep_preds = torch.zeros(T) <span class="comment"># 初始化</span></span><br><span class="line">multistep_preds[: n_train + tau] = x[:n_train + tau] <span class="comment"># 选取测试集数据</span></span><br><span class="line"><span class="comment"># [n_train : n_train + τ] 测试集开始前的真实值</span></span><br><span class="line"><span class="comment"># [n_train + τ :] 用模型逐步预测后续的所有值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_train + tau, T):</span><br><span class="line">    multistep_preds[i] = net(multistep_preds[i-tau:i].reshape(<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">plt.plot(time, x.detach().numpy(), label=<span class="string">&quot;data&quot;</span>)</span><br><span class="line">plt.plot(time[tau:], onestep_preds.detach().numpy(),label=<span class="string">&quot;1-step preds&quot;</span>)</span><br><span class="line">plt.plot(time[n_train + tau:], multistep_preds[n_train+tau:].detach().numpy(), <span class="string">&#x27;-.&#x27;</span>, label=<span class="string">&quot;multistep preds&quot;</span>) <span class="comment"># 显示利用预测值去预测的结果</span></span><br><span class="line">plt.grid()</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510301258.webp" alt="202510301258" style="zoom:80%;" /><p>绿线的预测显然并不理想，预测的结果很快就会衰减到一个常数，这是由于错误的积累，误差可能会相当快地偏离真实的观测结果</p><p>对于不同的k值，对比结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">max_step = <span class="number">64</span> <span class="comment"># 定义最大步伐</span></span><br><span class="line"><span class="comment"># 定义特征矩阵，前tau列为历史数据，后max_step存储模型预测值，以最大创建</span></span><br><span class="line">features = torch.zeros((T-tau-max_step+<span class="number">1</span>, tau+max_step))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tau):</span><br><span class="line">    features[:, i] = x[i: i+T-tau-max_step+<span class="number">1</span>] <span class="comment"># 前tau列填入真实历史值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tau, tau + max_step):</span><br><span class="line">    <span class="comment"># 后tau+max_step填入预测值</span></span><br><span class="line">    features[:, i] = net(features[:, i - tau:i]).reshape(-<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">steps = (<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> steps:</span><br><span class="line">    plt.plot(time[tau + i - <span class="number">1</span> : T - max_step + i], <span class="comment"># time长度与y匹配</span></span><br><span class="line">             features[:, tau + i - <span class="number">1</span>].detach().numpy(),</span><br><span class="line">             label=<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>-step preds&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510301326.webp" alt="202510301326" style="zoom: 80%;" /><p>清楚地说明了试图预测更远的未来时，预测的质量是如何变化的</p><p>一般超过4步预测跨度的预测几乎就是无用的</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>内插法(在现有观测值之间进行估计)和外推法(对超出已知观测范围进行预测)在实践的难度上差别很大，对于所拥有的序列数据，在训练时始终要尊重其时间顺序，最好不要基于未来的数据进行训练</li><li>序列模型的估计需要专门的统计工具，两种较流行的选择是自回归模型和隐变量自回归模型</li><li>着对预测时间$k$值的增加，会造成误差的快速累积和预测质量的极速下降</li></ul><h2 id="文本预处理"><a href="#文本预处理" class="headerlink" title="文本预处理"></a>文本预处理</h2><p>文本的常见预处理步骤，包括：</p><ol><li>将文本作为字符串加载到内存中</li><li>将字符串拆分为词元(如单词和字符)</li><li>建立一个词表，将拆分的词元映射到数字索引</li><li>将文本转换为数字索引序列，方便模型操作</li></ol><p>新增加的导入库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections <span class="comment">#　提供了一些比普通字典、列表更灵活的数据结构</span></span><br><span class="line"><span class="keyword">import</span> re          <span class="comment">#  用于字符串匹配、查找、替换、分割等操作</span></span><br></pre></td></tr></table></figure><p><code>collections</code> —— 高级数据结构工具箱</p><p>常见成员：</p><ul><li><code>Counter</code>：计数器，用来统计元素出现次数</li><li><code>deque</code>(双端队列)：高效地在头尾插入或删除元素</li></ul><p><code>re</code> —— 正则表达式库</p><p>常用函数：</p><ul><li><p><code>re.search(pattern, text)</code>：在文本中搜索匹配项</p></li><li><p><code>re.findall(pattern, text)</code>：找到所有匹配的子串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re.findall(<span class="string">r&quot;[A-Za-z]+&quot;</span>, <span class="string">&quot;Hi 123 there!&quot;</span>)  <span class="comment"># [&#x27;Hi&#x27;, &#x27;there&#x27;]</span></span><br><span class="line"><span class="comment"># +号代表 匹配连续的一个或多个字母</span></span><br></pre></td></tr></table></figure></li><li><p><code>re.sub(pattern, repl, text)</code>：按规则替换字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;Room 404&quot;</span>)  <span class="comment"># &quot;Room X&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h3><p>从H.G.Well的<a href="https://www.gutenberg.org/ebooks/35">The Time Machine</a>中加载文本，这是一个相当小的语料库，只有30000多个单词</p><p>下面的函数将数据集读取到由多条文本行组成的列表中，其中每条文本行都是一个字符串，在这里忽略了标点符号和字母大写</p><p>数据集导入，和Kaggle类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DATA_HUB[<span class="string">&#x27;time_machine&#x27;</span>] = (  <span class="comment">#@save</span></span><br><span class="line">    DATA_URL + <span class="string">&#x27;timemachine.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;090b5e7e70c295757f55df93cb0a180b9691891a&#x27;</span>) </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_time_machine</span>():  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将时间机器数据集加载到文本行的列表中&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(download(<span class="string">&#x27;time_machine&#x27;</span>), <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 一次性读取文件中所有行，结果是一个列表，每个元素是一行字符串</span></span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="comment"># 正则表达式，匹配所有非英文字母，替换为空格，&#x27; &#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [re.sub(<span class="string">&#x27;[^A-Za-z]+&#x27;</span>, <span class="string">&#x27; &#x27;</span>, line).strip().lower() <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line">    <span class="comment"># .strip() 去掉字符串首尾多余的空格，中间的保留</span></span><br><span class="line">    <span class="comment"># .lower() 转换成小写</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lines = read_time_machine()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 文本总行数: <span class="subst">&#123;<span class="built_in">len</span>(lines)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(lines[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(lines[<span class="number">10</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文本总行数: 3221</span><br><span class="line">the time machine by h g wells</span><br><span class="line">twinkled and his usually pale face was flushed and animated the</span><br></pre></td></tr></table></figure><h3 id="词元化"><a href="#词元化" class="headerlink" title="词元化"></a>词元化</h3><p><code>tokenize</code>函数将文本行列表(<code>lines</code>)作为输入，列表中的每个元素是一个文本序列(如一条文本行)</p><p>每个文本序列又被拆分成一个词元列表，**词元(token)**是文本的基本单位</p><p>最后，返回一个由词元列表组成的列表，其中的每个词元都是一个字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tokenize</span>(<span class="params">lines, token=<span class="string">&#x27;words&#x27;</span></span>): <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将文本行拆分为单词或字符词元&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> token == <span class="string">&#x27;words&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> [line.split() <span class="keyword">for</span> line <span class="keyword">in</span> lines] <span class="comment"># 根据空格切分字符串</span></span><br><span class="line">    <span class="keyword">elif</span> token == <span class="string">&#x27;char&#x27;</span>: <span class="comment"># 直接把每行拆成单个字符</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">list</span>(line) <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;unknown token&#x27;</span> + token)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tokens = tokenize(lines) <span class="comment"># 将刚刚拆开的行放入</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>): <span class="comment"># 前11行</span></span><br><span class="line">    <span class="built_in">print</span>(tokens[i]) </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;the&#x27;, &#x27;time&#x27;, &#x27;machine&#x27;, &#x27;by&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;wells&#x27;]</span><br><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">[&#x27;i&#x27;]</span><br><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">[&#x27;the&#x27;, &#x27;time&#x27;, &#x27;traveller&#x27;, &#x27;for&#x27;, &#x27;so&#x27;, &#x27;it&#x27;, &#x27;will&#x27;, &#x27;be&#x27;, &#x27;convenient&#x27;, &#x27;to&#x27;, &#x27;speak&#x27;, &#x27;of&#x27;, &#x27;him&#x27;]</span><br><span class="line">[&#x27;was&#x27;, &#x27;expounding&#x27;, &#x27;a&#x27;, &#x27;recondite&#x27;, &#x27;matter&#x27;, &#x27;to&#x27;, &#x27;us&#x27;, &#x27;his&#x27;, &#x27;grey&#x27;, &#x27;eyes&#x27;, &#x27;shone&#x27;, &#x27;and&#x27;]</span><br><span class="line">[&#x27;twinkled&#x27;, &#x27;and&#x27;, &#x27;his&#x27;, &#x27;usually&#x27;, &#x27;pale&#x27;, &#x27;face&#x27;, &#x27;was&#x27;, &#x27;flushed&#x27;, &#x27;and&#x27;, &#x27;animated&#x27;, &#x27;the&#x27;]</span><br></pre></td></tr></table></figure><h3 id="词表"><a href="#词表" class="headerlink" title="词表"></a>词表</h3><p>在文本处理中，词元通常是字符串，但深度学习模型只能处理数值输入，需要构建一个<strong>词表(vocabulary)</strong>，用于将每个词元映射为从0开始的整数索引</p><p>构建词表的步骤如下：</p><ol><li>将训练集中的所有文本合并，对其中出现的唯一词元进行统计，这个整体称为<strong>语料(corpus)</strong></li><li>根据每个词元的出现频率为其分配索引，出现频率过低的词元通常会被舍弃，以降低模型复杂度</li><li>对于语料中未出现或被删除的词元，会统一映射到一个特殊的<strong>未知词元</strong>(<code>&quot;&lt;unk&gt;&quot;</code>)</li></ol><p>词表中还可以包含一些特殊标记，用于在训练和生成过程中发挥作用</p><ul><li><code>&quot;&lt;pad&gt;&quot;</code>：填充词元，用于对齐序列长度</li><li><code>&quot;&lt;bos&gt;&quot;</code>：序列开始标记</li><li><code>&quot;&lt;eos&gt;&quot;</code>：序列结束标记</li></ul><p>构建一个<code>Vocab</code>类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_corpus</span>(<span class="params">tokens</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;统计词元的频率&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 这里的tokens是1D列表或2D列表</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tokens) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(tokens[<span class="number">0</span>], <span class="built_in">list</span>):</span><br><span class="line">        <span class="comment"># 将词元列表展平成一个列表</span></span><br><span class="line">        tokens = [token <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line]</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        flat = []</span></span><br><span class="line"><span class="string">        for line in tokens:</span></span><br><span class="line"><span class="string">            for token in line:</span></span><br><span class="line"><span class="string">                flat.append(token)</span></span><br><span class="line"><span class="string">        tokens = flat</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Python 内置的计数器容器类型</span></span><br><span class="line">    <span class="comment"># 返回一个字典状的对象：键是词元，值是出现次数</span></span><br><span class="line">    <span class="keyword">return</span> collections.Counter(tokens)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vocab</span>: <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;文本词表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># reserved_tokens 包含特殊标记</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tokens=<span class="literal">None</span>, min_freq=<span class="number">0</span>, reserved_tokens=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> tokens <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tokens=[]</span><br><span class="line">        <span class="keyword">if</span> reserved_tokens <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            reserved_tokens=[]</span><br><span class="line">        <span class="comment"># 按出现频率排序</span></span><br><span class="line">        counter = count_corpus(tokens)</span><br><span class="line">        <span class="comment"># 变量名前加一个下划线_ 表示这是类的内部属性，外部最好别直接访问</span></span><br><span class="line">        <span class="variable language_">self</span>._token_freqs = <span class="built_in">sorted</span>(</span><br><span class="line">            counter.items(),</span><br><span class="line">            key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>],</span><br><span class="line">            reverse=<span class="literal">True</span>) <span class="comment"># 降序排序，默认升序</span></span><br><span class="line">        <span class="comment"># 未知词元的索引为0</span></span><br><span class="line">        <span class="variable language_">self</span>.idx_to_token = [<span class="string">&#x27;&lt;unk&gt;&#x27;</span>] + reserved_tokens</span><br><span class="line">        <span class="comment"># 构建反向映射字典：“词元 → 索引”</span></span><br><span class="line">        <span class="variable language_">self</span>.token_to_idx = &#123;token: idx</span><br><span class="line">                             <span class="keyword">for</span> idx, token <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.idx_to_token)&#125;</span><br><span class="line">        <span class="keyword">for</span> token, freq <span class="keyword">in</span> <span class="variable language_">self</span>._token_freqs:</span><br><span class="line">            <span class="keyword">if</span> freq &lt; min_freq: <span class="comment"># 如果频率太小直接抛弃</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 检查当前词是否已在词表中</span></span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.token_to_idx:</span><br><span class="line">                <span class="variable language_">self</span>.idx_to_token.append(token) <span class="comment"># 加入 idx_to_token 列表末尾</span></span><br><span class="line">                <span class="comment"># 在 token_to_idx 里记录它的索引，长度-1为索引</span></span><br><span class="line">                <span class="variable language_">self</span>.token_to_idx[token] = <span class="built_in">len</span>(<span class="variable language_">self</span>.idx_to_token) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.idx_to_token)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, tokens</span>): <span class="comment"># 索引运算符重载</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tokens, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)):</span><br><span class="line">            <span class="comment"># 输入是单个词元</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.token_to_idx.get(tokens, <span class="variable language_">self</span>.unk)</span><br><span class="line">            <span class="comment"># .get(tokens, self.unk) 词元在词表里，返回它对应的索引，不在返回unk</span></span><br><span class="line">        <span class="comment"># 输入是多个词元(列表or元组)</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="variable language_">self</span>.__getitem__(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_tokens</span>(<span class="params">self, indices</span>): <span class="comment"># 将输出转回词元</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(indices, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.idx_to_token[indices]</span><br><span class="line">        <span class="keyword">return</span> [<span class="variable language_">self</span>.idx_to_token[index] <span class="keyword">for</span> index <span class="keyword">in</span> indices]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property </span><span class="comment"># 装饰器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unk</span>(<span class="params">self</span>):  <span class="comment"># 未知词元的索引为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 其实它是一个函数，但用 @property 包装后可以当变量用</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">token_freqs</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._token_freqs</span><br></pre></td></tr></table></figure><p>使用时光机器数据集作为语料库来构建词表，然后打印前几个高频词元及其索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vocab = Vocab(tokens)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(vocab.token_to_idx.items())[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(&#x27;&lt;unk&gt;&#x27;, 0), (&#x27;the&#x27;, 1), (&#x27;i&#x27;, 2), (&#x27;and&#x27;, 3), (&#x27;of&#x27;, 4), (&#x27;a&#x27;, 5), (&#x27;to&#x27;, 6), (&#x27;was&#x27;, 7), (&#x27;in&#x27;, 8), (&#x27;that&#x27;, 9)]</span><br></pre></td></tr></table></figure><p>现在可以将每一条文本行转换成一个数字索引列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">10</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;文本:&#x27;</span>, tokens[i])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;索引:&#x27;</span>, vocab[tokens[i]])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文本: [&#x27;the&#x27;, &#x27;time&#x27;, &#x27;machine&#x27;, &#x27;by&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;wells&#x27;]</span><br><span class="line">索引: [1, 19, 50, 40, 2183, 2184, 400]</span><br><span class="line">文本: [&#x27;twinkled&#x27;, &#x27;and&#x27;, &#x27;his&#x27;, &#x27;usually&#x27;, &#x27;pale&#x27;, &#x27;face&#x27;, &#x27;was&#x27;, &#x27;flushed&#x27;, &#x27;and&#x27;, &#x27;animated&#x27;, &#x27;the&#x27;]</span><br><span class="line">索引: [2186, 3, 25, 1044, 362, 113, 7, 1421, 3, 1045, 1]</span><br></pre></td></tr></table></figure><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>将所有功能打包到<code>load_corpus_time_machine</code>函数中，该函数返回<code>corpus</code>(词元索引列表)和<code>vocab</code>(时光机器语料库的词表)</p><p>在这里做了一些改变：</p><ol><li>为了简化训练，使用字符实现文本词元化(字符词表量级小，26个字母+空格)</li><li>时光机器数据集中的每个文本行不一定是一个句子或一个段落，还可能是一个单词，因此返回的<code>corpus</code>仅处理为单个列表，而不是使用多词元列表构成的一个列表</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_corpus_time_machine</span>(<span class="params">max_tokens=-<span class="number">1</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回时光机器数据集的词元索引列表和词表&quot;&quot;&quot;</span></span><br><span class="line">    lines = read_time_machine()</span><br><span class="line">    tokens = tokenize(lines, <span class="string">&#x27;char&#x27;</span>) <span class="comment"># 每一行的文本被拆成一个个字母</span></span><br><span class="line">    vocab = Vocab(tokens)</span><br><span class="line">    <span class="comment"># 因为时光机器数据集中的每个文本行不一定是一个句子或一个段落，</span></span><br><span class="line">    <span class="comment"># 所以将所有文本行展平到一个列表中</span></span><br><span class="line">    corpus = [vocab[token] <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line]</span><br><span class="line">    <span class="keyword">if</span> max_tokens &gt; <span class="number">0</span>:</span><br><span class="line">        corpus = corpus[:max_tokens]</span><br><span class="line">    <span class="keyword">return</span> corpus, vocab <span class="comment"># 字符索引的序列，词表对象</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corpus, vocab = load_corpus_time_machine()</span><br><span class="line"><span class="built_in">len</span>(corpus), <span class="built_in">len</span>(vocab)  <span class="comment"># (170580, 28)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(vocab.idx_to_token)</span><br><span class="line"><span class="comment"># [&#x27;&lt;unk&gt;&#x27;, &#x27; &#x27;, &#x27;e&#x27;, &#x27;t&#x27;, &#x27;a&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;s&#x27;, &#x27;h&#x27;, &#x27;r&#x27;, &#x27;d&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;u&#x27;, &#x27;c&#x27;, &#x27;f&#x27;, &#x27;w&#x27;, &#x27;g&#x27;, &#x27;y&#x27;, &#x27;p&#x27;, &#x27;b&#x27;, &#x27;v&#x27;, &#x27;k&#x27;, &#x27;x&#x27;, &#x27;z&#x27;, &#x27;j&#x27;, &#x27;q&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>词元化是一个关键的预处理步骤，它因语言而异，尝试找到另外三种常用的词元化文本的方法</p><p>方法一：词级分词：直接以空格和标点作为分隔符，把句子切分成单词，最直观、最传统的方式</p><p>依赖空格分割，对中文、日文等无空格语言完全失效，标点、缩写(如<code>H.G.</code>)可能导致歧义，会造成词表巨大，模型容易出现未知词，一般用于入门级语言模型</p><p>方法二：子词分词，这是现代 NLP 模型最常用的方式，代表算法有：</p><ul><li>BPE(Byte Pair Encoding)</li><li>WordPiece</li><li>SentencePiece</li></ul><p>把单词拆成更小的、可重复组合的单元(子词 subword)，高效，词表小、覆盖率高且与语言无关</p><p>但子词边界不总与语义边界对齐，实现复杂</p><p>方法三：中文分词，针对没有空格的语言，必须借助统计或机器学习方法决定词边界，常用工具：</p><ul><li>jieba(结巴分词)</li><li>THULAC(清华大学)</li><li>HanLP(多语言自然语言处理库)</li></ul><p>依赖词典，难以处理新词；不同分词标准会造成语义差异</p><h2 id="语言模型和数据集"><a href="#语言模型和数据集" class="headerlink" title="语言模型和数据集"></a>语言模型和数据集</h2><p>在给定文本序列时，语言模型的目标是估计序列的联合概率，一个理想的语言模型能够基于模型本身生成自然文本</p><h3 id="学习语言模型"><a href="#学习语言模型" class="headerlink" title="学习语言模型"></a>学习语言模型</h3><p>假设在单词级别对文本数据进行词元化，从基本概率规则开始<br>$$<br>P(x_1, x_2, \ldots, x_T) &#x3D; \prod_{t&#x3D;1}^T P(x_t  \mid  x_1, \ldots, x_{t-1}).<br>$$<br>包含了四个单词的一个文本序列的概率是：<br>$$<br>P(\text{deep}, \text{learning}, \text{is}, \text{fun}) &#x3D;  P(\text{deep}) P(\text{learning}  \mid  \text{deep}) P(\text{is}  \mid  \text{deep}, \text{learning}) P(\text{fun}  \mid  \text{deep}, \text{learning}, \text{is}).<br>$$<br>为了训练语言模型，需要计算单词的概率，以及在给定前面几个单词后，下一个单词出现的条件概率。这些概率就是语言模型的参数</p><p>假设训练数据集是一个大型的文本语料库，单词的概率可以用它在语料中的相对频率来近似计算</p><p>例如，单词 “deep” 的概率可以通过它在文本中出现的次数除以所有单词总数来估计<br>$$<br>\hat{P}( \text{deep}) &#x3D; \frac{n(\text{deep})}{总词数}<br>$$<br>对于频繁出现的词这种方法不错，可以尝试估计<br>$$<br>\hat{P}(\text{learning} \mid \text{deep}) &#x3D; \frac{n(\text{deep, learning})}{n(\text{deep})}<br>$$<br>其中$n(x)$和$n(x, x’)$分别是单个单词和连续单词对的出现次数</p><p>但“deep learning”这样连续词对出现得远比单个词少，因此这种估计在遇到罕见的词组时会不太可靠，因为样本太少，很难得到准确的概率</p><p>一种常见的策略是执行某种形式的<strong>拉普拉斯平滑(Laplace smoothing)</strong>，具体方法是在所有计数中添加一个小常量</p><p>用$n$表示训练集中的单词总数，用$m$表示词表大小<br>$$<br>\begin{split}\begin{aligned}<br>\hat{P}(x) &amp; &#x3D; \frac{n(x) + \epsilon_1&#x2F;m}{n + \epsilon_1}, \\<br>\hat{P}(x’ \mid x) &amp; &#x3D; \frac{n(x, x’) + \epsilon_2 \hat{P}(x’)}{n(x) + \epsilon_2}, \\<br>\hat{P}(x’’ \mid x,x’) &amp; &#x3D; \frac{n(x, x’,x’’) + \epsilon_3 \hat{P}(x’’)}{n(x, x’) + \epsilon_3}.<br>\end{aligned}\end{split}<br>$$<br>其中$\epsilon_1,\epsilon_2,\epsilon_3$为超参数，当$\epsilon_1 &#x3D; 0$时不应用平滑，接近无穷大时$\hat{P}(x)$接近均匀概率分布$1&#x2F;m$</p><p>然而这样的模型很容易变得无效</p><ul><li>需要存储所有的计数</li><li>完全忽略单词的意思</li></ul><p>因此一个模型如果只是简单地统计先前“看到”的单词序列频率，那么模型面对长单词序列问题肯定是表现不佳的</p><h3 id="马尔可夫模型与n元语法"><a href="#马尔可夫模型与n元语法" class="headerlink" title="马尔可夫模型与n元语法"></a>马尔可夫模型与n元语法</h3><p>在语言建模中，若假设$P(x_{t+1} \mid x_t, \ldots, x_1) &#x3D; P(x_{t+1} \mid x_t)$，则序列满足一阶马尔可夫性质，阶数越高，对应的依赖关系就越长</p><p>可以得到不同阶数下的近似形式:<br>$$<br>\begin{split}\begin{aligned}<br>P(x_1, x_2, x_3, x_4) &amp;&#x3D;  P(x_1) P(x_2) P(x_3) P(x_4)(零阶)\\<br>P(x_1, x_2, x_3, x_4) &amp;&#x3D;  P(x_1) P(x_2  \mid  x_1) P(x_3  \mid  x_2) P(x_4  \mid  x_3)(一阶)\\<br>P(x_1, x_2, x_3, x_4) &amp;&#x3D;  P(x_1) P(x_2  \mid  x_1) P(x_3  \mid  x_1, x_2) P(x_4  \mid  x_2, x_3)(二阶)<br>\end{aligned}\end{split}<br>$$<br>阶数越高，模型捕捉到的上下文信息越多，但计算与存储开销也随之增加</p><p>通常，涉及一个、两个和三个变量的概率公式分别被称为一元语法(unigram)、二元语法(bigram)和三元语法(trigram)模型</p><h3 id="自然语言统计"><a href="#自然语言统计" class="headerlink" title="自然语言统计"></a>自然语言统计</h3><p>根据时光机器数据集构建词表，并打印前10个最常用的(频率最高的)单词</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tokens = tokenize(read_time_machine())</span><br><span class="line">corpus = [token <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line] <span class="comment"># 展平tokens</span></span><br><span class="line">vocab = Vocab(corpus)</span><br><span class="line">vocab.token_freqs[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[(&#x27;the&#x27;, 2261),</span><br><span class="line"> (&#x27;i&#x27;, 1267),</span><br><span class="line"> (&#x27;and&#x27;, 1245),</span><br><span class="line"> (&#x27;of&#x27;, 1155),</span><br><span class="line"> (&#x27;a&#x27;, 816),</span><br><span class="line"> (&#x27;to&#x27;, 695),</span><br><span class="line"> (&#x27;was&#x27;, 552),</span><br><span class="line"> (&#x27;in&#x27;, 541),</span><br><span class="line"> (&#x27;that&#x27;, 443),</span><br><span class="line"> (&#x27;my&#x27;, 440)]</span><br></pre></td></tr></table></figure><p>会发现，最多的词并没有意义，这些词通常被称为<strong>停用词(stop words)</strong>，因此可以被过滤掉</p><p>还有个明显的问题是词频衰减的速度相当地快</p><p>可以画出词频图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">freqs = [freq <span class="keyword">for</span> token, freq <span class="keyword">in</span> vocab.token_freqs] <span class="comment"># 把频率单独拉出来</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">plt.plot(freqs)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;token: x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;freq: n(x)&#x27;</span>)</span><br><span class="line">plt.xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">plt.yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510301716.png" alt="202510301716" style="zoom: 67%;" /><p>词频以一种明确的方式迅速衰减</p><p>将前几个单词作为例外消除后，剩余的所有单词大致遵循双对数坐标图上的一条直线</p><p>这意味着单词的频率满足<strong>齐普夫定律(Zipf’s law)</strong>，即第$i$个最常用单词的频率$n_i$为<br>$$<br>n_i \propto \frac{1}{i^\alpha}<br>$$<br>等价于<br>$$<br>\log n_i &#x3D; -\alpha \log i + c,<br>$$<br>所以通过计数统计和平滑来建模单词是不可行的，因为这样会大大高估尾部单词的频率，也就是所谓的不常用单词</p><p>对于二元语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bigram_tokens = [pair <span class="keyword">for</span> pair <span class="keyword">in</span> <span class="built_in">zip</span>(corpus[:-<span class="number">1</span>], corpus[<span class="number">1</span>:])] <span class="comment"># 相邻绑定</span></span><br><span class="line">bigram_vocab = Vocab(bigram_tokens)</span><br><span class="line">bigram_vocab.token_freqs[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[((&#x27;of&#x27;, &#x27;the&#x27;), 309),</span><br><span class="line"> ((&#x27;in&#x27;, &#x27;the&#x27;), 169),</span><br><span class="line"> ((&#x27;i&#x27;, &#x27;had&#x27;), 130),</span><br><span class="line"> ((&#x27;i&#x27;, &#x27;was&#x27;), 112),</span><br><span class="line"> ((&#x27;and&#x27;, &#x27;the&#x27;), 109),</span><br><span class="line"> ((&#x27;the&#x27;, &#x27;time&#x27;), 102),</span><br><span class="line"> ((&#x27;it&#x27;, &#x27;was&#x27;), 99),</span><br><span class="line"> ((&#x27;to&#x27;, &#x27;the&#x27;), 85),</span><br><span class="line"> ((&#x27;as&#x27;, &#x27;i&#x27;), 78),</span><br><span class="line"> ((&#x27;of&#x27;, &#x27;a&#x27;), 73)]</span><br></pre></td></tr></table></figure><p>在十个最频繁的词对中，有九个是由两个停用词组成的，只有“the time”涵盖信息</p><p>再进一步看看三元语法的频率是否表现出相同的行为方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trigram_tokens = [triple <span class="keyword">for</span> triple <span class="keyword">in</span> <span class="built_in">zip</span>(corpus[:-<span class="number">2</span>], corpus[<span class="number">1</span>:-<span class="number">1</span>], corpus[<span class="number">2</span>:])]</span><br><span class="line">trigram_vocab = Vocab(trigram_tokens)</span><br><span class="line">trigram_vocab.token_freqs[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[((&#x27;the&#x27;, &#x27;time&#x27;, &#x27;traveller&#x27;), 59),</span><br><span class="line"> ((&#x27;the&#x27;, &#x27;time&#x27;, &#x27;machine&#x27;), 30),</span><br><span class="line"> ((&#x27;the&#x27;, &#x27;medical&#x27;, &#x27;man&#x27;), 24),</span><br><span class="line"> ((&#x27;it&#x27;, &#x27;seemed&#x27;, &#x27;to&#x27;), 16),</span><br><span class="line"> ((&#x27;it&#x27;, &#x27;was&#x27;, &#x27;a&#x27;), 15),</span><br><span class="line"> ((&#x27;here&#x27;, &#x27;and&#x27;, &#x27;there&#x27;), 15),</span><br><span class="line"> ((&#x27;seemed&#x27;, &#x27;to&#x27;, &#x27;me&#x27;), 14),</span><br><span class="line"> ((&#x27;i&#x27;, &#x27;did&#x27;, &#x27;not&#x27;), 14),</span><br><span class="line"> ((&#x27;i&#x27;, &#x27;saw&#x27;, &#x27;the&#x27;), 13),</span><br><span class="line"> ((&#x27;i&#x27;, &#x27;began&#x27;, &#x27;to&#x27;), 13)]</span><br></pre></td></tr></table></figure><p>直观地对比三种模型中的词元频率：一元语法、二元语法和三元语法</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510301951.webp" alt="202510301951" style="zoom:67%;" /><p>这张图非常令人振奋！原因有很多：</p><ol><li>除了一元语法词，单词序列似乎也遵循齐普夫定律，尽管公式中$\alpha$更小(指数大小受序列长度影响)</li><li>尽管可能的$n$元组数量理论上非常庞大，但在实际语料中却远小于理论上限，说明自然语言中存在强烈的结构规律性与约束，使得能够用模型有效地进行语言建模</li><li>大量的$n$元组几乎从未出现，这使得拉普拉斯平滑无法有效处理这种稀疏性，作为替代，将使用基于深度学习的模型</li></ol><h3 id="读取长序列数据"><a href="#读取长序列数据" class="headerlink" title="读取长序列数据"></a>读取长序列数据</h3><p>序列数据本质上是连续的，在建模时必须解决其长度不定的问题，当序列过长而无法被模型一次性处理时，通常会将其切分成多个较短的片段，以便模型逐段读取</p><p>在使用神经网络训练语言模型时，模型一次只能处理长度固定的小批量序列，需要设计一种方法，随机生成小批量的特征与标签对供模型训练</p><p>由于文本序列的长度可以任意，任意长序列可以被划分为若干个长度相同的子序列，每个小批量就由这些子序列组成，并输入模型进行学习</p><p>切分序列时的起始偏移量可以自由选择，不同的偏移量会产生不同的子序列划分方式，从而提高数据的多样性与模型的泛化能力</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/timemachine-5gram.webp" alt="timemachine-5gram" style="zoom:80%;" /><p>可以从随机偏移量开始划分序列，以同时获得覆盖性和随机性</p><p>有两种策略：<strong>随机采样(random sampling)<strong>和</strong>顺序分区(sequential partitioning)</strong></p><h4 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h4><p>在随机采样中，每个样本都是在原始的长序列上任意捕获的子序列</p><p>在迭代过程中，来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻</p><p>对于语言建模，目标是基于到目前为止看到的词元来预测下一个词元，因此标签是移位了一个词元的原始序列</p><p>下面的代码每次可以从数据中随机生成一个小批量，参数<code>batch_size</code>指定了每个小批量中子序列样本的数目，参数<code>num_steps</code>是模型在一次前向传播中看到的时间长度</p><blockquote><p>并不是预测num_steps长度，都是用前一个预测后一个</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seq_data_iter_random</span>(<span class="params">corpus, batch_size, num_steps</span>): <span class="comment"># @save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用随机抽样生成一个小批量子序列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从随机偏移量开始对序列进行分区，随机范围包括num_steps-1</span></span><br><span class="line">    corpus = corpus[random.randint(<span class="number">0</span>, num_steps - <span class="number">1</span>):] <span class="comment"># 随机偏移量起始，但不能超过num_steps</span></span><br><span class="line">    <span class="comment"># 减去1，是因为需要考虑标签</span></span><br><span class="line">    num_subseqs = (<span class="built_in">len</span>(corpus) - <span class="number">1</span>) // num_steps</span><br><span class="line">    <span class="comment"># 长度为num_steps的子序列的起始索引</span></span><br><span class="line">    initial_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, num_subseqs * num_steps, num_steps))</span><br><span class="line">    <span class="comment"># 在随机抽样的迭代过程中，</span></span><br><span class="line">    <span class="comment"># 来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻</span></span><br><span class="line">    random.shuffle(initial_indices) <span class="comment"># 打乱起点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">data</span>(<span class="params">pos</span>):</span><br><span class="line">        <span class="comment"># 返回从pos位置开始的长度为num_steps的序列</span></span><br><span class="line">        <span class="keyword">return</span> corpus[pos: pos + num_steps]</span><br><span class="line"></span><br><span class="line">    num_batches = num_subseqs // batch_size</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, batch_size * num_batches, batch_size):</span><br><span class="line">        initial_indices_per_batch = initial_indices[i : i+batch_size]</span><br><span class="line">        X = [data(j) <span class="keyword">for</span> j <span class="keyword">in</span> initial_indices_per_batch]</span><br><span class="line">        Y = [data(j+<span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> initial_indices_per_batch] <span class="comment"># 后移一位</span></span><br><span class="line">        <span class="keyword">yield</span> torch.tensor(X), torch.tensor(Y)</span><br></pre></td></tr></table></figure><p>生成一个0到34的序列，批量大小为2，时间步为5，可以生成(35-1)&#x2F;5 &#x3D; 6个“特征－标签”子序列对，所以只能有3个小批量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_seq = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">35</span>))</span><br><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> seq_data_iter_random(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X: &#x27;</span>, X, <span class="string">&#x27;\nY:&#x27;</span>, Y)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X:  tensor([[25, 26, 27, 28, 29],</span><br><span class="line">        [15, 16, 17, 18, 19]]) </span><br><span class="line">Y: tensor([[26, 27, 28, 29, 30],</span><br><span class="line">        [16, 17, 18, 19, 20]])</span><br><span class="line">X:  tensor([[10, 11, 12, 13, 14],</span><br><span class="line">        [20, 21, 22, 23, 24]]) </span><br><span class="line">Y: tensor([[11, 12, 13, 14, 15],</span><br><span class="line">        [21, 22, 23, 24, 25]])</span><br><span class="line">X:  tensor([[5, 6, 7, 8, 9],</span><br><span class="line">        [0, 1, 2, 3, 4]]) </span><br><span class="line">Y: tensor([[ 6,  7,  8,  9, 10],</span><br><span class="line">        [ 1,  2,  3,  4,  5]])</span><br></pre></td></tr></table></figure><h4 id="顺序分区"><a href="#顺序分区" class="headerlink" title="顺序分区"></a>顺序分区</h4><p>在随机采样中，每个样本都是在原始的长序列上任意捕获的子序列</p><p>下面的代码每次可以从数据中随机生成一个小批量，参数<code>batch_size</code>指定了每个小批量中子序列样本的数目，参数<code>num_steps</code>是每次送入模型的时间步长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seq_data_iter_sequential</span>(<span class="params">corpus, batch_size, num_steps</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用顺序分区生成一个小批量子序列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从随机偏移量开始划分序列</span></span><br><span class="line">    offset = random.randint(<span class="number">0</span>,num_steps) <span class="comment"># 这里允许偏移等于一个完整的时间窗口</span></span><br><span class="line">    num_tokens = ((<span class="built_in">len</span>(corpus) - offset - <span class="number">1</span>) // batch_size) * batch_size</span><br><span class="line">    Xs = torch.tensor(corpus[offset: offset + num_tokens])</span><br><span class="line">    Ys = torch.tensor(corpus[offset + <span class="number">1</span>: offset + num_tokens + <span class="number">1</span>])</span><br><span class="line">    Xs, Ys = Xs.reshape(batch_size, -<span class="number">1</span>), Ys.reshape(batch_size, -<span class="number">1</span>)</span><br><span class="line">    num_batches = Xs.shape[<span class="number">1</span>] // num_steps  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_steps * num_batches, num_steps):</span><br><span class="line">        X = Xs[:, i: i + num_steps]</span><br><span class="line">        Y = Ys[:, i: i + num_steps]</span><br><span class="line">        <span class="keyword">yield</span> X, Y</span><br></pre></td></tr></table></figure><p>基于相同的设置，通过顺序分区读取每个小批量的子序列的特征<code>X</code>和标签<code>Y</code></p><p>将它们打印出来可以发现：迭代期间来自两个相邻的小批量中的子序列在原始序列中确实是相邻的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> seq_data_iter_sequential(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X: &#x27;</span>, X, <span class="string">&#x27;\nY:&#x27;</span>, Y)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X:  tensor([[ 4,  5,  6,  7,  8],</span><br><span class="line">        [19, 20, 21, 22, 23]]) </span><br><span class="line">Y: tensor([[ 5,  6,  7,  8,  9],</span><br><span class="line">        [20, 21, 22, 23, 24]])</span><br><span class="line">X:  tensor([[ 9, 10, 11, 12, 13],</span><br><span class="line">        [24, 25, 26, 27, 28]]) </span><br><span class="line">Y: tensor([[10, 11, 12, 13, 14],</span><br><span class="line">        [25, 26, 27, 28, 29]])</span><br><span class="line">X:  tensor([[14, 15, 16, 17, 18],</span><br><span class="line">        [29, 30, 31, 32, 33]]) </span><br><span class="line">Y: tensor([[15, 16, 17, 18, 19],</span><br><span class="line">        [30, 31, 32, 33, 34]])</span><br></pre></td></tr></table></figure><p>将上面的两个采样函数包装到一个类中， 以便稍后可以将其用作数据迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeqDataLoader</span>:  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;加载序列数据的迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, batch_size, num_steps, use_random_iter, max_tokens</span>):</span><br><span class="line">        <span class="keyword">if</span> use_random_iter:</span><br><span class="line">            <span class="variable language_">self</span>.data_iter_fn = seq_data_iter_random</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.data_iter_fn = seq_data_iter_sequential</span><br><span class="line">        <span class="variable language_">self</span>.corpus, <span class="variable language_">self</span>.vocab = load_corpus_time_machine(max_tokens)</span><br><span class="line">        <span class="variable language_">self</span>.batch_size, <span class="variable language_">self</span>.num_steps = batch_size, num_steps</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data_iter_fn(<span class="variable language_">self</span>.corpus, <span class="variable language_">self</span>.batch_size, <span class="variable language_">self</span>.num_steps)</span><br></pre></td></tr></table></figure><p>定义了一个函数<code>load_data_time_machine</code>，它同时返回数据迭代器和词表，因此可以与其他带有<code>load_data</code>前缀的函数类似地使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_time_machine</span>(<span class="params">batch_size, num_steps,  <span class="comment">#@save</span></span></span><br><span class="line"><span class="params">                           use_random_iter=<span class="literal">False</span>, max_tokens=<span class="number">10000</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回时光机器数据集的迭代器和词表&quot;&quot;&quot;</span></span><br><span class="line">    data_iter = SeqDataLoader(</span><br><span class="line">        batch_size, num_steps, use_random_iter, max_tokens)</span><br><span class="line">    <span class="keyword">return</span> data_iter, data_iter.vocab</span><br></pre></td></tr></table></figure><h2 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h2><p>在n元语法模型中,假设单词$x_t$的出现仅依赖于前面$n-1$个单词<br>$$<br>P(x_t \mid x_{t-1}, \ldots, x_1) \approx P(x_t \mid x_{t-1},\cdots ,x_{t-n+1}),<br>$$<br>如果希望模型考虑更长的上下文，就必须增大$n$</p><p>这样虽然能捕捉更复杂的语言结构，但模型的参数量会急剧增加，因为词表需要存储$\mid \mathcal{V}\mid ^n$个概率值，当词表很大时，这几乎无法计算与存储</p><p>为了解决这个问题，可以用一个<strong>隐变量模型</strong>进行近似<br>$$<br>P(x_t \mid x_{t-1}, \ldots, x_1) \approx P(x_t \mid h_{t-1})<br>$$<br>其中$h_{t-1}$是<strong>隐状态(hidden state)</strong>，也称为<strong>隐藏变量(hidden variable)</strong>，用于总结截至时间步$t-1$的全部上下文信息</p><p>在每一步，模型都会更新这个隐藏状态$h_t &#x3D; f(x_{t}, h_{t-1})$</p><p>从而以固定大小的参数捕捉潜在的语言依赖关系</p><p><font color='DarkViolet'>隐藏层和隐状态指的是两个截然不同的概念</font>，隐藏层是在从输入到输出的路径上(以观测角度来理解)的隐藏的层，而隐状态则是在给定步骤所做的任何事情的输入，并且这些状态只能通过先前时间步的数据来计算</p><p>**循环神经网络(recurrent neural networks，RNNs)**是具有隐状态的神经网络</p><h3 id="隐状态"><a href="#隐状态" class="headerlink" title="隐状态"></a>隐状态</h3><p>假设在时间步$t$有小批量输入$\mathbf{X}_t \in \mathbb{R}^{n \times d}$，用$\mathbf{H}_t \in \mathbb{R}^{n \times h}$示时间步的隐藏变量</p><p>与多层感知机不同的是，在这里保存了前一个时间步的隐藏变量$\mathbf H_{t-1}$，并引入了一个新的权重参数$\mathbf W_{hh} \in \mathbb R^{h \times h}$，来描述如何在当前时间步中使用前一个时间步的隐藏变量</p><p>具体地说，当前时间步隐藏变量由当前时间步的输入与前一个时间步的隐藏变量一起计算得出：<br>$$<br>\mathbf H_t &#x3D; \phi(\mathbf X_t \mathbf W_{xh} + \mathbf H_{t-1} \mathbf W_{hh}  + \mathbf b_h)<br>$$<br>多添加了一项$\mathbf H_{t-1} \mathbf W_{hh}$，这些变量捕获并保留了序列直到其当前时间步的历史信息，这样的隐藏变量被称为<strong>隐状态(hidden state)</strong></p><p>隐状态使用的定义与前一个时间步中使用的定义相同，因此计算是循环的，在循环神经网络中执行循环计算的层称为<strong>循环层(recurrent layer)</strong></p><p>输出层的输出类似于多层感知机中的计算<br>$$<br>\mathbf O_t &#x3D; \mathbf H_t \mathbf W_{hq} + \mathbf b_q.<br>$$<br>即使在不同的时间步，循环神经网络也总是使用同样的模型参数，因此循环神经网络的参数开销不会随着时间步的增加而增加</p><p>下图展示了循环神经网络在三个相邻时间步的计算逻辑</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/rnn.jpg" alt="rnn" style="zoom:80%;" /><p>在任意时间步隐状态的计算可以被视为：</p><ol><li>拼接当前时间步$t$的输入$\mathbf X_t$和前一时间步$t-1$的隐状态$\mathbf H_{t-1}$</li><li>将拼接的结果送入带有激活函数$\phi$的全连接层，全连接层的输出是当前时间步$t$的隐状态$\mathbf H_{t}$</li></ol><p>隐状态中$\mathbf X_t \mathbf W_{xh} + \mathbf H_{t-1} \mathbf W_{hh}$的计算，相当于$\mathbf X_t$和$\mathbf H_{t-1}$的拼接与$\mathbf W_{xh}$和$\mathbf W_{hh}$的拼接的矩阵乘法</p><p>用一段简单代码示意</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X, W_xh = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">1</span>)), torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line">H, W_hh = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">4</span>)), torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">torch.matmul(X, W_xh) + torch.matmul(H, W_hh)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tensor([[-1.1493,  6.7741, -5.4517,  0.2577],</span><br><span class="line">        [ 2.3512,  1.1124,  0.5166,  0.8442],</span><br><span class="line">        [ 2.5654,  1.5250, -0.3778,  1.3976]])</span><br></pre></td></tr></table></figure><p>沿列(轴1)拼接矩阵<code>X</code>和<code>H</code>，沿行(轴0)拼接矩阵<code>W_xh</code>和<code>W_hh</code></p><p>这两个拼接分别产生形状(3,5)和形状(5,4)的矩阵，将这两个拼接的矩阵相乘，得到与上面相同形状(3,4)的输出矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.matmul(torch.cat((X, H), 1), torch.cat((W_xh, W_hh), 0))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tensor([[-1.1493,  6.7741, -5.4517,  0.2577],</span><br><span class="line">        [ 2.3512,  1.1124,  0.5166,  0.8442],</span><br><span class="line">        [ 2.5654,  1.5250, -0.3778,  1.3976]])</span><br></pre></td></tr></table></figure><h3 id="字符级语言模型"><a href="#字符级语言模型" class="headerlink" title="字符级语言模型"></a>字符级语言模型</h3><p>目标是根据过去的和当前的词元预测下一个词元，因此将原始序列移位一个词元作为标签</p><p>Bengio等人首先提出使用神经网络进行语言建模 (Bengio <em>et al.</em>, 2003)</p><p>设小批量大小为1，批量中的文本序列为“machine”，为了简化后续部分的训练，考虑使用<strong>字符级语言模型</strong>， 将文本词元化为字符而不是单词</p><p>下图演示了如何通过基于字符级语言建模的循环神经网络，使用当前的和先前的字符预测下一个字符</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/rnn-train.jpg" alt="rnn-train" style="zoom:80%;" /><p>输入序列和标签序列分别为“machin”和“achine”</p><p>在训练过程中，对每个时间步的输出层的输出进行softmax操作，然后利用交叉熵损失计算模型输出和标签之间的误差</p><p>在实践中使用的批量大小$n&gt;1$，每个词元都由一个$d$维向量表示，在时间步$t$输入$X_t$将是一个$n\times d$矩阵</p><h3 id="困惑度-Perplexity"><a href="#困惑度-Perplexity" class="headerlink" title="困惑度(Perplexity)"></a>困惑度(Perplexity)</h3><p>可以通过计算序列的似然概率来度量模型的质量，然而这是一个难以理解、难以比较的数字，因为较短的序列比较长的序列更有可能出现</p><p>一个更好的语言模型应该能更准确地预测下一个词元，因此它应该允许压缩序列时花费更少的比特</p><p>可以通过一个序列中所有的$n$个词元的交叉熵损失的平均值来衡量<br>$$<br>\frac{1}{n} \sum_{t&#x3D;1}^n -\log P(x_t \mid x_{t-1}, \ldots, x_1)<br>$$<br>这使得不同长度的文档的性能具有了可比性</p><p>但是自然语言处理的科学家更喜欢使用一个叫做**困惑度(perplexity)**的量，是交叉熵损失的指数<br>$$<br>\exp\left(-\frac{1}{n} \sum_{t&#x3D;1}^n \log P(x_t \mid x_{t-1}, \ldots, x_1)\right).<br>$$<br>困惑度可以理解为模型在预测下一个词元时，实际有效选择数量的调和平均数，值越小，模型越自信</p><ul><li>理想情况：模型总能完美预测正确词元，模型的困惑度为1，没有任何困惑</li><li>最坏情况：模型总是把正确词元的概率估计为0，困惑度趋于无穷，模型失败</li><li>基线(均匀分布)：如果模型认为所有词元的概率相同，困惑度等于词表大小，相当于盲猜，因此这种方式提供了一个重要的上限$\mid \mathcal{V}\mid$，而任何实际模型都必须超越这个上限</li></ul><h3 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>如果使用循环神经网络来预测文本序列中的下一个字符，那么任意输出所需的维度是多少？</p><p>模型的输出是对所有可能字符的概率分布，所以输出的维度等于词表中字符的数量</p></li><li><p>如果基于一个长序列进行反向传播，梯度会发生什么状况？</p><p>当基于一个很长的序列进行反向传播时，梯度会在时间维度上反复被权重矩阵和激活函数的导数相乘，很可能会出现梯度消失或梯度爆炸，因为如果权重稍小，连乘就容易湮灭，如果权重稍大，容易爆炸，需要 LSTM、GRU 等结构来稳定训练</p></li></ol><h2 id="循环神经网络底层实现"><a href="#循环神经网络底层实现" class="headerlink" title="循环神经网络底层实现"></a>循环神经网络底层实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure><h3 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h3><p>将每个索引映射为相互不同的单位向量，假如词元的索引是整数$i$，创建长度为N的全0向量，并在$i$处设为1，获得独热向量，在0和2处创建独热向量举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F.one_hot(torch.tensor([<span class="number">0</span>, <span class="number">2</span>]), <span class="built_in">len</span>(vocab))</span><br></pre></td></tr></table></figure><p>每次采样的小批量数据形状为(batch_size，num_steps)，<code>one_hot</code>函数将小批量数据转换成三维张量，张量的最后一个维度等于词表大小(vocab_size)</p><p>经常转换输入的维度，获得形状为<code>(num_steps，batch_size，vocab_size)</code>的输出，将能够更方便地通过最外层的维度，一步一步地更新小批量数据的隐状态</p><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>隐藏单元数<code>num_hiddens</code>是一个可调的超参数，当训练语言模型时，输入和输出来自相同的词表，具有相同的维度，即词表的大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_params</span>(<span class="params">vocab_size, num_hiddens, device</span>):</span><br><span class="line">    num_inputs = num_outputs = vocab_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normal</span>(<span class="params">shape</span>):</span><br><span class="line">        <span class="keyword">return</span> torch.randn(size=shape, device=device) * <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐藏层参数</span></span><br><span class="line">    W_xh = normal((num_inputs, num_hiddens))</span><br><span class="line">    W_hh = normal((num_hiddens, num_hiddens))</span><br><span class="line">    b_h = torch.zeros(num_hiddens, device=device)</span><br><span class="line">    <span class="comment"># 输出层参数</span></span><br><span class="line">    W_hq = normal((num_hiddens, num_outputs))</span><br><span class="line">    b_q = torch.zeros(num_outputs, device=device)</span><br><span class="line">    <span class="comment"># 附加梯度</span></span><br><span class="line">    params = [W_xh, W_hh, b_h, W_hq, b_q]</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> params</span><br></pre></td></tr></table></figure><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>为了定义循环神经网络模型，首先需要一个<code>init_rnn_state</code>函数在初始化时返回隐状态</p><p>函数的返回值是一个张量，全0填充，形状为<code>(batch_size，num_hiddens)</code></p><p>隐状态可能包含多个变量，而使用元组可以更容易地处理些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_rnn_state</span>(<span class="params">batch_size, num_hiddens, device</span>):</span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device), )</span><br><span class="line"><span class="comment"># 加了一个逗号，返回值就变成了一个单元素元组</span></span><br></pre></td></tr></table></figure><p>下面的<code>rnn</code>函数定义了如何在一个时间步内计算隐状态和输出</p><p>循环神经网络模型通过<code>inputs</code>最外层的维度实现循环，以便逐时间步更新小批量数据的隐状态<code>H</code></p><p>这里使用<code>tanh</code>函数作为激活函数，平均值为0</p><blockquote><p>如果用ReLU，虽然缓解了梯度消失问题，却让梯度爆炸更容易出现，更需要梯度裁剪</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rnn</span>(<span class="params">inputs, state, params</span>):</span><br><span class="line">    <span class="comment"># inputs: (时间步数, 批量大小, 词表大小)</span></span><br><span class="line">    <span class="comment"># state: 隐藏状态 (H,)</span></span><br><span class="line">    W_xh, W_hh, b_h, W_hq, b_q = params</span><br><span class="line">    H, = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="comment"># X：(batch_size, vocab_size)</span></span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        H = torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h)</span><br><span class="line">        Y = torch.mm(H, W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">0</span>), (H,)</span><br><span class="line"><span class="comment"># torch.cat(outputs, dim=0) 把小张量在时间维拼起来</span></span><br><span class="line"><span class="comment"># (H,)返回最终隐藏状态，作为下一个序列的初始状态</span></span><br></pre></td></tr></table></figure><p>对应<br>$$<br>\mathbf H_t &#x3D; \phi(\mathbf X_t \mathbf W_{xh} + \mathbf H_{t-1} \mathbf W_{hh}  + \mathbf b_h)\\<br>\mathbf O_t &#x3D; \mathbf H_t \mathbf W_{hq} + \mathbf b_q.<br>$$<br>定义了所有需要的函数之后，接下来创建一个类来包装这些函数，并存储从零开始实现的循环神经网络模型的参数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RNNModelScratch</span>: <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;从零开始实现的循环神经网络模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, num_hiddens, device,</span></span><br><span class="line"><span class="params">                 get_params, init_state, forward_fn</span>):</span><br><span class="line">        <span class="variable language_">self</span>.vocab_size, <span class="variable language_">self</span>.num_hiddens = vocab_size, num_hiddens</span><br><span class="line">        <span class="variable language_">self</span>.params = get_params(vocab_size, num_hiddens, device)</span><br><span class="line">        <span class="variable language_">self</span>.init_state, <span class="variable language_">self</span>.forward_fn = init_state, forward_fn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, X, state</span>): <span class="comment"># 前向传播方法</span></span><br><span class="line">        <span class="comment"># 先转置变成(num_steps, batch_size)，方便按时间步迭代</span></span><br><span class="line">        X = F.one_hot(X.T, <span class="variable language_">self</span>.vocab_size).<span class="built_in">type</span>(torch.float32)</span><br><span class="line">        <span class="comment"># 传入forward_fn函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.forward_fn(X, state, <span class="variable language_">self</span>.params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">begin_state</span>(<span class="params">self, batch_size, device</span>):</span><br><span class="line">        <span class="comment"># 初始化隐藏状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.init_state(batch_size, <span class="variable language_">self</span>.num_hiddens, device)</span><br></pre></td></tr></table></figure><p>检查输出是否具有正确的形状，例如，隐状态的维数是否保持不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num_hiddens = <span class="number">512</span></span><br><span class="line">X = torch.arange(<span class="number">10</span>).reshape((<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">net = RNNModelScratch(<span class="built_in">len</span>(vocab), num_hiddens, try_gpu(), get_params,</span><br><span class="line">                      init_rnn_state, rnn)</span><br><span class="line">state = net.begin_state(X.shape[<span class="number">0</span>], try_gpu())</span><br><span class="line">Y, new_state = net(X.to(try_gpu()), state)</span><br><span class="line">Y.shape, <span class="built_in">len</span>(new_state), new_state[<span class="number">0</span>].shape</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(torch.Size([10, 28]), 1, torch.Size([2, 512]))</span><br></pre></td></tr></table></figure><p><font color='DarkViolet'>输出形状是(时间步数×批量大小，词表大小)，隐状态形状保持不变(批量大小，隐藏单元数)</font></p><h3 id="预测-1"><a href="#预测-1" class="headerlink" title="预测"></a>预测</h3><p>首先定义预测函数来生成<code>prefix</code>之后的新字符，其中的<code>prefix</code>是一个用户提供的包含多个字符的字符串，在循环遍历<code>prefix</code>中的开始字符时，不断地将隐状态传递到下一个时间步，但是不生成任何输出</p><p>这被称为**预热(warm-up)**期，在此期间模型会自我更新，但不会进行预测</p><p>预热期结束后，隐状态的值通常比刚开始的初始值更适合预测，从而预测字符并输出它们</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict_ch8</span>(<span class="params">prefix, num_preds, net, vocab, device</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;在prefix后面生成新字符&quot;&quot;&quot;</span></span><br><span class="line">    state = net.begin_state(batch_size=<span class="number">1</span>, device=device) <span class="comment"># 一次只生成一个序列</span></span><br><span class="line">    outputs = [vocab[prefix[<span class="number">0</span>]]] <span class="comment"># 把前缀的第一个字符转成索引</span></span><br><span class="line">    get_input = <span class="keyword">lambda</span>: torch.tensor([outputs[-<span class="number">1</span>]], device=device).reshape((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 让模型根据整个前缀更新隐藏状态，使其“理解上下文”</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> prefix[<span class="number">1</span>:]:  <span class="comment"># 预热期</span></span><br><span class="line">        _, state = net(get_input(), state)</span><br><span class="line">        outputs.append(vocab[y])</span><br><span class="line">    <span class="comment"># 正式预测阶段</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_preds):  <span class="comment"># 预测num_preds步</span></span><br><span class="line">        y, state = net(get_input(), state)</span><br><span class="line">        outputs.append(<span class="built_in">int</span>(y.argmax(dim=<span class="number">1</span>).reshape(<span class="number">1</span>)))</span><br><span class="line">    <span class="comment"># 遍历 outputs 里的所有索引用 vocab.idx_to_token 查回对应字符拼接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([vocab.idx_to_token[i] <span class="keyword">for</span> i <span class="keyword">in</span> outputs])</span><br></pre></td></tr></table></figure><p>将前缀指定为<code>time traveller</code>，并基于这个前缀生成10个后续字符</p><p>还没有训练网络，它会生成荒谬的预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_ch8(<span class="string">&#x27;time traveller &#x27;</span>, <span class="number">10</span>, net, vocab, try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;time traveller pycscscscs&#x27;</span><br></pre></td></tr></table></figure><h3 id="梯度裁剪"><a href="#梯度裁剪" class="headerlink" title="梯度裁剪"></a>梯度裁剪</h3><p>对于长度为$T$序列，在迭代中计算这$T$个时间步上的梯度，将会在反向传播过程中产生长度为$\mathcal{O}(T)$的矩阵乘法链，为了避免$T$较大时导致不稳定，需要额外的方式来支持稳定训练</p><p>如果假设目标函数$f$表现良好，在常数下是<strong>利普希茨连续的(Lipschitz continuous)</strong>，对于任意$x,y$有：<br>$$<br>|f(\mathbf{x}) - f(\mathbf{y})| \leq L \mid\mid\mathbf{x} - \mathbf{y}\mid\mid<br>$$<br>这时可以安全假设<br>$$<br>|f(\mathbf{x}) - f(\mathbf{x} - \eta\mathbf{g})| \leq L \eta||\mathbf{g}||<br>$$<br>这意味着不会观察到超过$L \eta ||\mathbf{g}||$的变化，这限制了变化大小</p><p>有时梯度可能很大，从而优化算法可能无法收敛，可以通过降低学习率来解决这个问题，但这种情况很少发生，一直使用较小的学习率就会让训练速度变得很慢</p><p>一个流行的替代方案是通过将梯度$\mathbf{g}$投影回给定半径$\theta$的球来裁剪梯度<br>$$<br>\mathbf{g} \leftarrow \min\left(1, \frac{\theta}{||\mathbf{g}||}\right) \mathbf{g}.<br>$$<br>这样做梯度的范数永远不会大于$\theta$，更新后的梯度方向与原始梯度保持一致，并且通过限制每个小批量对参数更新的影响，模型的训练过程会更加稳定</p><p>梯度裁剪提供了一个快速修复梯度爆炸的方法，虽然它并不能完全解决问题，但它是众多有效的技术之一</p><p>定义一个函数来裁剪模型的梯度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">grad_clipping</span>(<span class="params">net, theta</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;裁剪梯度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module):</span><br><span class="line">        params = [p <span class="keyword">for</span> p <span class="keyword">in</span> net.parameters() <span class="keyword">if</span> p.requires_grad]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        params = net.params</span><br><span class="line">    norm = torch.sqrt(<span class="built_in">sum</span>(torch.<span class="built_in">sum</span>((p.grad ** <span class="number">2</span>)) <span class="keyword">for</span> p <span class="keyword">in</span> params))</span><br><span class="line">    <span class="keyword">if</span> norm &gt; theta:</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param.grad[:] *= theta / norm</span><br></pre></td></tr></table></figure><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><p>与之前的训练方式有所不同</p><ol><li>序列数据的不同采样方法(随机采样和顺序分区)将导致隐状态初始化的差异</li><li>在更新模型参数之前裁剪梯度，即使训练过程中某个点上发生了梯度爆炸，也能保证模型不会发散</li><li>用困惑度来评价模型</li></ol><p>在顺序分区采样中，只在每个迭代周期开始时初始化隐藏状态，因为下一个小批量与上一个在时间上是连续的，所以上一个小批量最后一个时间步的隐藏状态会被用作下一个小批量的初始状态</p><p>但这样在任何一点隐状态的计算都依赖于同一迭代周期中前面所有的小批量数据，这使得梯度计算变得复杂</p><p>为了降低计算难度，通常在处理每个小批量数据前切断梯度的反向传播，让隐藏状态的梯度计算仅限于当前小批量的时间范围内</p><p>而当使用随机采样时，由于每个小批量样本之间没有时间连续性，必须在每次迭代开始时重新初始化隐藏状态</p><p><code>updater</code>是更新模型参数的常用函数，既可以是自定义函数，也可以是深度学习框架中内置的优化函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_epoch_ch8</span>(<span class="params">net, train_iter, loss, updater, device, use_random_iter</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;训练网络一个迭代周期(定义见第8章)&quot;&quot;&quot;</span></span><br><span class="line">    state, timer = <span class="literal">None</span>, Timer()</span><br><span class="line">    metric = Accumulator(<span class="number">2</span>)  <span class="comment"># 训练损失之和,词元数量</span></span><br><span class="line">    <span class="keyword">for</span> X, Y <span class="keyword">in</span> train_iter:</span><br><span class="line">        <span class="keyword">if</span> state <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> use_random_iter:</span><br><span class="line">            <span class="comment"># 在第一次迭代或使用随机抽样时初始化state</span></span><br><span class="line">            state = net.begin_state(batch_size=X.shape[<span class="number">0</span>], device=device)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(state, <span class="built_in">tuple</span>):</span><br><span class="line">                <span class="comment"># state对于nn.GRU是个张量</span></span><br><span class="line">                state.detach_()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># state对于nn.LSTM或对于我们从零开始实现的模型是个张量</span></span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> state:</span><br><span class="line">                    s.detach_()</span><br><span class="line">        y = Y.T.reshape(-<span class="number">1</span>)</span><br><span class="line">        X, y = X.to(device), y.to(device)</span><br><span class="line">        y_hat, state = net(X, state)</span><br><span class="line">        l = loss(y_hat, y.long()).mean()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(updater, torch.optim.Optimizer):</span><br><span class="line">            updater.zero_grad()</span><br><span class="line">            l.backward()</span><br><span class="line">            grad_clipping(net, <span class="number">1</span>)</span><br><span class="line">            updater.step()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l.backward()</span><br><span class="line">            grad_clipping(net, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 因为已经调用了mean函数</span></span><br><span class="line">            updater(batch_size=<span class="number">1</span>)</span><br><span class="line">        metric.add(l * y.numel(), y.numel())</span><br><span class="line">    <span class="keyword">return</span> math.exp(metric[<span class="number">0</span>] / metric[<span class="number">1</span>]), metric[<span class="number">1</span>] / timer.stop()</span><br></pre></td></tr></table></figure><p>循环神经网络模型的训练函数既支持从零开始实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_ch8</span>(<span class="params">net, train_iter, vocab, lr, num_epochs, device,</span></span><br><span class="line"><span class="params">              use_random_iter=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;训练模型(定义见第8章)&quot;&quot;&quot;</span></span><br><span class="line">    loss = nn.CrossEntropyLoss()</span><br><span class="line">    animator = Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;perplexity&#x27;</span>,</span><br><span class="line">                            legend=[<span class="string">&#x27;train&#x27;</span>], xlim=[<span class="number">10</span>, num_epochs])</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module):</span><br><span class="line">        updater = torch.optim.SGD(net.parameters(), lr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        updater = <span class="keyword">lambda</span> batch_size: sgd(net.params, lr, batch_size)</span><br><span class="line">    predict = <span class="keyword">lambda</span> prefix: predict_ch8(prefix, <span class="number">50</span>, net, vocab, device)</span><br><span class="line">    <span class="comment"># 训练和预测</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        ppl, speed = train_epoch_ch8(</span><br><span class="line">            net, train_iter, loss, updater, device, use_random_iter)</span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(predict(<span class="string">&#x27;time traveller&#x27;</span>))</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>, [ppl])</span><br><span class="line">    animator.show()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;困惑度 <span class="subst">&#123;ppl:<span class="number">.1</span>f&#125;</span>, <span class="subst">&#123;speed:<span class="number">.1</span>f&#125;</span> 词元/秒 <span class="subst">&#123;<span class="built_in">str</span>(device)&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(predict(<span class="string">&#x27;time traveller&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(predict(<span class="string">&#x27;traveller&#x27;</span>))</span><br></pre></td></tr></table></figure><p>训练循环神经网络模型，因为在数据集中只使用了10000个词元，所以模型需要更多的迭代周期来更好地收敛</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510302311.png" alt="202510302311" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">困惑度 1.0, 81491.4 词元/秒 cpu</span><br><span class="line">time traveller with a slight accession ofcheerfulness really thi</span><br><span class="line">travelleryou can show black is white by argument said filby</span><br></pre></td></tr></table></figure><p>检查一下使用随机抽样方法的结果</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251030231642428.png" alt="image-20251030231642428" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">困惑度 1.4, 81358.9 词元/秒 cpu</span><br><span class="line">time traveller smiled abe y ut to she ot soee pincandescendlight</span><br><span class="line">travellerit s against reason said filbywhat for thishing to</span><br></pre></td></tr></table></figure><p>输出结果都很奇怪</p><h2 id="循环神经网络的简洁实现"><a href="#循环神经网络的简洁实现" class="headerlink" title="循环神经网络的简洁实现"></a>循环神经网络的简洁实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>高级API提供了循环神经网络的实现，构造一个具有256个隐藏单元的单隐藏层的循环神经网络层<code>rnn_layer</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_hiddens = <span class="number">256</span></span><br><span class="line">rnn_layer = nn.RNN(<span class="built_in">len</span>(vocab), num_hiddens)</span><br></pre></td></tr></table></figure><p>使用张量来初始化隐状态，它的形状是(隐藏层数，批量大小，隐藏单元数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state = torch.zeros((<span class="number">1</span>, batch_size, num_hiddens))</span><br><span class="line">state.shape  <span class="comment"># torch.Size([1, 32, 256])</span></span><br></pre></td></tr></table></figure><p>通过一个隐状态和一个输入，就可以用更新后的隐状态计算输出</p><p><code>rnn_layer</code>的“输出”(<code>Y</code>)不涉及输出层的计算：它是指每个时间步的隐状态，这些隐状态可以用作后续输出层的输入</p><table><thead><tr><th>输出</th><th>含义</th><th>形状</th></tr></thead><tbody><tr><td><code>Y</code></td><td>每个时间步的输出序列</td><td><code>(num_steps, batch_size, num_hiddens)</code></td></tr><tr><td><code>state_new</code></td><td>最后一个时间步的隐藏状态</td><td><code>(num_layers, batch_size, num_hiddens)</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(num_steps, batch_size, <span class="built_in">len</span>(vocab))) <span class="comment"># 时间步数，样本数，词表大小</span></span><br><span class="line">Y, state_new = rnn_layer(X, state)</span><br><span class="line">Y.shape, state_new.shape</span><br><span class="line"><span class="comment"># (torch.Size([35, 32, 256]), torch.Size([1, 32, 256]))</span></span><br></pre></td></tr></table></figure><p>为一个完整的循环神经网络模型定义了一个<code>RNNModel</code>类，注意<code>rnn_layer</code>只包含隐藏的循环层，还需要创建一个单独的输出层</p><table><thead><tr><th>模块</th><th>功能</th><th>输入形状</th><th>输出形状</th></tr></thead><tbody><tr><td>One-hot 编码</td><td>把索引变成向量</td><td><code>(num_steps, batch_size)</code></td><td><code>(num_steps, batch_size, vocab_size)</code></td></tr><tr><td>RNN 层</td><td>提取时序特征</td><td>上一步输出</td><td><code>(num_steps, batch_size, num_hiddens)</code></td></tr><tr><td>Linear 层</td><td>预测下一个词</td><td><code>(num_steps * batch_size, num_hiddens)</code></td><td><code>(num_steps * batch_size, vocab_size)</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RNNModel</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;循环神经网络模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rnn_layer, vocab_size, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs) <span class="comment"># 允许传入额外参数，灵活扩展</span></span><br><span class="line">        <span class="variable language_">self</span>.rnn = rnn_layer <span class="comment"># 传入已经定义好的循环层</span></span><br><span class="line">        <span class="variable language_">self</span>.vocab_size = vocab_size <span class="comment"># 词表大小(用于输出层维度)</span></span><br><span class="line">        <span class="variable language_">self</span>.num_hiddens = <span class="variable language_">self</span>.rnn.hidden_size <span class="comment"># 隐藏层的维度</span></span><br><span class="line">        <span class="comment"># 判断是否双向，与输出维度有关</span></span><br><span class="line">        <span class="comment"># RNN 负责“记忆”，Linear 负责“说出预测结果”</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.rnn.bidirectional:</span><br><span class="line">            <span class="variable language_">self</span>.num_directions = <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.linear = nn.Linear(<span class="variable language_">self</span>.num_hiddens, <span class="variable language_">self</span>.vocab_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.num_directions = <span class="number">2</span></span><br><span class="line">            <span class="variable language_">self</span>.linear = nn.Linear(<span class="variable language_">self</span>.num_hiddens * <span class="number">2</span>, <span class="variable language_">self</span>.vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs, state</span>):</span><br><span class="line">        <span class="comment"># 输入 inputs 的形状是 (batch_size, num_steps)</span></span><br><span class="line">        X = F.one_hot(inputs.T.long(), <span class="variable language_">self</span>.vocab_size)</span><br><span class="line">        X = X.to(torch.float32)</span><br><span class="line">        Y, state = <span class="variable language_">self</span>.rnn(X, state)</span><br><span class="line">        <span class="comment"># Y：每个时间步的输出(num_steps, batch_size, num_hiddens * num_directions)</span></span><br><span class="line">        <span class="comment"># 全连接层首先将Y的形状改为(时间步数*批量大小,隐藏单元数)</span></span><br><span class="line">        <span class="comment"># 输出形状是(时间步数*批量大小,词表大小)。</span></span><br><span class="line">        output = <span class="variable language_">self</span>.linear(Y.reshape((-<span class="number">1</span>, Y.shape[-<span class="number">1</span>])))</span><br><span class="line">        <span class="keyword">return</span> output, state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">begin_state</span>(<span class="params">self, device, batch_size=<span class="number">1</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(<span class="variable language_">self</span>.rnn, nn.LSTM):</span><br><span class="line">            <span class="comment"># nn.GRU以张量作为隐状态</span></span><br><span class="line">            <span class="keyword">return</span>  torch.zeros((<span class="variable language_">self</span>.num_directions * <span class="variable language_">self</span>.rnn.num_layers,</span><br><span class="line">                                 batch_size, <span class="variable language_">self</span>.num_hiddens),</span><br><span class="line">                                device=device)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># nn.LSTM以元组作为隐状态</span></span><br><span class="line">            <span class="keyword">return</span> (torch.zeros((</span><br><span class="line">                <span class="variable language_">self</span>.num_directions * <span class="variable language_">self</span>.rnn.num_layers,</span><br><span class="line">                batch_size, <span class="variable language_">self</span>.num_hiddens), device=device),</span><br><span class="line">                    torch.zeros((</span><br><span class="line">                        <span class="variable language_">self</span>.num_directions * <span class="variable language_">self</span>.rnn.num_layers,</span><br><span class="line">                        batch_size, <span class="variable language_">self</span>.num_hiddens), device=device))</span><br></pre></td></tr></table></figure><h3 id="训练与预测"><a href="#训练与预测" class="headerlink" title="训练与预测"></a>训练与预测</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">device = try_gpu()</span><br><span class="line">net = RNNModel(rnn_layer, vocab_size=<span class="built_in">len</span>(vocab))</span><br><span class="line">net = net.to(device)</span><br><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line">train_ch8(net, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251030233533524.png" alt="image-20251030233533524" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">困惑度 1.3, 196616.9 词元/秒 cpu</span><br><span class="line">time traveller but now you begin to seethe object of my investig</span><br><span class="line">traveller pores ththo dimensions are pussing ain time ascon</span><br></pre></td></tr></table></figure><p>与刚刚自定义的随机抽样方法相比，由于深度学习框架的高级API对代码进行了更多的优化，该模型在较短的时间内达到了较低的困惑度</p><h2 id="通过时间反向传播"><a href="#通过时间反向传播" class="headerlink" title="通过时间反向传播"></a>通过时间反向传播</h2><p>RNN的训练基于<strong>时间反向传播(backpropagation through time，BPTT)</strong>(Werbos, 1990)，利用链式法则计算序列中每个时间步的梯度</p><p>要求将循环神经网络的计算图一次展开一个时间步，以获得模型变量和参数之间的依赖关系</p><p>但在长序列中，梯度会出现爆炸或消失，因此在实践中通过截断传播与梯度裁剪来保证模型稳定收敛</p><h3 id="梯度分析"><a href="#梯度分析" class="headerlink" title="梯度分析"></a>梯度分析</h3><p>输入和隐状态可以拼接后与隐藏层中的一个权重变量相乘，分别使用$w_h$和$w_o$来表示隐藏层和输出层的权重，每个时间步的隐状态和输出可以写为：<br>$$<br>\begin{split}\begin{aligned}h_t &amp;&#x3D; f(x_t, h_{t-1}, w_h),\\o_t &amp;&#x3D; g(h_t, w_o),\end{aligned}\end{split}<br>$$<br>有一个链${\ldots, (x_{t-1}, h_{t-1}, o_{t-1}), (x_{t}, h_{t}, o_t), \ldots}$通过循环计算彼此依赖，前向传播相当简单，一次一个时间步的遍历三元组，然后通过一个目标函数在所有$T$个时间步内评估输出和对应的标签之间的差异<br>$$<br>L(x_1, \ldots, x_T, y_1, \ldots, y_T, w_h, w_o) &#x3D; \frac{1}{T}\sum_{t&#x3D;1}^T l(y_t, o_t).<br>$$<br>对于反向传播需要根据链式法则：<br>$$<br>\begin{split}\begin{aligned}\frac{\partial L}{\partial w_h}  &amp; &#x3D; \frac{1}{T}\sum_{t&#x3D;1}^T \frac{\partial l(y_t, o_t)}{\partial w_h}  \\&amp; &#x3D; \frac{1}{T}\sum_{t&#x3D;1}^T \frac{\partial l(y_t, o_t)}{\partial o_t} \frac{\partial g(h_t, w_o)}{\partial h_t}  \frac{\partial h_t}{\partial w_h}.\end{aligned}\end{split}<br>$$<br>乘积的第一项和第二项很容易计算，而第三项是困难所在，需要循环地计算参数$w_h$对$h_t$的影响</p><p>$h_t$既依赖于$h_{t-1}$又依赖于$w_h$，$h_{t-1}$的计算也依赖于$w_h$，使用链式法则产生：<br>$$<br>\frac{\partial h_t}{\partial w_h}&#x3D; \frac{\partial f(x_{t},h_{t-1},w_h)}{\partial w_h} +\frac{\partial f(x_{t},h_{t-1},w_h)}{\partial h_{t-1}} \frac{\partial h_{t-1}}{\partial w_h}.<br>$$<br>假设有三个序列${a_{t}},{b_{t}},{c_{t}}$，当$t&#x3D;1,2,\ldots$时，序列满足$a_{0}&#x3D;0$且$a_{t}&#x3D;b_{t}+c_{t}a_{t-1}$，对于$t\geq 1$就很容易得出：<br>$$<br>a_{t}&#x3D;b_{t}+\sum_{i&#x3D;1}^{t-1}\left(\prod_{j&#x3D;i+1}^{t}c_{j}\right)b_{i}.<br>$$<br>基于下列公式替换<br>$$<br>\begin{split}\begin{aligned}a_t &amp;&#x3D; \frac{\partial h_t}{\partial w_h},\\<br>b_t &amp;&#x3D; \frac{\partial f(x_{t},h_{t-1},w_h)}{\partial w_h}, \\<br>c_t &amp;&#x3D; \frac{\partial f(x_{t},h_{t-1},w_h)}{\partial h_{t-1}},\end{aligned}\end{split}<br>$$<br>所以刚刚那个复杂的链式法则可以转换为<br>$$<br>\frac{\partial h_t}{\partial w_h}&#x3D;\frac{\partial f(x_{t},h_{t-1},w_h)}{\partial w_h}+\sum_{i&#x3D;1}^{t-1}\left(\prod_{j&#x3D;i+1}^{t} \frac{\partial f(x_{j},h_{j-1},w_h)}{\partial h_{j-1}} \right) \frac{\partial f(x_{i},h_{i-1},w_h)}{\partial w_h}.<br>$$<br>虽然这样可以计算了，但是$t$很大时这个链会很长</p><h4 id="截断时间步"><a href="#截断时间步" class="headerlink" title="截断时间步"></a>截断时间步</h4><p>在$\tau$步后截断求和计算，在实践中这种方式工作得很好，通常被称为截断的通过时间反向传播 (Jaeger, 2002)</p><p>这样做导致该模型主要侧重于短期影响，而不是长期影响，这在现实中是可取的，因为它会将估计值偏向更简单和更稳定的模型</p><h4 id="随机截断"><a href="#随机截断" class="headerlink" title="随机截断"></a>随机截断</h4><p>可以用一个随机变量替换$\partial h_t&#x2F;\partial w_h$，该随机变量在预期中是正确的，但是会截断序列</p><p>通过使用序列$\xi_t$来实现，$0 \leq \pi_t \leq 1$，$P(\xi_t &#x3D; 0) &#x3D; 1-\pi_t$，期望$E[\xi_t] &#x3D; 1$，保证整个过程在期望意义上仍是无偏估计</p><p>使用它来替换$\partial h_t&#x2F;\partial w_h$<br>$$<br>z_t&#x3D; \frac{\partial f(x_{t},h_{t-1},w_h)}{\partial w_h} +\xi_t \frac{\partial f(x_{t},h_{t-1},w_h)}{\partial h_{t-1}} \frac{\partial h_{t-1}}{\partial w_h}.<br>$$<br>每当$\xi_t &#x3D; 0$时，递归计算终止在这个时间步，这导致了不同长度序列的加权和，长序列的梯度被截断得更频繁，短序列则更多被完整传播，因此这种方法相当于自适应加权不同长度的梯度贡献</p><p>这个想法是由塔莱克和奥利维尔(Tallec and Ollivier, 2017)提出的</p><h4 id="比较策略"><a href="#比较策略" class="headerlink" title="比较策略"></a>比较策略</h4><p>比较RNN中计算梯度的策略，3行自上而下分别为：随机截断、常规截断、完整计算</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/truncated-bptt.jpg" alt="truncated-bptt" style="zoom:80%;" /><ul><li>随机截断：将文本划分为不同长度的片断</li><li>常规截断：将文本分解为相同长度的子序列，这也是在循环神经网络实验中一直在做的</li><li>通过时间的完全反向传播：产生了在计算上不可行的表达式</li></ul><p>虽然随机截断在理论上具有吸引力，但很可能是由于多种因素在实践中并不比常规截断更好</p><h2 id="门控循环单元-GRU"><a href="#门控循环单元-GRU" class="headerlink" title="门控循环单元(GRU)"></a>门控循环单元(GRU)</h2><p>普通 RNN 缺乏对“重要信息的记忆”和“无关信息的屏蔽”能力</p><p>三类经典问题：</p><ul><li>需要长期记忆：早期观测(如第一个词元)对后续预测至关重要，普通 RNN 难以让这种早期信息在数百步后仍然“保留”，这会导致梯度必须极大才能维持影响，从而引发梯度爆炸</li><li>需要遗忘无关信息：某些输入与任务无关，例如网页文本中的 HTML 标签，RNN没法“跳过”这些噪声，它会无差别地更新隐状态，让无意义的信息污染记忆，降低模型性能，需要选择性屏蔽</li><li>需要重置记忆：序列中存在逻辑中断或上下文变化，旧的隐藏状态可能对新片段产生负面干扰，需要自适应地清空或重置内部状态</li></ul><p>在学术界已经提出了许多方法来解决这类问题，其中最早的方法是“长短期记忆”(long-short-term memory，LSTM) (Hochreiter and Schmidhuber, 1997)，门控循环单元(gated recurrent unit，GRU)(Cho <em>et al.</em>, 2014) 是一个稍微简化的变体，通常能够提供同等的效果，并且计算(Chung <em>et al.</em>, 2014)的速度明显更快</p><h3 id="门控隐状态"><a href="#门控隐状态" class="headerlink" title="门控隐状态"></a>门控隐状态</h3><p>门控循环单元(GRU)与普通循环神经网络的主要区别在于：它增加了门控机制，能自动学习在什么时候更新或重置隐藏状态，从而更好地控制信息的保留与遗忘</p><h4 id="重置门和更新门"><a href="#重置门和更新门" class="headerlink" title="重置门和更新门"></a>重置门和更新门</h4><p>**重置门(reset gate)<strong>和</strong>更新门(update gate)**是$(0,1)$区间的向量，可以对旧状态和新状态进行加权融合(凸组合)</p><p>重置门控制要保留多少来自过去的记忆；更新门控制当前状态中有多少直接来自旧状态</p><p>下图描述了门控循环单元中的重置门和更新门的输入，输入是当前输入和前一时刻的隐藏状态，输出由带sigmoid激活函数的全连接层计算得到</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/gru-1.jpg" alt="gru-1" style="zoom:80%;" /><p>假设输入是一个小批量$\mathbf X_t \in \mathbb R^{n \times d}$，样本个数为$n$，输入特征维度$d$，上一个时间步的隐状态是$\mathbf H_{t-1} \in \mathbb R^{n \times h}$</p><p>那么重置门$\mathbf R_t \in \mathbb R^{n \times h}$和更新门$\mathbf Z_t \in \mathbb{R}^{n \times h}$的计算如下所示<br>$$<br>\begin{split}\begin{aligned}<br>\mathbf R_t &#x3D; \sigma(\mathbf X_t \mathbf W_{xr} + \mathbf H_{t-1} \mathbf W_{hr} + \mathbf b_r)\\<br>\mathbf Z_t &#x3D; \sigma(\mathbf X_t \mathbf W_{xz} + \mathbf H_{t-1} \mathbf W_{hz} + \mathbf b_z)<br>\end{aligned}\end{split}<br>$$<br>其中$\mathbf W_{xr}, \mathbf W_{xz} \in \mathbb{R}^{d \times h}$和$\mathbf W_{hr}, \mathbf W_{hz} \in \mathbb{R}^{h \times h}$是权重参数，$\mathbf b_r, \mathbf b_z \in \mathbb{R}^{1 \times h}$是偏置参数，使用sigmoid函数将输出值转换到区间$(0,1)$</p><h4 id="候选隐状态"><a href="#候选隐状态" class="headerlink" title="候选隐状态"></a>候选隐状态</h4><p>将重置门$\mathbf R_t$与常规隐状态更新机制集成，得到在时间步$t$的<strong>候选隐状态(candidate hidden state)</strong>$\tilde H_t \in \mathbb R^{n \times h}$<br>$$<br>\tilde H_t &#x3D; \tanh(\mathbf X_t \mathbf W_{xh} + \left(\mathbf R_t \odot \mathbf H_{t-1}\right) \mathbf W_{hh} + \mathbf b_h),<br>$$<br>符号$\odot$是Hadamard积(按元素乘积)运算符，使用tanh非线性激活函数来确保候选隐状态中的值保持在区间$(-1,1)$</p><p>$\mathbf R_t$和$\mathbf H_{t-1}$的元素相乘可以减少以往状态的影响</p><ul><li>重置门$\mathbf R_t$中的项接近1时，恢复普通的循环神经网络</li><li>重置门$\mathbf R_t$中的项接近0时，候选隐状态是以$\mathbf X_t$作为输入的多层感知机的结果，因此任何预先存在的隐状态都会被重置为默认值</li></ul><p>下图说明了应用重置门之后的计算流程</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/gru-2.jpg" alt="gru-2" style="zoom:80%;" /><h4 id="隐状态-1"><a href="#隐状态-1" class="headerlink" title="隐状态"></a>隐状态</h4><p>上述的计算结果只是候选隐状态，仍然需要结合更新门$\mathbf Z_t$的效果，这一步确定新的隐状态$\mathbf H_t \in \mathbb{R}^{n \times h}$在多大程度上来自旧的状态$\mathbf H_{t-1}$和新的候选状态$\tilde H_t $，更新门仅实现凸组合，得出了门控循环单元的最终更新公式：<br>$$<br>\mathbf H_t &#x3D; \mathbf Z_t \odot \mathbf H_{t-1}  + (1 - \mathbf Z_t) \odot \tilde{\mathbf H}_t.<br>$$</p><ul><li>更新门$\mathbf Z_t$接近1时，模型就倾向只保留旧状态，来自$\mathbf X_t$的信息被忽略，从而有效地跳过了依赖链条中的时间步</li><li>更新门$\mathbf Z_t$接近0时，新的隐状态就会接近候选隐状态</li></ul><p>这些设计可以帮助处理循环神经网络中的梯度消失问题，并更好地捕获时间步距离很长的序列的依赖关系</p><p>如果整个子序列的所有时间步的更新门都接近于1，无论序列的长度如何，在序列起始时间步的隐状态将很容易保留并传递到序列结束</p><p>下图说明了更新门起作用后的计算流</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/gru-3.jpg" alt="gru-3" style="zoom:80%;" /><p>总结：</p><p>门控循环单元具有以下两个显著特征</p><ul><li>重置门有助于捕获序列中的短期依赖关系</li><li>更新门有助于捕获序列中的长期依赖关系</li></ul><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>读取之前使用的时间机器数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure><h4 id="初始化模型参数-1"><a href="#初始化模型参数-1" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h4><p>从<strong>标准差为0.01</strong>的高斯分布中提取权重，并将偏置项设为0，超参数<code>num_hiddens</code>定义隐藏单元的数量， 实例化与更新门、重置门、候选隐状态和输出层相关的所有权重和偏置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_params</span>(<span class="params">vocab_size, num_hiddens, device</span>):</span><br><span class="line">    <span class="comment"># 输入和输出的维度都等于词表大小(因为这是语言模型)</span></span><br><span class="line">    num_inputs = num_outputs = vocab_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normal</span>(<span class="params">shape</span>):</span><br><span class="line">        <span class="comment"># 从标准正态分布采样，并缩放为较小的随机值(标准差=0.01)</span></span><br><span class="line">        <span class="keyword">return</span> torch.randn(size=shape, device=device) * <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">three</span>():</span><br><span class="line">        <span class="comment"># 返回一组循环层参数：(W_x, W_h, b)</span></span><br><span class="line">        <span class="comment"># 分别对应：输入权重矩阵、隐藏状态权重矩阵、偏置项</span></span><br><span class="line">        <span class="keyword">return</span> (normal((num_inputs, num_hiddens)),   <span class="comment"># W_x* — 输入到隐藏层</span></span><br><span class="line">                normal((num_hiddens, num_hiddens)),  <span class="comment"># W_h* — 隐藏层到隐藏层</span></span><br><span class="line">                torch.zeros(num_hiddens, device=device))  <span class="comment"># b* — 偏置项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---- 门控循环单元的参数 ----</span></span><br><span class="line">    <span class="comment"># 更新门 (update gate) 参数</span></span><br><span class="line">    W_xz, W_hz, b_z = three()</span><br><span class="line">    <span class="comment"># 重置门 (reset gate) 参数</span></span><br><span class="line">    W_xr, W_hr, b_r = three()</span><br><span class="line">    <span class="comment"># 候选隐状态 (candidate hidden state) 参数</span></span><br><span class="line">    W_xh, W_hh, b_h = three()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出层参数(将隐藏状态映射到词表维度)</span></span><br><span class="line">    W_hq = normal((num_hiddens, num_outputs)) </span><br><span class="line">    b_q = torch.zeros(num_outputs, device=device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---- 收集全部可训练参数 ----</span></span><br><span class="line">    params = [W_xz, W_hz, b_z,</span><br><span class="line">              W_xr, W_hr, b_r,</span><br><span class="line">              W_xh, W_hh, b_h,</span><br><span class="line">              W_hq, b_q]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启用自动梯度跟踪</span></span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> params</span><br></pre></td></tr></table></figure><h4 id="定义模型-1"><a href="#定义模型-1" class="headerlink" title="定义模型"></a>定义模型</h4><p>定义隐状态的初始化函数<code>init_gru_state</code>，与之前定义的<code>init_rnn_state</code>函数一样，此函数返回一个形状为(批量大小，隐藏单元个数)的张量，张量的值全部为零</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_gru_state</span>(<span class="params">batch_size, num_hiddens, device</span>):</span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device), )</span><br></pre></td></tr></table></figure><p>准备定义门控循环单元模型，模型的架构与基本的循环神经网络单元是相同的，只是权重更新公式更为复杂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gru</span>(<span class="params">inputs, state, params</span>):</span><br><span class="line">    W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q = params</span><br><span class="line">    H, = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        Z = torch.sigmoid((X @ W_xz) + (H @ W_hz) + b_z)</span><br><span class="line">        R = torch.sigmoid((X @ W_xr) + (H @ W_hr) + b_r)</span><br><span class="line">        H_tilda = torch.tanh((X @ W_xh) + ((R * H) @ W_hh) + b_h)</span><br><span class="line">        H = Z * H + (<span class="number">1</span> - Z) * H_tilda</span><br><span class="line">        Y = H @ W_hq + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">0</span>), (H,) <span class="comment"># 习惯写法，因为LSTM(H,C)</span></span><br></pre></td></tr></table></figure><h4 id="训练与预测-1"><a href="#训练与预测-1" class="headerlink" title="训练与预测"></a>训练与预测</h4><p>训练和预测的工作方式与普通RNN完全相同</p><p>训练结束后，分别打印输出训练集的困惑度，以及前缀“time traveler”和“traveler”的预测序列上的困惑度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vocab_size, num_hiddens, device = <span class="built_in">len</span>(vocab), <span class="number">256</span>, try_gpu()</span><br><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line">model = RNNModelScratch(<span class="built_in">len</span>(vocab), num_hiddens, device, get_params,</span><br><span class="line">                            init_gru_state, gru)</span><br><span class="line">train_ch8(model, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510311655.png" alt="202510311655" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">困惑度 1.1, 57687.6 词元/秒 cpu</span><br><span class="line">time traveller for so it will be convenient to speak of himwas e</span><br><span class="line">travelleryou can show black is white by argument said filby</span><br></pre></td></tr></table></figure><h3 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h3><p>高级API包含了前文介绍的所有配置细节，可以直接实例化门控循环单元模型</p><p>这段代码的运行速度要快得多，因为它使用的是编译好的运算符而不是Python来处理之前阐述的许多细节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_inputs = vocab_size</span><br><span class="line">gru_layer = nn.GRU(num_inputs, num_hiddens)</span><br><span class="line">model = RNNModel(gru_layer, <span class="built_in">len</span>(vocab))</span><br><span class="line">model = model.to(device)</span><br><span class="line">train_ch8(model, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251101151204768.png" alt="image-20251101151204768" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">困惑度 1.0, 85331.8 词元/秒 cpu</span><br><span class="line">time travelleryou can show black is white by argument said filby</span><br><span class="line">travelleryou can show black is white by argument said filby</span><br></pre></td></tr></table></figure><p>虽然困惑度降到1.0了，但是训练样本少，模型还没泛化，输出句子只是记忆，不是真正语言建模的泛化效果</p><h2 id="长短期记忆网络-LSTM"><a href="#长短期记忆网络-LSTM" class="headerlink" title="长短期记忆网络(LSTM)"></a>长短期记忆网络(LSTM)</h2><p>隐变量模型存在着长期信息保存和短期输入缺失的问题，解决这一问题的最早方法之一是长短期存储器**(long short-term memory，LSTM)**(Hochreiter and Schmidhuber, 1997)</p><p>它有许多与门控循环单元一样的属性，但长短期记忆网络的设计比门控循环单元稍微复杂一些，却比门控循环单元早诞生了近20年</p><h3 id="门控记忆元"><a href="#门控记忆元" class="headerlink" title="门控记忆元"></a>门控记忆元</h3><p>LSTM的设计灵感源自计算机中的逻辑门结构，它在传统循环神经网络的基础上，引入了一个用于保存信息的<strong>记忆元(memory cell)</strong>，简称为<strong>单元(cell)</strong></p><p>有些文献认为，记忆元是一种特殊形式的隐状态，与隐状态具有相同的形状，但专门用于长期信息的保存</p><p>为了有效地控制记忆元的信息流动，LSTM 设计了多种门机制</p><ul><li><strong>输入门(input gate)</strong>：决定何时将新的信息写入单元；</li><li><strong>遗忘门(forget gate)</strong>：决定何时清除旧的信息；</li><li><strong>输出门(output gate)</strong>：控制何时从单元中输出信息</li></ul><h4 id="门机制"><a href="#门机制" class="headerlink" title="门机制"></a>门机制</h4><p>就如在门控循环单元中一样，当前时间步的输入和前一个时间步的隐状态作为数据送入长短期记忆网络的门中，它们由三个具有sigmoid激活函数的全连接层处理，以计算输入门、遗忘门和输出门的值</p><p>这三个门的值都在(0,1)范围内</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/lstm-0.jpg" alt="lstm-0" style="zoom:80%;" /><p>假设有$h$个隐藏单元，批量大小为$n$，输入数为$d$，输入为$\mathbf X_t \in \mathbb{R}^{n \times d}$，前一时间步的隐状态为$\mathbf H_{t-1} \in \mathbb{R}^{n \times h}$，相应的输入门是$\mathbf I_t \in \mathbb{R}^{n \times h}$，遗忘门是$\mathbf F_t \in \mathbb{R}^{n \times h}$，输出门是$\mathbf O_t \in \mathbb{R}^{n \times h}$</p><p>它们的计算方法如下：<br>$$<br>\begin{split}\begin{aligned}<br>\mathbf I_t &amp;&#x3D; \sigma(\mathbf X_t \mathbf W_{xi} + \mathbf H_{t-1} \mathbf W_{hi} + \mathbf b_i),\\<br>\mathbf F_t &amp;&#x3D; \sigma(\mathbf X_t \mathbf W_{xf} + \mathbf H_{t-1} \mathbf W_{hf} + \mathbf b_f),\\<br>\mathbf O_t &amp;&#x3D; \sigma(\mathbf X_t \mathbf W_{xo} + \mathbf H_{t-1} \mathbf W_{ho} + \mathbf b_o),<br>\end{aligned}\end{split}<br>$$<br>其中$\mathbf W_{xi}, \mathbf W_{xf}, \mathbf W_{xo} \in \mathbb{R}^{d \times h}$，$\mathbf W_{hi}, \mathbf W_{hf}, \mathbf W_{ho} \in \mathbb{R}^{h \times h}$</p><h4 id="候选记忆元"><a href="#候选记忆元" class="headerlink" title="候选记忆元"></a>候选记忆元</h4><p><strong>候选记忆元(candidate memory cell)</strong>$\tilde{\mathbf C}_t \in \mathbb{R}^{n \times h}$</p><p>它的计算与上面描述的三个门的计算类似，但是使用$\tanh$函数作为激活函数，函数的值范围为(-1,1)<br>$$<br>\bf\tilde{C_t} &#x3D; \text{tanh}(\mathbf X_t \mathbf W_{xc} + \mathbf H_{t-1} \mathbf W_{hc} + \mathbf b_c),<br>$$<br>候选记忆元如图所示</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/lstm-1.jpg" alt="lstm-1" style="zoom:80%;" /><h4 id="记忆元"><a href="#记忆元" class="headerlink" title="记忆元"></a>记忆元</h4><p>在门控循环单元中，有一种机制来控制输入和遗忘(或跳过)，在长短期记忆网络中，也有两个门用于这样的目的<br>$$<br>\mathbf C_t &#x3D; \mathbf F_t \odot \mathbf C_{t-1} + \mathbf I_t \odot \bf\tilde{C_t}<br>$$<br>如果遗忘门始终为1且输入门始终为0，则过去的记忆元$\mathbf C_{t-1}$将随时间被保存并传递到当前时间步</p><p>引入这种设计是为了缓解梯度消失问题，并更好地捕获序列中的长距离依赖关系</p><p>这样就得到了计算记忆元的流程图</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/lstm-2.jpg" alt="lstm-2" style="zoom:80%;" /><h4 id="隐状态-2"><a href="#隐状态-2" class="headerlink" title="隐状态"></a>隐状态</h4><p>需要定义如何计算隐状态$\mathbf H_t \in \mathbb{R}^{n \times h}$，这就是输出门发挥作用的地方</p><p>在长短期记忆网络中，隐状态是“经过输出门调制的记忆元快照”，是记忆元的$\tanh$的门控版本，确保$\mathbf H_t$的值始终在区间(-1,1)内<br>$$<br>\mathbf H_t &#x3D; \mathbf O_t \odot \tanh(\mathbf C_t).<br>$$<br>只要输出门接近1，就能够有效地将所有记忆信息传递给预测部分，而对于输出门接近0，只保留记忆元内的所有信息，而不需要更新隐状态</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/lstm-3.jpg" alt="lstm-3" style="zoom:80%;" /><p>输出表示为：<br>$$<br>\mathbf Y_t &#x3D; \mathbf H_t \mathbf W_{hq} +\mathbf b_q<br>$$</p><h4 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h4><table><thead><tr><th>组件</th><th>功能</th><th>类比</th></tr></thead><tbody><tr><td>遗忘门</td><td>决定丢弃多少旧记忆</td><td>清空一部分硬盘内容</td></tr><tr><td>输入门</td><td>决定写入多少新信息</td><td>把新数据写入硬盘</td></tr><tr><td>候选记忆</td><td>新的候选内容</td><td>新文件内容</td></tr><tr><td>记忆元</td><td>存储长期信息</td><td>硬盘本体</td></tr><tr><td>输出门</td><td>控制输出多少记忆</td><td>决定要不要从硬盘读出来</td></tr><tr><td>隐状态</td><td>当前对外可见的输出</td><td>屏幕上显示的内容</td></tr></tbody></table><p>与 GRU 的对比</p><table><thead><tr><th>特征</th><th>LSTM</th><th>GRU</th></tr></thead><tbody><tr><td>门数量</td><td>3 个(输入、遗忘、输出)</td><td>2 个(重置、更新)</td></tr><tr><td>记忆元</td><td>独立</td><td>与隐状态合一</td></tr><tr><td>结构复杂度</td><td>稍高，性能更强</td><td>简洁高效，参数更少</td></tr><tr><td>学习能力</td><td>适合复杂依赖</td><td>适合中短期依赖</td></tr></tbody></table><p>输出门的存在是为了控制信息暴露：</p><ul><li>当网络认为当前时刻的信息还不成熟或不重要时，关上输出门；</li><li>这样隐状态不会被下游层使用；</li><li>但记忆元仍然积累经验，为未来的时间步准备</li></ul><p>这种设计是 LSTM 相比 GRU 更“细腻”的地方：它能明确地区分“内部记忆”和“外部输出”</p><h3 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure><h4 id="初始化模型参数-2"><a href="#初始化模型参数-2" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h4><p>超参数<code>num_hiddens</code>定义隐藏单元的数量，按照标准差0.01的高斯分布初始化权重，并将偏置项设为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化网络参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_lstm_params</span>(<span class="params">vocab_size, num_hiddens, device</span>):</span><br><span class="line">    num_inputs = num_outputs = vocab_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normal</span>(<span class="params">shape</span>):</span><br><span class="line">        <span class="keyword">return</span> torch.randn(size = shape, device=device)*<span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">three</span>():</span><br><span class="line">        <span class="keyword">return</span> (normal((num_inputs, num_hiddens)),</span><br><span class="line">                normal((num_hiddens, num_hiddens)),</span><br><span class="line">                torch.zeros(num_hiddens, device=device))</span><br><span class="line"></span><br><span class="line">    W_xi, W_hi, b_i = three()  <span class="comment"># 输入门参数</span></span><br><span class="line">    W_xf, W_hf, b_f = three()  <span class="comment"># 遗忘门参数</span></span><br><span class="line">    W_xo, W_ho, b_o = three()  <span class="comment"># 输出门参数</span></span><br><span class="line">    W_xc, W_hc, b_c = three()  <span class="comment"># 候选记忆元参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出层参数</span></span><br><span class="line">    W_hq = normal((num_hiddens, num_outputs))</span><br><span class="line">    b_q = torch.zeros(num_outputs, device=device)</span><br><span class="line">    <span class="comment"># 加上梯度</span></span><br><span class="line">    params = [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc, b_c, W_hq, b_q]</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> params</span><br></pre></td></tr></table></figure><h4 id="定义模型-2"><a href="#定义模型-2" class="headerlink" title="定义模型"></a>定义模型</h4><p>在初始化函数中，长短期记忆网络需要初始化隐藏状态和记忆元，单元的值为0，形状均为(batch_size, num_hiddens)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化隐藏状态和记忆元</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_lstm_state</span>(<span class="params">batch_size, num_hiddens, device</span>):</span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device),</span><br><span class="line">            torch.zeros((batch_size, num_hiddens), device=device))</span><br></pre></td></tr></table></figure><p>实际模型的定义与前面讨论的一样：提供三个门和一个额外的记忆元，只有隐状态才会传递到输出层，而记忆元不直接参与输出计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lstm</span>(<span class="params">inputs, state, params</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        inputs: 输入序列，形状为 (num_steps, batch_size, input_size)</span></span><br><span class="line"><span class="string">        state:  初始状态 (H, C)</span></span><br><span class="line"><span class="string">        params: 所有模型参数(权重与偏置)，包含14个张量</span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        outputs: 所有时间步的输出拼接结果</span></span><br><span class="line"><span class="string">        (H, C): 当前时间步的隐状态和记忆元，用于下一批次</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 解包参数，对应四个门 + 输出层</span></span><br><span class="line">    [W_xi, W_hi, b_i,      <span class="comment"># 输入门参数</span></span><br><span class="line">     W_xf, W_hf, b_f,      <span class="comment"># 遗忘门参数</span></span><br><span class="line">     W_xo, W_ho, b_o,      <span class="comment"># 输出门参数</span></span><br><span class="line">     W_xc, W_hc, b_c,      <span class="comment"># 候选记忆参数</span></span><br><span class="line">     W_hq, b_q] = params   <span class="comment"># 输出层参数(hidden → output)</span></span><br><span class="line">    </span><br><span class="line">    (H, C) = state</span><br><span class="line">    outputs = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        I = torch.sigmoid((X @ W_xi) + (H @ W_hi) + b_i)</span><br><span class="line">        F = torch.sigmoid((X @ W_xf) + (H @ W_hf) + b_f)</span><br><span class="line">        O = torch.sigmoid((X @ W_xo) + (H @ W_ho) + b_o)</span><br><span class="line">        C_tilda = torch.tanh((X @ W_xc) + (H @ W_hc) + b_c)</span><br><span class="line">        C = F * C + I * C_tilda</span><br><span class="line">        H = O * torch.tanh(C)</span><br><span class="line">        Y = (H @ W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="comment"># outputs: 所有时间步拼接后的输出 (num_steps * batch_size, output_size)</span></span><br><span class="line">    <span class="comment"># (H, C): 当前时间步的最终状态</span></span><br><span class="line">    <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">0</span>), (H, C)</span><br></pre></td></tr></table></figure><h4 id="训练和预测"><a href="#训练和预测" class="headerlink" title="训练和预测"></a>训练和预测</h4><p>引入的<code>RNNModelScratch</code>类来训练一个长短期记忆网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vocab_size, num_hiddens, device = <span class="built_in">len</span>(vocab), <span class="number">256</span>, try_gpu()</span><br><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line">model = RNNModelScratch(<span class="built_in">len</span>(vocab), num_hiddens, device, get_lstm_params, init_lstm_state, lstm)</span><br><span class="line">train_ch8(model, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202511011607.webp" alt="202511011607" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">困惑度 1.1, 45695.4 词元/秒 cpu</span><br><span class="line">time traveller of the samm thack is of space and thating haid th</span><br><span class="line">traveller curiessions of spaceing we care the gotither so i</span><br></pre></td></tr></table></figure><h3 id="简洁实现-1"><a href="#简洁实现-1" class="headerlink" title="简洁实现"></a>简洁实现</h3><p>使用高级API，可以直接实例化<code>LSTM</code>模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_inputs = vocab_size</span><br><span class="line">lstm_layer = nn.LSTM(num_inputs, num_hiddens)</span><br><span class="line">model = RNNModel(lstm_layer, <span class="built_in">len</span>(vocab))</span><br><span class="line">model = model.to(device)</span><br><span class="line">train_ch8(model, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251101161336227.png" alt="image-20251101161336227" style="zoom: 80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">困惑度 1.0, 125343.0 词元/秒 cpu</span><br><span class="line">time traveller with a slight accession ofcheerfulness really thi</span><br><span class="line">travelleryou can show black is white by argument said filby</span><br></pre></td></tr></table></figure><p>长短期记忆网络是典型的具有重要状态控制的隐变量自回归模型，多年来已经提出了其许多变体，例如，多层、残差连接、不同类型的正则化</p><p>然而，由于序列的长距离依赖性，训练长短期记忆网络和其他序列模型(例如门控循环单元)的成本是相当高的，将使用更高级的替代模型，比如Transformer</p><h2 id="深度循环神经网络"><a href="#深度循环神经网络" class="headerlink" title="深度循环神经网络"></a>深度循环神经网络</h2><p>到目前为止，只讨论了具有一个单向隐藏层的循环神经网络</p><p>隐变量和观测值与具体的函数形式的交互方式是相当随意的，对一个单层来说，这可能具有相当的挑战性，之前在线性模型中，通过添加更多的层来解决这个问题</p><p>可以将多层循环神经网络堆叠在一起，通过对几个简单层的组合，产生了一个灵活的机制</p><p>下图描述了一个具有$L$个隐藏层的深度循环神经网络，每个隐状态都连续地传递到当前层的下一个时间步和下一层的当前时间步</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/deep-rnn.jpg" alt="deep-rnn" style="zoom:80%;" /><h3 id="函数依赖关系"><a href="#函数依赖关系" class="headerlink" title="函数依赖关系"></a>函数依赖关系</h3><p>将$l^\mathrm{th}$隐藏层($l&#x3D;1,\ldots,L$)的隐状态设为$\mathbf H_t^{(l)} \in \mathbb{R}^{n \times h}$，设$\mathbf H_t^{(0)} &#x3D; \mathbf X_t$，第$l$个隐藏层的隐状态使用激活函数$\phi_l$<br>$$<br>\mathbf H_t^{(l)} &#x3D; \phi_l(\mathbf H_t^{(l-1)} \mathbf W_{xh}^{(l)} + \mathbf H_{t-1}^{(l)} \mathbf W_{hh}^{(l)}  + \mathbf b_h^{(l)}),<br>$$<br>输出层的计算仅基于第$l$个隐藏层最终的隐状态<br>$$<br>\mathbf O_t &#x3D; \mathbf H_t^{(L)} \mathbf W_{hq} + \mathbf b_q<br>$$<br>与多层感知机一样隐藏层数目$L$和隐藏单元数目$h$都是超参数</p><h3 id="简洁实现-2"><a href="#简洁实现-2" class="headerlink" title="简洁实现"></a>简洁实现</h3><p>实现多层循环神经网络所需的许多逻辑细节在高级API中都是现成的，以长短期记忆网络模型为例，与之前的模型代码相似，唯一的区别是指定了层的数量，而不是使用单一层这个默认值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = load_data_time_machine(batch_size, num_steps)</span><br><span class="line">vocab_size, num_hiddens, num_layers = <span class="built_in">len</span>(vocab), <span class="number">256</span>, <span class="number">2</span></span><br><span class="line">num_inputs = vocab_size</span><br><span class="line">device = try_gpu()</span><br><span class="line">lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers) <span class="comment"># 新增参数</span></span><br><span class="line">model = RNNModel(lstm_layer, <span class="built_in">len</span>(vocab))</span><br><span class="line">model = model.to(device)</span><br></pre></td></tr></table></figure><h3 id="训练与预测-2"><a href="#训练与预测-2" class="headerlink" title="训练与预测"></a>训练与预测</h3><p>由于使用了长短期记忆网络模型来实例化两个层，使用GPU能加快训练速度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">2</span></span><br><span class="line">train_ch8(model, train_iter, vocab, lr*<span class="number">1.0</span>, num_epochs, device)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251101171722334.png" alt="image-20251101171722334" style="zoom: 80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">困惑度 1.0, 60333.7 词元/秒 cpu</span><br><span class="line">time traveller for so it will be convenient to speak of himwas e</span><br><span class="line">travelleryou can show black is white by argument said filby</span><br></pre></td></tr></table></figure><h2 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h2><p>在序列学习中，以往假设的目标是在给定观测的情况下对下一个输出进行建模，但还可能出现填空的任务</p><h3 id="隐马尔可夫的动态规划"><a href="#隐马尔可夫的动态规划" class="headerlink" title="隐马尔可夫的动态规划"></a>隐马尔可夫的动态规划</h3><p>设计一个隐变量模型：在任意时间步假设存在某个隐变量$h_t$，通过概率$P(x_t \mid h_t)$控制观测到的$x_t$，任何$h_t \to h_{t+1}$转移都是由一些状态转移概率$P(h_{t+1} \mid h_{t})$给出</p><p>下图为<strong>隐马尔可夫模型(hidden Markov model，HMM)</strong></p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/hmm.jpg" alt="hmm"></p><p>在观测状态和隐状态上具有以下联合概率分布：<br>$$<br>P(x_1, \ldots, x_T, h_1, \ldots, h_T) &#x3D; \prod_{t&#x3D;1}^T P(h_t \mid h_{t-1}) P(x_t \mid h_t), \text{ where } P(h_1 \mid h_0) &#x3D; P(h_1).<br>$$<br>假设观测到所有的$x_i$，除了$x_j$，目标是计算$P(x_j \mid x_{-j})$，其中$x_{-j} &#x3D; (x_1, \ldots, x_{j-1}, x_{j+1}, \ldots, x_{T})$，即$x_{-j}$代表除了$x_j$以外的所有观测值</p><p>如果任何$h_i$可以接受$k$个不同的值(有限的状态数)，这意味着需要对$k^T$个项求和，要直接计算上面的和，计算量爆炸！</p><p>有个巧妙的解决方案：<strong>动态规划(dynamic programming)</strong></p><p>结合**前向递归(forward recursion)<strong>和</strong>后向递归(backward recursion)**能够计算<br>$$<br>P(x_j \mid x_{-j}) \propto \sum_{h_j} \pi_j(h_j) \rho_j(h_j) P(x_j \mid h_j).<br>$$<br>用前向量$\pi$和后向量$\rho$就能高效地计算任意时刻观测的概率分布</p><h3 id="双向模型"><a href="#双向模型" class="headerlink" title="双向模型"></a>双向模型</h3><p>希望在循环神经网络中拥有一种机制，使之能够提供与隐马尔可夫模型类似的前瞻能力，需要修改循环神经网络的设计</p><p>只需要增加一个“从最后一个词元开始从后向前运行”的循环神经网络，而不是只有一个在前向模式下“从第一个词元开始运行”的循环神经网络</p><p>**双向循环神经网络(bidirectional RNNs)**添加了反向传递信息的隐藏层，以便更灵活地处理此类信息，下图描述具有单个隐藏层的双向循环神经网络的架构</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/birnn.jpg" alt="birnn" style="zoom: 80%;" /><p>这与隐马尔可夫模型中的动态规划的前向和后向递归没有太大区别</p><p>相当于两个RNN，正向 RNN 从头看，反向 RNN 从尾看</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>双向循环神经网络是由(Schuster and Paliwal, 1997)提出的，关于各种架构的详细讨论请参阅 (Graves and Schmidhuber, 2005)</p><p>对于任意时间步，在双向架构中，设该时间步的前向和反向隐状态分别为$\overrightarrow{\bf{H}}_t \in \mathbb{R}^{n \times h}$和$\overleftarrow{\bf{H}}_t \in \mathbb{R}^{n \times h}$</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-11-01_17-47-37.webp" alt="Snipaste_2025-11-01_17-47-37" style="zoom:80%;" /><p>将前向隐状态和反向隐状态连接起来，获得需要送入输出层的隐状态$\bf{H}_t \in \mathbb{R}^{n \times 2h}$</p><p>在具有多个隐藏层的深度双向循环神经网络中，该信息作为输入传递到下一个双向层</p><p>输出层计算得到的输出为<br>$$<br>\mathbf O_t &#x3D; \mathbf H_t \mathbf W_{hq} + \mathbf b_q.<br>$$<br>权重矩阵$\bf{W}_{hq} \in \mathbb{R}^{2h \times q}$和偏置$\bf{b}_q \in \mathbb{R}^{1 \times q}$是输出层的模型参数</p><h4 id="模型的问题"><a href="#模型的问题" class="headerlink" title="模型的问题"></a>模型的问题</h4><p>双向循环神经网络的一个关键特性是：使用来自序列两端的信息来估计输出</p><p>在训练期间，能够利用过去和未来的数据来估计现在空缺的词；而在测试期间，只有过去的数据，因此预测精度将会很差</p><p>另一个严重问题是，双向循环神经网络的计算速度非常慢。其主要原因是网络的前向传播需要在双向层中进行前向和后向递归，并且网络的反向传播还依赖于前向传播的结果</p><p>双向层的使用在实践中非常少，并且仅仅应用于部分场合</p><h3 id="错误应用"><a href="#错误应用" class="headerlink" title="错误应用"></a>错误应用</h3><p>由于双向循环神经网络使用了过去的和未来的数据，所以不能盲目地将这一语言模型应用于任何预测任务，尽管模型产出的困惑度是合理的，该模型预测未来词元的能力却可能存在严重缺陷</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">batch_size, num_steps, device = <span class="number">32</span>, <span class="number">35</span>, try_gpu()</span><br><span class="line">train_iter, vocab = load_data_time_machine(batch_size, num_steps)</span><br><span class="line"><span class="comment"># 通过设置“bidirective=True”来定义双向LSTM模型</span></span><br><span class="line">vocab_size, num_hiddens, num_layers = <span class="built_in">len</span>(vocab), <span class="number">256</span>, <span class="number">2</span></span><br><span class="line">num_inputs = vocab_size</span><br><span class="line">lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers, bidirectional=<span class="literal">True</span>)</span><br><span class="line">model = RNNModel(lstm_layer, <span class="built_in">len</span>(vocab))</span><br><span class="line">model = model.to(device)</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line">train_ch8(model, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure><p>会出现很抽象的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">困惑度 1.1, 23421.1 词元/秒 cpu</span><br><span class="line">time travellerererererererererererererererererererererererererer</span><br><span class="line">travellerererererererererererererererererererererererererer</span><br></pre></td></tr></table></figure><h2 id="机器翻译与数据集"><a href="#机器翻译与数据集" class="headerlink" title="机器翻译与数据集"></a>机器翻译与数据集</h2><p>语言模型是自然语言处理的关键，而机器翻译是语言模型最成功的基准测试</p><p><strong>机器翻译(machine translation)<strong>指的是将序列从一种语言自动翻译成另一种语言，正是将输入序列转换成输出序列的</strong>序列转换模型(sequence transduction)</strong></p><h3 id="下载和预处理数据集"><a href="#下载和预处理数据集" class="headerlink" title="下载和预处理数据集"></a>下载和预处理数据集</h3><p>下载一个由<a href="http://www.manythings.org/anki/">Tatoeba项目的双语句子对</a> 组成的“英－法”数据集，数据集中的每一行都是制表符分隔的文本序列对，序列对由英文文本序列和翻译后的法语文本序列组成</p><p>每个文本序列可以是一个句子，也可以是包含多个句子的一个段落</p><p>在这个问题中，英语是<strong>源语言(source language)</strong>，法语是<strong>目标语言(target language)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATA_HUB[<span class="string">&#x27;fra-eng&#x27;</span>] = (  <span class="comment">#@save</span></span><br><span class="line">    DATA_URL + <span class="string">&#x27;fra-eng.zip&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;94646ad1522d915e7b0f9296181140edcf86a4f5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data_nmt</span>():  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;载入“英语－法语”数据集&quot;&quot;&quot;</span></span><br><span class="line">    data_dir = download_extract(<span class="string">&#x27;fra-eng&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(data_dir, <span class="string">&#x27;fra.txt&#x27;</span>), <span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">             encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raw_text = read_data_nmt()</span><br><span class="line"><span class="built_in">print</span>(raw_text[:<span class="number">75</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">正在从http://d2l-data.s3-accelerate.amazonaws.com/fra-eng.zip下载../data\fra-eng.zip...</span><br><span class="line">Go.Va !</span><br><span class="line">Hi.Salut !</span><br><span class="line">Run!Cours !</span><br><span class="line">Run!Courez !</span><br><span class="line">Who?Qui ?</span><br><span class="line">Wow!Ça alors !</span><br></pre></td></tr></table></figure><p>下载数据集后，原始文本数据需要经过几个预处理步骤</p><p>需要用空格代替<strong>不间断空格(non-breaking space)</strong>，使用小写字母替换大写字母，并在单词和标点符号之间插入空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_nmt</span>(<span class="params">text</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;预处理“英语－法语”数据集&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 判断是否应该在标点前加空格</span></span><br><span class="line">    <span class="comment"># 如果标点前面没空格，就给它补上空格</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">no_space</span>(<span class="params">char, prev_char</span>):</span><br><span class="line">        <span class="keyword">return</span> char <span class="keyword">in</span> <span class="built_in">set</span>(<span class="string">&#x27;,.!?&#x27;</span>) <span class="keyword">and</span> prev_char != <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把不间断空格(\u202f, \xa0)替换成普通空格</span></span><br><span class="line">    <span class="comment"># 使用小写字母替换大写字母</span></span><br><span class="line">    text = text.replace(<span class="string">&#x27;\u202f&#x27;</span>, <span class="string">&#x27; &#x27;</span>).replace(<span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27; &#x27;</span>).lower()</span><br><span class="line">    <span class="comment"># 在单词和标点符号之间插入空格</span></span><br><span class="line">    out = [<span class="string">&#x27; &#x27;</span> + char <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> no_space(char, text[i - <span class="number">1</span>]) <span class="keyword">else</span> char</span><br><span class="line">           <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(text)]</span><br><span class="line">    <span class="comment"># out 是列表，用 join() 把它们拼回去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(out)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text = preprocess_nmt(raw_text)</span><br><span class="line"><span class="built_in">print</span>(text[:<span class="number">80</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go .va !</span><br><span class="line">hi .salut !</span><br><span class="line">run !cours !</span><br><span class="line">run !courez !</span><br><span class="line">who ?qui ?</span><br><span class="line">wow !ça alors !</span><br></pre></td></tr></table></figure><h3 id="词元化-1"><a href="#词元化-1" class="headerlink" title="词元化"></a>词元化</h3><p>与之前字符级词元化不同，在机器翻译中更喜欢单词级词元化</p><p>下面的<code>tokenize_nmt</code>函数对前<code>num_examples</code>个文本序列对进行词元，每个词元要么是一个词，要么是一个标点符号</p><p>此函数返回两个词元列表：<code>source</code>和<code>target</code></p><p>&#96;&#96;source[i]<code>是源语言第$i$个文本序列的词元列表，</code>target[i]&#96;是目标语言第$i$个文本序列的词元列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tokenize_nmt</span>(<span class="params">text, num_examples=<span class="literal">None</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;词元化“英语－法语”数据数据集&quot;&quot;&quot;</span></span><br><span class="line">    source, target = [], []</span><br><span class="line">    <span class="comment"># 把整个文本按换行符拆成行</span></span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(text.split(<span class="string">&#x27;\n&#x27;</span>)):</span><br><span class="line">        <span class="comment"># i为行号，line为内容</span></span><br><span class="line">        <span class="keyword">if</span> num_examples <span class="keyword">and</span> i &gt; num_examples:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        parts = line.split(<span class="string">&#x27;\t&#x27;</span>) <span class="comment"># 把一行用制表符分成两部分</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(parts) == <span class="number">2</span>:</span><br><span class="line">            source.append(parts[<span class="number">0</span>].split(<span class="string">&#x27; &#x27;</span>)) <span class="comment"># 按空格切成单词</span></span><br><span class="line">            target.append(parts[<span class="number">1</span>].split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> source, target</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source, target = tokenize_nmt(text)</span><br><span class="line">source[:<span class="number">6</span>], target[:<span class="number">6</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">([[&#x27;go&#x27;, &#x27;.&#x27;],</span><br><span class="line">  [&#x27;hi&#x27;, &#x27;.&#x27;],</span><br><span class="line">  [&#x27;run&#x27;, &#x27;!&#x27;],</span><br><span class="line">  [&#x27;run&#x27;, &#x27;!&#x27;],</span><br><span class="line">  [&#x27;who&#x27;, &#x27;?&#x27;],</span><br><span class="line">  [&#x27;wow&#x27;, &#x27;!&#x27;]],</span><br><span class="line">  </span><br><span class="line"> [[&#x27;va&#x27;, &#x27;!&#x27;],</span><br><span class="line">  [&#x27;salut&#x27;, &#x27;!&#x27;],</span><br><span class="line">  [&#x27;cours&#x27;, &#x27;!&#x27;],</span><br><span class="line">  [&#x27;courez&#x27;, &#x27;!&#x27;],</span><br><span class="line">  [&#x27;qui&#x27;, &#x27;?&#x27;],</span><br><span class="line">  [&#x27;ça&#x27;, &#x27;alors&#x27;, &#x27;!&#x27;]])</span><br></pre></td></tr></table></figure><p>绘制每个文本序列所包含的词元数量的直方图，在这个数据集中，大多数文本序列的词元数量少于20个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_list_len_pair_hist</span>(<span class="params">legend, xlabel, ylabel, xlist, ylist</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制列表长度对的直方图&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算每个句子的长度(词元数)</span></span><br><span class="line">    x_lengths = [<span class="built_in">len</span>(l) <span class="keyword">for</span> l <span class="keyword">in</span> xlist]</span><br><span class="line">    y_lengths = [<span class="built_in">len</span>(l) <span class="keyword">for</span> l <span class="keyword">in</span> ylist]</span><br><span class="line">    <span class="comment"># 设置图形大小</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">     <span class="comment"># 绘制两个直方图</span></span><br><span class="line">    counts, bins, patches = plt.hist(</span><br><span class="line">        [x_lengths, y_lengths],</span><br><span class="line">        bins=<span class="number">20</span>,   <span class="comment"># 直方图柱子数量(可调整)</span></span><br><span class="line">        color=[<span class="string">&#x27;skyblue&#x27;</span>, <span class="string">&#x27;salmon&#x27;</span>],</span><br><span class="line">        label=legend,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 给第二组加上斜线纹理(</span></span><br><span class="line">    <span class="keyword">for</span> patch <span class="keyword">in</span> patches[<span class="number">1</span>]:</span><br><span class="line">        patch.set_hatch(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(xlabel)</span><br><span class="line">    plt.ylabel(ylabel)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_list_len_pair_hist([<span class="string">&#x27;source&#x27;</span>, <span class="string">&#x27;target&#x27;</span>], <span class="string">&#x27;# tokens per sequence&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, source, target);</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202511011950.png" alt="202511011950" style="zoom:80%;" /><h3 id="词表-1"><a href="#词表-1" class="headerlink" title="词表"></a>词表</h3><p>可以分别为源语言和目标语言构建两个词表，使用单词级词元化时，词表大小将明显大于使用字符级词元化时的词表大小</p><p>为减少词表规模，把出现次数少于2次的词都当作同一个未知词<code>&lt;unk&gt;</code>，还添加了几个特殊符号：</p><ul><li><code>&lt;pad&gt;</code>：在小批量训练时，用于把句子填充到相同长度；</li><li><code>&lt;bos&gt;</code>：表示句子开始；</li><li><code>&lt;eos&gt;</code>：表示句子结束</li></ul><p>这些特殊词元在自然语言处理任务中比较常用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src_vocab = Vocab(source, min_freq=<span class="number">2</span>, </span><br><span class="line">                  reserved_tokens=[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="string">&#x27;&lt;eos&gt;&#x27;</span>])</span><br><span class="line"><span class="built_in">len</span>(src_vocab)  <span class="comment"># 10012</span></span><br></pre></td></tr></table></figure><h3 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h3><p>语言模型中的序列样本都有一个固定的长度，这个固定长度是由<code>num_steps</code>(时间步数或词元数量)参数指定的</p><p>在机器翻译中，每个样本都是由源和目标组成的文本序列对，其中的每个文本序列可能具有不同的长度</p><p>为了提高计算效率，仍然可以通过**截断(truncation)<strong>和</strong>填充(padding)**方式实现一次只处理一个小批量的文本序列</p><p>在一个小批量中，所有序列的长度都设为相同的<code>num_steps</code>，如果太短在末尾补上 <code>&lt;pad&gt;</code> 直到其长度达到<code>num_steps</code>；如果太长只保留前 <code>num_steps</code> 个词元</p><p>下面的<code>truncate_pad</code>函数将截断或填充文本序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">truncate_pad</span>(<span class="params">line, num_steps, padding_token</span>): <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;截断或填充文本序列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) &gt; num_steps:</span><br><span class="line">        <span class="keyword">return</span> line[:num_steps]  <span class="comment"># 截断</span></span><br><span class="line">    <span class="keyword">return</span> line + [padding_token] * (num_steps - <span class="built_in">len</span>(line))  <span class="comment"># 填充</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate_pad(src_vocab[source[<span class="number">0</span>]], <span class="number">10</span>, src_vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[47, 4, 1, 1, 1, 1, 1, 1, 1, 1]</span><br></pre></td></tr></table></figure><p>现在定义一个函数，可以将文本序列转换成小批量数据集用于训练</p><p>将特定的<code>&lt;eos&gt;</code>词元添加到所有序列的末尾，用于表示序列的结束</p><p>当模型通过一个词元接一个词元地生成序列进行预测时，生成的<code>&lt;eos&gt;</code>词元说明完成了序列输出工作，此外还记录了每个文本序列的长度，统计长度时排除了填充词元，在稍后将要介绍的一些模型会需要这个长度信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_array_nmt</span>(<span class="params">lines, vocab, num_steps</span>): <span class="comment"># #@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将机器翻译的文本序列转换成小批量&quot;&quot;&quot;</span></span><br><span class="line">    lines = [vocab[l] <span class="keyword">for</span> l <span class="keyword">in</span> lines]</span><br><span class="line">    <span class="comment"># 在每个句子末尾加上 &lt;eos&gt;</span></span><br><span class="line">    lines = [l + [vocab[<span class="string">&#x27;&lt;eos&gt;&#x27;</span>]] <span class="keyword">for</span> l <span class="keyword">in</span> lines]</span><br><span class="line">    array = torch.tensor([truncate_pad(</span><br><span class="line">        l, num_steps, vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>]) <span class="keyword">for</span> l <span class="keyword">in</span> lines])</span><br><span class="line">    <span class="comment"># 用bool值转为int累加即为长度</span></span><br><span class="line">    valid_len = (array != vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>]).<span class="built_in">type</span>(torch.int32).<span class="built_in">sum</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> array, valid_len</span><br></pre></td></tr></table></figure><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>定义<code>load_data_nmt</code>函数来返回数据迭代器，以及源语言和目标语言的两种词表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_nmt</span>(<span class="params">batch_size, num_steps, num_examples=<span class="number">600</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回翻译数据集的迭代器和词表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 读取原始英法语料并清洗文本</span></span><br><span class="line">    text = preprocess_nmt(read_data_nmt())</span><br><span class="line">    <span class="comment"># 2. 将文本拆分为词元列表</span></span><br><span class="line">    source, target = tokenize_nmt(text, num_examples)</span><br><span class="line">    <span class="comment"># 3. 分别构建源语言和目标语言词表</span></span><br><span class="line">    src_vocab = Vocab(source, min_freq=<span class="number">2</span>,</span><br><span class="line">                          reserved_tokens=[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="string">&#x27;&lt;eos&gt;&#x27;</span>])</span><br><span class="line">    tgt_vocab = Vocab(target, min_freq=<span class="number">2</span>,</span><br><span class="line">                          reserved_tokens=[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="string">&#x27;&lt;eos&gt;&#x27;</span>])</span><br><span class="line">    <span class="comment"># 4. 把句子转为统一长度的索引张量</span></span><br><span class="line">    src_array, src_valid_len = build_array_nmt(source, src_vocab, num_steps)</span><br><span class="line">    tgt_array, tgt_valid_len = build_array_nmt(target, tgt_vocab, num_steps)</span><br><span class="line">    <span class="comment"># 5. 打包所有张量并生成可迭代数据加载器</span></span><br><span class="line">    data_arrays = (src_array, src_valid_len, tgt_array, tgt_valid_len)</span><br><span class="line">    data_iter = load_array(data_arrays, batch_size)</span><br><span class="line">    <span class="comment"># 6. 返回训练数据迭代器及词表</span></span><br><span class="line">    <span class="keyword">return</span> data_iter, src_vocab, tgt_vocab</span><br></pre></td></tr></table></figure><p>读出“英语－法语”数据集中的第一个小批量数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">train_iter, src_vocab, tgt_vocab = load_data_nmt(batch_size=<span class="number">2</span>, num_steps=<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> X, X_valid_len, Y, Y_valid_len <span class="keyword">in</span> train_iter:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X:&#x27;</span>, X.<span class="built_in">type</span>(torch.int32))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X的有效长度:&#x27;</span>, X_valid_len)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Y:&#x27;</span>, Y.<span class="built_in">type</span>(torch.int32))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Y的有效长度:&#x27;</span>, Y_valid_len)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X: tensor([[31,  0,  4,  3,  1,  1,  1,  1],</span><br><span class="line">        [39, 19,  4,  3,  1,  1,  1,  1]], dtype=torch.int32)</span><br><span class="line">X的有效长度: tensor([4, 4])</span><br><span class="line">Y: tensor([[77, 23,  0,  4,  3,  1,  1,  1],</span><br><span class="line">        [92, 12,  5,  3,  1,  1,  1,  1]], dtype=torch.int32)</span><br><span class="line">Y的有效长度: tensor([5, 4])</span><br></pre></td></tr></table></figure><h2 id="编码器-解码器架构"><a href="#编码器-解码器架构" class="headerlink" title="编码器-解码器架构"></a>编码器-解码器架构</h2><p>机器翻译是典型的序列到序列转换问题，输入和输出的长度都可能不同</p><p>为了解决这个问题，使用一种由两个部分组成的结构：</p><ul><li>编码器(encoder)：把输入序列转化为一个固定长度的编码状态；</li><li>解码器(decoder)：根据这个表示生成输出序列</li></ul><p>这被称为**编码器-解码器(encoder-decoder)**架构</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/encoder-decoder.jpg" alt="encoder-decoder" style="zoom:80%;" /><p>由于“编码器－解码器”架构是形成不同序列转换模型的基础，将把这个架构转换为接口方便后面的代码实现</p><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>在编码器接口中，只指定长度可变的序列作为编码器的输入<code>X</code>，任何继承这个<code>Encoder</code>基类的模型将完成代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>(nn.Module):   <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;编码器-解码器架构的基本编码器接口&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X, *args</span>):</span><br><span class="line">        <span class="comment"># 只是定义接口，不做实现，如果继承却没写自己的 forward就报错</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p>在下面的解码器接口中，新增一个<code>init_state</code>函数，用于将编码器的输出(<code>enc_outputs</code>)转换为编码后的状态</p><p>此步骤可能需要额外的输入，例如输入序列的有效长度</p><p>为了逐个地生成长度可变的词元序列，解码器在每个时间步都会将输入(例如：在前一时间步生成的词元)和编码后的状态映射成当前时间步的输出词元</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decoder</span>(nn.Module):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;编码器-解码器架构的基本解码器接口&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_state</span>(<span class="params">self, enc_outputs, *args</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X, state</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><h3 id="合并编码器和解码器"><a href="#合并编码器和解码器" class="headerlink" title="合并编码器和解码器"></a>合并编码器和解码器</h3><p>“编码器-解码器”架构包含了一个编码器和一个解码器，并且还拥有可选的额外的参数</p><p>在前向传播中，编码器的输出用于生成编码状态，这个状态又被解码器作为其输入的一部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EncoderDecoder</span>(nn.Module):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;编码器-解码器架构的基类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, encoder, decoder, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.encoder = encoder</span><br><span class="line">        <span class="variable language_">self</span>.decoder = decoder</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_X, dec_X, *args</span>):</span><br><span class="line">        enc_outputs = <span class="variable language_">self</span>.encoder(enc_X, *args)</span><br><span class="line">        dec_state = <span class="variable language_">self</span>.decoder.init_state(enc_outputs, *args)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.decoder(dec_X, dec_state)</span><br></pre></td></tr></table></figure><p>“编码器－解码器”体系架构中的术语状态会启发人们使用具有状态的神经网络来实现该架构</p>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积神经网络</title>
      <link href="/posts/21309.html"/>
      <url>/posts/21309.html</url>
      
        <content type="html"><![CDATA[<p>图像数据的每个样本都由一个二维像素网格组成，每个像素可能是一个或者多个数值，取决于是黑白还是彩色图像</p><p>之前仅仅通过将图像数据展平成一维向量而忽略了每个图像的空间结构信息，再将数据送入一个全连接的多层感知机中。因为这些网络特征元素的顺序是不变的，因此最优的结果是利用先验知识，即利用相近像素之间的相互关联性，从图像数据中学习得到有效的模型</p><p>**卷积神经网络(convolutional neural network，CNN)**是一类强大的、为处理图像数据而设计的神经网络，基于卷积神经网络架构的模型在计算机视觉领域中已经占主导地位</p><p>卷积神经网络需要的参数少于全连接架构的网络，而且卷积也很容易用GPU并行计算</p><h2 id="从全连接层到卷积"><a href="#从全连接层到卷积" class="headerlink" title="从全连接层到卷积"></a>从全连接层到卷积</h2><p>MLP适合处理那些“每个特征相互独立且无结构”的任务</p><p>对于表格数据，特征之间的关系往往复杂且难以事先定义，模式可能来源于任意特征的非线性交互，此时多层感知机可能是最好的选择</p><p>然而对于高维感知数据，这种缺少结构的网络可能会变得不实用</p><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>假设想从一张图片中找到某个物体，合理的假设是：无论哪种方法找到这个物体，都应该和物体的位置无关</p><p>卷积神经网络(CNN)正是把这种“空间不变性”的思想系统化的模型。它能在不同位置识别出相同的特征，通过共享参数与局部感知实现高效的特征学习，用更少的参数捕捉图像中的关键信息</p><p>特性总结：</p><ol><li><strong>平移不变性(translation invariance)</strong>：不管检测对象出现在图像中的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应，即为“平移不变性”</li><li><strong>局部性(locality)</strong>：神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则</li></ol><h3 id="多层感知机的限制"><a href="#多层感知机的限制" class="headerlink" title="多层感知机的限制"></a>多层感知机的限制</h3><p>存在两个核心问题：</p><ol><li><strong>参数太多</strong>，容易过拟合且计算开销大</li><li><strong>忽略空间结构</strong>，无法捕捉局部特征的空间关系(例如邻近像素常常相关)</li></ol><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>为了使每个隐藏神经元都能接收到每个输入像素的信息，将参数从权重矩阵替换为四阶权重张量$\mathsf{W}$，假设$\mathbf{U}$包含偏置参数，可以将全连接层形式化地表示为<br>$$<br>\begin{split}\begin{aligned} \mathbf H_{i, j} &amp;&#x3D; \mathbf U_{i, j} + \sum_k \sum_l\mathsf W_{i, j, k, l}  \mathbf X_{k, l}\\ &amp;&#x3D;  \mathbf U_{i, j} + \sum_a \sum_b \mathsf V_{i, j, a, b}  \mathbf X_{i+a, j+b}.\end{aligned}\end{split}<br>$$<br>从$\mathsf{W}$到$\mathsf{V}$的转换只是形式上的转换，使$k &#x3D; i+a, l &#x3D; j+b$</p><p>把输入索引从绝对坐标$(k, l)$改写成相对输出位置的位移$(a,b)$<br>$$<br>\mathsf V_{i, j, a, b} &#x3D; \mathsf W_{i, j, i+a, j+b}<br>$$<br>索引$a$和$b$通过在正偏移和负偏移之间移动覆盖了整个图像</p><h4 id="平移不变性"><a href="#平移不变性" class="headerlink" title="平移不变性"></a>平移不变性</h4><p>检测对象在输入$\mathbf{X}$中的平移，应该仅导致隐藏表示$\mathbf{H}$中的平移，$\mathsf{V,U}$实际上不依赖于$(i, j)$的值</p><p>可以简化$\mathbf{H}$为<br>$$<br>\mathbf H_{i, j} &#x3D; u + \sum_a\sum_b \mathbf V_{a, b} \mathbf X_{i+a, j+b}.<br>$$<br>这就是<strong>卷积(convolution)</strong></p><p>使用系数$\mathbf V_{a, b}$对位置$(i, j)$附近的像素$(i+a, j+b)$进行加权得到$[\mathbf{H}]_{i, j}$</p><p>卷积核在图像上滑动(平移)，每个位置使用同一组参数，实现<strong>权重共享(weight sharing)</strong>，保证了平移不变性</p><h4 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h4><p>不应偏离到距$(i,j)$很远的地方，在$\mid a\mid  &gt; \Delta , \mid b\mid &gt;\Delta $的范围之外可以设置$[\mathbf{V}]_{a, b} &#x3D; 0$</p><p>可以将$\mathbf H_{i, j}$重写为<br>$$<br>\mathbf H_{i, j} &#x3D; u + \sum_{a &#x3D; -\Delta}^{\Delta} \sum_{b &#x3D; -\Delta}^{\Delta} \mathbf V_{a, b}  \mathbf X_{i+a, j+b}.<br>$$<br>这就是<strong>卷积层(convolutional layer)</strong></p><p>在深度学习研究社区中$\mathbf{V}$被称为<strong>卷积核(convolution kernel)<strong>或者</strong>滤波器(filter)</strong></p><p>亦或简单地称之为该卷积层的权重，通常该权重是可学习的参数</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p><font color='Violetred'>为什么平移不变性可能也不是好主意呢？</font></p><p>平移不变性关注的是特征是否出现过，而不在意它在图像中的位置</p><p>在图像分类等任务中非常有效，但当任务依赖精确位置或结构时，这种假设反而会成为限制</p><p>理想的做法不是彻底放弃平移不变性，而是在保持共享的同时引入位置信息，让模型既高效又具空间感知</p><h2 id="图像卷积"><a href="#图像卷积" class="headerlink" title="图像卷积"></a>图像卷积</h2><h3 id="互相关"><a href="#互相关" class="headerlink" title="互相关"></a>互相关</h3><p>在数学中，两个离散二维张量之间的“卷积”被定义为<br>$$<br>(f * g)(i, j) &#x3D; \sum_a\sum_b f(a, b) g(i-a, j-b).<br>$$<br>会发现其实数学定义是需要翻转的，但是刚刚写的并没有翻转，深度学习里所谓的“卷积”其实严格意义上是<strong>互相关(cross-correlation)</strong>，它没有翻转卷积核，只是把核在输入上滑动求和</p><p>但人们习惯仍称它为“卷积层”，因为计算形式和思想完全一致</p><p>因为卷积核的宽度和高度大于1，而卷积核只与图像中每个大小完全适合的位置进行互相关运算，设输入大小为$n_h \times n_w$，卷积核大小$k_h \times k_w$，则输出大小<br>$$<br>\color{purple} (n_h-k_h+1) \times (n_w-k_w+1).<br>$$<br>在<code>corr2d</code>函数中实现如上过程，该函数接受输入张量<code>X</code>和卷积核张量<code>K</code>，并返回输出张量<code>Y</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d</span>(<span class="params">X, K</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算二维互相关运算&quot;&quot;&quot;</span></span><br><span class="line">    h, w = K.shape</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            Y[i, j] = (X[i:i + h, j:j + w] * K).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><p>测试函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">K = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]])</span><br><span class="line"><span class="built_in">print</span>(corr2d(X, K))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[19., 25.],</span><br><span class="line">        [37., 43.]])</span><br></pre></td></tr></table></figure><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/correlation.jpg" alt="correlation"></p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出</p><p>卷积层中的两个被训练的参数是卷积核权重和标量偏置，也需要随机初始化</p><p>基于上面定义的<code>corr2d</code>函数实现二维卷积层，在<code>__init__</code>构造函数中，将<code>weight</code>和<code>bias</code>声明为两个模型参数，前向传播函数调用<code>corr2d</code>函数并添加偏置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Conv2D</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kernel_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        <span class="variable language_">self</span>.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> corr2d(X, <span class="variable language_">self</span>.weight) + <span class="variable language_">self</span>.bias</span><br></pre></td></tr></table></figure><h3 id="目标的边缘检测"><a href="#目标的边缘检测" class="headerlink" title="目标的边缘检测"></a>目标的边缘检测</h3><p>通过找到像素变化的位置，来检测图像中不同颜色的边缘</p><p>构造一个6×8像素的黑白图像，中间四列为黑色(0)，周围为白色(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = torch.ones((<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">X[:, <span class="number">2</span>:<span class="number">6</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><p>构造一个高度为1、宽度为2的卷积核$K$，当进行互相关运算时，如果水平相邻的两元素相同，则输出为零，否则输出为非零</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K = torch.tensor([[<span class="number">1.0</span>, -<span class="number">1.0</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = corr2d(X, K)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span><br><span class="line">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span><br><span class="line">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span><br><span class="line">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span><br><span class="line">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span><br><span class="line">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.]])</span><br></pre></td></tr></table></figure><p>发现输出很明显的边缘信息</p><p>现在将输入的二维图像转置，再进行如上的互相关运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">corr2d(X.t(), K)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tensor([[0., 0., 0., 0., 0.],</span><br><span class="line">        [0., 0., 0., 0., 0.],</span><br><span class="line">        [0., 0., 0., 0., 0.],</span><br><span class="line">        [0., 0., 0., 0., 0.],</span><br><span class="line">        [0., 0., 0., 0., 0.],</span><br><span class="line">        [0., 0., 0., 0., 0.],</span><br><span class="line">        [0., 0., 0., 0., 0.],</span><br><span class="line">        [0., 0., 0., 0., 0.]])</span><br></pre></td></tr></table></figure><p>之前检测到的垂直边缘消失了，这个卷积核<code>K</code>只可以检测垂直边缘，无法检测水平边缘</p><h3 id="学习卷积核"><a href="#学习卷积核" class="headerlink" title="学习卷积核"></a>学习卷积核</h3><p>如果只需寻找黑白边缘，那么[-1,1]边缘检测器足以，当有了更复杂数值的卷积核，或者连续的卷积层时，不可能手动设计滤波器</p><p>所以就要进入迭代学习的部分</p><p>先讲一下<code>nn.Conv2d</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nn.Conv2d(</span><br><span class="line">    in_channels,  <span class="comment"># 输入通道数，灰度1，彩色3</span></span><br><span class="line">    out_channels, <span class="comment"># 输出通道数，也就是卷积核数</span></span><br><span class="line">    kernel_size,  <span class="comment"># 卷积核的大小，常用(3,3)</span></span><br><span class="line">    stride=<span class="number">1</span>,     <span class="comment"># 步幅，每次滑动的步长，默认1</span></span><br><span class="line">    padding=<span class="number">0</span>,    <span class="comment"># 默认0不填充</span></span><br><span class="line">    bias=<span class="literal">True</span>,    <span class="comment"># 是否使用偏置项，默认True</span></span><br><span class="line">    padding_mode=<span class="string">&#x27;zeros&#x27;</span>  <span class="comment"># 填充方式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造一个二维卷积层，它具有1个输出通道和形状为(1，2)的卷积核</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>,<span class="number">1</span>, kernel_size=(<span class="number">1</span>,<span class="number">2</span>),bias=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 使用四维输入和输出格式(批量大小、通道、高度、宽度)</span></span><br><span class="line">X = X.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">Y = Y.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">lr = <span class="number">3e-2</span>  <span class="comment"># 学习率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    Y_hat = conv2d(X)</span><br><span class="line">    l = (Y_hat - Y)**<span class="number">2</span></span><br><span class="line">    conv2d.zero_grad()</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    <span class="comment"># 迭代卷积核</span></span><br><span class="line">    conv2d.weight.data[:] -= lr * conv2d.weight.grad</span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;epoch <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.<span class="built_in">sum</span>():<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epoch 2, loss 7.668</span><br><span class="line">epoch 4, loss 1.313</span><br><span class="line">epoch 6, loss 0.231</span><br><span class="line">epoch 8, loss 0.043</span><br><span class="line">epoch 10, loss 0.009</span><br></pre></td></tr></table></figure><p>在10次迭代之后，误差已经降到足够低</p><p>查看学习获得的卷积核权重张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conv2d.weight.data.reshape(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 0.9800, -0.9914]])</span><br></pre></td></tr></table></figure><p>和之前定义的基本接近</p><h3 id="特征映射和感受野"><a href="#特征映射和感受野" class="headerlink" title="特征映射和感受野"></a>特征映射和感受野</h3><p>输出的卷积层有时被称为<strong>特征映射(feature map)</strong>，因为它可以被视为一个输入映射到下一层的空间维度的转换器</p><p>在卷积神经网络中，对于某一层的任意元素$x$，其**感受野(receptive field)**是指在前向传播期间可能影响$x$计算的所有元素(来自所有先前层)</p><p>感受野可能大于输入的实际大小，在多层卷积网络中，感受野会随着层数的增加逐渐变大</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/correlation.jpg" alt="correlation"></p><p>若每一层卷积核大小为 2×2，第一层输出的每个元素受输入4个像素影响，再经过一层卷积后，感受野不仅是输入的4个元素，还有最初的9个输入</p><p>因此随着卷积层的叠加，感受野不断扩大，使网络能够捕捉更高层次、更全局的特征</p><h2 id="填充和步幅"><a href="#填充和步幅" class="headerlink" title="填充和步幅"></a>填充和步幅</h2><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>在应用了连续的卷积之后，最终得到的输出远小于输入大小，如此一来原始图像的边界丢失了许多有用信息，**填充(padding)**是解决此问题最有效的方法</p><p>在输入图像的边界填充元素(通常填充元素是0)</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/conv-pad.jpg" alt="conv-pad"></p><p>通常对称填充，填充大小为$p_h&#x3D;k_h-1$和$p_w&#x3D;k_w-1$，使得输入和输出具有相同高度和宽度</p><p>卷积神经网络中卷积核的高度和宽度通常为奇数，例如1、3、5或7，选择奇数的好处是，保持空间维度的同时，在对称方向上填充的行数相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了方便起见，定义了一个计算卷积层的函数</span></span><br><span class="line"><span class="comment"># 此函数初始化卷积层权重，并对输入和输出提高和缩减相应的维数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">comp_conv2d</span>(<span class="params">conv2d, X</span>):</span><br><span class="line">    <span class="comment"># 这里的(1，1)表示批量大小和通道数都是1</span></span><br><span class="line">    X = X.reshape((<span class="number">1</span>,<span class="number">1</span>)+X.shape)</span><br><span class="line">    Y = conv2d(X)</span><br><span class="line">    <span class="comment"># 省略前两个维度：批量大小和通道</span></span><br><span class="line">    <span class="keyword">return</span> Y.reshape(Y.shape[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>当卷积核高度宽度相同时，填充大小相同；如果不同，需要填充不同的高度和宽度</p><p><code>padding</code>大小为<code>(kernel_size-1)/2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>) </span><br><span class="line"><span class="comment"># conv2d = nn.Conv2d(1, 1, kernel_size=(5, 3), padding=(2, 1))</span></span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([8, 8])</span><br></pre></td></tr></table></figure><h3 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h3><p>在计算互相关时，卷积窗口从输入张量的左上角开始，向下、向右滑动</p><p>默认每次滑动一个元素，但有时候为了高效计算或是缩减采样次数，卷积窗口可以跳过中间位置，每次滑动多个元素</p><p>将每次滑动元素的数量称为<strong>步幅(stride)</strong></p><p>垂直步幅为3，水平步幅为2的二维互相关运算</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/conv-stride.jpg" alt="conv-stride"></p><p>当垂直步幅为$s_h$，水平步幅为$s_w$时，输出形状为<br>$$<br>\color{purple}H &#x3D; \lfloor \frac{n_h-k_h+p_h}{s_h}+1\rfloor \qquad W&#x3D;\lfloor\frac{n_w-k_w+p_w}{s_w}+1\rfloor.<br>$$</p><blockquote><p>公式通用的，计算池化后的尺寸也是用这个</p></blockquote><p>如果设置了填充大小为$p_h&#x3D;k_h-1$和$p_w&#x3D;k_w-1$，简化为<br>$$<br>H &#x3D; \lfloor \frac{n_h-1}{s_h}+1\rfloor \qquad W&#x3D;\lfloor\frac{n_w-1}{s_w}+1\rfloor.<br>$$<br>如果<font color='DarkViolet'>输入的高度和宽度可以被垂直和水平步幅整除</font>，则输出形状将为$(n_h&#x2F;s_h) \times (n_w&#x2F;s_w)$</p><p>将高度和宽度的步幅设置为2，从而将输入的高度和宽度减半</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([4, 4])</span><br></pre></td></tr></table></figure><h2 id="多输入多输出"><a href="#多输入多输出" class="headerlink" title="多输入多输出"></a>多输入多输出</h2><h3 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h3><p>假设输入的通道数为$c_i$，那么卷积核的输入通道数也需要为$c_i$</p><p>$c_i&#x3D;1$时可以把卷积核看作形状为$k_h\times k_w$的二维张量</p><p>$c_i&gt;1$时可以得到形状为$c_i\times k_h\times k_w$的卷积核，对每个通道输入的二维张量和卷积核的二维张量进行互相关运算，再对通道求和得到二维张量</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/conv-multi-in.jpg" alt="conv-multi-in"></p><p>函数实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="comment"># 遍历累加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(corr2d(x, k) <span class="keyword">for</span> x, k <span class="keyword">in</span> <span class="built_in">zip</span>(X, K))</span><br></pre></td></tr></table></figure><p>求和代表融合后的特征，综合了所有输入通道在同一空间位置的响应</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]],</span><br><span class="line">               [[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], [<span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>]]])</span><br><span class="line">K = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]], [[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]])</span><br><span class="line"></span><br><span class="line">corr2d_multi_in(X, K)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 56.,  72.],</span><br><span class="line">        [104., 120.]])</span><br></pre></td></tr></table></figure><h3 id="多输出通道"><a href="#多输出通道" class="headerlink" title="多输出通道"></a>多输出通道</h3><p>随着神经网络层数的加深，常会增加输出通道的维数，通过减少空间分辨率以获得更大的通道深度</p><p>即可以将每个通道看作对不同特征的响应，每个通道并不是彼此独立而是协同优化的</p><p>为了获得多个通道的输出，可以为每个输出通道创建一个形状为$c_i\times k_h\times k_w$的卷积核张量，卷积核的形状是$\color{red}c_o\times c_i\times k_h\times k_w$，输出$c_o$个通道</p><p>实现一个计算多个通道的输出的互相关函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="keyword">return</span> torch.stack([corr2d_multi_in(X,k) <span class="keyword">for</span> k <span class="keyword">in</span> K ], <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">K = torch.stack((K, K + <span class="number">1</span>, K + <span class="number">2</span>), <span class="number">0</span>)</span><br><span class="line">corr2d_multi_in_out(X, K)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tensor([[[ 56.,  72.],</span><br><span class="line">         [104., 120.]],</span><br><span class="line"></span><br><span class="line">        [[ 76., 100.],</span><br><span class="line">         [148., 172.]],</span><br><span class="line"></span><br><span class="line">        [[ 96., 128.],</span><br><span class="line">         [192., 224.]]])</span><br></pre></td></tr></table></figure><p>现在的输出包含3个通道，第一个通道的结果与先前结果一致</p><h4 id="1×1卷积层"><a href="#1×1卷积层" class="headerlink" title="1×1卷积层"></a>1×1卷积层</h4><p>看起来似乎没有多大意义，但是可以进行通道计算，输出中的每个元素都是从输入图像中同一位置的元素的线性组合</p><p>可以将1×1卷积层看作在每个像素位置应用的全连接层</p><p>以$c_i$个输入值转换为$c_o$个输出值</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/conv-1x1.jpg" alt="conv-1x1"></p><p>使用全连接层实现1×1卷积，需要对输入和输出形状进行调整</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out_1x1</span>(<span class="params">X, K</span>):</span><br><span class="line">    c_i ,h, w = X.shape</span><br><span class="line">    c_o = K.shape[<span class="number">0</span>]</span><br><span class="line">    X = X.reshape((c_i, h*w))</span><br><span class="line">    K = K.reshape((c_o, c_i))</span><br><span class="line">    <span class="comment"># 全连接层的矩阵乘法</span></span><br><span class="line">    Y = torch.matmul(K, X)</span><br><span class="line">    <span class="keyword">return</span> Y.reshape((c_o,h,w))</span><br></pre></td></tr></table></figure><p>1×1 卷积没有空间移动，只在通道维度上“融合信息”</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>多输入多输出通道可以用来扩展卷积层的模型</li><li>当以每像素为基础应用时，1×1卷积层相当于全连接层</li><li>1×1卷积层通常用于调整网络层的通道数量和控制模型复杂性</li></ul><h3 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>假设有两个卷积核大小分别为$k_1$和$k_2$(中间没有非线性激活函数)</p><p>两次卷积等价于一次卷积，因为卷积运算有结合律</p><p>等效卷积核大小为$k_1+k_2-1$</p><p>但一个大卷积 ≠ 任意两次小卷积，除非满足特殊可分离条件</p></li><li><p>假设输入为$c_i\times h\times w$，卷积核大小为$c_o\times c_i\times k_h\times k_w$，填充为$(p_h, p_w)$，步幅为$(s_h, s_w)$</p><ol><li><p>前向传播的计算成本(乘法和加法)是多少？</p><p>输出空间尺寸<br>$$<br>H &#x3D; \lfloor \frac{n_h-k_h+p_h}{s_h}+1\rfloor \qquad W&#x3D;\lfloor\frac{n_w-k_w+p_w}{s_w}+1\rfloor.<br>$$<br>每个输出像素是一个长度为$c_i k_hk_w$的点积<br>$$<br>\mathrm{Multi_{fwd}} &#x3D; c_oHW(c_ik_h k_w) \qquad \mathrm{Add_{fwd}}&#x3D; c_oHW(c_i k_hk_w-1)<br>$$<br>若有偏置，再为每个输出像素加一次加法</p><p>总复杂度$O(c_oHWc_ik_hk_w)$</p></li><li><p>内存占用是多少?</p><p>必须同时驻留输入、权重、输出(以及可选偏置)<br>$$<br>Mem_{fwd}&#x3D; c_ihw+ c_oc_ik_hk_w +c_oHW +(c_o)<br>$$<br>再乘以dtype大小，$c_o$为偏置大小</p></li></ol></li><li><p>如果将输入通道和输出通道的数量加倍，计算数量会增加多少？把填充数量翻一番会怎么样？</p><p>计算量增加4倍；</p><p>填充增大导致输出空间略变大，对计算量的影响相对较小、近似线性</p></li></ol><h2 id="汇聚-池化"><a href="#汇聚-池化" class="headerlink" title="汇聚&#x2F;池化"></a>汇聚&#x2F;池化</h2><p>当处理图像时，希望逐渐降低隐藏表示的空间分辨率、聚集信息，这样随着在神经网络中层叠的上升，每个神经元对其敏感的感受野(输入)就越大</p><p>机器学习任务通常会跟全局图像的问题有关，所以最后一层的神经元应该对整个输入全局敏感</p><p>通过逐渐聚合信息，生成越来越粗糙的映射，最终实现学习全局表示的目标，同时将卷积图层的所有优势保留在中间层</p><p><strong>汇聚(pooling)层</strong>的目的：</p><ul><li>降低卷积层对位置的敏感性</li><li>降低对空间降采样表示的敏感性</li></ul><p><font color='Violetred'>汇聚层做的就是池化操作</font></p><h3 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h3><p>汇聚层与卷积层相似，都通过一个固定大小的窗口在输入上滑动，并根据步幅计算输出</p><p>但汇聚层执行的是确定性的运算，没有可学习的参数，通常取窗口内元素的最大值或平均值，即<strong>最大汇聚(max pooling)<strong>和</strong>平均汇聚(average pooling)</strong></p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/pooling.jpg" alt="pooling"></p><blockquote><p>几乎不会用到最小池化，因为最小池化往往保留噪声或背景，不太有助于学习</p><p>Softmax软最大在性能上并没有带来显著提升，难以抵消其计算代价，并不常用</p></blockquote><p>在下面的<code>pool2d</code>函数实现汇聚层的前向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span><br><span class="line">    p_h, p_w = pool_size</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>]-p_h+<span class="number">1</span>, X.shape[<span class="number">1</span>]-p_w+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i:i+p_h, j:j+p_w].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i:i+p_h, j:j+p_w].mean()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><p>其实和互相关很像，但是没用到卷积核</p><p>输入张量<code>X</code>，验证二维最大汇聚层的输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line"><span class="built_in">print</span>(pool2d(X, (<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(pool2d(X, (<span class="number">2</span>, <span class="number">2</span>), mode=<span class="string">&#x27;avg&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[4., 5.],</span><br><span class="line">        [7., 8.]])</span><br><span class="line">tensor([[2., 3.],</span><br><span class="line">        [5., 6.]])        </span><br></pre></td></tr></table></figure><h3 id="填充和步幅-1"><a href="#填充和步幅-1" class="headerlink" title="填充和步幅"></a>填充和步幅</h3><p>与卷积层一样，汇聚层也可以改变输出形状，仍然通过填充和步幅来实现</p><p>首先构造了一个输入张量<code>X</code>，它有四个维度，其中样本数和通道数都是1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[[[ 0.,  1.,  2.,  3.],</span><br><span class="line">          [ 4.,  5.,  6.,  7.],</span><br><span class="line">          [ 8.,  9., 10., 11.],</span><br><span class="line">          [12., 13., 14., 15.]]]])</span><br></pre></td></tr></table></figure><p>默认情况下，深度学习框架中的步幅与汇聚窗口的大小相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.MaxPool2d(</span><br><span class="line">    kernel_size,  <span class="comment"># 池化窗口大小</span></span><br><span class="line">    stride=<span class="literal">None</span>,  <span class="comment"># 步幅，默认与 kernel_size 相同</span></span><br><span class="line">    padding=<span class="number">0</span>,    <span class="comment"># 填充</span></span><br><span class="line">    return_indices=<span class="literal">False</span>,  <span class="comment"># 是否返回最大值所在的索引，用于反池化</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([[[[10.]]]])</span><br></pre></td></tr></table></figure><p>填充和步幅可以手动设定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d((<span class="number">2</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">3</span>), padding=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[[[ 5.,  7.],</span><br><span class="line">          [13., 15.]]]])</span><br></pre></td></tr></table></figure><h3 id="多个通道"><a href="#多个通道" class="headerlink" title="多个通道"></a>多个通道</h3><p>在处理多通道输入数据时，汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总，所以汇聚层的输出通道数与输入通道数相同</p><p>将在通道维度上连结张量<code>X</code>和<code>X + 1</code>，以构建具有2个通道的输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X1 = torch.cat((X, X + <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">pool2d = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">pool2d(X1)</span><br></pre></td></tr></table></figure><p>汇聚后输出通道的数量仍然是2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[[[ 5.,  7.],</span><br><span class="line">          [13., 15.]],</span><br><span class="line"></span><br><span class="line">         [[ 6.,  8.],</span><br><span class="line">          [14., 16.]]]])</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>对于给定输入元素，最大汇聚层会输出该窗口内的最大值，平均汇聚层会输出该窗口内的平均值</li><li>汇聚层的主要优点之一是减轻卷积层对位置的过度敏感</li><li>可以指定汇聚层的填充和步幅</li><li>使用最大汇聚层以及大于1的步幅，可减少空间维度(如高度和宽度)</li><li>汇聚层的输出通道数与输入通道数相同</li></ul><h2 id="卷积神经网络-LeNet"><a href="#卷积神经网络-LeNet" class="headerlink" title="卷积神经网络(LeNet)"></a>卷积神经网络(LeNet)</h2><p>LeNet，它是最早发布的卷积神经网络之一，发布时的目的是识别图像(LeCun <em>et al.</em>, 1998)中的手写数字</p><p>LeNet取得了与**支持向量机(support vector machines)**性能相媲美的成果，成为监督学习的主流方法，被广泛用于自动取款机(ATM)机中，帮助识别处理支票的数字</p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>总体来看，LeNet(LeNet-5)由两个部分组成：</p><ul><li>卷积编码器：由两个卷积层组成</li><li>全连接层稠密块：由三个全连接层组成</li></ul><blockquote><p>稠密块可以理解为一组顺序堆叠的<strong>全连接层 + 激活函数</strong></p><p>和后面的DenseNet没有关系</p></blockquote><p>该架构如图所示</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/lenet.webp" alt="lenet"></p><p>每个卷积块由一个使用 5×5 卷积核的卷积层、一个 sigmoid 激活函数和一个平均汇聚层组成</p><p><font color='Violetred'>虽然 ReLU 激活函数和最大汇聚层在性能上更高效，但它们当时尚未被提出</font></p><p>这些层将输入映射到多个二维特征输出，并在提取特征的同时逐步增加通道数</p><p>第一层卷积输出6个通道，第二层卷积输出16个通道</p><p>汇聚操作采用2×2窗口，通过空间下采样使特征图尺寸缩小4倍，减少计算量</p><p>在将卷积块的输出输入至稠密块前，必须在小批量中展平每个样本，将样本从四维张量(批量、通道、高、宽)转换为二维矩阵，第一维表示样本索引，第二维为该样本的平面向量表示</p><p>LeNet的稠密块有三个全连接层，分别有120、84和10个输出</p><p>由于任务是手写数字识别，最终的 10 维输出对应于 10 个数字类别</p><p>只需要实例化一个<code>Sequential</code>块并将需要的层连接在一起就能实现LeNet-5</p><blockquote><p>因为用的MNIST，所以不是原版32×32，所以在第一层卷积的时候加入padding让28-&gt;32</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对原始模型做了一点小改动，去掉了最后一层的高斯激活</p><p>将一个大小为28×28的单通道(黑白)图像通过LeNet，并在每一层打印输出的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>), dtype=torch.float32)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;Layer&#x27;</span>:&lt;<span class="number">15</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;Output shape&#x27;</span>&#125;</span>&quot;</span>)  <span class="comment"># 学习利用格式化字符串&quot;&lt;&quot;对齐</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">30</span>)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;layer.__class__.__name__:&lt;<span class="number">15</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">tuple</span>(X.shape))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Layer          Output shape</span><br><span class="line">------------------------------</span><br><span class="line">Conv2d         (1, 6, 28, 28)</span><br><span class="line">Sigmoid        (1, 6, 28, 28)</span><br><span class="line">AvgPool2d      (1, 6, 14, 14)</span><br><span class="line">Conv2d         (1, 16, 10, 10)</span><br><span class="line">Sigmoid        (1, 16, 10, 10)</span><br><span class="line">AvgPool2d      (1, 16, 5, 5)</span><br><span class="line">Flatten        (1, 400)</span><br><span class="line">Linear         (1, 120)</span><br><span class="line">Sigmoid        (1, 120)</span><br><span class="line">Linear         (1, 84)</span><br><span class="line">Sigmoid        (1, 84)</span><br></pre></td></tr></table></figure><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>看看LeNet在Fashion-MNIST数据集上的表现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size=batch_size)</span><br></pre></td></tr></table></figure><p>虽然卷积神经网络的参数较少，但与深度的多层感知机相比，它们的计算成本仍然很高，因为每个参数都参与更多的乘法，通过使用GPU，可以用它加快训练</p><p>由于完整的数据集位于内存中，因此在模型使用GPU计算数据集之前，需要将其复制到显存中</p><p>对之前<code>evaluate_accuracy</code>函数进行轻微的修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_accuracy_gpu</span>(<span class="params">net, data_iter, device=<span class="literal">None</span></span>): <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用GPU计算模型在数据集上的精度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module):</span><br><span class="line">        net.<span class="built_in">eval</span>()  <span class="comment"># 设置为评估模式</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> device:</span><br><span class="line">            device = <span class="built_in">next</span>(<span class="built_in">iter</span>(net.parameters())).device</span><br><span class="line">    <span class="comment"># 正确预测的数量，总预测的数量</span></span><br><span class="line">    metric = Accumulator(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(X, <span class="built_in">list</span>):</span><br><span class="line">                <span class="comment"># BERT微调所需的(之后将介绍)</span></span><br><span class="line">                X = [x.to(device) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                X = X.to(device)</span><br><span class="line">            y = y.to(device)</span><br><span class="line">            metric.add(accuracy(net(X), y), y.numel())</span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>训练函数也有所变化，进行正向和反向传播之前，需要将每一小批量数据移动到指定的设备(例如GPU)上</p><p>训练函数<code>train_ch6</code>也类似于之前定义的<code>train_ch3</code>，这里用到sigmoid激活所以使用<code>Xavier</code>初始化模型参数，使用交叉熵损失函数和小批量随机梯度下降</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_ch6</span>(<span class="params">net, train_iter, test_iter, num_epochs, lr, device</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用GPU训练模型(在第六章定义)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, (nn.Conv2d, nn.Linear)):</span><br><span class="line">            nn.init.xavier_uniform_(m.weight)</span><br><span class="line">    net.apply(init_weights)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;training on&#x27;</span>, device)</span><br><span class="line">    net.to(device)</span><br><span class="line">    optimizer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">    loss = nn.CrossEntropyLoss()</span><br><span class="line">    animator = Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs],</span><br><span class="line">                            legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">    timer, num_batches = Timer(), <span class="built_in">len</span>(train_iter)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="comment"># 训练损失之和，训练准确率之和，样本数</span></span><br><span class="line">        metric = Accumulator(<span class="number">3</span>)</span><br><span class="line">        net.train()</span><br><span class="line">        <span class="keyword">for</span> i, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):</span><br><span class="line">            timer.start()</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            X, y = X.to(device), y.to(device)</span><br><span class="line">            y_hat = net(X)</span><br><span class="line">            l = loss(y_hat, y)</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                metric.add(l * X.shape[<span class="number">0</span>], accuracy(y_hat, y), X.shape[<span class="number">0</span>])</span><br><span class="line">            timer.stop()</span><br><span class="line">            train_l = metric[<span class="number">0</span>] / metric[<span class="number">2</span>]</span><br><span class="line">            train_acc = metric[<span class="number">1</span>] / metric[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">                animator.add(epoch + (i + <span class="number">1</span>) / num_batches,</span><br><span class="line">                             (train_l, train_acc, <span class="literal">None</span>))</span><br><span class="line">        test_acc = evaluate_accuracy_gpu(net, test_iter)</span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, test_acc))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;epoch <span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;train_l:<span class="number">.3</span>f&#125;</span>, acc <span class="subst">&#123;train_acc:<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    animator.show()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;loss <span class="subst">&#123;train_l:<span class="number">.3</span>f&#125;</span>, train acc <span class="subst">&#123;train_acc:<span class="number">.3</span>f&#125;</span>, &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;test acc <span class="subst">&#123;test_acc:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;metric[<span class="number">2</span>] * num_epochs / timer.<span class="built_in">sum</span>():<span class="number">.1</span>f&#125;</span> examples/sec &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;on <span class="subst">&#123;<span class="built_in">str</span>(device)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs = <span class="number">0.9</span>, <span class="number">10</span></span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">training on cpu</span><br><span class="line">epoch 1, loss 2.321, acc 0.102</span><br><span class="line">epoch 2, loss 2.165, acc 0.168</span><br><span class="line">epoch 3, loss 1.031, acc 0.586</span><br><span class="line">epoch 4, loss 0.805, acc 0.686</span><br><span class="line">epoch 5, loss 0.679, acc 0.734</span><br><span class="line">epoch 6, loss 0.622, acc 0.758</span><br><span class="line">epoch 7, loss 0.575, acc 0.777</span><br><span class="line">epoch 8, loss 0.535, acc 0.793</span><br><span class="line">epoch 9, loss 0.500, acc 0.811</span><br><span class="line">epoch 10, loss 0.478, acc 0.819</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510232252.webp" alt="202510232252" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.478, train acc 0.819, test acc 0.821</span><br><span class="line">34923.8 examples/sec on cpu</span><br></pre></td></tr></table></figure><h3 id="模型升级"><a href="#模型升级" class="headerlink" title="模型升级"></a>模型升级</h3><p>如果想将ReLU和最大汇聚层加入其中优化，需要对结构进行一些修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同时初始化函数要修改为<code>Kaiming</code>初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, (nn.Conv2d, nn.Linear)):</span><br><span class="line">        nn.init.kaiming_uniform_(m.weight, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br></pre></td></tr></table></figure><p>因为ReLU的梯度比较大，所以学习率不能那么大，设为0.15</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs = <span class="number">0.15</span>, <span class="number">10</span></span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">training on cpu</span><br><span class="line">epoch 1, loss 0.764, acc 0.724</span><br><span class="line">epoch 2, loss 0.450, acc 0.834</span><br><span class="line">epoch 3, loss 0.379, acc 0.861</span><br><span class="line">epoch 4, loss 0.343, acc 0.873</span><br><span class="line">epoch 5, loss 0.319, acc 0.881</span><br><span class="line">epoch 6, loss 0.299, acc 0.888</span><br><span class="line">epoch 7, loss 0.287, acc 0.892</span><br><span class="line">epoch 8, loss 0.277, acc 0.897</span><br><span class="line">epoch 9, loss 0.261, acc 0.902</span><br><span class="line">epoch 10, loss 0.252, acc 0.906</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510232335.webp" alt="202510232335" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.252, train acc 0.906, test acc 0.885</span><br><span class="line">33082.3 examples/sec on cpu</span><br></pre></td></tr></table></figure><p>可以看到准确率得到了大幅提升</p><h3 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>将平均汇聚层替换为最大汇聚层，会发生什么？</p><p>平均汇聚会把特征“柔化”，而最大汇聚让模型更关注最突出的区域，所以输出特征图会更稀疏、更“尖锐”</p><p>只有最大值那一个像素会收到梯度更新，对于 LeNet 这种浅层网络来说，可能导致部分通道几乎不更新，梯度传播变稀疏</p><p>收敛速度可能更快，但不稳定</p><p>需要对应更换激活函数为ReLU才能发货最大汇聚层的优势</p></li><li><p>改进LeNet</p><table><thead><tr><th>方面</th><th>原始设计</th><th>改进方向</th></tr></thead><tbody><tr><td>激活函数</td><td>Sigmoid</td><td>改为 ReLU</td></tr><tr><td>池化方式</td><td>AvgPool</td><td>改为 MaxPool</td></tr><tr><td>卷积核大小</td><td>5×5</td><td>改为 3×3(更细特征)</td></tr><tr><td>输出通道数</td><td>6, 16</td><td>增大为 16, 32</td></tr><tr><td>卷积层数量</td><td>2 层</td><td>增加到 3 层</td></tr><tr><td>全连接层数量</td><td>3 层</td><td>减少到 2 层或用 Dropout 防过拟合</td></tr><tr><td>初始化</td><td>Xavier</td><td>改为 Kaiming</td></tr><tr><td>优化器</td><td>SGD(lr&#x3D;0.9)</td><td>改为 Adam(lr&#x3D;1e-3)</td></tr><tr><td>训练轮数</td><td>10</td><td>增加到 15~20</td></tr></tbody></table><p>基本就能实现91–93%的准确率</p></li></ol><h2 id="深度卷积神经网络-AlexNet"><a href="#深度卷积神经网络-AlexNet" class="headerlink" title="深度卷积神经网络(AlexNet)"></a>深度卷积神经网络(AlexNet)</h2><p>在LeNet提出后，卷积神经网络在计算机视觉和机器学习领域中很有名气，但卷积神经网络并没有主导这些领域</p><p>因为虽然LeNet在小数据集上取得了很好的效果，但是在更大、更真实的数据集上训练卷积神经网络的性能和可行性还有待研究</p><h3 id="学习表征"><a href="#学习表征" class="headerlink" title="学习表征"></a>学习表征</h3><p>在2012年前，图像特征都是机械地计算出来的，SIFT(Lowe, 2004)、SURF(Bay <em>et al.</em>, 2006)、HOG(定向梯度直方图)(Dalal and Triggs, 2005)、bags of visual words等特征提取方法占据了主导地位</p><p>另一组研究人员提出<strong>特征应由模型自动学习</strong>，并通过多层神经网络在不同层次提取抽象特征，在视觉任务中，底层可学习边缘、颜色和纹理等基本特征</p><p>这一思想在AlexNet(Krizhevsky <em>et al.</em>, 2012) 中得到突破性验证</p><p>AlexNet 的底层卷积核学到的模式与传统图像滤波器极为相似</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/filters.webp" alt="filters"></p><p>AlexNet的更高层建立在这些底层表示的基础上，以表示更大的特征</p><p>深度卷积神经网络的突破出现在2012年，突破可归因于两个关键因素</p><ul><li>数据：10年以后数据集的规模快速扩大(ImageNet)</li><li>硬件：GPU并行计算实现</li></ul><h3 id="网络结构-1"><a href="#网络结构-1" class="headerlink" title="网络结构"></a>网络结构</h3><p>AlexNet和LeNet的架构非常相似，左图为LeNet结构，右图为AlexNet结构</p><p>图中AlexNet结构去除了原文需要两个小型GPU同时运算的设计特点</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/alexnet.webp" alt="alexnet" style="zoom:80%;" /><p>AlexNet和LeNet的设计理念非常相似，但也存在显著差异</p><ol><li><p>AlexNet比相对LeNet要深得多，由八层组成：五个卷积层、两个全连接隐藏层和一个全连接输出层</p></li><li><p>AlexNet使用ReLU而不是sigmoid作为其激活函数</p><p>计算更简单，不需要幂次计算，并且避免出现初始化异常导致梯度消失的情况</p></li></ol><p>第一层卷积窗口的形状是11×11，这是因为ImageNet的图片是要比MNIST长宽大10倍以上，需要一个更大的卷积窗口来捕获目标；第二层的形状为5×5，其余卷积层为3×3</p><p>在第一层、第二层和第五层卷积层之后，加入窗口形状为3×3，步幅为2的最大汇聚层，并且卷积通道数是LeNet的10倍</p><p>在最后一个卷积层后有两个全连接层，分别有4096个输出，这两个巨大的全连接层拥有将近1GB的模型参数</p><blockquote><p>早期GPU内存有限，原版AlexNet采用了双数据流设计，使得每个GPU负责存储和计算模型的一半参数，现在很少需要跨GPU分解模型了</p></blockquote><p>AlexNet通过暂退法控制全连接层的模型复杂度，而LeNet只使用了权重衰减</p><p>为了进一步扩充数据，AlexNet在训练时增加了大量的图像增强数据，如翻转、裁切和变色，这使得模型更健壮，更大的样本量有效地减少了过拟合(以下代码中没有体现)</p><p>实例化一个<code>Sequential</code>块并将需要的层连接在一起实现AlexNet</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, stride=<span class="number">4</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 减小卷积窗口且增大输出通道数, padding保持输入输出大小一致</span></span><br><span class="line">    nn.Conv2d(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 使用三个连续的卷积层和较小的卷积窗口</span></span><br><span class="line">    nn.Conv2d(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">384</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">384</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    <span class="comment"># 全连接层的输出数量是LeNet中的好几倍。使用dropout层来减轻过拟合</span></span><br><span class="line">    nn.Linear(<span class="number">256</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">4096</span>), nn.ReLU(),</span><br><span class="line">    nn.Dropout(p = <span class="number">0.5</span>),</span><br><span class="line">    nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>), nn.ReLU(),</span><br><span class="line">    nn.Dropout(p = <span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 输出层，由于使用Fashion-MNIST，所以用类别数为10，而非论文中的1000</span></span><br><span class="line">    nn.Linear(<span class="number">4096</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>构造一个高度和宽度都为224的单通道数据，来观察每一层输出的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;Layer&#x27;</span>:&lt;<span class="number">15</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;Output Shape&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">30</span>)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;layer.__class__.__name__:&lt;<span class="number">15</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">tuple</span>(X.shape))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Layer          Output Shape</span><br><span class="line">------------------------------</span><br><span class="line">Conv2d         (1, 96, 54, 54)</span><br><span class="line">ReLU           (1, 96, 54, 54)</span><br><span class="line">MaxPool2d      (1, 96, 26, 26)</span><br><span class="line">Conv2d         (1, 256, 26, 26)</span><br><span class="line">ReLU           (1, 256, 26, 26)</span><br><span class="line">MaxPool2d      (1, 256, 12, 12)</span><br><span class="line">Conv2d         (1, 384, 12, 12)</span><br><span class="line">ReLU           (1, 384, 12, 12)</span><br><span class="line">Conv2d         (1, 384, 12, 12)</span><br><span class="line">ReLU           (1, 384, 12, 12)</span><br><span class="line">Conv2d         (1, 256, 12, 12)</span><br><span class="line">ReLU           (1, 256, 12, 12)</span><br><span class="line">MaxPool2d      (1, 256, 5, 5)</span><br><span class="line">Flatten        (1, 6400)</span><br><span class="line">Linear         (1, 4096)</span><br><span class="line">ReLU           (1, 4096)</span><br><span class="line">Dropout        (1, 4096)</span><br><span class="line">Linear         (1, 4096)</span><br><span class="line">ReLU           (1, 4096)</span><br><span class="line">Dropout        (1, 4096)</span><br><span class="line">Linear         (1, 10)</span><br></pre></td></tr></table></figure><h3 id="模型训练-1"><a href="#模型训练-1" class="headerlink" title="模型训练"></a>模型训练</h3><p>原文中AlexNet是在ImageNet上进行训练的，但在这里使用的是Fashion-MNIST数据集</p><p>因为即使在现代GPU上，训练ImageNet模型，同时使其收敛可能需要数小时或数天的时间</p><p>将AlexNet直接应用于Fashion-MNIST会出现一个问题，Fashion-MNIST图像的分辨率低于ImageNet图像，在这里为了方便使用直接将MNIST图像<code>resize</code>到224×224(通常这不是一个明智的做法)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size, resize=<span class="number">224</span>)</span><br></pre></td></tr></table></figure><p>现在AlexNet可以开始被训练了，这里的主要变化是使用更小的学习速率训练，这是因为网络更深更广、图像分辨率更高，训练卷积神经网络就更昂贵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs = <span class="number">0.01</span>, <span class="number">10</span></span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, try_gpu())</span><br></pre></td></tr></table></figure><p>到这里cpu烤不动了，得换到有GPU的电脑来跑了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">training on cuda:0</span><br><span class="line">epoch 1, loss 0.795, acc 0.716</span><br><span class="line">epoch 2, loss 0.483, acc 0.825</span><br><span class="line">epoch 3, loss 0.414, acc 0.851</span><br><span class="line">epoch 4, loss 0.375, acc 0.865</span><br><span class="line">epoch 5, loss 0.347, acc 0.873</span><br><span class="line">epoch 6, loss 0.328, acc 0.880</span><br><span class="line">epoch 7, loss 0.312, acc 0.885</span><br><span class="line">epoch 8, loss 0.299, acc 0.891</span><br><span class="line">epoch 9, loss 0.287, acc 0.896</span><br><span class="line">epoch 10, loss 0.275, acc 0.900</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/2025-10-24_152814_212.png" alt="2025-10-24_152814_212" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.275, train acc 0.900, test acc 0.899</span><br><span class="line">1432.2 examples/sec on cuda:0</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>AlexNet的架构与LeNet相似，但使用了更多的卷积层和更多的参数来拟合大规模的ImageNet数据集</li><li>AlexNet已经被更有效的架构所超越，但它是从浅层网络到深层网络的关键一步</li><li><font color='DarkViolet'>Dropout、ReLU和预处理是提升计算机视觉任务性能的其他关键步骤</font></li></ul><h3 id="思考题-3"><a href="#思考题-3" class="headerlink" title="思考题"></a>思考题</h3><p>分析了AlexNet的计算性能</p><ul><li><p>在AlexNet中主要是哪部分占用显存？</p><p><strong>特征图(feature maps)</strong> 和 <strong>模型参数(parameters)</strong></p><p>模型参数：</p><table><thead><tr><th>类型</th><th>层定义参数</th><th>输出尺寸</th><th>模型参数</th></tr></thead><tbody><tr><td>Conv1</td><td>11×11, stride&#x3D;4, padding&#x3D;2, out_channels&#x3D;96</td><td>55×55×96</td><td>34,944</td></tr><tr><td>MaxPool</td><td>3×3, stride&#x3D;2</td><td>27×27×96</td><td></td></tr><tr><td>Conv2</td><td>5×5, padding&#x3D;2, out_channels&#x3D;256</td><td>27×27×256</td><td>614,656</td></tr><tr><td>MaxPool</td><td>3×3, stride&#x3D;2</td><td>13×13×256</td><td></td></tr><tr><td>Conv3</td><td>3×3, out_channels&#x3D;384</td><td>13×13×384</td><td>885,120</td></tr><tr><td>Conv4</td><td>3×3, out_channels&#x3D;384</td><td>13×13×384</td><td>1,327,488</td></tr><tr><td>Conv5</td><td>3×3, out_channels&#x3D;256</td><td>13×13×256</td><td>884,992</td></tr><tr><td>MaxPool</td><td>3×3, stride&#x3D;2</td><td>6×6×256</td><td></td></tr><tr><td>FC1</td><td>4096 neurons</td><td>-</td><td>37,752,832</td></tr><tr><td>FC2</td><td>4096 neurons</td><td>-</td><td>16,781,312</td></tr><tr><td>FC3</td><td>1000 neurons (ImageNet classes)</td><td>-</td><td>4,097,000</td></tr></tbody></table><p>卷积层的参数计算公式<br>$$<br>\mathrm{Params} &#x3D; (k_h\times k_w\times C_{in})\times C_{out}+C_{out}<br>$$</p><table><thead><tr><th>模块</th><th>参数数量</th></tr></thead><tbody><tr><td>卷积层</td><td>≈ 3.75 M</td></tr><tr><td>全连接层</td><td>≈ 58.6 M</td></tr><tr><td>总计</td><td>≈ 62.3 M</td></tr></tbody></table></li><li><p>在AlexNet中主要是哪部分需要更多的计算？</p><p>中间到后期的卷积层</p><p>对于一个卷积层，乘加次数为<br>$$<br>\mathrm{MAC_s} &#x3D; K_h\times K_w\times C_{in}\times H_{out}\times W_{out}\times C_{out}<br>$$</p><table><thead><tr><th>层</th><th>输入尺寸</th><th>卷积核</th><th>输出通道</th><th>输出尺寸</th><th>乘加次数</th></tr></thead><tbody><tr><td>Conv1</td><td>3×224×224</td><td>11×11</td><td>96</td><td>54×54</td><td>105M</td></tr><tr><td>Conv2</td><td>96×54×54</td><td>5×5</td><td>256</td><td>26×26</td><td>448M</td></tr><tr><td>Conv3</td><td>256×26×26</td><td>3×3</td><td>384</td><td>26×26</td><td>298M</td></tr><tr><td>Conv4</td><td>384×26×26</td><td>3×3</td><td>384</td><td>26×26</td><td>447M</td></tr><tr><td>Conv5</td><td>384×26×26</td><td>3×3</td><td>256</td><td>26×26</td><td>298M</td></tr></tbody></table><p>全连接层虽然参数多(占了 90% 的参数量)，但计算量反而较小</p><p>业内有两种说法：</p><ul><li>FLOPs 把一次乘加算 2 次运算</li><li>MACs 把一次乘加算 1 次运算</li></ul></li></ul><h2 id="使用块的网络-VGG"><a href="#使用块的网络-VGG" class="headerlink" title="使用块的网络(VGG)"></a>使用块的网络(VGG)</h2><p>虽然AlexNet证明深层神经网络卓有成效，但它没有提供一个通用的模板</p><p>与芯片设计中工程师从放置晶体管到逻辑元件再到逻辑块的过程类似，神经网络架构的设计也逐渐变得更加抽象，开始从单个神经元的角度思考问题，发展到整个层，现在又转向块，重复层的模式</p><p>使用块的想法首先出现在牛津大学的视觉几何组的VGG网络中</p><h3 id="VGG块"><a href="#VGG块" class="headerlink" title="VGG块"></a>VGG块</h3><p>经典卷积神经网络的基本组成部分是下面的这个序列：</p><ol><li>带填充以保持分辨率的卷积层</li><li>非线性激活函数，如ReLU</li><li>汇聚层，如最大汇聚层</li></ol><p>而一个VGG块与之类似，由一系列卷积层组成，后面再加上用于空间下采样的最大汇聚层</p><p>在最初的VGG论文中(Simonyan and Zisserman, 2014)使用了带有3×3卷积核，填充为1(保持高度和宽度)的卷积层和2×2汇聚窗口、步幅为2(每个块后分辨率减半)的最大汇聚层</p><p>定义一个名为<code>vgg_block</code>的函数来实现一个VGG块</p><p>该函数有三个参数，分别对应于卷积层的数量<code>num_convs</code>、输入通道的数量<code>in_channels</code> 和输出通道的数量<code>out_channels</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vgg_block</span>(<span class="params">num_convs, in_channels, out_channels</span>):</span><br><span class="line">    layers = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_convs):</span><br><span class="line">        layers.append(nn.Conv2d(in_channels, out_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>))</span><br><span class="line">        layers.append(nn.ReLU())</span><br><span class="line">        in_channels = out_channels <span class="comment"># 更新后继续输入</span></span><br><span class="line">    layers.append(nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(*layers) <span class="comment"># 解包列表，逐个放入</span></span><br></pre></td></tr></table></figure><h3 id="网络结构-2"><a href="#网络结构-2" class="headerlink" title="网络结构"></a>网络结构</h3><p>与AlexNet、LeNet一样，VGG网络可以分为两部分：第一部分主要由卷积层和汇聚层组成，第二部分由全连接层组成</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/vgg.webp" alt="vgg" style="zoom:80%;" /><p>VGG神经网络连接几个VGG块(在<code>vgg_block</code>函数中定义)，其中有超参数变量<code>conv_arch</code></p><p>该变量指定了每个VGG块里卷积层个数和输出通道数，全连接模块则与AlexNet中的相同</p><p>原始VGG网络有5个卷积块，其中前两个块各有一个卷积层，后三个块各包含两个卷积层</p><p>第一个模块有64个输出通道，每个后续模块将输出通道数量翻倍，直到该数字达到512。由于该网络使用8个卷积层和3个全连接层，因此它通常被称为VGG-11</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># conv_arch 的内容为(num_convs, out_channels)，输入通道由程序逻辑推导</span></span><br><span class="line">conv_arch = ((<span class="number">1</span>, <span class="number">64</span>), (<span class="number">1</span>, <span class="number">128</span>), (<span class="number">2</span>, <span class="number">256</span>), (<span class="number">2</span>, <span class="number">512</span>), (<span class="number">2</span>, <span class="number">512</span>)) </span><br></pre></td></tr></table></figure><p>下面的代码实现了VGG-11，可以通过在<code>conv_arch</code>上执行for循环来简单实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vgg</span>(<span class="params">conv_arch</span>):</span><br><span class="line">    conv_blks = []</span><br><span class="line">    in_channels = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 卷积层部分</span></span><br><span class="line">    <span class="keyword">for</span> (num_convs, out_channels) <span class="keyword">in</span> conv_arch:</span><br><span class="line">        conv_blks.append(vgg_block(num_convs, in_channels, out_channels))</span><br><span class="line">        in_channels = out_channels</span><br><span class="line">    conv_part = nn.Sequential(*conv_blks)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟前向传播计算flatten大小</span></span><br><span class="line">    X = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> conv_part:</span><br><span class="line">        X = layer(X)</span><br><span class="line">    flatten_dim = X.numel() <span class="comment"># 计算展开维度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        conv_part, nn.Flatten(),</span><br><span class="line">        nn.Linear(flatten_dim, <span class="number">4096</span>), nn.ReLU(), nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">        nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>), nn.ReLU(), nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">        nn.Linear(<span class="number">4096</span>, <span class="number">10</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>构建一个高度和宽度为224的单通道数据样本，以观察每个层输出的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">net = vgg(conv_arch)</span><br><span class="line">X = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;Layer&#x27;</span>:&lt;<span class="number">15</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;Output Shape&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">30</span>)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    <span class="comment"># 如果是卷积部分(Sequential)，继续深入打印</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(layer, nn.Sequential):</span><br><span class="line">        <span class="keyword">for</span> sub_layer <span class="keyword">in</span> layer:</span><br><span class="line">            X = sub_layer(X)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;sub_layer.__class__.__name__:&lt;<span class="number">15</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">tuple</span>(X.shape))&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        X = layer(X)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;layer.__class__.__name__:&lt;<span class="number">15</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">tuple</span>(X.shape))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Layer          Output Shape</span><br><span class="line">------------------------------</span><br><span class="line">Sequential     (1, 64, 112, 112)</span><br><span class="line">Sequential     (1, 128, 56, 56)</span><br><span class="line">Sequential     (1, 256, 28, 28)</span><br><span class="line">Sequential     (1, 512, 14, 14)</span><br><span class="line">Sequential     (1, 512, 7, 7)</span><br><span class="line">Flatten        (1, 25088)</span><br><span class="line">Linear         (1, 4096)</span><br><span class="line">ReLU           (1, 4096)</span><br><span class="line">Dropout        (1, 4096)</span><br><span class="line">Linear         (1, 4096)</span><br><span class="line">ReLU           (1, 4096)</span><br></pre></td></tr></table></figure><p>正如从代码中所看到的，在每个块输出的高度和宽度减半，最终高度和宽度都为7，最后再展平表示，送入全连接层处理</p><p>为了方便打印，把打印封装为函数</p><p>如果没有遍历sub_layer会将多个卷积视为一个块，只会输出一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_net_shapes</span>(<span class="params">net, X</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;Layer&#x27;</span>:&lt;<span class="number">15</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;Output Shape&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">        <span class="comment"># 如果是块Sequential，继续深入再打印</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(layer, nn.Sequential):</span><br><span class="line">            <span class="keyword">for</span> sub_layer <span class="keyword">in</span> layer:</span><br><span class="line">                X = sub_layer(X)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;sub_layer.__class__.__name__:&lt;<span class="number">15</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">tuple</span>(X.shape))&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X = layer(X)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;layer.__class__.__name__:&lt;<span class="number">15</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">tuple</span>(X.shape))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="模型训练-2"><a href="#模型训练-2" class="headerlink" title="模型训练"></a>模型训练</h3><p>由于VGG-11比AlexNet计算量更大，因此构建了一个通道数较少的网络，足够用于训练Fashion-MNIST数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ratio = <span class="number">4</span>  <span class="comment"># 减少输出通道数倍率</span></span><br><span class="line">small_conv_arch = [(pair[<span class="number">0</span>], pair[<span class="number">1</span>] // ratio) <span class="keyword">for</span> pair <span class="keyword">in</span> conv_arch]</span><br><span class="line">net = vgg(small_conv_arch)</span><br></pre></td></tr></table></figure><p>除了使用略高的学习率外，模型训练过程与AlexNet类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.05</span>, <span class="number">10</span>, <span class="number">128</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size, resize=<span class="number">224</span>)</span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">epoch 1, loss 0.675, acc 0.755</span><br><span class="line">epoch 2, loss 0.353, acc 0.871</span><br><span class="line">epoch 3, loss 0.301, acc 0.890</span><br><span class="line">epoch 4, loss 0.267, acc 0.902</span><br><span class="line">epoch 5, loss 0.241, acc 0.910</span><br><span class="line">epoch 6, loss 0.221, acc 0.918</span><br><span class="line">epoch 7, loss 0.204, acc 0.925</span><br><span class="line">epoch 8, loss 0.189, acc 0.930</span><br><span class="line">epoch 9, loss 0.175, acc 0.937</span><br><span class="line">epoch 10, loss 0.163, acc 0.940</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/2025-10-24_171101_367.png" alt="2025-10-24_171101_367" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.163, train acc 0.940, test acc 0.928</span><br><span class="line">1030.3 examples/sec on cuda:0</span><br></pre></td></tr></table></figure><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul><li>VGG-11使用可复用的卷积块构造网络，不同的VGG模型可通过每个块中卷积层数量和输出通道数量的差异来定义</li><li>块的使用导致网络定义的非常简洁，使用块可以有效地设计复杂的网络</li><li>在VGG论文中，他们发现<strong>深层且窄的卷积(3×3)<strong>比</strong>浅层且宽的卷积</strong>更有效</li></ul><h3 id="思考题-4"><a href="#思考题-4" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>与AlexNet相比，VGG的计算要慢得多，而且它还需要更多的显存。分析出现这种情况的原因</p><table><thead><tr><th>模型</th><th>卷积层数</th><th>卷积核大小</th><th>通道增长</th><th>参数量</th></tr></thead><tbody><tr><td>AlexNet</td><td>5 层</td><td>11×11, 5×5, 3×3</td><td>96→256→384→384→256</td><td>~61M</td></tr><tr><td>VGG-11</td><td>8 层</td><td>3×3</td><td>64→128→256→512→512</td><td>~132M</td></tr></tbody></table><p>VGG 的卷积层数量更多，通道数更多，参数几乎翻倍，中间特征图分辨率保持更高</p></li><li><p>尝试将Fashion-MNIST数据集图像的高度和宽度从224改为96，这对实验有什么影响</p><p>卷积层的输出特征图变小，全连接层输入维度随之改变，计算效率会得到提高</p></li></ol><h3 id="不同的VGG"><a href="#不同的VGG" class="headerlink" title="不同的VGG"></a>不同的VGG</h3><table><thead><tr><th>模型</th><th>卷积层数</th><th>全连接层</th><th>总层数(卷积+全连接)</th></tr></thead><tbody><tr><td>VGG-11 (A型)</td><td>8</td><td>3</td><td>11</td></tr><tr><td>VGG-16 (D型)</td><td>13</td><td>3</td><td>16</td></tr><tr><td>VGG-19 (E型)</td><td>16</td><td>3</td><td>19</td></tr></tbody></table><p>卷积块设计：</p><table><thead><tr><th>Block</th><th>输出通道</th><th>池化后尺寸</th><th>VGG-11</th><th>VGG-16</th><th>VGG-19</th></tr></thead><tbody><tr><td>1</td><td>64</td><td>112×112</td><td>Conv×1</td><td>Conv×2</td><td>Conv×2</td></tr><tr><td>2</td><td>128</td><td>56×56</td><td>Conv×1</td><td>Conv×2</td><td>Conv×2</td></tr><tr><td>3</td><td>256</td><td>28×28</td><td>Conv×2</td><td>Conv×3</td><td>Conv×4</td></tr><tr><td>4</td><td>512</td><td>14×14</td><td>Conv×2</td><td>Conv×3</td><td>Conv×4</td></tr><tr><td>5</td><td>512</td><td>7×7</td><td>Conv×2</td><td>Conv×3</td><td>Conv×4</td></tr></tbody></table><p>性能对比：</p><table><thead><tr><th>模型</th><th>参数量</th><th>GFLOPs</th><th>Top-5 准确率</th><th>特征</th></tr></thead><tbody><tr><td>VGG-11</td><td>≈ 133M</td><td>≈ 7.6</td><td>~89.5%</td><td>最浅、最快、参数最少</td></tr><tr><td>VGG-16</td><td>≈ 138M</td><td>≈ 15.3</td><td>~92.7%</td><td>标准版，最常用</td></tr><tr><td>VGG-19</td><td>≈ 144M</td><td>≈ 19.6</td><td>~93.0%</td><td>最深、最慢、参数略多</td></tr></tbody></table><p>VGG-16是性能与代价的最佳平衡点，从VGG-16到VGG-19精度几乎不变，但计算量大幅增加</p><p><font color='Violetred'>所以工业界和研究中最常用的是 VGG-16</font></p><p>如果想要修改VGG模型，只需要修改conv_arch，以下为VGG-16结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conv_arch = ((<span class="number">2</span>, <span class="number">64</span>), (<span class="number">2</span>, <span class="number">128</span>), (<span class="number">3</span>, <span class="number">256</span>), (<span class="number">3</span>, <span class="number">512</span>), (<span class="number">3</span>, <span class="number">512</span>))</span><br></pre></td></tr></table></figure><h2 id="网络中的网络-NiN"><a href="#网络中的网络-NiN" class="headerlink" title="网络中的网络(NiN)"></a>网络中的网络(NiN)</h2><p>LeNet、AlexNet和VGG都有一个共同的设计模式：通过一系列的卷积层与汇聚层来提取空间结构特征，然后通过全连接层对特征的表征进行处理</p><p>AlexNet和VGG对LeNet的改进主要在于如何扩大和加深这两个模块</p><p>如果在这个过程的早期使用了全连接层，可能会完全放弃表征的空间结构，NiN提供了一个非常简单的解决方案：在每个像素的通道上分别使用多层感知机(Lin <em>et al.</em>, 2013)</p><h3 id="NiN块"><a href="#NiN块" class="headerlink" title="NiN块"></a>NiN块</h3><p>NiN的核心思想是：在每个像素位置上应用一个1×1卷积(可视为局部全连接层)，把空间维度的每个像素当作独立样本，通道维度作为其特征进行学习</p><p>VGG和NiN及它们的块之间主要架构差异：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/nin~1.webp" alt="nin~1" style="zoom:80%;" /><p>NiN块以一个普通卷积层开始，输入输出通道数通常由用户设置，后面是两个1×1的卷积层，这两个卷积层充当带有ReLU激活函数的逐像素全连接层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nin_block</span>(<span class="params">in_channels, out_channels, kernel_size, stride, padding</span>):</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">        nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>), nn.ReLU())</span><br></pre></td></tr></table></figure><h3 id="网络结构-3"><a href="#网络结构-3" class="headerlink" title="网络结构"></a>网络结构</h3><p>最初的NiN在AlexNet后不久提出，结构类似，仍用11×11、5×5、3×3卷积和步幅为2的3×3最大池化，输出通道数相同，主要区别在于用NiN块替代全连接层，并通过**全局平均汇聚层(global average pooling layer)**输出类别</p><p>NiN设计显著减少参数量，但在实际中可能会增加训练模型的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nin_block(<span class="number">1</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, stride=<span class="number">4</span>, padding=<span class="number">0</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nin_block(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="number">2</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nin_block(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 标签类别为10</span></span><br><span class="line">    nin_block(<span class="number">384</span>, <span class="number">10</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)), <span class="comment"># 对每个类别通道取平均，固定输出尺寸</span></span><br><span class="line">    <span class="comment"># 输出 [batch_size, channels, 1, 1]</span></span><br><span class="line">    nn.Flatten() <span class="comment"># 展平为[batch_size, channels]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>创建一个数据样本来查看每个块的输出形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;Layer&#x27;</span>:&lt;<span class="number">20</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;Output Shape&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;layer.__class__.__name__:&lt;<span class="number">20</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">tuple</span>(X.shape))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Layer               Output Shape</span><br><span class="line">----------------------------------------</span><br><span class="line">Sequential          (1, 96, 54, 54)</span><br><span class="line">MaxPool2d           (1, 96, 26, 26)</span><br><span class="line">Sequential          (1, 256, 26, 26)</span><br><span class="line">MaxPool2d           (1, 256, 12, 12)</span><br><span class="line">Sequential          (1, 384, 12, 12)</span><br><span class="line">MaxPool2d           (1, 384, 5, 5)</span><br><span class="line">Dropout             (1, 384, 5, 5)</span><br><span class="line">Sequential          (1, 10, 5, 5)</span><br><span class="line">AdaptiveAvgPool2d   (1, 10, 1, 1)</span><br><span class="line">Flatten             (1, 10)</span><br></pre></td></tr></table></figure><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>使用Fashion-MNIST来训练模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.1</span>, <span class="number">10</span>, <span class="number">128</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size, resize=<span class="number">224</span>)</span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">epoch 1, loss 2.084, acc 0.224, time 61.468</span><br><span class="line">epoch 2, loss 1.739, acc 0.381, time 64.322</span><br><span class="line">epoch 3, loss 1.147, acc 0.614, time 71.435</span><br><span class="line">epoch 4, loss 0.797, acc 0.712, time 72.637</span><br><span class="line">epoch 5, loss 0.715, acc 0.744, time 72.469</span><br><span class="line">epoch 6, loss 0.663, acc 0.772, time 65.857</span><br><span class="line">epoch 7, loss 0.632, acc 0.788, time 65.089</span><br><span class="line">epoch 8, loss 0.626, acc 0.792, time 64.080</span><br><span class="line">epoch 9, loss 0.576, acc 0.807, time 65.202</span><br><span class="line">epoch 10, loss 0.554, acc 0.814, time 65.073</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/2025-10-24_223841_316.png" alt="2025-10-24_223841_316" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.554, train acc 0.814, test acc 0.787</span><br><span class="line">1250.5 examples/sec on cuda:0</span><br></pre></td></tr></table></figure><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ul><li>NiN使用由一个卷积层和多个1×1卷积层组成的块，该块可以在卷积神经网络中使用，以允许更多的每像素非线性</li><li>NiN去除了容易造成过拟合的全连接层，将它们替换为全局平均汇聚层(即在所有位置上进行求和)，该汇聚层通道数量为所需的输出数量</li><li>移除全连接层可减少过拟合，同时显著减少NiN的参数</li><li>虽然NiN的性能不比VGG，但它取消全连接层的思想很重要，为后来的 GoogLeNet、ResNet 等模型奠定了基础</li></ul><h3 id="思考题-5"><a href="#思考题-5" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>为什么NiN块中有两个1×1卷积层？</p><table><thead><tr><th>层次</th><th>功能</th><th>类比</th></tr></thead><tbody><tr><td>普通卷积</td><td>提取局部空间特征</td><td>“卷积滤波器”</td></tr><tr><td>第一个 1×1 卷积</td><td>对通道特征进行第一次变换</td><td>“小型全连接层”</td></tr><tr><td>第二个 1×1 卷积</td><td>进一步学习通道间非线性关系</td><td>“堆叠的多层感知机”</td></tr></tbody></table><p>第一个用于提取和压缩通道特征，第二个用于再次组合与非线性变换，增强表示能力</p><p>如果删除一个1×1卷积，模型仍然可以训练，但准确率通常下降，收敛更慢，并且表达能力变弱，尤其在复杂数据集上</p></li><li><p>一次性直接将384×5×5的表示缩减为10×5×5的表示会出现什么问题</p><p>如果直接用1×1卷积将通道数压缩到10，这会让非线性减弱，学不到高阶的通道交互，而且梯度通道太窄，容易欠拟合，将优化压力给到前面层</p><p>通常会导致泛化变差，准确率降低</p></li><li><p>计算NiN的资源使用情况</p><ul><li><p>参数数量</p><p>第一层(11×11, 1→96)参数约 11×11×1×96 &#x3D; 11,616</p><p>第二层(5×5, 96→256)参数约 5×5×96×256 &#x3D; 614,400</p><p>第三层(3×3, 256→384)参数约 3×3×256×384 &#x3D; 884,736</p><p>整网加起来约 8M，比AlexNet少得多，因为少了全连接层</p></li><li><p>计算量<br>$$<br>\mathrm{MAC_s} &#x3D; K_h\times K_w\times C_{in}\times H_{out}\times W_{out}\times C_{out}<br>$$<br>虽然1×1卷积核简单，但是输出通道多，计算量也不小，FLOPs约为1~1.5GFLOPs，小于VGG</p></li></ul></li></ol><h2 id="含并行连结的网络-GoogleNet"><a href="#含并行连结的网络-GoogleNet" class="headerlink" title="含并行连结的网络(GoogleNet)"></a>含并行连结的网络(GoogleNet)</h2><p>GoogLeNet(Szegedy <em>et al.</em>, 2015)借鉴NiN的串联结构，并在此基础上做了改进，通过组合不同大小的卷积核来解决卷积核尺寸选择问题</p><p>接下来实现的GoogLeNet稍微简化，省略了一些为稳定训练而添加的特殊特性，因为现在有了更好的训练方法，这些特性不是必要的</p><h3 id="Inception块"><a href="#Inception块" class="headerlink" title="Inception块"></a>Inception块</h3><p>在GoogLeNet中，基本的卷积块被称为<strong>Inception块(Inception block)</strong></p><p>这很可能得名于电影《盗梦空间》(Inception)，因为电影中的一句话“We need to go deeper”</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/inception.jpg" alt="inception" style="zoom:80%;" /><p>Inception块由四条并行路径组成。前三条路径使用窗口大小为1×1,3×3,5×5的卷积层，从不同空间大小中提取信息；中间的两条路径在输入上执行1×1卷积，以减少通道数从而降低模型的复杂性；第四条路径使用3×3最大汇聚层，然后使用1×1卷积层来改变通道数</p><p><font color='DarkViolet'>核心思想是同时用多尺度卷积去提取不同层次的特征，再把它们拼在一起</font></p><p>这四条路径都使用合适的填充来使输入与输出的高和宽一致，最后将每条线路的输出在通道维度上连结，并构成Inception块的输出</p><p>在Inception块中，通常调整的超参数是每层输出通道数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Inception</span>(nn.Module):</span><br><span class="line">    <span class="comment"># c1--c4是每条路径的输出通道</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels, c1, c2, c3, c4, **kwargs</span>):</span><br><span class="line">        <span class="comment"># **kwargs接收任意额外参数，方便子类继承时继续传参</span></span><br><span class="line">        <span class="built_in">super</span>(Inception, <span class="variable language_">self</span>).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 线路1，单1×1卷积层</span></span><br><span class="line">        <span class="variable language_">self</span>.p1_1 = nn.Conv2d(in_channels, c1, kernel_size=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 线路2，1x1卷积层后接3x3卷积层</span></span><br><span class="line">        <span class="variable language_">self</span>.p2_1 = nn.Conv2d(in_channels, c2[<span class="number">0</span>], kernel_size=<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.p2_2 = nn.Conv2d(c2[<span class="number">0</span>], c2[<span class="number">1</span>], kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 线路3，1x1卷积层后接5x5卷积层</span></span><br><span class="line">        <span class="variable language_">self</span>.p3_1 = nn.Conv2d(in_channels, c3[<span class="number">0</span>], kernel_size=<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.p3_2 = nn.Conv2d(c3[<span class="number">0</span>], c3[<span class="number">1</span>], kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 线路4，3x3最大汇聚层后接1x1卷积层</span></span><br><span class="line">        <span class="variable language_">self</span>.p4_1 = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.p4_2 = nn.Conv2d(in_channels, c4, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        p1 = F.relu(<span class="variable language_">self</span>.p1_1(x))</span><br><span class="line">        p2 = F.relu(<span class="variable language_">self</span>.p2_2(F.relu(<span class="variable language_">self</span>.p2_1(x))))</span><br><span class="line">        p3 = F.relu(<span class="variable language_">self</span>.p3_2(F.relu(<span class="variable language_">self</span>.p3_1(x))))</span><br><span class="line">        p4 = F.relu(<span class="variable language_">self</span>.p4_2(F.relu(<span class="variable language_">self</span>.p4_1(x))))</span><br><span class="line">        <span class="comment"># 在通道维度上连接输出</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat((p1, p2, p3, p4), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>为什么GoogLeNet这个网络如此有效呢？</p><p>不同尺寸的卷积滤波器能捕捉图像中不同尺度的特征，小核捕捉局部细节，大核关注全局结构，从而同时学习细节与整体特征，增强了模型的表达能力</p><h3 id="网络结构-4"><a href="#网络结构-4" class="headerlink" title="网络结构"></a>网络结构</h3><p>GoogLeNet一共使用9个Inception块和全局平均汇聚层的堆叠来生成其估计值，Inception块之间的最大汇聚层可降低维度</p><p>第一个模块类似于AlexNet和LeNet，Inception块的组合从VGG继承，全局平均汇聚层从NiN继承，避免了在最后使用全连接层</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/inception-full.jpg" alt="inception-full" style="zoom:80%;" /><p>逐一实现GoogLeNet的每个模块</p><p>第一模块和之前的网络相同，使用一个7×7卷积层，输出64个通道，步幅为2，填充为3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b1 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第二模块使用两个卷积层，第一个卷积层输出64通道，第二个卷积层输出192通道</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b2 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">64</span>, <span class="number">192</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><font color='DarkViolet'>从第三模块开始有Inception块</font></p><p>第三模块串联两个完整的Inception块，输入通道数为192</p><p>第一个Inception块的输出通道数为64+128+32+32&#x3D;256，四个路径的输出通道比为2:4:1:1</p><p>第二条和第三条路径首先将输入通道的数量分别减少为1&#x2F;2(96)和1&#x2F;12(16)，然后连接第二个卷积层</p><p>第二个Inception块将输出通道数增加到128+192+96+64&#x3D;480，四个路径之间的输出通道数量比为4:6:3:2，第二条和第三条路径首先将输入通道的数量分别减少为1&#x2F;2(128)和1&#x2F;8(32)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b3 = nn.Sequential(</span><br><span class="line">    Inception(<span class="number">192</span>, <span class="number">64</span>, (<span class="number">96</span>, <span class="number">128</span>), (<span class="number">16</span>, <span class="number">32</span>), <span class="number">32</span>),</span><br><span class="line">    Inception(<span class="number">256</span>, <span class="number">128</span>, (<span class="number">128</span>, <span class="number">192</span>), (<span class="number">32</span>, <span class="number">96</span>), <span class="number">64</span>),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第四模块更加复杂，它串联了5个Inception块，其输出通道数分别是192+208+48+64&#x3D;512，160+224+64+64&#x3D;512，128+256+64+64&#x3D;512，112+288+64+64&#x3D;528和256+320+128+128&#x3D;832</p><p>路径的通道分配和第三模块类似，<font color='Violetred'>含3×3卷积层的第二条路径输出最多通道，其次是仅含1×1卷积层的第一条路径，之后是含5×5卷积层的第三条路径和含3×3最大汇聚层的第四条路径</font></p><p>第二、第三条路径都会先按比例减小通道数，这个比例在各个Inception块中都略有不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b4 = nn.Sequential(</span><br><span class="line">    Inception(<span class="number">480</span>, <span class="number">192</span>, (<span class="number">96</span>, <span class="number">208</span>), (<span class="number">16</span>, <span class="number">48</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>, <span class="number">160</span>, (<span class="number">112</span>, <span class="number">224</span>), (<span class="number">24</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>, <span class="number">128</span>, (<span class="number">128</span>, <span class="number">256</span>), (<span class="number">24</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>, <span class="number">112</span>, (<span class="number">144</span>, <span class="number">288</span>), (<span class="number">32</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">528</span>, <span class="number">256</span>, (<span class="number">160</span>, <span class="number">320</span>), (<span class="number">32</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第五模块包含两个Inception块，输出通道数为256+320+128+128&#x3D;832和384+384+128+128&#x3D;1024，其中每条路径通道数的分配思路和第三、第四模块中的一致，只是在具体数值上有所不同</p><p>需要注意的是，第五模块的后面紧跟输出层，<font color='DarkViolet'>该模块同NiN一样使用全局平均汇聚层</font>，将每个通道的高和宽变成1，最后将输出变成二维数组，再接上一个输出个数为标签类别数的全连接层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b5 = nn.Sequential(</span><br><span class="line">    Inception(<span class="number">832</span>, <span class="number">256</span>, (<span class="number">160</span>, <span class="number">320</span>), (<span class="number">32</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">    Inception(<span class="number">832</span>, <span class="number">384</span>, (<span class="number">192</span>, <span class="number">384</span>), (<span class="number">48</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">    nn.Flatten()</span><br><span class="line">)</span><br><span class="line">net = nn.Sequential(b1, b2, b3, b4, b5, nn.Linear(<span class="number">1024</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>GoogLeNet模型的计算复杂，而且不如VGG那样便于修改通道数</p><p>为了使Fashion-MNIST上的训练短小精悍，将输入的高和宽从224降到96，这简化了计算</p><p>下面演示各个模块输出的形状变化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">96</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;Layer&#x27;</span>:&lt;<span class="number">20</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;Output Shape&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;layer.__class__.__name__:&lt;<span class="number">20</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">tuple</span>(X.shape))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Layer               Output Shape</span><br><span class="line">----------------------------------------</span><br><span class="line">Sequential          (1, 64, 24, 24)</span><br><span class="line">Sequential          (1, 192, 12, 12)</span><br><span class="line">Sequential          (1, 480, 6, 6)</span><br><span class="line">Sequential          (1, 832, 3, 3)</span><br><span class="line">Sequential          (1, 1024)</span><br><span class="line">Linear              (1, 10)</span><br></pre></td></tr></table></figure><h3 id="训练模型-1"><a href="#训练模型-1" class="headerlink" title="训练模型"></a>训练模型</h3><p>在训练之前，将图片转换为96×96分辨率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.01</span>, <span class="number">10</span>, <span class="number">128</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size, resize=<span class="number">96</span>)</span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">epoch 1, loss 0.957, acc 0.650, time 42.424</span><br><span class="line">epoch 2, loss 0.507, acc 0.812, time 41.946</span><br><span class="line">epoch 3, loss 0.423, acc 0.844, time 42.178</span><br><span class="line">epoch 4, loss 0.370, acc 0.864, time 41.612</span><br><span class="line">epoch 5, loss 0.342, acc 0.875, time 44.255</span><br><span class="line">epoch 6, loss 0.317, acc 0.883, time 43.916</span><br><span class="line">epoch 7, loss 0.300, acc 0.889, time 44.202</span><br><span class="line">epoch 8, loss 0.285, acc 0.896, time 44.064</span><br><span class="line">epoch 9, loss 0.270, acc 0.900, time 43.925</span><br><span class="line">epoch 10, loss 0.260, acc 0.903, time 44.153</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251024230401380.png" alt="image-20251024230401380" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.260, train acc 0.903, test acc 0.878</span><br><span class="line">2036.9 examples/sec on cuda:0</span><br></pre></td></tr></table></figure><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><ul><li>Inception块相当于一个有4条路径的子网络，它通过不同窗口形状的卷积层和最大汇聚层来并行抽取信息，并使用1×1卷积层减少每像素级别上的通道维数从而降低模型复杂度</li><li>GoogLeNet将多个设计精细的Inception块与其他层(卷积层、全连接层)串联起来，其中Inception块的通道数分配之比是在ImageNet数据集上通过大量的实验得来的</li><li>GoogLeNet和它的后继者们一度是ImageNet上最有效的模型之一：它以较低的计算复杂度提供了类似的测试精度</li></ul><h3 id="思考题-6"><a href="#思考题-6" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>使用GoogLeNet的最小图像大小是多少？</p><table><thead><tr><th>层</th><th>操作</th><th>尺寸变化</th><th>输出尺寸(H×W)</th></tr></thead><tbody><tr><td>输入</td><td>-</td><td>-</td><td>224×224</td></tr><tr><td>Conv1</td><td>7×7, stride&#x3D;2, padding&#x3D;3</td><td>↓ 一半</td><td>112×112</td></tr><tr><td>MaxPool1</td><td>3×3, stride&#x3D;2</td><td>↓ 一半</td><td>56×56</td></tr><tr><td>Conv2</td><td>3×3, stride&#x3D;1</td><td>保持</td><td>56×56</td></tr><tr><td>MaxPool2</td><td>3×3, stride&#x3D;2</td><td>↓ 一半</td><td>28×28</td></tr><tr><td>Inception 3a+3b</td><td>stride&#x3D;1</td><td>保持</td><td>28×28</td></tr><tr><td>MaxPool3</td><td>3×3, stride&#x3D;2</td><td>↓ 一半</td><td>14×14</td></tr><tr><td>Inception 4a+4b</td><td>stride&#x3D;1</td><td>保持</td><td>14×14</td></tr><tr><td>MaxPool4</td><td>3×3, stride&#x3D;2</td><td>↓ 一半</td><td>7×7</td></tr><tr><td>Inception 5a+5b</td><td>stride&#x3D;1</td><td>保持</td><td>7×7</td></tr><tr><td>Global AvgPool</td><td>通道合并</td><td></td><td></td></tr></tbody></table><p>所以在进入Global AvgPool前尺寸减少了$2^5$次，所以理论最小是32</p></li><li><p>将AlexNet、VGG和NiN的模型参数大小与GoogLeNet进行比较。后两个网络架构是如何显著减少模型参数大小的？</p><table><thead><tr><th>模型</th><th>参数量</th><th>主要节省策略</th><th>关键创新</th></tr></thead><tbody><tr><td>AlexNet(2012)</td><td>60M</td><td>无优化</td><td>首次大规模 CNN</td></tr><tr><td>VGG-16(2014)</td><td>138M</td><td>深层结构但全连接太大</td><td>多层小卷积</td></tr><tr><td>NiN(2013)</td><td>8M</td><td>1×1 Conv + GAP，去除FC</td><td>Network in Network</td></tr><tr><td>GoogLeNet (2014)</td><td>6.8M</td><td>Inception + 通道压缩 + GAP</td><td>模块化多尺度设计</td></tr></tbody></table><p>VGG和AlexNet的参数主要来源于三个巨大的全连接层</p><p>NiN 通过 1×1 卷积和全局平均池化消除了冗余的全连接层</p><p>GoogLeNet 在此基础上进一步通过 多分支 + 通道压缩 把参数量进一步压缩</p></li></ol><h2 id="批量规范化"><a href="#批量规范化" class="headerlink" title="批量规范化"></a>批量规范化</h2><p>训练深层神经网络是十分困难的，特别是在较短的时间内使他们收敛更加棘手</p><p><strong>批量规范化(batch normalization,BN)</strong>(Ioffe and Szegedy, 2015)是一种流行且有效的技术，可持续加速深层网络的收敛速度</p><h3 id="实际挑战"><a href="#实际挑战" class="headerlink" title="实际挑战"></a>实际挑战</h3><p>数据预处理的方式通常会对最终结果产生巨大影响</p><p>批量规范化是为了解决训练神经网络时输入分布不稳定、梯度难以收敛等问题。在训练时对每一层的小批量输入计算均值与方差，将其规范化为均值为0、方差为1的分布，再通过可学习的<strong>拉伸参数(scale)</strong>$\gamma$以及<strong>偏移参数(shift)</strong>$\beta$恢复模型的表达能力</p><p>这样做可以：</p><ul><li>减少不同层之间分布的剧烈变化，加快收敛；</li><li>使训练对学习率不那么敏感；</li><li>起到一定正则化作用，减轻过拟合</li></ul><p>需要注意的是，BN 依赖于小批量的统计特性，因此批量太小会导致不稳定或无效</p><p>从形式上来说$\mathbf{x} \in \mathcal{B}$表示一个来自小批量的输入，批量规范化根据以下表达式转换$\mathbf{x}$<br>$$<br>BN(x) &#x3D; \gamma \cdot \frac{x - \hat \mu_B}{\hat \sigma_B} + \beta<br>$$<br>批量均值与方差分别为<br>$$<br>\begin{aligned}<br>\hat\mu_\mathcal B &amp;&#x3D; \frac{1}{| B|} \sum_{x \in  B} x \\<br>\hat\sigma^2_B &amp;&#x3D; \frac{1}{| B|} \sum_{x \in  B} (x - \hat\mu_B)^2 + \epsilon<br>\end{aligned}<br>$$<br>在方差估计值中添加一个小的常量以确保永远不会尝试除以零，训练中的随机性与噪声可视为一种正则化，有助于泛化</p><p>(Teye <em>et al.</em>, 2018)和(Luo <em>et al.</em>, 2018)分别将批量规范化的性质与贝叶斯先验相关联，这些理论揭示了为什么批量规范化最适应50~100范围中等批量大小的难题</p><p>批量规范化在训练和预测阶段的行为不同：</p><ul><li>训练模式：使用当前小批量的均值和方差进行规范化，因为此时无法获得全数据统计</li><li>预测模式：使用在训练过程中累计得到的全局均值和方差，对输入进行稳定规范化</li></ul><h3 id="批量规范化层"><a href="#批量规范化层" class="headerlink" title="批量规范化层"></a>批量规范化层</h3><p>批量规范化和其他层之间的一个关键区别是，由于批量规范化在完整的小批量上运行，因此不能像以前在引入其他层时那样忽略批量大小</p><p><font color='DarkViolet'>批量规范化层置于全连接层&#x2F;卷积层后，激活函数之前</font></p><h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p>设全连接层的输入为$\mathbf{x}$，激活函数为$\phi$，批量规范化的运算符为$\mathrm{BN}$，使用批量规范化的全连接层的输出的计算详情如下<br>$$<br>\mathbf{h} &#x3D; \phi(\mathrm{BN}(\mathbf{W}\mathbf{x} + \mathbf{b}) ).<br>$$<br>均值和方差是在应用变换的“相同”小批量上计算的</p><h4 id="卷积层-1"><a href="#卷积层-1" class="headerlink" title="卷积层"></a>卷积层</h4><p>当卷积有多个输出通道时，需要对这些通道的每个输出执行批量规范化，<font color='Violetred'>每个通道都有自己的拉伸和偏移参数</font>，这两个参数都是标量</p><p>设一个小批量中有$m$个样本，每个通道输出的特征图尺寸为$p×q$，那么需要对每个输出通道的$m \cdot p \cdot q$个元素上同时执行批量规范化</p><h4 id="预测过程"><a href="#预测过程" class="headerlink" title="预测过程"></a>预测过程</h4><p>批量规范化在训练与预测阶段的行为不同，训练时依赖当前小批量数据的均值和方差进行规范化，因此包含随机噪声和批次间波动，而预测阶段则需要稳定、确定的输出，不再使用小批量统计量，而是采用在训练过程中通过移动平均得到的全局均值和方差</p><p><font color='Violetred'>BN层与暂退法类似，在训练和推理阶段的计算方式并不相同</font></p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">batch_norm</span>(<span class="params">X, gamma, beta, moving_mean, moving_var, eps, momentum</span>):</span><br><span class="line">    <span class="comment"># momentum动量参数，用于更新移动平均的平滑程度</span></span><br><span class="line">    <span class="comment"># 通过is_grad_enabled来判断当前模式是训练模式还是预测模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> torch.is_grad_enabled():</span><br><span class="line">        <span class="comment"># 如果预测模式，直接使用传入的移动平均获得的均值和方差</span></span><br><span class="line">        X_hat = (X-moving_mean) / torch.sqrt(moving_var + eps)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(X.shape) <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(X.shape) == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 使用全连接层的情况，计算特征维上的均值和方差</span></span><br><span class="line">            mean = X.mean(dim=<span class="number">0</span>)</span><br><span class="line">            var = ((X-mean)**<span class="number">2</span>).mean(dim=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 使用二维卷积层的情况，计算通道维上(axis=1)的均值和方差</span></span><br><span class="line">            mean = X.mean(dim=(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line">            var = ((X-mean)**<span class="number">2</span>).mean(dim=(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 训练模式下，用当前的均值和方差做标准化</span></span><br><span class="line">        X_hat = (X - mean) / torch.sqrt(var + eps)</span><br><span class="line">        <span class="comment"># 更新移动平均的均值和方差</span></span><br><span class="line">        <span class="comment"># 越大的 momentum 越依赖过去的统计值</span></span><br><span class="line">        moving_mean = momentum * moving_mean + (<span class="number">1.0</span> - momentum) * mean</span><br><span class="line">        moving_var = momentum * moving_var + (<span class="number">1.0</span> - momentum) * var</span><br><span class="line">    Y = gamma * X_hat + beta <span class="comment"># 缩放和移位</span></span><br><span class="line">    <span class="keyword">return</span> Y, moving_mean.data, moving_var.data</span><br></pre></td></tr></table></figure><p>在可以创建一个正确的<code>BatchNorm</code>层，这个层将保持适当的参数：拉伸<code>gamma</code>和偏移<code>beta</code>，这两个参数将在训练过程中更新，将保存均值和方差的移动平均值，以便在模型预测期间随后使用</p><p>将此功能集成到一个自定义层中，其代码主要处理数据移动到训练设备(如GPU)、分配和初始化任何必需的变量、跟踪移动平均线(此处为均值和方差)等问题，这里代码需要指定整个特征的数量，但在深度学习框架中的API不需要考虑这个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BatchNorm</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_features, num_dims</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">if</span> num_dims == <span class="number">2</span>:</span><br><span class="line">            shape = (<span class="number">1</span>, num_features)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            shape = (<span class="number">1</span>, num_features, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 参与求梯度和迭代的拉伸和偏移参数，分别初始化成1和0</span></span><br><span class="line">        <span class="variable language_">self</span>.gamma = nn.Parameter(torch.ones(shape))</span><br><span class="line">        <span class="variable language_">self</span>.beta = nn.Parameter(torch.zeros(shape))</span><br><span class="line">        <span class="comment"># 非模型参数的变量初始化为0和1</span></span><br><span class="line">        <span class="variable language_">self</span>.moving_mean = torch.zeros(shape)</span><br><span class="line">        <span class="variable language_">self</span>.moving_var = torch.ones(shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># 如果X不在内存上，将moving_mean和moving_var复制到X所在显存</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.moving_mean.device != X.device:</span><br><span class="line">            <span class="variable language_">self</span>.moving_mean = <span class="variable language_">self</span>.moving_mean.to(X.device)</span><br><span class="line">            <span class="variable language_">self</span>.moving_var = <span class="variable language_">self</span>.moving_var.to(X.device)</span><br><span class="line">        Y, <span class="variable language_">self</span>.moving_mean, <span class="variable language_">self</span>.moving_var = batch_norm(</span><br><span class="line">            X, <span class="variable language_">self</span>.gamma, <span class="variable language_">self</span>.beta, <span class="variable language_">self</span>.moving_mean, <span class="variable language_">self</span>.moving_var,</span><br><span class="line">            eps = <span class="number">1e-5</span>, momentum = <span class="number">0.9</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><h3 id="带入LeNet"><a href="#带入LeNet" class="headerlink" title="带入LeNet"></a>带入LeNet</h3><p>批量规范化是在卷积层或全连接层之后、相应的激活函数之前应用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    <span class="comment"># 这里第一层没加padding，所以最后输出的是4*4</span></span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>), BatchNorm(<span class="number">6</span>, num_dims=<span class="number">4</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), BatchNorm(<span class="number">16</span>, num_dims=<span class="number">4</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">4</span> * <span class="number">4</span>, <span class="number">120</span>), BatchNorm(<span class="number">120</span>, num_dims=<span class="number">2</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), BatchNorm(<span class="number">84</span>, num_dims=<span class="number">2</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>和以前一样，将在Fashion-MNIST数据集上训练网络，但区别是学习率大得多</p><p>批量规范化通过控制中间层输入的分布，让网络在数值上对学习率更加鲁棒，因此可以安全使用更大的学习率，以加快收敛并提升泛化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">1.0</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size)</span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">epoch 1, loss 0.759, acc 0.727, time 9.976</span><br><span class="line">epoch 2, loss 0.478, acc 0.825, time 9.793</span><br><span class="line">epoch 3, loss 0.406, acc 0.851, time 9.434</span><br><span class="line">epoch 4, loss 0.362, acc 0.868, time 9.730</span><br><span class="line">epoch 5, loss 0.331, acc 0.881, time 9.272</span><br><span class="line">epoch 6, loss 0.313, acc 0.885, time 10.261</span><br><span class="line">epoch 7, loss 0.300, acc 0.890, time 9.568</span><br><span class="line">epoch 8, loss 0.287, acc 0.894, time 9.825</span><br><span class="line">epoch 9, loss 0.279, acc 0.897, time 9.699</span><br><span class="line">epoch 10, loss 0.270, acc 0.902, time 9.667</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251025153222380.png" alt="image-20251025153222380" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.270, train acc 0.902, test acc 0.871</span><br><span class="line">24791.2 examples/sec on cpu</span><br></pre></td></tr></table></figure><p>来看看从第一个批量规范化层中学到的拉伸参数<code>gamma</code>和偏移参数<code>beta</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net[<span class="number">1</span>].gamma.reshape((-<span class="number">1</span>,)), net[<span class="number">1</span>].beta.reshape((-<span class="number">1</span>,))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(tensor([0.5371, 2.9680, 4.2053, 3.2385, 0.3399, 3.5118],</span><br><span class="line">        grad_fn=&lt;ViewBackward0&gt;),</span><br><span class="line"> tensor([-0.5215,  1.7145, -2.4500,  0.6433, -0.5788,  3.7196],</span><br><span class="line">        grad_fn=&lt;ViewBackward0&gt;))</span><br></pre></td></tr></table></figure><h3 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h3><p>可以直接使用深度学习框架中定义的<code>BatchNorm</code>，net中修改一下即可，只需要输入输出通道数作为参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>), nn.BatchNorm2d(<span class="number">6</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.BatchNorm2d(<span class="number">16</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">4</span> * <span class="number">4</span>, <span class="number">120</span>), nn.BatchNorm1d(<span class="number">120</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.BatchNorm1d(<span class="number">84</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通常高级API变体运行速度快得多，因为它的代码已编译为C++或CUDA，而自定义代码由Python实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">epoch 1, loss 0.647, acc 0.760, time 9.311</span><br><span class="line">epoch 2, loss 0.418, acc 0.847, time 9.212</span><br><span class="line">epoch 3, loss 0.360, acc 0.868, time 9.311</span><br><span class="line">epoch 4, loss 0.330, acc 0.878, time 9.302</span><br><span class="line">epoch 5, loss 0.313, acc 0.884, time 9.373</span><br><span class="line">epoch 6, loss 0.295, acc 0.891, time 8.978</span><br><span class="line">epoch 7, loss 0.278, acc 0.898, time 9.393</span><br><span class="line">epoch 8, loss 0.270, acc 0.901, time 9.384</span><br><span class="line">epoch 9, loss 0.257, acc 0.905, time 8.945</span><br><span class="line">epoch 10, loss 0.251, acc 0.908, time 9.630</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251025154825344.png" alt="image-20251025154825344" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.251, train acc 0.908, test acc 0.885</span><br><span class="line">34264.4 examples/sec on cpu</span><br></pre></td></tr></table></figure><h3 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h3><p>批量规范化常被直观地认为能让优化过程更平滑、更稳定，然而这种“直觉解释”并不等同于科学原理，事实上至今仍未完全理解即使是简单神经网络(如多层感知机、传统CNN)为何能如此有效泛化</p><p>BN的提出者在论文中将其效果归因于减少<strong>内部协变量偏移(internal covariate shift)</strong>，即训练过程中各层输入分布的变化，但这种解释存在两点问题：</p><ol><li>内部协变量偏移与严格意义上的**协变量偏移(covariate shift)**不同，命名并不严谨</li><li>该解释仅是一种模糊的直觉，并未真正揭示 BN 成功的机制</li></ol><p>其他研究者提出了新的观点：BN 的作用机制可能与原论文的解释相反(Santurkar et al., 2018)，其真正效果更接近于改善优化几何性质，使损失函数更光滑</p><p>无论解释如何分歧，批量规范化几乎成为现代神经网络训练的标准组成部分，尤其在图像分类任务中表现突出，并在学术界获得了数万次引用</p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><ul><li>在模型训练过程中，批量规范化利用小批量的均值和标准差，不断调整神经网络的中间输出，使整个神经网络各层的中间输出值更加稳定</li><li>批量规范化在全连接层和卷积层的使用略有不同</li><li>批量规范化层和暂退层一样，在训练模式和预测模式下计算不同</li><li>批量规范化有许多有益的副作用，主要是正则化</li></ul><h3 id="思考题-7"><a href="#思考题-7" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>在使用批量规范化之前，是否可以从全连接层或卷积层中删除偏置参数？为什么？</p><p>可以删除偏置参数，因为BN的$\beta$拥有“平移能力”，原本线性层的偏置就变得多余</p><p>大多数现代实现(包括 ResNet、VGG-BN、DenseNet等)都是在有 BN 的情况下，关闭前一层的 bias，这不仅简化了参数，还能略微提高训练效率，避免无意义的梯度更新</p></li><li><p>比较使用和不使用批量规范化情况下的学习率</p><p>BN会扩大稳定学习率范围，所以用BN可以把学习率开得更大</p></li><li><p>是否需要在每个层中进行批量规范化？</p><p>删除全连接层后面的批量规范化对结果影响不大，所以不是非要每个层</p><ul><li><strong>卷积层</strong>：在每个卷积层后(激活函数前)加 BN 通常是有益的，因为早期特征分布变化大</li><li><strong>全连接层</strong>：加 BN 的收益远小于卷积层，常见做法是只在第一个或前几个全连接层上使用</li></ul><p>在浅层网络(如LeNet)中，只需在卷积层后加 BN 即可，在更深网络(如ResNet、DenseNet)，BN才几乎每层使用</p></li><li><p>对比批量规范化和暂退法</p><table><thead><tr><th>特征</th><th>批量规范化</th><th>暂退法</th></tr></thead><tbody><tr><td>引入的噪声</td><td>来自小批量统计(均值、方差的随机性)</td><td>来自神经元随机屏蔽</td></tr><tr><td>噪声作用层面</td><td>连续扰动——数值被平滑缩放</td><td>离散扰动——神经元直接置零</td></tr><tr><td>对梯度的影响</td><td>稳定梯度流</td><td>阻断部分梯度路径，增加训练噪声</td></tr><tr><td>对模型行为</td><td>加速收敛、提高数值稳定性</td><td>提高泛化、减轻过拟合</td></tr><tr><td>推理阶段</td><td>去噪(使用滑动均值&#x2F;方差)</td><td>去噪(缩放激活值)</td></tr></tbody></table><ul><li><p>BN的噪声可以视作一种隐式贝叶斯正则，但强度有限</p></li><li><p>Dropout 的噪声是显式的、较强的随机化机制</p></li></ul><p>根据网络类型进行选择，BN对卷积层效果更好，Dropout对全连接层效果更好</p><table><thead><tr><th>场景</th><th>常见做法</th></tr></thead><tbody><tr><td>卷积网络(如LeNet、ResNet)</td><td>通常用 BN，不用 Dropout</td></tr><tr><td>全连接层较多(如传统 MLP)</td><td>通常用 Dropout，BN 作用有限</td></tr><tr><td>小数据集或易过拟合任务</td><td>同时使用 BN + Dropout<br />但 Dropout 需放在 BN 之后(否则统计不稳定)</td></tr><tr><td>大模型 + 大数据</td><td>通常使用 BN，不再需要 Dropout</td></tr></tbody></table></li></ol><h2 id="残差网络-ResNet"><a href="#残差网络-ResNet" class="headerlink" title="残差网络(ResNet)"></a>残差网络(ResNet)</h2><p>随着设计越来越深的网络，深刻理解“新添加的层如何提升神经网络的性能”变得至关重要</p><h3 id="函数类"><a href="#函数类" class="headerlink" title="函数类"></a>函数类</h3><p>假设有一类特定的神经网络架构$\mathcal{F}$，它包括学习速率和其他超参数设置，对于所有$f \in \mathcal{F}$存在一些参数集(例如权重和偏置)，这些参数可以通过在合适的数据集上进行训练而获得</p><p>假设$f^\ast$是真正想要找到的函数，如果$f^\ast \in \mathcal{F}$那可以轻而易举的训练得到它，但通常不会那么幸运，因此将尝试找到一个函数$f^\ast_\mathcal{F}$，这是在$\mathcal{F}$中的最佳选择</p><p>给定一个具有$\mathbf{X}$特性和$\mathbf y$标签的数据集，可以尝试通过解决以下优化问题来找到它<br>$$<br>f^\ast_\mathcal{F} :&#x3D; \mathop{\mathrm{argmin}}_f L(\mathbf{X}, \mathbf{y}, f) \text{ subject to } f \in \mathcal{F}.<br>$$<br>想要近似，唯一合理的可能性是设计一个更强大的架构$\mathcal{F}’$，但是如果$\mathcal{F} \not\subseteq \mathcal{F}’$则无法保证新的体系“更近似”</p><p>对于**非嵌套函数(non-nested function)**类，较复杂的函数类并不总是向真函数$f^\ast$靠拢(复杂度由1到6递增)，在左图中虽然$\mathcal{F}_3$比$\mathcal{F}_1$更接近$f^\ast$，但$\mathcal{F}_6$更远了</p><p>对于右侧的**嵌套函数(nested function)**类可以避免这个问题</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/functionclasses.jpg" alt="functionclasses" style="zoom:80%;" /><p>只有当较复杂的函数类包含较简单的函数类时，模型性能才有可能提升</p><p>在深度神经网络，如果新增层能学到<strong>恒等映射(identity function)</strong>，则新旧模型表现相同，更深的模型具备更强表示能力，能够找到更优解，从而更容易降低训练误差</p><p>针对这一问题，何恺明等人提出了<strong>残差网络(ResNet)</strong>(He <em>et al.</em>, 2016)</p><p><font color='DarkViolet'>残差网络的核心思想是：每个附加层都应该更容易地包含原始函数作为其元素之一</font></p><p>**残差块(residual blocks)**便诞生了，这个设计对如何建立深层神经网络产生了深远的影响</p><h3 id="残差块"><a href="#残差块" class="headerlink" title="残差块"></a>残差块</h3><p>在神经网络中，假设输入为$x$，理想映射为$f(\mathbf{x})$(作为激活函数的输入)，左图的虚线框直接拟合$f(\mathbf{x})$，右图的虚线框则学习残差$f(\mathbf{x}) - \mathbf{x}$，实践表明，残差映射往往更容易优化</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/residual-block.jpg" alt="residual-block" style="zoom:80%;" /><p>左图为正常块，右图展示了ResNet的基本单元——残差块，其中输入可通过跨层连接直接向前传播，从而加速训练并缓解梯度消失问题</p><p>若将右图中加权层的权重与偏置设为0，即得到恒等映射</p><p>当理想映射接近恒等映射时，残差结构能轻松捕捉这种细微偏差</p><p>ResNet沿用了VGG完整的3×3卷积层设计，残差块里首先有2个有相同输出通道数的3×3卷积层，每个卷积层后接一个批量规范化层和ReLU激活函数，通过跨层数据通路，跳过这2个卷积运算，将输入直接加在最后的ReLU激活函数前</p><p>这样的设计要求2个卷积层的输出与输入形状一样从而使它们可以相加，如果想要改变通道数，就需要引入一个额外的1×1卷积层来将输入变换成需要的形状后再做相加运算</p><p>残差块的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Residual</span>(nn.Module):  <span class="comment">#@save</span></span><br><span class="line">    <span class="comment"># 输入通道数，输出通道数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_channels, num_channels,</span></span><br><span class="line"><span class="params">                 use_1x1conv=<span class="literal">False</span>, strides=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># 两个连续的3×3卷积层</span></span><br><span class="line">        <span class="comment"># 第一个卷积可选择步幅，控制下采样</span></span><br><span class="line">        <span class="variable language_">self</span>.conv1 = nn.Conv2d(input_channels, num_channels,</span><br><span class="line">                               kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="variable language_">self</span>.conv2 = nn.Conv2d(num_channels, num_channels,</span><br><span class="line">                               kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 实现捷径，调整X与的通道与大小</span></span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            <span class="variable language_">self</span>.conv3 = nn.Conv2d(input_channels, num_channels,</span><br><span class="line">                                   kernel_size=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.conv3 = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.bn1 = nn.BatchNorm2d(num_channels)</span><br><span class="line">        <span class="variable language_">self</span>.bn2 = nn.BatchNorm2d(num_channels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># 第一层：Conv → BN → ReLU</span></span><br><span class="line">        Y = F.relu(<span class="variable language_">self</span>.bn1(<span class="variable language_">self</span>.conv1(X)))</span><br><span class="line">        <span class="comment"># 第二层：Conv → BN</span></span><br><span class="line">        Y = <span class="variable language_">self</span>.bn2(<span class="variable language_">self</span>.conv2(Y))</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.conv3:</span><br><span class="line">            X = <span class="variable language_">self</span>.conv3(X)</span><br><span class="line">        Y += X</span><br><span class="line">        <span class="comment"># ReLU留到残差加和后激活</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(Y)</span><br></pre></td></tr></table></figure><p>此代码生成两种类型的网络，当<code>use_1x1conv=False</code>时应用ReLU非线性函数之前，将输入添加到输出；当<code>use_1x1conv=True</code>时，添加通过1×1卷积调整通道和分辨率</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/resnet-block.webp" alt="resnet-block" style="zoom:80%;" /><p>来查看输入和输出形状一致的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">block = Residual(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">X = torch.rand(<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>)</span><br><span class="line">Y = block(X)</span><br><span class="line">Y.shape</span><br><span class="line"><span class="comment"># torch.Size([4, 3, 6, 6])</span></span><br></pre></td></tr></table></figure><p>增加输出通道数的同时，减半输出的高和宽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blk = Residual(<span class="number">3</span>, <span class="number">6</span>, use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>)</span><br><span class="line">blk(X).shape</span><br><span class="line"><span class="comment"># torch.Size([4, 6, 3, 3])</span></span><br></pre></td></tr></table></figure><h3 id="网络结构-5"><a href="#网络结构-5" class="headerlink" title="网络结构"></a>网络结构</h3><p>ResNet的第一层跟GoogLeNet一样：在输出通道数为64、步幅为2的7×7卷积层后，接步幅为2的3×3的最大汇聚层，不同之处在于ResNet每个卷积层后增加了批量规范化层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b1 = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">                   nn.BatchNorm2d(<span class="number">64</span>), nn.ReLU(),</span><br><span class="line">                   nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>GoogLeNet在后面接了4个由Inception块组成的模块，而ResNet则使用4个由残差块组成的模块构成，每个模块内的残差块输出通道数相同</p><p>因为在b1中最大池化已经下采样了，所以第一个模块步幅为1，不再下采样</p><table><thead><tr><th>场景</th><th>是否使用 1×1 卷积</th><th>步幅</th><th>作用</th></tr></thead><tbody><tr><td>第一个模块</td><td>否</td><td>1</td><td>保持通道数与尺寸</td></tr><tr><td>其他模块的第一个残差块</td><td>是</td><td>2</td><td>通道数翻倍、尺寸减半</td></tr><tr><td>其他模块中的后续块</td><td>否</td><td>1</td><td>保持不变</td></tr></tbody></table><p>来实现这个模块，对第一个模块做了特别处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resnet_block</span>(<span class="params">input_channels, num_channels, num_residuals,</span></span><br><span class="line"><span class="params">                 first_block=<span class="literal">False</span></span>):</span><br><span class="line">    blk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block: <span class="comment"># 判断是不是第一个块</span></span><br><span class="line">            <span class="comment"># 后续模块的首个残差块负责通道翻倍和空间下采样</span></span><br><span class="line">            blk.append(Residual(input_channels, num_channels,</span><br><span class="line">                                use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            blk.append(Residual(num_channels, num_channels))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br></pre></td></tr></table></figure><p>在ResNet加入所有残差块，这里每个模块使用2个残差块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b2 = nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>))</span><br><span class="line">b3 = nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>))</span><br><span class="line">b4 = nn.Sequential(*resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line">b5 = nn.Sequential(*resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>最后，与GoogLeNet一样，在ResNet中加入全局平均汇聚层，以及全连接层输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(b1, b2, b3, b4, b5,</span><br><span class="line">                    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                    nn.Flatten(), nn.Linear(<span class="number">512</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>每个模块有4个卷积层(不包括恒等映射的1×1卷积层)，加上第一个7×7卷积层和最后一个全连接层，共有18层，这种模型通常被称为ResNet-18</p><p>通过配置不同的通道数和模块里的残差块数可以得到不同的ResNet模型，例如更深的含152层的ResNet-152</p><p>虽然ResNet的主体架构跟GoogLeNet类似，但ResNet架构更简单，修改也更方便</p><p>下图为完整的ResNet-18架构</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/resnet18.webp" alt="resnet18" style="zoom:80%;" /><p>在训练ResNet之前，观察一下ResNet中不同模块的输入形状是如何变化的</p><p>在之前所有架构中，分辨率降低，通道数量增加，直到全局平均汇聚层聚集所有特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;Layer&#x27;</span>:&lt;<span class="number">20</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;Output Shape&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;layer.__class__.__name__:&lt;<span class="number">20</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">tuple</span>(X.shape))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Layer               Output Shape</span><br><span class="line">----------------------------------------</span><br><span class="line">Sequential          (1, 64, 56, 56)  # 两次下采样</span><br><span class="line">Sequential          (1, 64, 56, 56)  # 第一个模块步幅为1，通道数不变</span><br><span class="line">Sequential          (1, 128, 28, 28) # 通道数加倍，步幅为2下采样</span><br><span class="line">Sequential          (1, 256, 14, 14) # 通道数加倍，步幅为2下采样</span><br><span class="line">Sequential          (1, 512, 7, 7)   # 通道数加倍，步幅为2下采样</span><br><span class="line">AdaptiveAvgPool2d   (1, 512, 1, 1)   </span><br><span class="line">Flatten             (1, 512)</span><br><span class="line">Linear              (1, 10)</span><br></pre></td></tr></table></figure><h3 id="训练模型-2"><a href="#训练模型-2" class="headerlink" title="训练模型"></a>训练模型</h3><p>在Fashion-MNIST数据集上训练ResNet</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.05</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size, resize=<span class="number">96</span>)</span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">epoch 1, loss 0.649, acc 0.820</span><br><span class="line">epoch 2, loss 0.268, acc 0.903</span><br><span class="line">epoch 3, loss 0.206, acc 0.926</span><br><span class="line">epoch 4, loss 0.160, acc 0.943</span><br><span class="line">epoch 5, loss 0.124, acc 0.957</span><br><span class="line">epoch 6, loss 0.091, acc 0.970</span><br><span class="line">epoch 7, loss 0.067, acc 0.979</span><br><span class="line">epoch 8, loss 0.041, acc 0.989</span><br><span class="line">epoch 9, loss 0.024, acc 0.994</span><br><span class="line">epoch 10, loss 0.018, acc 0.996</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510251949.png" alt="202510251949" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss 0.018, train acc 0.996, test acc 0.913</span><br></pre></td></tr></table></figure><p>非常夸张的训练集精确度啊</p><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><ul><li>学习嵌套函数是训练神经网络的理想情况，在深层神经网络中，学习另一层作为恒等映射较容易(尽管这是一个极端情况)</li><li>残差映射可以更容易地学习同一函数，例如将权重层中的参数近似为零</li><li>利用残差块可以训练出一个有效的深层神经网络：输入可以通过层间的残余连接更快地向前传播</li><li>ResNet对随后的深层神经网络设计产生了深远影响</li></ul><h3 id="思考题-8"><a href="#思考题-8" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>Inception块与残差块之间的主要区别是什么？在删除了Inception块中的一些路径之后，它们是如何相互关联的？</p><p>对比二者：</p><table><thead><tr><th>特征</th><th>Inception块</th><th>残差块(Residual Block)</th></tr></thead><tbody><tr><td>主要动机</td><td>增加网络的宽度(多尺度特征提取)</td><td>增加网络的深度(更容易优化的深层结构)</td></tr><tr><td>核心结构</td><td>多条卷积路径并行(1×1、3×3、5×5 等)再拼接</td><td>一条主路径 + 一条恒等捷径，进行相加</td></tr><tr><td>特征融合方式</td><td>把各路径输出在通道维度上堆叠</td><td>把输入与变换后的特征直接相加</td></tr><tr><td>设计目的</td><td>让网络在同一层中感受不同尺度的特征</td><td>让网络学习残差，稳定训练</td></tr><tr><td>对梯度传播的影响</td><td>并行路径增加特征表达能力，但深度增加后仍易梯度衰减</td><td>恒等连接保证梯度能直接后传，不易消失</td></tr></tbody></table><p>两者的关联：</p><p>把Inception块中的多分支路径删掉，只保留一条主要的卷积路径，这个结构就很接近一个普通的卷积层，如果再加上一条跨层的恒等连接，就演化为了残差块</p></li></ol><h3 id="ResNet变体"><a href="#ResNet变体" class="headerlink" title="ResNet变体"></a>ResNet变体</h3><p>参考ResNet论文(He <em>et al.</em>, 2016)中的表1，学习多种变体</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-10-25_20-08-15.webp" alt="Snipaste_2025-10-25_20-08-15" style="zoom: 67%;" /><table><thead><tr><th>模型</th><th>Block 类型</th><th>[conv2_x, conv3_x, conv4_x, conv5_x]</th><th>总层数</th></tr></thead><tbody><tr><td>ResNet-18</td><td>BasicBlock</td><td>[2, 2, 2, 2]</td><td>18</td></tr><tr><td>ResNet-34</td><td>BasicBlock</td><td>[3, 4, 6, 3]</td><td>34</td></tr><tr><td>ResNet-50</td><td>Bottleneck</td><td>[3, 4, 6, 3]</td><td>50</td></tr><tr><td>ResNet-101</td><td>Bottleneck</td><td>[3, 4, 23, 3]</td><td>101</td></tr><tr><td>ResNet-152</td><td>Bottleneck</td><td>[3, 8, 36, 3]</td><td>152</td></tr></tbody></table><p>在ResNet-50&#x2F;101&#x2F;152 都用到了<strong>Bottleneck</strong>，每个残差块由三个卷积核组成，其中1×1卷积的主要作用是降维+升维</p><p>以50-layers conv2_x为例：</p><table><thead><tr><th>卷积层</th><th>核大小</th><th>通道变化</th><th>作用</th></tr></thead><tbody><tr><td>第一层</td><td>1×1</td><td>256 → 64</td><td>降维，减少计算量</td></tr><tr><td>第二层</td><td>3×3</td><td>64 → 64</td><td>提取特征</td></tr><tr><td>第三层</td><td>1×1</td><td>64 → 256</td><td>升维，恢复通道数以便残差相加</td></tr></tbody></table><p>这样使得3×3卷积不会在高通道上操作，降低计算量</p><p>1×1卷积几乎不增加计算负担，却能控制通道数</p><hr><p>在ResNet v2中，作者将“卷积层、批量规范化层和激活层”架构更改为“批量规范化层、激活层和卷积层”架构</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-10-25_20-24-58.webp" alt="Snipaste_2025-10-25_20-24-58" style="zoom:67%;" /><table><thead><tr><th>类型</th><th>顺序</th><th>关键特性</th></tr></thead><tbody><tr><td>ResNet v1</td><td>Conv → BN → ReLU → Conv → BN → Add → ReLU</td><td>加法后再激活(post-activation)</td></tr><tr><td>ResNet v2</td><td>BN → ReLU → Conv → BN → ReLU → Conv → Add</td><td>加法前激活(pre-activation)</td></tr></tbody></table><p><code>post-activation</code>在浅层时没问题，但在非常深的网络中，梯度在跨层传播时容易衰减，因为 BN 和 ReLU 在加法之后才起作用</p><p><code>pre-activation</code>将BN和ReLU放在卷积层之前，残差相加不再经过激活函数，使残差连接成为真正的恒等映射，更利于梯度直接传播</p><h2 id="稠密连接网络-DenseNet"><a href="#稠密连接网络-DenseNet" class="headerlink" title="稠密连接网络(DenseNet)"></a>稠密连接网络(DenseNet)</h2><p>ResNet极大地改变了如何参数化深层网络中函数的观点，稠密连接网络(DenseNet)(Huang <em>et al.</em>, 2017)在某种程度上是ResNet的逻辑扩展</p><h3 id="从ResNet到DenseNet"><a href="#从ResNet到DenseNet" class="headerlink" title="从ResNet到DenseNet"></a>从ResNet到DenseNet</h3><p>任意函数的泰勒展开式它把这个函数分解成越来越高阶的项，在$x$接近0时<br>$$<br>f(x) &#x3D; f(0) + f’(0) x + \frac{f’’(0)}{2!}  x^2 + \frac{f’’’(0)}{3!}  x^3 + \ldots.<br>$$<br>同样ResNet将函数展开为<br>$$<br>f(\mathbf{x}) &#x3D; \mathbf{x} + g(\mathbf{x})<br>$$<br>就是说，ResNet将$f$分解为两部分：一个简单的线性项和一个复杂的非线性项</p><p>再向前拓展一步，想将$f$拓展成超过两部分的信息呢，一种方案便是DenseNet</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/densenet-block.jpg" alt="densenet-block" style="zoom:80%;" /><p>ResNet(左)和DenseNet(右)的关键区别在于，DenseNet输出是连接而不是如ResNet的简单相加</p><p>因此，在应用越来越复杂的函数序列后，执行从$\mathbf {x}$到其展开式的映射<br>$$<br>\mathbf{x} \to \left[<br>\mathbf{x},<br>f_1(\mathbf{x}),<br>f_2([\mathbf{x}, f_1(\mathbf{x})]), f_3([\mathbf{x}, f_1(\mathbf{x}), f_2([\mathbf{x}, f_1(\mathbf{x})])]), \ldots\right].<br>$$<br>最后，将这些展开式结合连接到多层感知机中，再次减少特征的数量</p><p>DenseNet这个名字由变量之间的“稠密连接”而得来，最后一层与之前的所有层紧密相连</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/densenet.jpg" alt="densenet" style="zoom:80%;" /><p>稠密网络主要由2部分构成：<strong>稠密块(dense block)<strong>和</strong>过渡层(transition layer)</strong></p><p>前者定义如何连接输入和输出，而后者则控制通道数量，使其不会太复杂</p><h3 id="稠密块体"><a href="#稠密块体" class="headerlink" title="稠密块体"></a>稠密块体</h3><p>DenseNet使用了ResNet改良版的“批量规范化、激活和卷积”架构，首先实现一下这个架构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conv_block</span>(<span class="params">input_channels, num_channels</span>):</span><br><span class="line">    <span class="comment"># 固定三个步骤，BN-&gt;ReLU-&gt;Conv</span></span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.BatchNorm2d(input_channels), nn.ReLU(),</span><br><span class="line">        nn.Conv2d(input_channels, num_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>一个稠密块由多个卷积块组成，每个卷积块使用相同数量的输出通道</p><p>在前向传播中，将每个卷积块的输入和输出在通道维上连结</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DenseBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_convs, input_channels, num_channels</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        layer = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_convs):</span><br><span class="line">            layer.append(conv_block(</span><br><span class="line">                num_channels * i + input_channels, num_channels))</span><br><span class="line">        <span class="variable language_">self</span>.net = nn.Sequential(*layer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">for</span> blk <span class="keyword">in</span> <span class="variable language_">self</span>.net:</span><br><span class="line">            Y = blk(X)</span><br><span class="line">            <span class="comment"># 连接通道维度上每个块的输入和输出</span></span><br><span class="line">            X = torch.cat((X, Y), dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> X</span><br></pre></td></tr></table></figure><table><thead><tr><th>第几层</th><th>输入通道数</th><th>输出通道数</th><th>输入来自</th></tr></thead><tbody><tr><td>第 1 层</td><td>64</td><td>32</td><td>原始输入</td></tr><tr><td>第 2 层</td><td>64 + 32 &#x3D; 96</td><td>32</td><td>输入 + 第 1 层输出</td></tr><tr><td>第 3 层</td><td>64 + 32×2 &#x3D; 128</td><td>32</td><td>输入 + 第 1、2 层输出</td></tr></tbody></table><p>每一层不仅接收上一层的输出，还接收前面所有层的特征图，这种模式被称为<strong>特征重用(feature reuse)</strong></p><p>定义一个有2个卷积块，输出通道数为10的<code>DenseBlock</code>，使用通道数为3的输入时，会得到通道数为3+2×10&#x3D;23的输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blk = DenseBlock(<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">X = torch.randn(<span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line">Y = blk(X)</span><br><span class="line">Y.shape</span><br><span class="line"><span class="comment"># torch.Size([4, 23, 8, 8])</span></span><br></pre></td></tr></table></figure><p>卷积块的通道数控制了输出通道数相对于输入通道数的增长，因此也被称为<strong>增长率(growth rate)</strong></p><h3 id="过渡层"><a href="#过渡层" class="headerlink" title="过渡层"></a>过渡层</h3><p>由于每个稠密块都会带来通道数的增加，使用过多则会过于复杂化模型，过渡层可以用来控制模型复杂度，通过1×1卷积层来减少通道数，并使用步幅为2的平均汇聚层减半高和宽，从而进一步降低模型复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">transition_block</span>(<span class="params">input_channels, num_channels</span>):</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.BatchNorm2d(input_channels), nn.ReLU(),</span><br><span class="line">        nn.Conv2d(input_channels, num_channels, kernel_size=<span class="number">1</span>),</span><br><span class="line">        nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>对刚刚的输出使用通道数为10的过渡层，此时输出的通道数减为10，高和宽均减半</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blk = transition_block(<span class="number">23</span>, <span class="number">10</span>)</span><br><span class="line">blk(Y).shape</span><br><span class="line"><span class="comment"># torch.Size([4, 10, 4, 4])</span></span><br></pre></td></tr></table></figure><h3 id="网络结构-6"><a href="#网络结构-6" class="headerlink" title="网络结构"></a>网络结构</h3><p>DenseNet首先使用同ResNet一样的单卷积层和最大汇聚层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b1 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">    nn.BatchNorm2d(<span class="number">64</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>类似于ResNet使用的4个残差块，DenseNet使用的是4个稠密块</p><p>与ResNet类似，可以设置每个稠密块使用多少个卷积层，这里设成4使得与刚刚的ResNet-18保持一致</p><p>稠密块里的卷积层通道数(即增长率)设为32，所以每个稠密块将增加128个通道</p><p>在每个模块之间，ResNet通过步幅为2的残差块减小高和宽，DenseNet则使用过渡层来减半高和宽，并减半通道数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># num_channels为当前的通道数</span></span><br><span class="line">num_channels, growth_rate = <span class="number">64</span>, <span class="number">32</span></span><br><span class="line">num_convs_in_dense_blocks = [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">blks = []</span><br><span class="line"><span class="keyword">for</span> i, num_convs <span class="keyword">in</span> <span class="built_in">enumerate</span>(num_convs_in_dense_blocks):</span><br><span class="line">    blks.append(DenseBlock(num_convs, num_channels, growth_rate))</span><br><span class="line">    <span class="comment"># 上一个稠密块的输出通道数</span></span><br><span class="line">    num_channels += num_convs * growth_rate</span><br><span class="line">    <span class="comment"># 在稠密块之间添加一个转换层，使通道数量减半</span></span><br><span class="line">    <span class="keyword">if</span> i != <span class="built_in">len</span>(num_convs_in_dense_blocks) - <span class="number">1</span>:</span><br><span class="line">        blks.append(transition_block(num_channels, num_channels // <span class="number">2</span>))</span><br><span class="line">        num_channels = num_channels // <span class="number">2</span></span><br></pre></td></tr></table></figure><p>与ResNet类似，最后接上全局汇聚层和全连接层来输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    b1, *blks,</span><br><span class="line">    nn.BatchNorm2d(num_channels), nn.ReLU(),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(num_channels, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>测试一下模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;Layer&#x27;</span>:&lt;<span class="number">20</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;Output Shape&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;layer.__class__.__name__:&lt;<span class="number">20</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">tuple</span>(X.shape))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Layer               Output Shape</span><br><span class="line">----------------------------------------</span><br><span class="line">Sequential          (1, 64, 56, 56)</span><br><span class="line">DenseBlock          (1, 192, 56, 56)   # 固定+128</span><br><span class="line">Sequential          (1, 96, 28, 28)    # 减半</span><br><span class="line">DenseBlock          (1, 224, 28, 28)</span><br><span class="line">Sequential          (1, 112, 14, 14)</span><br><span class="line">DenseBlock          (1, 240, 14, 14)</span><br><span class="line">Sequential          (1, 120, 7, 7)</span><br><span class="line">DenseBlock          (1, 248, 7, 7)</span><br><span class="line">BatchNorm2d         (1, 248, 7, 7)</span><br><span class="line">ReLU                (1, 248, 7, 7)</span><br><span class="line">AdaptiveAvgPool2d   (1, 248, 1, 1)</span><br></pre></td></tr></table></figure><h3 id="训练模型-3"><a href="#训练模型-3" class="headerlink" title="训练模型"></a>训练模型</h3><p>由于这里使用了比较深的网络，将输入高和宽从224降到96来简化计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.1</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size, resize=<span class="number">96</span>)</span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">epoch 1, loss 0.500, acc 0.827, time 35.426</span><br><span class="line">epoch 2, loss 0.295, acc 0.892, time 35.322</span><br><span class="line">epoch 3, loss 0.248, acc 0.912, time 35.535</span><br><span class="line">epoch 4, loss 0.221, acc 0.919, time 35.744</span><br><span class="line">epoch 5, loss 0.199, acc 0.928, time 37.568</span><br><span class="line">epoch 6, loss 0.179, acc 0.936, time 35.875</span><br><span class="line">epoch 7, loss 0.169, acc 0.939, time 36.142</span><br><span class="line">epoch 8, loss 0.153, acc 0.944, time 35.817</span><br><span class="line">epoch 9, loss 0.143, acc 0.948, time 35.799</span><br><span class="line">epoch 10, loss 0.129, acc 0.954, time 35.932</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510252138.png" alt="202510252138" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.129, train acc 0.954, test acc 0.882</span><br><span class="line">1915.5 examples/sec on cuda:0</span><br></pre></td></tr></table></figure><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><ul><li>在跨层连接上，不同于ResNet中将输入与输出相加，稠密连接网络(DenseNet)在通道维上连结输入与输出</li><li>DenseNet的主要构建模块是稠密块和过渡层</li><li>在构建DenseNet时，需要通过添加过渡层来控制网络的维数，从而再次减少通道的数量</li></ul><h3 id="思考题-9"><a href="#思考题-9" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>为什么DenseNet在过渡层使用平均汇聚层而不是最大汇聚层？ </p><p>DenseNet 与 ResNet 的主要不同在于每一层都把前面所有层的输出拼接起来，用作输入</p><p>这种密集连接意味着：</p><ul><li>网络内部的特征是累积的</li><li>每一层都依赖前面层的信息</li><li>信息流要尽量顺畅、完整、不被破坏</li></ul><p>平均池化能平滑压缩空间维度，同时保留全局分布特征，不会“只选最亮的像素”</p></li><li><p>DenseNet的优点之一是其模型参数比ResNet小，为什么呢？</p><p>在ResNet中，每一层都要“重新计算”很多通用底层特征(例如边缘、纹理)，而DenseNet 直接复用前面层的特征图，不用重新卷积计算这些特征，因此减少参数</p><table><thead><tr><th>模型</th><th>层数</th><th>参数量 (M)</th><th>Top-1 Error (%)</th></tr></thead><tbody><tr><td>ResNet-50</td><td>50</td><td>25.6M</td><td>23.9</td></tr><tr><td>DenseNet-121</td><td>121</td><td>8.0M</td><td>25.0</td></tr><tr><td>ResNet-152</td><td>152</td><td>60.2M</td><td>23.0</td></tr><tr><td>DenseNet-169</td><td>169</td><td>14.1M</td><td>24.0</td></tr></tbody></table><p>DenseNet 参数量只有 ResNet 的三分之一甚至更少，却达到相近精度</p></li><li><p>DenseNet一个诟病的问题是内存或显存消耗过多，为什么？</p><p>DenseNet参数少，但中间特征多且需要全部保留参与拼接，在现代GPU上显存的主要消耗主要来源于特征图</p><p>假设一个 block 有 4 层，每层输出通道数 &#x3D; 32</p><table><thead><tr><th>层</th><th>输入通道 (ResNet)</th><th>输入通道 (DenseNet)</th></tr></thead><tbody><tr><td>1</td><td>64</td><td>64</td></tr><tr><td>2</td><td>64</td><td>96 (&#x3D;64+32)</td></tr><tr><td>3</td><td>64</td><td>128 (&#x3D;64+32×2)</td></tr><tr><td>4</td><td>64</td><td>160 (&#x3D;64+32×3)</td></tr></tbody></table><p>在 DenseNet 中，输入通道逐层增加，这意味着卷积层要处理越来越多的特征图</p><p>在 ImageNet 级别的模型上，DenseNet-121&#x2F;169显存消耗比ResNet-50&#x2F;101高约 1.5～2 倍，这也是 DenseNet 没有被工业界大规模取代 ResNet 的一个重要原因</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只有LeNet输入的是28×28的小尺寸图片，其余的都是在ImageNet上测试的，所以输入均为3×224×224</p><table><thead><tr><th>意义模型</th><th>年份</th><th>核心创新</th><th>意义</th><th>局限</th></tr></thead><tbody><tr><td>LeNet</td><td>1998</td><td>卷积 + 池化</td><td>开创CNN</td><td>太浅，Sigmoid饱和</td></tr><tr><td>AlexNet</td><td>2012</td><td>ReLU + Dropout + GPU</td><td>让CNN复活</td><td>结构设计经验化，参数多</td></tr><tr><td>VGG</td><td>2014</td><td>小卷积核深堆叠</td><td>简洁、通用</td><td>参数暴涨，训练成本高</td></tr><tr><td>NiN</td><td>2013</td><td>1×1卷积 + GAP</td><td>通道融合、轻量</td><td>模型深度有限，精度略低</td></tr><tr><td>GoogLeNet</td><td>2014</td><td>多尺度Inception</td><td>高效、强大</td><td>结构复杂，设计依赖经验<br />不易泛化到其它任务</td></tr><tr><td>ResNet</td><td>2015</td><td>残差连接</td><td>深度可扩展</td><td>依赖BN</td></tr><tr><td>DenseNet</td><td>2017</td><td>全连接特征流</td><td>特征复用、梯度顺畅</td><td>显存大</td></tr></tbody></table><p>BN → ReLU → Conv 是ResNet后比较固定的模块</p>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习计算</title>
      <link href="/posts/65314.html"/>
      <url>/posts/65314.html</url>
      
        <content type="html"><![CDATA[<p>神经网络研究人员已经从考虑单个人工神经元的行为转变为从层的角度构思网络，通常在设计架构时考虑的是更粗糙的<strong>块(block)</strong></p><p>将深入探索深度学习计算的关键组件，即模型构建、参数访问与初始化、设计自定义层和块、将模型读写到磁盘，以及利用GPU实现显著的加速</p><h2 id="层和块"><a href="#层和块" class="headerlink" title="层和块"></a>层和块</h2><p>单个输出的线性神经网络模型：接收输入、生成标量输出，并通过可调参数优化目标函数</p><p>扩展到多输出网络时，可用矢量化算法统一描述整层神经元的行为</p><p>层与单个神经元类似，Softmax 回归中单层即可构成模型，而多层感知机在此基础上通过层的堆叠保留了相同的基本结构</p><p>在多层感知机中，整个模型及各层都遵循这种架构：模型接收特征并生成预测，各层接收上一层输出并传递结果，同时通过反向传播更新参数</p><p>研究常聚焦于介于“单层”和“整体模型”之间的结构，例如<font color='DarkViolet'>ResNet-152</font>由层组(groups of layers)重复堆叠而成，赢得了2015年ImageNet和COCO计算机视觉比赛的识别和检测任务，并成为视觉任务的主流架构，类似的分层设计在 NLP 和语音领域也已普遍采用</p><p>为构建这类复杂网络，引入了神经网络**块(block)**的概念，块可表示单个层、由多个层组成的组件或整个模型本身</p><p>利用块进行递归式组合，可通过简洁的代码实现结构灵活、复杂度可控的神经网络</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/blocks.webp" alt="blocks" style="zoom: 67%;" /><p>从编程的角度来看，块由**类(class)**表示</p><p>之前一直在通过<code>net(X)</code>调用模型来获得模型的输出，实际上是<code>net.__call__(X)</code>的简写</p><p>这个前向传播函数非常简单：它将列表中的每个块连接在一起，将每个块的输出作为下一个块的输入</p><h3 id="自定义块"><a href="#自定义块" class="headerlink" title="自定义块"></a>自定义块</h3><p>每个块必须提供的基本功能：</p><ol><li>将输入数据作为其前向传播函数的参数</li><li>通过前向传播函数来生成输出，输出形状和输入形状无关</li><li>计算其输出关于输入的梯度，可通过其反向传播函数进行访问，通常这是自动发生的</li><li>存储和访问前向传播计算所需的参数</li><li>根据需要初始化模型参数</li></ol><p>实现一个块类，包含一个多层感知机，其具有256个隐藏单元的隐藏层和一个10维输出层</p><p><code>MLP</code>类继承了表示块的类，只需要提供自己的构造函数(Python中的<code>__init__</code>函数)和前向传播函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLP</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 调用MLP的父类Module的构造函数来执行必要的初始化</span></span><br><span class="line">        <span class="comment"># 在类实例化时也可以指定其他函数参数，例如模型参数params(稍后将介绍)</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()  <span class="comment"># 显式调用父类的构造函数，固定写法</span></span><br><span class="line">        <span class="variable language_">self</span>.hidden = nn.Linear(<span class="number">20</span>, <span class="number">256</span>)  <span class="comment"># 隐藏层</span></span><br><span class="line">        <span class="variable language_">self</span>.out = nn.Linear(<span class="number">256</span>, <span class="number">10</span>)  <span class="comment"># 输出层</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义模型的前向传播，即如何根据输入X返回所需的模型输出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># 注意，这里使用ReLU的函数版本，其在nn.functional模块中定义</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.out(F.relu(<span class="variable language_">self</span>.hidden(X)))</span><br></pre></td></tr></table></figure><p>来试一下这个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">net = MLP()</span><br></pre></td></tr></table></figure><p>块的一个主要优点是它的多功能性，可以子类化块以创建层(如全连接层的类)、整个模型(如上面的<code>MLP</code>类)或具有中等复杂度的各种组件</p><h3 id="顺序块"><a href="#顺序块" class="headerlink" title="顺序块"></a>顺序块</h3><p>为了构建自己的简化的<code>MySequential</code>，只需要定义两个关键函数：</p><ol><li>一种将块逐个追加到列表中的函数</li><li>一种前向传播函数，用于将输入按追加块的顺序传递给块组成的“链条”</li></ol><p>下面的<code>MySequential</code>类提供了与默认<code>Sequential</code>类相同的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySequential</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.blocks = nn.ModuleList(args)  <span class="comment"># 以列表形式自动注册块，不用循环</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> <span class="variable language_">self</span>.blocks: <span class="comment"># 循环块进行网络传播</span></span><br><span class="line">            X = block(X)</span><br><span class="line">        <span class="keyword">return</span> X</span><br></pre></td></tr></table></figure><p><code>__init__</code>函数将每个模块逐个添加到有序字典<code>_modules</code>中</p><p>现在可以使用<code>MySequential</code>类重新实现多层感知机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net = MySequential(nn.Linear(<span class="number">20</span>, <span class="number">256</span>), nn.ReLU(), nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="前向传播函数"><a href="#前向传播函数" class="headerlink" title="前向传播函数"></a>前向传播函数</h3><p><code>Sequential</code>类使模型构造变得简单，允许组合新的架构，而不必定义自己的类</p><p>有时希望合并既不是上一层的结果也不是可更新参数的项，称之为<em>常数参数</em>(constant parameter)</p><p>需要一个计算函数$f(\mathbf{x},\mathbf{w}) &#x3D; c \cdot \mathbf{w}^\top \mathbf{x}$的层，其中$\mathbf{x}$是输入，$\mathbf{w}$是参数，$c$是某个在优化过程中没有更新的指定常量</p><p>实现了一个<code>FixedHiddenMLP</code>类，如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FixedHiddenMLP</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># requires_grad设置False，参数在训练过程中保持固定不变</span></span><br><span class="line">        <span class="variable language_">self</span>.rand_weight = torch.rand((<span class="number">20</span>, <span class="number">20</span>), requires_grad=<span class="literal">False</span>) <span class="comment">#</span></span><br><span class="line">        <span class="variable language_">self</span>.linear = nn.Linear(<span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        X = <span class="variable language_">self</span>.linear(X)</span><br><span class="line">        <span class="comment"># 使用创建的常量参数以及relu和mm函数</span></span><br><span class="line">        X = F.relu(torch.mm(X, <span class="variable language_">self</span>.rand_weight) + <span class="number">1</span>) <span class="comment">#引入非线性和固定随机特征映射</span></span><br><span class="line">        X = <span class="variable language_">self</span>.linear(X) <span class="comment"># 参数共享的第二次线性变换</span></span><br><span class="line">        <span class="comment"># 控制流</span></span><br><span class="line">        <span class="keyword">while</span> X.<span class="built_in">abs</span>().<span class="built_in">sum</span>() &gt; <span class="number">1</span>:</span><br><span class="line">            X /= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> X.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>实现了一个隐藏层，其权重(<code>self.rand_weight</code>)在实例化时被随机初始化，之后为常量</p><p>直接调用类就可以实现网络构建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net = FixedHiddenMLP()</span><br></pre></td></tr></table></figure><p>可以混合搭配各种组合块的方法实现嵌套</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestMLP</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.net = nn.Sequential(nn.Linear(<span class="number">20</span>, <span class="number">64</span>), nn.ReLU(),</span><br><span class="line">                                 nn.Linear(<span class="number">64</span>, <span class="number">32</span>), nn.ReLU())</span><br><span class="line">        <span class="variable language_">self</span>.linear = nn.Linear(<span class="number">32</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.linear(<span class="variable language_">self</span>.net(X))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chimera = nn.Sequential(NestMLP(), nn.Linear(<span class="number">16</span>, <span class="number">20</span>), FixedHiddenMLP())</span><br></pre></td></tr></table></figure><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>如果将<code>MySequential</code>中存储块的方式更改为Python列表，会出现什么样的问题？</p><p>把层存在 Python 列表里，PyTorch 就完全看不到它们</p><p>不会报错，但是参数不会更新、设备不会同步、模型不会保存</p></li><li><p>实现一个块，它以两个块为参数，例如<code>net1</code>和<code>net2</code>，并返回前向传播中两个网络的串联输出，这也被称为<font color='DarkViolet'>平行块</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParallelBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, net1, net2</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.net1 = net1</span><br><span class="line">        <span class="variable language_">self</span>.net2 = net2</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># 分别通过两个网络</span></span><br><span class="line">        Y1 = <span class="variable language_">self</span>.net1(X)</span><br><span class="line">        Y2 = <span class="variable language_">self</span>.net2(X)</span><br><span class="line">        <span class="comment"># 特征上拼接</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat((Y1, Y2), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>如果要实现多个网络的拼接，利用<code>ModuleList()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiParallelBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *nets</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.nets = nn.ModuleList(nets)  <span class="comment"># 自动注册所有子模块</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        outputs = [net(X) <span class="keyword">for</span> net <span class="keyword">in</span> <span class="variable language_">self</span>.nets] <span class="comment"># 依次传播X</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">1</span>) <span class="comment"># 列方向拼接输出</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="参数管理"><a href="#参数管理" class="headerlink" title="参数管理"></a>参数管理</h2><p>在选择了架构并设置了超参数后进入训练阶段，目标是找到使损失函数最小化的模型参数值</p><p>有时希望提取参数，或者说将模型保存下来，以便它可以在其他软件中执行</p><p>先定义一个具有单隐藏层的多层感知机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">4</span>, <span class="number">8</span>), nn.ReLU(), nn.Linear(<span class="number">8</span>, <span class="number">1</span>))</span><br><span class="line">X = torch.rand(size=(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">net(X)</span><br></pre></td></tr></table></figure><h3 id="参数访问"><a href="#参数访问" class="headerlink" title="参数访问"></a>参数访问</h3><p>当通过<code>Sequential</code>类定义模型时，可以通过索引来访问模型的任意层，每层的参数都在其属性中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].state_dict())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrderedDict([(&#x27;weight&#x27;, tensor([[ 0.0763, -0.1380,  0.0337,  0.3220,  0.3303,  0.2827,  0.0141,  0.3154]])), (&#x27;bias&#x27;, tensor([-0.2091]))])</span><br></pre></td></tr></table></figure><p>在<code>nn.Sequential</code>中$y&#x3D;Xw^T+b$，所以<code>shape</code>是<code>torch.Size([1, 8])</code></p><h4 id="目标参数"><a href="#目标参数" class="headerlink" title="目标参数"></a>目标参数</h4><p>每个参数都表示为参数类的一个实例，要对参数执行任何操作，首先需要访问底层的数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].weight)</span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].bias)</span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].bias.data) </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parameter containing:</span><br><span class="line">tensor([[ 0.0763, -0.1380,  0.0337,  0.3220,  0.3303,  0.2827,  0.0141,  0.3154]],</span><br><span class="line">       requires_grad=True)</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([-0.2091], requires_grad=True)</span><br><span class="line">tensor([-0.2091])</span><br></pre></td></tr></table></figure><p>参数是复合的对象，包含值、梯度和额外信息</p><p>刚刚还没调用方向传播，所以参数的梯度处于初始状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net[<span class="number">2</span>].weight.grad == <span class="literal">None</span>  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h4 id="遍历参数"><a href="#遍历参数" class="headerlink" title="遍历参数"></a>遍历参数</h4><p>需要对所有参数执行操作时，逐个访问它们可能会很麻烦，如果是复杂块(比如嵌套)，需要递归来实现</p><p>对比访问方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单层</span></span><br><span class="line"><span class="built_in">print</span>(*[(name, param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> net[<span class="number">0</span>].named_parameters()])</span><br><span class="line"><span class="comment"># 全部</span></span><br><span class="line"><span class="built_in">print</span>(*[(name, param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> net.named_parameters()])</span><br></pre></td></tr></table></figure><p><code>*</code>用于解包，让打印结果更干净、无方括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;weight&#x27;, torch.Size([8, 4])) (&#x27;bias&#x27;, torch.Size([8]))</span><br><span class="line">(&#x27;0.weight&#x27;, torch.Size([8, 4])) (&#x27;0.bias&#x27;, torch.Size([8])) (&#x27;2.weight&#x27;, torch.Size([1, 8])) (&#x27;2.bias&#x27;, torch.Size([1]))</span><br></pre></td></tr></table></figure><p>可以发现每一层的命名方法，因此可以利用刚刚的字典结构去访问具体参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(net.state_dict()[<span class="string">&#x27;0.weight&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="从嵌套块收集参数"><a href="#从嵌套块收集参数" class="headerlink" title="从嵌套块收集参数"></a>从嵌套块收集参数</h4><p>如果将多个块相互嵌套，参数命名约定是如何工作的？</p><p>首先定义一个生成块的函数，然后将这些块组合到更大的块中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">block1</span>():</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(nn.Linear(<span class="number">4</span>,<span class="number">8</span>), nn.ReLU(),</span><br><span class="line">                         nn.Linear(<span class="number">8</span>,<span class="number">4</span>), nn.ReLU())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">block2</span>():</span><br><span class="line">    net = nn.Sequential()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        net.add_module(<span class="string">f&quot;block<span class="subst">&#123;i&#125;</span>&quot;</span>, block1())</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line">rgnet = nn.Sequential(block2(),nn.Linear(<span class="number">4</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>设计了网络后，看看它是如何工作的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(rgnet)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Sequential(</span><br><span class="line">  (0): Sequential(</span><br><span class="line">    (block0): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block1): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True) # 一会访问的位置</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block2): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block3): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (1): Linear(in_features=4, out_features=1, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>因为层是分层嵌套的，所以也可以像通过嵌套列表索引一样访问它们</p><p>访问第一个主要的块中、第二个子块的第一层的偏置项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rgnet[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>].bias</span><br></pre></td></tr></table></figure><h3 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h3><p>深度学习框架提供默认随机初始化，也允许创建自定义初始化方法，满足通过其他规则实现初始化权重</p><p>默认情况下，PyTorch会根据一个范围均匀地初始化权重和偏置矩阵，这个范围是根据输入和输出维度计算出的</p><h4 id="内置初始化"><a href="#内置初始化" class="headerlink" title="内置初始化"></a>内置初始化</h4><p>这里的tensor常为<code>weight</code>or<code>bias</code></p><p><strong>常规初始化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nn.init.constant_(tensor, val)       <span class="comment"># 所有元素设为常数</span></span><br><span class="line">nn.init.zeros_(tensor)               <span class="comment"># 全零</span></span><br><span class="line">nn.init.ones_(tensor)                <span class="comment"># 全一</span></span><br><span class="line">nn.init.uniform_(tensor, a, b)       <span class="comment"># 均匀分布 U(a, b)</span></span><br><span class="line">nn.init.normal_(tensor, mean, std)   <span class="comment"># 正态分布 N(mean, std)</span></span><br></pre></td></tr></table></figure><p><strong>Xavier(Glorot)初始化</strong></p><p>保持前后层的方差一致，防止梯度消失或爆炸，常用于 Sigmoid 或 tanh 激活</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nn.init.xavier_uniform_(tensor)</span><br><span class="line">nn.init.xavier_normal_(tensor)</span><br></pre></td></tr></table></figure><p><strong>Kaiming(He)初始化</strong></p><p>适用于 ReLU 或 LeakyReLU 激活函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nn.init.kaiming_uniform_(tensor, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">nn.init.kaiming_normal_(tensor, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>正交初始化</strong></p><p>保持权重矩阵的正交性，广泛用于循环神经网络(RNN&#x2F;LSTM)，可以避免梯度爆炸</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.init.orthogonal_(tensor)</span><br></pre></td></tr></table></figure><p><strong>稀疏初始化</strong></p><p>让部分连接为0，适合稀疏神经网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.init.sparse_(tensor, sparsity=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><h4 id="自定义初始化"><a href="#自定义初始化" class="headerlink" title="自定义初始化"></a>自定义初始化</h4><p>有时，深度学习框架没有提供需要的初始化方法<br>$$<br>\begin{split}\begin{aligned}<br>    w \sim \begin{cases}<br>        U(5, 10) &amp; p&#x3D; \frac{1}{4} \\<br>            0    &amp; p&#x3D; \frac{1}{2} \\<br>        U(-10, -5) &amp; p&#x3D; \frac{1}{4}<br>    \end{cases}<br>\end{aligned}\end{split}<br>$$<br>实现了一个<code>my_init</code>函数来应用到<code>net</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_init</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(m)==nn.Linear):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Init&quot;</span>, *[(name,param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> m.named_parameters()][<span class="number">0</span>])</span><br><span class="line">        nn.init.uniform_(m.weight, -<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">        m.weight.data *= m.weight.data.<span class="built_in">abs</span>()&gt;=<span class="number">5</span></span><br><span class="line">        </span><br><span class="line">net.apply(my_init)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Init weight torch.Size([8, 4])</span><br><span class="line">Init weight torch.Size([1, 8])</span><br><span class="line">Sequential(</span><br><span class="line">  (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">  (1): ReLU()</span><br><span class="line">  (2): Linear(in_features=8, out_features=1, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>有时希望在多个层间共享参数：可以定义一个稠密层，然后使用它的参数来设置另一个层的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shared = nn.Linear(<span class="number">8</span>,<span class="number">8</span>)</span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">4</span>,<span class="number">8</span>), nn.ReLU(),</span><br><span class="line">                    shared, nn.ReLU(),</span><br><span class="line">                    shared, nn.ReLU(),</span><br><span class="line">                    nn.Linear(<span class="number">8</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 前向传播(只是为了初始化参数)</span></span><br><span class="line">net(X)</span><br><span class="line"><span class="comment"># 检查共享层权重是否相同</span></span><br><span class="line"><span class="built_in">print</span>(torch.equal(net[<span class="number">2</span>].weight[<span class="number">0</span>], net[<span class="number">4</span>].weight[<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># 修改参数(安全方式，不用 .data)</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    net[<span class="number">2</span>].weight[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line"><span class="comment"># 检查是否一起变化</span></span><br><span class="line"><span class="built_in">print</span>(torch.equal(net[<span class="number">2</span>].weight[<span class="number">0</span>], net[<span class="number">4</span>].weight[<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># 验证：它们指向同一块内存</span></span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].weight.data_ptr() == net[<span class="number">4</span>].weight.data_ptr())</span><br></pre></td></tr></table></figure><p>不用 <code>.data</code>，改用 <code>with torch.no_grad()</code>，这让修改参数不会被 autograd 追踪，也不会破坏计算图</p><p>当参数绑定时，梯度会发生什么情况？</p><p>由于模型参数包含梯度，因此在反向传播期间第二个隐藏层(即第三个神经网络层)和第三个隐藏层(即第五个神经网络层)的梯度会加在一起</p><h2 id="延后初始化"><a href="#延后初始化" class="headerlink" title="延后初始化"></a>延后初始化</h2><p>在之前的定义中可能会有一些疑问：</p><ol><li>定义了网络架构，但没有指定输入维度</li><li>添加层时没有指定前一层的输出维度</li><li>在初始化参数时，甚至没有足够的信息来确定模型应该包含多少参数</li></ol><p>这里用到了框架的<strong>延后初始化(defers initialization)</strong>，即直到数据第一次通过模型传递时，框架才会动态地推断出每个层的大小</p><p>当使用卷积神经网络时，由于输入维度(即图像的分辨率)将影响每个后续层的维数，在编写代码时无须知道维度是什么就可以设置参数，这种能力可以大大简化定义和修改模型的任务</p><h3 id="实例化网络"><a href="#实例化网络" class="headerlink" title="实例化网络"></a>实例化网络</h3><p>实例化一个多层感知机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">net = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">256</span>, activation=tf.nn.relu),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>这里用到了<code>tensorflow</code>，相比<code>torch.nn</code>不需要再显式指定输入维度</p><table><thead><tr><th>概念</th><th>PyTorch 写法</th><th>TensorFlow 写法</th></tr></thead><tbody><tr><td>定义模型</td><td><code>nn.Sequential([...])</code></td><td><code>tf.keras.models.Sequential([...])</code></td></tr><tr><td>层的基类</td><td><code>nn.Module</code></td><td><code>tf.keras.layers.Layer</code></td></tr><tr><td>全连接层</td><td><code>nn.Linear(in, out)</code></td><td><code>tf.keras.layers.Dense(out)</code></td></tr><tr><td>激活函数</td><td><code>nn.ReLU()</code></td><td><code>activation=tf.nn.relu</code></td></tr><tr><td>模型调用</td><td><code>net(x)</code></td><td><code>net(x)</code></td></tr></tbody></table><p>为输入维数是未知的，所以网络不可能知道输入层权重的维数</p><p>框架尚未初始化任何参数，通过尝试访问以下参数进行确认</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[net.layers[i].get_weights() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(net.layers))] </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[], []]</span><br></pre></td></tr></table></figure><p>每个层对象都存在，但权重为空</p><p>使用<code>net.get_weights()</code>将抛出一个错误，因为权重尚未初始化</p><p>让将数据通过网络，最终使框架初始化参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = tf.random.uniform((<span class="number">2</span>, <span class="number">20</span>))</span><br><span class="line">net(X)</span><br><span class="line">[w.shape <span class="keyword">for</span> w <span class="keyword">in</span> net.get_weights()]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(20, 256), (256,), (256, 10), (10,)]</span><br></pre></td></tr></table></figure><p>当知道输入维度为20时，框架可以通过代入值20来识别第一层权重矩阵的形状，识别出第一层的形状后，框架处理第二层，依此类推，直到所有形状都已知为止</p><p>在这种情况下，只有第一层需要延迟初始化，但是框架仍是按顺序初始化的，等到知道了所有的参数形状，框架就可以初始化参数</p><h3 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>如果指定了第一层的输入尺寸，但没有指定后续层的尺寸，会发生什么？是否立即进行初始化？</p><p>指定第一层的输入形状，只会让第一层立即建权重；后续层仍然是<strong>延迟初始化</strong>，直到真正看到数据流动时才构建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">256</span>, activation=tf.nn.relu, input_shape=(<span class="number">4</span>,)),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li><li><p>如果指定了不匹配的维度会发生什么？</p><p>会在第一次真正使用模型时检查输入输出维度是否一致，一旦不匹配，就立即抛出<code>ValueError</code></p></li><li><p>如果输入具有不同的维度，需要做什么？</p><table><thead><tr><th>场景</th><th>例子</th><th>解决思路</th></tr></thead><tbody><tr><td>每个样本特征数不同</td><td>文本句长不一、时间序列长短不一</td><td>padding、截断</td></tr><tr><td>多模态输入</td><td>图像+文本、图像+数值</td><td>使用Functional API<br />定义多个 Input</td></tr></tbody></table></li></ol><h2 id="自定义层"><a href="#自定义层" class="headerlink" title="自定义层"></a>自定义层</h2><h3 id="不带参数的层"><a href="#不带参数的层" class="headerlink" title="不带参数的层"></a>不带参数的层</h3><p>下面的<code>CenteredLayer</code>类要从其输入中减去均值，没有任何参数</p><p>要构建它，只需继承基础层类并实现前向传播功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CenteredLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> X - X.mean()</span><br></pre></td></tr></table></figure><p>向该层提供一些数据，验证它是否能按预期工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layer = CenteredLayer()</span><br><span class="line">layer(torch.FloatTensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([-2., -1.,  0.,  1.,  2.])</span><br></pre></td></tr></table></figure><p>确实可行，可以将层作为组件合并到更复杂的模型中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Linear(<span class="number">8</span>,<span class="number">128</span>), CenteredLayer())</span><br><span class="line">Y = net(torch.rand(<span class="number">4</span>,<span class="number">8</span>))</span><br><span class="line">Y.mean() <span class="comment"># 输出0</span></span><br></pre></td></tr></table></figure><p>因为减去自身均值后，全局平均一定为 0</p><h3 id="带参数的层"><a href="#带参数的层" class="headerlink" title="带参数的层"></a>带参数的层</h3><p>定义具有参数的层，这些参数可以通过训练进行调整</p><p>可以使用内置函数来创建参数，这些函数提供一些基本的管理功能，比如管理访问、初始化、共享、保存和加载模型参数</p><p>实现自定义版本的全连接层，该层需要两个参数，一个表示权重，一个表示偏置</p><p>需要输入参数：<code>in_units</code>和<code>out_units</code>，分别表示输入数和输出数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinear</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_units, out_units</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.weight = nn.Parameter(torch.randn(in_units, out_units))</span><br><span class="line">        <span class="variable language_">self</span>.bias = nn.Parameter(torch.randn(out_units,))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        linear = torch.matmul(X, <span class="variable language_">self</span>.weight) + <span class="variable language_">self</span>.bias</span><br><span class="line">        <span class="keyword">return</span> F.relu(linear)</span><br><span class="line"></span><br><span class="line">linear = MyLinear(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">linear.weight</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parameter containing:</span><br><span class="line">tensor([[ 0.3906,  1.1024,  0.6969],</span><br><span class="line">        [ 0.4338, -1.2284,  0.7065],</span><br><span class="line">        [ 0.5477, -0.0035,  1.0133],</span><br><span class="line">        [-0.6144,  1.4496, -0.5322],</span><br><span class="line">        [-1.2321,  0.1517, -1.1284]], requires_grad=True)</span><br></pre></td></tr></table></figure><p>可以使用自定义层直接执行前向传播计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(linear(torch.rand(<span class="number">2</span>, <span class="number">5</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1.2887, 2.0474, 0.4946],</span><br><span class="line">        [0.6648, 1.4507, 0.0000]], grad_fn=&lt;ReluBackward0&gt;)</span><br></pre></td></tr></table></figure><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>保存训练的模型，以备将来在各种环境中使用(比如在部署中进行预测)</p><p>当运行一个耗时较长的训练过程时，最佳的做法是定期保存中间结果，以确保在服务器电源被不小心断掉时，不会损失几天的计算结果</p><h3 id="加载和保存张量"><a href="#加载和保存张量" class="headerlink" title="加载和保存张量"></a>加载和保存张量</h3><table><thead><tr><th></th><th>保存方式</th></tr></thead><tbody><tr><td>单个张量</td><td><code>torch.save(x, &#39;x-file&#39;)</code></td></tr><tr><td>张量列表</td><td><code>torch.save([x, y],&#39;x-files&#39;)</code></td></tr><tr><td>张量字典</td><td><code>torch.save(mydict, &#39;mydict&#39;)</code></td></tr></tbody></table><p>读回方式基本相同，不同的是接受容器要准备好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x2 = torch.load(<span class="string">&#x27;x-file&#x27;</span>, weights_only=<span class="literal">True</span>)      <span class="comment"># 单个张量</span></span><br><span class="line">x2, y2 = torch.load(<span class="string">&#x27;x-files&#x27;</span>, weights_only=<span class="literal">True</span>) <span class="comment"># 张量列表</span></span><br><span class="line">mydict2 = torch.load(<span class="string">&#x27;mydict&#x27;</span>, weights_only=<span class="literal">True</span>) <span class="comment"># 字典</span></span><br></pre></td></tr></table></figure><h3 id="加载和保存模型参数"><a href="#加载和保存模型参数" class="headerlink" title="加载和保存模型参数"></a>加载和保存模型参数</h3><p>保存单个权重向量(或其他张量)确实有用，但是如果想保存整个模型，并在以后加载它们，单独保存每个向量则会变得很麻烦</p><p>深度学习框架提供了内置函数来保存和加载整个网络，这将保存模型的参数而不是保存整个模型</p><p>因为模型本身可以包含任意代码，所以模型本身难以序列化</p><p>为了恢复模型，需要用代码生成架构，然后从磁盘加载参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MLP</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.hidden = nn.Linear(<span class="number">20</span>, <span class="number">256</span>)</span><br><span class="line">        <span class="variable language_">self</span>.output = nn.Linear(<span class="number">256</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.output(F.relu(<span class="variable language_">self</span>.hidden(x)))</span><br><span class="line"></span><br><span class="line">net = MLP()</span><br><span class="line">X = torch.randn(size=(<span class="number">2</span>, <span class="number">20</span>))</span><br><span class="line">Y = net(X)</span><br></pre></td></tr></table></figure><p>将模型的参数存储在一个叫做“mlp.params”的文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(net.state_dict(), <span class="string">&#x27;mlp.params&#x27;</span>)</span><br></pre></td></tr></table></figure><p>为了恢复模型，实例化了原始多层感知机模型的一个备份，这里不需要随机初始化模型参数，而是直接读取文件中存储的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clone = MLP()</span><br><span class="line">clone.load_state_dict(torch.load(<span class="string">&#x27;mlp.params&#x27;</span>,weights_only=<span class="literal">True</span>))</span><br><span class="line">clone.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MLP(</span><br><span class="line">  (hidden): Linear(in_features=20, out_features=256, bias=True)</span><br><span class="line">  (output): Linear(in_features=256, out_features=10, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在输入相同的<code>X</code>时，两个实例的计算结果应该相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y_clone = clone(X)</span><br><span class="line">torch.equal(Y_clone, Y) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><p>使用<code>nvidia-smi</code>命令来查看显卡信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><h3 id="计算设备"><a href="#计算设备" class="headerlink" title="计算设备"></a>计算设备</h3><p>在PyTorch中，CPU和GPU可以用<code>torch.device(&#39;cpu&#39;)</code> 和<code>torch.device(&#39;cuda&#39;)</code>表示</p><p>如果有多个GPU，使用<code>torch.device(f&#39;cuda:&#123;i&#125;&#39;)</code> 来表示第$i$块GPU(从0开始)</p><p>查询可用gpu的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cuda.device_count()</span><br></pre></td></tr></table></figure><p>定义了两个方便的函数，这两个函数允许在不存在所需所有GPU的情况下运行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">try_gpu</span>(<span class="params">i=<span class="number">0</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;如果存在，则返回gpu(i)，否则返回cpu()&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> torch.cuda.device_count() &gt;= i + <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> torch.device(<span class="string">f&#x27;cuda:<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> torch.device(<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">try_all_gpus</span>():  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回所有可用的GPU，如果没有GPU，则返回[cpu(),]&quot;&quot;&quot;</span></span><br><span class="line">    devices = [torch.device(<span class="string">f&#x27;cuda:<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(torch.cuda.device_count())]</span><br><span class="line">    <span class="keyword">return</span> devices <span class="keyword">if</span> devices <span class="keyword">else</span> [torch.device(<span class="string">&#x27;cpu&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">try_gpu(), try_all_gpus()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(device(type=&#x27;cuda&#x27;, index=0), [device(type=&#x27;cuda&#x27;, index=0)])</span><br></pre></td></tr></table></figure><h3 id="张量与GPU"><a href="#张量与GPU" class="headerlink" title="张量与GPU"></a>张量与GPU</h3><p>默认情况下，张量是在CPU上创建的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">x.device</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device(type=&#x27;cpu&#x27;)</span><br></pre></td></tr></table></figure><p>无论何时要对多个项进行操作，它们都必须在同一个设备上，否则框架将不知道在哪里存储结果，甚至不知道在哪里执行计算</p><h4 id="存储在GPU上"><a href="#存储在GPU上" class="headerlink" title="存储在GPU上"></a>存储在GPU上</h4><p>可以在创建张量时指定存储设备，在GPU上创建的张量只消耗这个GPU的显存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = torch.ones(<span class="number">2</span>, <span class="number">3</span>, device=try_gpu())</span><br><span class="line">X</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 1., 1.],</span><br><span class="line">        [1., 1., 1.]], device=&#x27;cuda:0&#x27;)</span><br></pre></td></tr></table></figure><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>如果创建了两个量在不同设备上，不能直接将它们相加，在同一设备上找不到数据会导致失败</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/copyto.svg" alt="copyto"  /><p>假设变量<code>X</code>已经存在于第一个GPU上，调用<code>X.cuda(0)</code>将返回<code>X</code>而不会复制并分配新内存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X.cuda(<span class="number">0</span>) <span class="keyword">is</span> X  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h4 id="旁注"><a href="#旁注" class="headerlink" title="旁注"></a>旁注</h4><p>GPU的计算速度很快，但设备间的数据传输(如 CPU 与 GPU 之间)要慢得多</p><p>为了减少等待和阻塞，应尽量减少拷贝操作，将多个小操作合并成较大的批量计算，频繁的数据交换会拖慢并行效率</p><p>当打印张量或转换为NumPy时，若数据不在内存中，系统会先将其拷回CPU，这也会增加传输开销，并受Python全局解释器锁的影响</p><p>GPU快在计算，慢在传输，减少数据移动才能提高效率</p><h3 id="神经网络与GPU"><a href="#神经网络与GPU" class="headerlink" title="神经网络与GPU"></a>神经网络与GPU</h3><p>神经网络模型可以指定设备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Linear(<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">net = net.to(device=try_gpu())</span><br></pre></td></tr></table></figure><p>当输入为GPU上的张量时，模型将在同一GPU上计算结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net(X)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[0.5950],</span><br><span class="line">        [0.5950]], device=&#x27;cuda:0&#x27;, grad_fn=&lt;AddmmBackward0&gt;)</span><br></pre></td></tr></table></figure><p>确认模型参数存储在同一个GPU上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net[<span class="number">0</span>].weight.device</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device(type=&#x27;cuda&#x27;, index=0)</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>尝试一个计算量更大的任务，比如大矩阵的乘法，看看CPU和GPU之间的速度差异，再试一个计算量很小的任务呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">timer = Timer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义大矩阵和小矩阵</span></span><br><span class="line">sizes = &#123;<span class="string">&#x27;大矩阵&#x27;</span>: <span class="number">4096</span>, <span class="string">&#x27;小矩阵&#x27;</span>: <span class="number">32</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, n <span class="keyword">in</span> sizes.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n<span class="subst">&#123;name&#125;</span>(<span class="subst">&#123;n&#125;</span>x<span class="subst">&#123;n&#125;</span>):&quot;</span>)</span><br><span class="line"></span><br><span class="line">    A = torch.randn(n, n)</span><br><span class="line">    B = torch.randn(n, n)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---- CPU 计算 ----</span></span><br><span class="line">    timer.start()</span><br><span class="line">    C = A @ B</span><br><span class="line">    cpu_time = timer.stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---- GPU 计算(如果可用)----</span></span><br><span class="line">    device = try_gpu()  <span class="comment"># 自动选择可用 GPU 或 CPU</span></span><br><span class="line">    <span class="keyword">if</span> device.<span class="built_in">type</span> == <span class="string">&#x27;cuda&#x27;</span>:</span><br><span class="line">        <span class="comment"># 把数据搬到 GPU</span></span><br><span class="line">        A_gpu, B_gpu = A.to(device), B.to(device)</span><br><span class="line">        torch.cuda.synchronize()</span><br><span class="line"></span><br><span class="line">        timer.start()</span><br><span class="line">        C_gpu = A_gpu @ B_gpu</span><br><span class="line">        torch.cuda.synchronize()</span><br><span class="line">        gpu_time = timer.stop()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;CPU: <span class="subst">&#123;cpu_time * <span class="number">1000</span>:<span class="number">.3</span>f&#125;</span> ms\tGPU: <span class="subst">&#123;gpu_time * <span class="number">1000</span>:<span class="number">.3</span>f&#125;</span> ms\t加速比: <span class="subst">&#123;cpu_time / gpu_time:<span class="number">.1</span>f&#125;</span>x&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;CPU: <span class="subst">&#123;cpu_time * <span class="number">1000</span>:<span class="number">.3</span>f&#125;</span> ms\t(未检测到 GPU)&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大矩阵(4096x4096):</span><br><span class="line">CPU: 616.677 msGPU: 195.000 ms加速比: 3.2x</span><br><span class="line"></span><br><span class="line">小矩阵(32x32):</span><br><span class="line">CPU: 24.073 msGPU: 0.946 ms加速比: 25.4x</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多层感知机</title>
      <link href="/posts/9999.html"/>
      <url>/posts/9999.html</url>
      
        <content type="html"><![CDATA[<p>从这里开始真正的深度网络，<font color='DarkViolet'>最简单的深度网络称为多层感知机</font></p><p>多层感知机由多层神经元组成，每一层与它的上一层相连，从中接收输入；同时每一层也与它的下一层相连，影响当前层的神经元</p><h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><h3 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h3><p>在线性神经网络中讲到仿射变换，它是一种带有偏置项的线性变换</p><p>softmax回归通过单个仿射变换将输入直接映射到输出，然后进行softmax操作，标签通过仿射变换后确实与输入数据相关，但是<font color='DarkViolet'>仿射变换中的线性是一个很强的假设</font></p><h4 id="线性模型的误差"><a href="#线性模型的误差" class="headerlink" title="线性模型的误差"></a>线性模型的误差</h4><p>线性意味着单调假设，任何特征的增大都会导致模型输出的增大，但这并不是在所有情况下都对</p><p>比如虽然收入与还款概率存在单调性，但它们不是线性相关的，处理这类问题的一种方法是使用对数进行预处理，使线性更合理</p><p>如何对猫和狗的图像进行分类呢？对线性模型的依赖对应于一个隐含的假设，即区分猫和狗的唯一要求是评估单个像素的强度，但是在一个倒置图像后依然保留类别的世界里，这种方法就会失败</p><p>在图像中，单个像素的意义几乎为零，像素的重要性取决于上下文——它周围像素的取值</p><p>如果能手动构造出一种新的特征表示，比如边缘特征、角点特征、梯度方向、颜色分布……，在这些“高级特征”上再用一个线性模型，就会表现很好，但我们并不知道怎么手工设计出这种完美的表示</p><p><font color='Violetred'>对于深度神经网络，它不依赖人工设计特征，而是通过数据自动学习特征表示，也就是隐藏层</font></p><h4 id="隐藏层的加入"><a href="#隐藏层的加入" class="headerlink" title="隐藏层的加入"></a>隐藏层的加入</h4><p>可以通过在网络中加入一个或多个隐藏层来克服线性模型的限制，使其能处理更普遍的函数关系类型</p><p>最简单的方法是将许多全连接层堆叠在一起，每一层都输出到上面的层，直到生成最后的输出</p><p>可以把前$L-1$层看作表示，把最后一层看作线性预测器，这种架构通常称为<strong>多层感知机(multilayer perceptron)</strong>，通常缩写为MLP</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/mlp.jpg" alt="mlp" style="zoom:80%;" /><p>这个多层感知机有4个输入，3个输出，其隐藏层包含5个隐藏单元，输入层不涉及计算，所以这个多层感知机中的层数为2，同样是全连接层</p><p>因为全连接层的复杂度，即使在不改变输入或输出大小的情况下，可能在参数节约和模型有效性之间进行权衡</p><h4 id="从线性到非线性"><a href="#从线性到非线性" class="headerlink" title="从线性到非线性"></a>从线性到非线性</h4><p>通过矩阵$\mathbf{X} \in \mathbb{R}^{n \times d}$来表示$n$个样本的小批量，其中每个样本具有$d$个输入特征</p><p>对于具有$h$个隐藏单元的单隐藏层多层感知机，用$\mathbf{H} \in \mathbb{R}^{n \times h}$表示隐藏层的输出，称为<strong>隐藏层变量(hidden-layer variable)</strong></p><p>因为隐藏层和输出层都是全连接的，有隐藏层权重$\mathbf{W}^{(1)} \in \mathbb{R}^{d \times h}$和隐藏层偏置$\mathbf{b}^{(1)} \in \mathbb{R}^{1 \times h}$以及输出层权重$\mathbf{W}^{(2)} \in \mathbb{R}^{h \times q}$和输出层偏置$\mathbf{b}^{(2)} \in \mathbb{R}^{1 \times q}$，输出$\mathbf{O} \in \mathbb{R}^{n \times q}$<br>$$<br>\begin{split}\begin{aligned}<br>    \mathbf{H} &amp; &#x3D; \mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)}, \\<br>    \mathbf{O} &amp; &#x3D; \mathbf{H}\mathbf{W}^{(2)} + \mathbf{b}^{(2)}<br>\end{aligned}\end{split}<br>$$<br>在添加隐藏层之后，模型现在需要跟踪和更新额外的参数，但从这个模型上看并没有得到好处</p><p>因为对于任意权重值只需合并隐藏层，便可产生具有参数$\mathbf{W} &#x3D; \mathbf{W}^{(1)}\mathbf{W}^{(2)}$和$\mathbf{b} &#x3D; \mathbf{b}^{(1)} \mathbf{W}^{(2)} + \mathbf{b}^{(2)}$的等价单层模型<br>$$<br>\mathbf{O} &#x3D; (\mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)})\mathbf{W}^{(2)} + \mathbf{b}^{(2)} &#x3D; \mathbf{X} \mathbf{W}^{(1)}\mathbf{W}^{(2)} + \mathbf{b}^{(1)} \mathbf{W}^{(2)} + \mathbf{b}^{(2)} &#x3D; \mathbf{X} \mathbf{W} + \mathbf{b}.<br>$$<br>为了发挥多层架构的潜力还需要一个额外的关键要素：在仿射变换之后对每个隐藏单元应用非线性的<strong>激活函数(activation function)</strong></p><p>激活函数的输出$\sigma(\cdot)$被称为<strong>活性值(activations)</strong></p><p>加入激活函数就不可能再将多层感知机退化成线性模型<br>$$<br>\begin{split}\begin{aligned}<br>    \mathbf{H} &amp; &#x3D; \sigma(\mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)}), \\<br>    \mathbf{O} &amp; &#x3D; \mathbf{H}\mathbf{W}^{(2)} + \mathbf{b}^{(2)}<br>\end{aligned}\end{split}<br>$$<br>出于记号习惯的考量，定义非线性函数也以按行的方式作用于其输入，即一次计算一个样本</p><p>大多数激活函数都是<font color='DarkViolet'>按元素计算，也就是说每个元素独立变换</font>；但像 softmax这样的激活函数，还会按行归一化，也就是每个样本(行)内部的元素彼此关联</p><table><thead><tr><th>类型</th><th>示例</th><th>是否行内相关</th><th>输出含义</th></tr></thead><tbody><tr><td>按元素</td><td>ReLU, Sigmoid, Tanh</td><td>❌ 否</td><td>非线性特征变换</td></tr><tr><td>按行</td><td>Softmax</td><td>✅ 是</td><td>概率归一化，类别竞争</td></tr></tbody></table><p>为了构建更通用的多层感知机，可以继续堆叠这样的隐藏层，比如$\mathbf{H}^{(1)} &#x3D; \sigma_1(\mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)})$，$\mathbf{H}^{(2)} &#x3D; \sigma_2(\mathbf{H}^{(1)} \mathbf{W}^{(2)} + \mathbf{b}^{(2)})$，通过使用更深的网络，可以更容易地逼近许多函数</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>**激活函数(activation function)**通过计算加权和并加上偏置来确定神经元是否应该被激活，大多数激活函数都是非线性的</p><h4 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h4><p><font color='DarkViolet'>最受欢迎的激活函数</font>是<strong>修正线性单元(Rectified linear unit，ReLU)</strong>，因为它实现简单，同时在各种预测任务中表现良好</p><p>ReLU提供了一种非常简单的非线性变换，给定元素$x$，ReLU函数被定义为该元素与0的最大值<br>$$<br>\operatorname{ReLU}(x) &#x3D; \max(x, 0).<br>$$<br>ReLU函数通过将相应的活性值设为0，仅保留正元素并丢弃所有负元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(-<span class="number">8.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = torch.relu(x)</span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>,<span class="number">2.5</span>))</span><br><span class="line">plt.plot(x.detach(), y.detach())</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;relu(x)&#x27;</span>)</span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019161724987.png" alt="image-20251019161724987" style="zoom:80%;" /><p>当输入为负时导数为0，而当输入为正时导数为1，当输入值等于0时ReLU函数不可导，默认使用左侧的导数，即输入0时导数为0</p><p>绘制其导数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y.<span class="built_in">sum</span>().backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>,<span class="number">2.5</span>))</span><br><span class="line">plt.plot(x.detach(), x.grad)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;grad of relu&#x27;</span>)</span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019161941635.png" alt="image-20251019161941635" style="zoom:80%;" /><p>使用ReLU的原因是，它求导表现得特别好：要么让参数消失，要么让参数通过</p><p>这使得优化表现得更好，并且ReLU减轻了困扰以往神经网络的梯度消失问题</p><p>ReLU函数有许多变体，包括**参数化ReLU(Parameterized ReLU，pReLU)**函数</p><p>该变体为ReLU添加了一个线性项，因此即使参数是负的，某些信息仍然可以通过<br>$$<br>\operatorname{pReLU}(x) &#x3D; \max(0, x) + \alpha \min(0, x).<br>$$</p><h4 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h4><p>对于一个定义域在$\mathbb{R}$中的输入，sigmoid函数将输入变换为区间(0, 1)上的输出</p><p>因此，sigmoid通常称为<strong>挤压函数(squashing function)</strong><br>$$<br>\operatorname{sigmoid}(x) &#x3D; \frac{1}{1 + \exp(-x)}.<br>$$<br><font color='Violetred'>当想要将输出视作二元分类问题的概率时，sigmoid仍然被广泛用作输出单元上的激活函数 </font>(sigmoid可以视为softmax的特例)</p><p>但sigmoid在隐藏层中已经较少使用，它在大部分时候被更简单、更容易训练的ReLU所取代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y = torch.sigmoid(x)</span><br><span class="line">plt.plot(x.detach(), y.detach())</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;sigmoid(x)&#x27;</span>)</span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019162110077.png" alt="image-20251019162110077" style="zoom:80%;" /><p>当输入接近0时，sigmoid函数接近线性变换</p><p>sigmoid函数的导数为<br>$$<br>\frac{d}{dx} \operatorname{sigmoid}(x) &#x3D; \frac{\exp(-x)}{(1 + \exp(-x))^2} &#x3D; \operatorname{sigmoid}(x)\left(1-\operatorname{sigmoid}(x)\right).<br>$$<br>当输入为0时，sigmoid函数的导数达到最大值0.25，而输入在任一方向上越远离0点时，导数越接近0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y.<span class="built_in">sum</span>().backward(retain_graph=<span class="literal">True</span>) <span class="comment"># 不加retain_graph自动释放计算图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>,<span class="number">2.5</span>))</span><br><span class="line">plt.plot(x.detach(), x.grad)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;grad of sigmoid&#x27;</span>)</span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019162150568.png" alt="image-20251019162150568" style="zoom:80%;" /><h4 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h4><p>与sigmoid函数类似，tanh(双曲正切)函数也能将其输入压缩转换到区间(-1, 1)上<br>$$<br>\operatorname{tanh}(x) &#x3D; \frac{1 - \exp(-2x)}{1 + \exp(-2x)}<br>$$<br>当输入在0附近时，tanh函数接近线性变换</p><p>函数的形状类似于sigmoid函数，不同的是tanh函数关于坐标系原点中心对称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y = torch.tanh(x)</span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>,<span class="number">2.5</span>))</span><br><span class="line">plt.plot(x.detach(), y.detach())</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;tanh(x)&#x27;</span>)</span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019162438781.png" alt="image-20251019162438781" style="zoom:80%;" /><p>tanh函数的导数<br>$$<br>\frac{d}{dx} \operatorname{tanh}(x) &#x3D; 1 - \operatorname{tanh}^2(x).<br>$$<br>tanh函数的导数和sigmoid类似，接近0时代最大值为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y.<span class="built_in">sum</span>().backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>,<span class="number">2.5</span>))</span><br><span class="line">plt.plot(x.detach(), x.grad)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;grad of tanh&#x27;</span>)</span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019162509297.png" alt="image-20251019162509297" style="zoom:80%;" /><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>如果一个非线性激活函数不是按样本逐元素地应用，而是对整个小批量(batch)一起应用，会出现什么问题？</p><p>激活函数是对每个神经元输出进行<strong>非线性变换</strong>，应该逐样本、逐元素独立地工作</p><p>如果批量处理激活函数输出不再只取决于当前样本，而依赖于整个batch，这意味着模型对单个样本的预测结果会受到 batch 中其他样本的影响，就会导致样本之间互相干扰，打破独立性，造成梯度传播混乱，最终使模型难以收敛甚至失效</p><h2 id="多层感知机的底层实现"><a href="#多层感知机的底层实现" class="headerlink" title="多层感知机的底层实现"></a>多层感知机的底层实现</h2><p>为了与之前softmax回归获得的结果进行比较，将继续使用Fashion-MNIST图像分类数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size)</span><br></pre></td></tr></table></figure><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>将每个图像视为具有784个输入特征和10个类的简单分类数据集，将实现一个具有单隐藏层的多层感知机，它包含256个隐藏单元，可以将这两个变量都视为超参数</p><p>通常选择2的若干次幂作为层的宽度，因为内存在硬件中的分配和寻址方式，这么做往往可以在计算上更高效</p><p>对于每一层都要记录一个权重矩阵和一个偏置向量，要为损失关于这些参数的梯度分配内存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line"><span class="comment"># nn.Parameter 内部初始化定义requires_grad = True</span></span><br><span class="line">W1 = nn.Parameter(torch.randn(num_inputs, num_hiddens)* <span class="number">0.01</span>)</span><br><span class="line">b1 = nn.Parameter(torch.zeros(num_hiddens))</span><br><span class="line">W2 = nn.Parameter(torch.randn(num_hiddens, num_outputs)* <span class="number">0.01</span>)</span><br><span class="line">b2 = nn.Parameter(torch.zeros(num_outputs))</span><br><span class="line">params = [W1, b1, W2, b2]</span><br></pre></td></tr></table></figure><h3 id="激活函数-1"><a href="#激活函数-1" class="headerlink" title="激活函数"></a>激活函数</h3><p>将实现ReLU激活函数，而不是直接调用内置的<code>relu</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">X</span>):</span><br><span class="line">    a = torch.zeros_like(X)</span><br><span class="line">    <span class="keyword">return</span> torch.<span class="built_in">max</span>(X, a)</span><br></pre></td></tr></table></figure><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>因为忽略了空间结构，所以使用<code>reshape</code>将每个二维图像转换为一个长度为<code>num_inputs</code>的向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">net</span>(<span class="params">X</span>):</span><br><span class="line">    X = X.reshape((-<span class="number">1</span>, num_inputs))</span><br><span class="line">    H = relu(X@W1 + b1)</span><br><span class="line">    <span class="keyword">return</span> (H@W2 + b2)</span><br></pre></td></tr></table></figure><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>已经从零实现过softmax函数，在这里直接使用高级API中的内置函数来计算softmax和交叉熵损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>多层感知机的训练过程与softmax回归的训练过程完全相同</p><p>直接调用<code>train_ch3</code>函数，将迭代周期数设置为10，并将学习率设置为0.1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, lr = <span class="number">10</span>, <span class="number">0.1</span></span><br><span class="line">updater = torch.optim.SGD(params, lr=lr)</span><br><span class="line">train_ch3(net, train_iter, test_iter, loss, num_epochs, updater)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Epoch  1/10: loss=1.0399, train_acc=0.634, test_acc=0.748</span><br><span class="line">Epoch  2/10: loss=0.6006, train_acc=0.791, test_acc=0.778</span><br><span class="line">Epoch  3/10: loss=0.5200, train_acc=0.819, test_acc=0.800</span><br><span class="line">Epoch  4/10: loss=0.4787, train_acc=0.833, test_acc=0.820</span><br><span class="line">Epoch  5/10: loss=0.4508, train_acc=0.842, test_acc=0.820</span><br><span class="line">Epoch  6/10: loss=0.4326, train_acc=0.848, test_acc=0.826</span><br><span class="line">Epoch  7/10: loss=0.4177, train_acc=0.853, test_acc=0.844</span><br><span class="line">Epoch  8/10: loss=0.4036, train_acc=0.858, test_acc=0.828</span><br><span class="line">Epoch  9/10: loss=0.3905, train_acc=0.863, test_acc=0.842</span><br><span class="line">Epoch 10/10: loss=0.3838, train_acc=0.866, test_acc=0.852</span><br><span class="line">Final loss 0.384, train acc 0.866, test acc 0.852</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019163412393.png" alt="image-20251019163412393" style="zoom:80%;" /><p>为了对学习到的模型进行评估，将在一些测试数据上应用这个模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_ch3(net, test_iter)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510171334.webp" alt="202510171334" style="zoom: 80%;" /><p>测试结果是一样的</p><h3 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3><p>改变 <code>num_hiddens</code> 会影响什么？</p><ul><li>太小：模型容量不足(underfitting) → 学不出复杂特征</li><li>适中：模型能恰好捕捉数据规律</li><li>太大：模型容量过大(overfitting) → 训练集精度高但测试集差</li></ul><p>隐藏层层数增加对结果有什么影响？</p><p>增加特征层级抽象能力，但可能会出现过拟合的情况</p><h2 id="多层感知机的简洁实现"><a href="#多层感知机的简洁实现" class="headerlink" title="多层感知机的简洁实现"></a>多层感知机的简洁实现</h2><h3 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h3><p>与softmax回归实现相比，唯一的区别是添加了2个全连接层</p><p>第一层是隐藏层，它包含256个隐藏单元，并使用了ReLU激活函数，第二层是输出层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(num_inputs, num_hiddens),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(num_hiddens, num_outputs))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std = <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights)</span><br></pre></td></tr></table></figure><p>这种模块化设计能够将与模型架构有关的内容独立出来</p><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch_size, lr, num_epochs = <span class="number">256</span>, <span class="number">0.1</span>, <span class="number">10</span></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line"></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size)</span><br><span class="line">train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Epoch  1/10: loss=1.0426, train_acc=0.637, test_acc=0.718</span><br><span class="line">Epoch  2/10: loss=0.5948, train_acc=0.791, test_acc=0.795</span><br><span class="line">Epoch  3/10: loss=0.5213, train_acc=0.817, test_acc=0.814</span><br><span class="line">Epoch  4/10: loss=0.4817, train_acc=0.830, test_acc=0.814</span><br><span class="line">Epoch  5/10: loss=0.4511, train_acc=0.841, test_acc=0.827</span><br><span class="line">Epoch  6/10: loss=0.4327, train_acc=0.848, test_acc=0.821</span><br><span class="line">Epoch  7/10: loss=0.4181, train_acc=0.852, test_acc=0.840</span><br><span class="line">Epoch  8/10: loss=0.4015, train_acc=0.859, test_acc=0.842</span><br><span class="line">Epoch  9/10: loss=0.3915, train_acc=0.862, test_acc=0.846</span><br><span class="line">Epoch 10/10: loss=0.3822, train_acc=0.865, test_acc=0.838</span><br><span class="line">Final loss 0.382, train acc 0.865, test acc 0.838</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019163831408.png" alt="image-20251019163831408" style="zoom:80%;" /><h2 id="模型选择、欠拟合和过拟合"><a href="#模型选择、欠拟合和过拟合" class="headerlink" title="模型选择、欠拟合和过拟合"></a>模型选择、欠拟合和过拟合</h2><p>机器学习科学家的目标是发现<strong>模式(pattern)</strong>，这些模式捕捉到了训练集潜在总体的规律</p><p>如何发现可以泛化的模式是机器学习的根本问题</p><p>将模型在训练数据上拟合的比在潜在分布中更接近的现象称为<strong>过拟合(overfitting)</strong>，用于对抗过拟合的技术称为<strong>正则化(regularization)</strong></p><h3 id="训练误差和泛化误差"><a href="#训练误差和泛化误差" class="headerlink" title="训练误差和泛化误差"></a>训练误差和泛化误差</h3><p><strong>训练误差(training error)</strong>：模型在训练数据上的平均错误</p><p><strong>泛化误差(generalization error)</strong>：模型在“从未见过”的新样本上的平均错误</p><p>泛化误差无法精确计算，因为真实数据分布是无限的，只能用独立的测试集(由未参与训练的随机样本组成)来近似估计它</p><h4 id="统计学习理论"><a href="#统计学习理论" class="headerlink" title="统计学习理论"></a>统计学习理论</h4><p>假设训练数据和测试数据都是从相同的分布中独立提取的(独立同分布假设)，这意味着对数据进行采样的过程没有进行“记忆”</p><p>即使这一假设被轻微违反，模型通常仍能良好工作，因为现实数据几乎总会偏离独立同分布</p><h4 id="模型复杂性"><a href="#模型复杂性" class="headerlink" title="模型复杂性"></a>模型复杂性</h4><p>当模型简单、数据充足时，训练误差与泛化误差接近</p><p>当模型复杂、样本较少时，训练误差下降但泛化误差上升</p><p><font color='Violetred'>影响模型泛化的因素</font></p><ul><li>模型复杂度，参数(自由度)越多越易过拟合</li><li>权重大小，权重的取值范围越大越易过拟合</li><li>训练样本的数量，样本越多越不易过拟合</li></ul><h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><p>在机器学习中通常在评估几个候选模型后选择最终的模型，这个过程叫做模型选择</p><p>比较内容可以是不同模型类型(如决策树与线性模型)，也可以是同模型的不同超参数(如层数、单元数、激活函数等)</p><p>为了确定候选模型中的最佳模型，通常会使用验证集</p><h4 id="验证集"><a href="#验证集" class="headerlink" title="验证集"></a>验证集</h4><p>在进行训练前一般将数据分成三份，训练集、测试集、<strong>验证集(validation set)</strong></p><p>验证集用于调整模型结构和超参数，但在实践中验证集与测试集往往来自同一数据源</p><p>因此输出的准确度其实是验证集准确度，而不是测试集准确度</p><h4 id="K折交叉验证"><a href="#K折交叉验证" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h4><p>当训练数据稀缺时，往往难以划分出足够的验证集</p><p>一种常用的解决方案是<strong>K 折交叉验证</strong>：</p><p>将原始训练数据划分为 K 个互不重叠的子集，每次使用其中 K−1 个子集进行训练，剩下的一个用于验证</p><p>重复 K 次后，对所有验证结果取平均，以更可靠地估计模型的训练与验证误差</p><h3 id="欠拟合-过拟合"><a href="#欠拟合-过拟合" class="headerlink" title="欠拟合&#x2F;过拟合"></a>欠拟合&#x2F;过拟合</h3><p>当训练误差和验证误差都很高时，说明模型无法有效拟合训练数据，通常表示模型过于简单、表达能力不足，被称为<strong>欠拟合(underfitting)</strong></p><p>当训练误差远低于验证误差时，则说明模型在训练集上表现良好，却无法泛化到新数据，被称为<strong>过拟合(overfitting)</strong></p><p>模型是否欠拟合或过拟合，取决于其复杂度与可用训练数据量的平衡</p><p>设训练数据由单个特征$x$和对应实数标签$y$组成，尝试用$d$阶多项式拟合<br>$$<br>\hat y&#x3D; \sum_{i&#x3D;0}^d x^i w_i<br>$$<br>这是一个线性回归问题，只不过输入特征为$x$的幂次</p><p>其中$w_i$为模型权重，$w_0$为偏置，损失函数采用平方误差</p><p>显然，高阶多项式的参数更多，模型更复杂，能表示的函数形状更灵活</p><p>在相同训练数据下，高阶多项式模型的训练误差通常会小于等于低阶多项式模型的训练误差</p><img src="https://zh.d2l.ai/_images/capacity-vs-error.svg" style="zoom: 80%;" /><h3 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h3><h4 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h4><p>使用以下三阶多项式来生成训练和测试数据的标签：<br>$$<br>y &#x3D; 5 + 1.2x - 3.4\frac{x^2}{2!} + 5.6 \frac{x^3}{3!} + \epsilon \text{ where }<br>\epsilon \sim \mathcal{N}(0, 0.1^2).<br>$$<br>在优化的过程中，通常希望避免非常大的梯度值或损失值，所以将特征从$x^i$调整为$x^i&#x2F;i!$，这样可以避免很大的$i$带来的特别大的指数值</p><p>将为训练集和测试集各生成100个样本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">max_degree = <span class="number">20</span>  <span class="comment"># 多项式的最大阶数</span></span><br><span class="line">n_train, n_test = <span class="number">100</span>, <span class="number">100</span>  <span class="comment"># 训练和测试数据集大小</span></span><br><span class="line">true_w = torch.zeros(max_degree)</span><br><span class="line">true_w[:<span class="number">4</span>] = torch.tensor([<span class="number">5</span>, <span class="number">1.2</span>, -<span class="number">3.4</span>, <span class="number">5.6</span>])</span><br><span class="line"></span><br><span class="line">features = torch.randn(n_train + n_test, <span class="number">1</span>)</span><br><span class="line">features = features[torch.randperm(features.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">poly_features = torch.<span class="built_in">pow</span>(features, torch.arange(max_degree).reshape(<span class="number">1</span>, -<span class="number">1</span>)) <span class="comment"># 构建多项式特征</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_degree): <span class="comment"># 用阶乘归一化</span></span><br><span class="line">    poly_features[:, i] /= math.gamma(i + <span class="number">1</span>)  <span class="comment"># gamma(n)=(n-1)!</span></span><br><span class="line"><span class="comment"># 生成含噪标签</span></span><br><span class="line">labels = torch.matmul(poly_features, true_w)</span><br><span class="line">labels += torch.normal(<span class="number">0.0</span>, <span class="number">0.1</span>, size=labels.shape)</span><br></pre></td></tr></table></figure><p>存储在<code>poly_features</code>中的单项式由gamma函数重新缩放</p><h4 id="训练和测试"><a href="#训练和测试" class="headerlink" title="训练和测试"></a>训练和测试</h4><p>实现一个函数来评估模型在给定数据集上的损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_loss</span>(<span class="params">net, data_iter, loss</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;评估给定数据集上模型的损失&quot;&quot;&quot;</span></span><br><span class="line">    metric = Accumulator(<span class="number">2</span>)  <span class="comment"># 损失的总和,样本数量</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        out = net(X)</span><br><span class="line">        y = y.reshape(out.shape)</span><br><span class="line">        l = loss(out, y)</span><br><span class="line">        metric.add(l.<span class="built_in">sum</span>(), l.numel())</span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>定义训练函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">train_features, test_features, train_labels, test_labels,</span></span><br><span class="line"><span class="params">          num_epochs=<span class="number">400</span></span>):</span><br><span class="line">    loss = nn.MSELoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    input_shape = train_features.shape[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 不设置偏置，因为在多项式特征中涵盖0阶</span></span><br><span class="line">    net = nn.Sequential(nn.Linear(input_shape, <span class="number">1</span>, bias=<span class="literal">False</span>))</span><br><span class="line">    batch_size = <span class="built_in">min</span>(<span class="number">10</span>, train_labels.shape[<span class="number">0</span>])</span><br><span class="line">    train_iter = load_array((train_features, train_labels.reshape(-<span class="number">1</span>,<span class="number">1</span>)),batch_size)</span><br><span class="line">    test_iter = load_array((test_features, test_labels.reshape(-<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                               batch_size, is_train=<span class="literal">False</span>)</span><br><span class="line">    trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line">    animator = Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">                            xlim=[<span class="number">1</span>, num_epochs], ylim=[<span class="number">1e-3</span>, <span class="number">1e2</span>],</span><br><span class="line">                            legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_epoch_ch3(net, train_iter, loss, trainer)</span><br><span class="line">        <span class="keyword">if</span> epoch == <span class="number">0</span> <span class="keyword">or</span> (epoch + <span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>, (evaluate_loss(net, train_iter, loss),</span><br><span class="line">                                     evaluate_loss(net, test_iter, loss)))</span><br><span class="line">    animator.show()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;weight:&#x27;</span>, net[<span class="number">0</span>].weight.data.numpy())</span><br></pre></td></tr></table></figure><h4 id="三阶多项式函数拟合-正常"><a href="#三阶多项式函数拟合-正常" class="headerlink" title="三阶多项式函数拟合(正常)"></a>三阶多项式函数拟合(正常)</h4><p>首先使用三阶多项式函数，它与数据生成函数的阶数相同，结果表明，该模型能有效降低训练损失和测试损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从多项式特征中选择前4个维度，即1,x,x^2/2!,x^3/3!</span></span><br><span class="line">train(poly_features[:n_train, :<span class="number">4</span>], poly_features[n_train:, :<span class="number">4</span>],</span><br><span class="line">      labels[:n_train], labels[n_train:])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weight: [[ 5.0210333  1.2359931 -3.4435396  5.543001 ]]</span><br></pre></td></tr></table></figure><p>学习到的模型参数也接近真实值$w &#x3D; [5, 1.2, -3.4, 5.6]$</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019171739585.png" alt="image-20251019171739585" style="zoom: 67%;" /><h4 id="线性函数拟合-欠拟合"><a href="#线性函数拟合-欠拟合" class="headerlink" title="线性函数拟合(欠拟合)"></a>线性函数拟合(欠拟合)</h4><p>线性函数拟合，减少该模型的训练损失相对困难</p><p>当用来拟合非线性模式(如这里的三阶多项式函数)时，线性模型容易欠拟合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从多项式特征中选择前2个维度，即1和x</span></span><br><span class="line">train(poly_features[:n_train, :<span class="number">2</span>], poly_features[n_train:, :<span class="number">2</span>],</span><br><span class="line">      labels[:n_train], labels[n_train:])</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019171828526.png" alt="image-20251019171828526" style="zoom: 67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weight: [[3.1353095 5.6418805]]</span><br></pre></td></tr></table></figure><h4 id="高阶多项式函数拟合-过拟合"><a href="#高阶多项式函数拟合-过拟合" class="headerlink" title="高阶多项式函数拟合(过拟合)"></a>高阶多项式函数拟合(过拟合)</h4><p>在这种情况下，没有足够的数据用于学到高阶系数应该具有接近于零的值</p><p>虽然训练损失可以有效地降低，但测试损失仍然很高，结果表明，复杂模型对数据造成了过拟合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从多项式特征中选取所有维度</span></span><br><span class="line">train(poly_features[:n_train, :], poly_features[n_train:, :],</span><br><span class="line">      labels[:n_train], labels[n_train:], num_epochs=<span class="number">1500</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019171924301.png" alt="image-20251019171924301" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">weight: [[ 5.0239668e+00  1.3013747e+00 -3.4798586e+00  5.2033052e+00</span><br><span class="line">   6.0640000e-02  9.5363843e-01  4.5289594e-01 -1.0846047e-01</span><br><span class="line">  -8.1542186e-02 -2.0034861e-02  2.2041972e-01  1.5507406e-01</span><br><span class="line">   8.8916212e-02 -1.3643771e-01  1.2644988e-01  1.2815433e-02</span><br><span class="line">  -1.4033292e-01 -3.4145068e-04 -8.9307956e-02  6.5196948e-03]]</span><br></pre></td></tr></table></figure><p>可以看到训练损失和测试损失的差值比三阶的更大了，因为一开始做了阶乘归一化，而且这里的训练次数也改到了1500所以不会导致很明显的过拟合</p><h2 id="权重衰减"><a href="#权重衰减" class="headerlink" title="权重衰减"></a>权重衰减</h2><p>虽然增加训练数据量可以有效降低过拟合风险，但这往往代价高昂、耗时漫长，短期内难以实现</p><p>在数据量已接近可行上限的情况下，通常将重点转向正则化方法</p><p>在前面的多项式拟合中通过调整多项式的阶数来限制模型的容量，<font color='DarkViolet'>限制特征的数量是缓解过拟合的一种常用技术</font></p><p>在多变量情形中，多项式扩展为由多个变量的幂次乘积构成的<strong>单项式(monomials)</strong>，单项式的阶数是各变量幂次之和，例如$x_1^2 x_2$和$x_3 x_5^2$都是3次单项式</p><p>随着阶数$d$的增长，单项式的数量迅速膨胀</p><p>给定$k$个变量，阶数为$d$的项的个数为<br>$$<br>\binom{k-1+d}{k-1}&#x3D;\frac{(k-1+d)!}{d!(k-1)!}<br>$$<br>这意味着阶数的微小提升都会显著提高模型的复杂度</p><p>因此仅仅依靠限制特征数量仍可能使模型在过于简单与过于复杂之间摇摆，需要一个更精细可控的手段来调节函数的复杂性，使模型在两者之间取得平衡</p><h3 id="范数与权重衰减"><a href="#范数与权重衰减" class="headerlink" title="范数与权重衰减"></a>范数与权重衰减</h3><p>在训练参数化机器学习模型时，**权重衰减(weight decay)**是最常用的正则化方法之一，也被称为$L_2$正则化，通过约束参数向量与零的距离来控制模型复杂度，从而防止过拟合</p><p>对于线性模型$f(\mathbf{x}) &#x3D; \mathbf{w}^\top \mathbf{x}$ 希望权重向量不要过大，常见做法是在损失函数中加入权重的平方范数惩罚项，调整为最小化预测损失和惩罚项之和</p><p>通过正则化常数$\lambda$来描述这种权衡，这是一个非负超参数<br>$$<br>L(\mathbf{w}, b) + \frac{\lambda}{2}\mid\mid \mathbf{w} \mid\mid^2<br>$$<br>对于$\lambda &#x3D; 0$恢复了原来的损失函数，对于$\lambda &gt; 0$限制$\mid\mid \mathbf{w} \mid\mid^2$的大小</p><p><font color='DarkViolet'>为什么在这里使用平方范数而不是标准范数(即欧几里得距离)?</font></p><p>平方$L_2$范数保留了权重平方和的形式，使得惩罚的导数很容易计算，导数的和等于和的导数<br>$$<br>\frac{\partial}{\partial w_{i}} \frac{1}{2}\mid\mid \mathbf{w} \mid\mid^2&#x3D;\frac{\partial}{\partial w_{i}} \frac{1}{2} \sum_{j} w_{j}^{2}&#x3D;w_{i}<br>$$<br><font color='DarkViolet'>为什么使用$L_2$范数，而不是$L_1$范数</font></p><p>$L_2$正则化对应<strong>岭回归(ridge regression)算法</strong>，会对权重的较大分量施加更强惩罚，使权重在多个特征上平滑分布，从而提高模型对噪声和观测误差的稳定性</p><p>$L_1$正则化线对应<strong>套索回归(lasso regression)<strong>会将部分权重推到零，实现</strong>特征选择(feature selection)</strong></p><p>两者都能抑制过拟合，但$L_2$更适合连续平滑的参数调整，$L_1$更适合产生稀疏解</p><p>$L_2$正则化回归的小批量随机梯度下降更新如下式<br>$$<br>\begin{aligned}<br>\mathbf{w} &amp; \leftarrow \left(1- \eta\lambda \right) \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right).<br>\end{aligned}<br>$$<br>权重衰减+普通梯度下降，<font color='Violetred'>通常网络输出层的偏置项不会被正则化</font></p><h3 id="高维线性回归"><a href="#高维线性回归" class="headerlink" title="高维线性回归"></a>高维线性回归</h3><p>通过一个简单的例子来演示权重衰减，生成一些数据：</p><p>$$<br>y &#x3D; 0.05 + \sum_{i &#x3D; 1}^d 0.01 x_i + \epsilon \text{ where }<br>\epsilon \sim \mathcal{N}(0, 0.01^2).<br>$$<br>选择标签是关于输入的线性函数，标签同时被均值为0，标准差为0.01高斯噪声破坏</p><p>为了使过拟合的效果更加明显，可以将问题的维数增加到$d &#x3D; 200$，并使用一个只包含20个样本的小训练集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w, b, num_examples</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成y=Xw+b+噪声&quot;&quot;&quot;</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w)))</span><br><span class="line">    y = torch.matmul(X, w) + b </span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)</span><br><span class="line">    <span class="keyword">return</span> X, y.reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">n_train, n_test, num_inputs, batch_size = <span class="number">20</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">5</span></span><br><span class="line">true_w, true_b = torch.ones((num_inputs, <span class="number">1</span>)) * <span class="number">0.01</span>, <span class="number">0.05</span></span><br><span class="line">train_data = synthetic_data(true_w, true_b, n_train)</span><br><span class="line">train_iter = load_array(train_data, batch_size)</span><br><span class="line">test_data = synthetic_data(true_w, true_b, n_test)</span><br><span class="line">test_iter = load_array(test_data, batch_size, is_train=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><h4 id="初始化模型参数-1"><a href="#初始化模型参数-1" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_params</span>():</span><br><span class="line">    w = torch.normal(<span class="number">0</span>, <span class="number">1</span>, size=(num_inputs, <span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">    b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> [w, b]</span><br></pre></td></tr></table></figure><h4 id="定义L2范数惩罚"><a href="#定义L2范数惩罚" class="headerlink" title="定义L2范数惩罚"></a>定义L2范数惩罚</h4><p>最方便的方法是对所有项求平方后并将它们求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">l2_penalty</span>(<span class="params">w</span>):</span><br><span class="line">    <span class="keyword">return</span> torch.<span class="built_in">sum</span>(w.<span class="built_in">pow</span>(<span class="number">2</span>)) / <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="定义训练代码"><a href="#定义训练代码" class="headerlink" title="定义训练代码"></a>定义训练代码</h4><p>唯一的变化是损失加上惩罚项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">lambd</span>):</span><br><span class="line">    w, b = init_params()</span><br><span class="line">    net, loss = <span class="keyword">lambda</span> X: linreg(X, w, b), squared_loss</span><br><span class="line">    num_epochs, lr = <span class="number">100</span>, <span class="number">0.003</span></span><br><span class="line">    animator = Animator(xlabel=<span class="string">&#x27;epochs&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">                            xlim=[<span class="number">5</span>, num_epochs], legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            <span class="comment"># 增加了L2范数惩罚项，</span></span><br><span class="line">            <span class="comment"># 广播机制使l2_penalty(w)成为一个长度为batch_size的向量</span></span><br><span class="line">            l = loss(net(X), y) + lambd * l2_penalty(w)</span><br><span class="line">            l.<span class="built_in">sum</span>().backward()</span><br><span class="line">            sgd([w, b], lr, batch_size)</span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>, (evaluate_loss(net, train_iter, loss),</span><br><span class="line">                                     evaluate_loss(net, test_iter, loss)))</span><br><span class="line">    animator.show()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;w的L2范数是：&#x27;</span>, torch.norm(w).item())</span><br></pre></td></tr></table></figure><h4 id="无正则化"><a href="#无正则化" class="headerlink" title="无正则化"></a>无正则化</h4><p>用<code>lambd = 0</code>禁用权重衰减后运行这个代码，这里训练误差有了减少，但测试误差没有减少，这意味着出现了严重的过拟合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train(lambd=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019173903702.png" alt="image-20251019173903702" style="zoom: 67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w的L2范数是： 14.787172317504883</span><br></pre></td></tr></table></figure><h4 id="权重衰减-1"><a href="#权重衰减-1" class="headerlink" title="权重衰减"></a>权重衰减</h4><p>使用权重衰减来运行代码，在这里训练误差增大，但测试误差减小，这正是期望从正则化中得到的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train(lambd=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019173959981.png" alt="image-20251019173959981" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w的L2范数是： 0.354495644569397</span><br></pre></td></tr></table></figure><p>能看出如果不加权重衰减很容易陷入过拟合</p><h3 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h3><p>深度学习框架将权重衰减直接集成到优化算法中，使其能够与任意损失函数方便结合</p><p>在实例化优化器时只需通过 <code>weight_decay</code> 参数即可指定权重衰减系数</p><p>在 PyTorch 中，默认情况下优化器会同时对权重参数和偏置参数施加衰减，这里只为权重设置了<code>weight_decay</code>，所以偏置参数不会衰减</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_concise</span>(<span class="params">wd</span>):</span><br><span class="line">    net = nn.Sequential(nn.Linear(num_inputs,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> net.parameters():</span><br><span class="line">        param.data.normal_()</span><br><span class="line">    loss = nn.MSELoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    num_epochs, lr = <span class="number">100</span>, <span class="number">0.003</span></span><br><span class="line">    trainer = torch.optim.SGD([</span><br><span class="line">        &#123;<span class="string">&quot;params&quot;</span>:net[<span class="number">0</span>].weight, <span class="string">&#x27;weight_decay&#x27;</span>:wd&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;params&quot;</span>:net[<span class="number">0</span>].bias&#125;], lr = lr)</span><br><span class="line">    animator = Animator(xlabel=<span class="string">&#x27;epochs&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>,yscale=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">                        xlim=[<span class="number">5</span>, num_epochs], legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            trainer.zero_grad()</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            l.mean().backward()</span><br><span class="line">            trainer.step()</span><br><span class="line">        <span class="keyword">if</span>(epoch + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>,</span><br><span class="line">                         (evaluate_loss(net, train_iter, loss),</span><br><span class="line">                          evaluate_loss(net, test_iter, loss)))</span><br><span class="line">    animator.show()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;w 的范数:&quot;</span>, net[<span class="number">0</span>].weight.norm().item())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_concise(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251018202634148.png" alt="image-20251018202634148" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w 的范数: 13.793038368225098</span><br></pre></td></tr></table></figure><p>结果和从零开始实现权重衰减时的图相同，然而它们运行得更快，更容易实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_concise(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251018202811058.png" alt="image-20251018202811058" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w 的范数: 0.3899060785770416</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>正则化是处理过拟合的常用方法：在训练集的损失函数中加入惩罚项，以降低学习到的模型的复杂度</li><li>保持模型简单的一个特别的选择是使用$L_2$惩罚的权重衰减。这会导致学习算法更新步骤中的权重衰减</li><li>在同一训练代码实现中，不同的参数集可以有不同的更新行为</li></ul><h3 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>训练与测试精度随 λ 变化的趋势</p><p>测试误差先下降后上升，呈 U 形曲线</p><p>正则化太弱 → 过拟合；正则化太强 → 欠拟合</p></li><li><p>使用验证集来找到$\lambda$最佳值。它真的是最优值吗？这有关系吗？</p><p>是相对于这个训练集和验证集的最优值，会根据数据集大小发生变化</p></li><li><p>如果使用$L_1$正则化作为选择的惩罚，那么代码如何修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">l1_penalty</span>(<span class="params">w</span>):</span><br><span class="line">    <span class="keyword">return</span> torch.<span class="built_in">sum</span>(torch.<span class="built_in">abs</span>(w))</span><br><span class="line">    ...</span><br><span class="line">    trainer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">    ...</span><br><span class="line">    l = l.mean() + lambd * l1_penalty(net[<span class="number">0</span>].weight)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ol><h2 id="暂退法Dropout"><a href="#暂退法Dropout" class="headerlink" title="暂退法Dropout"></a>暂退法Dropout</h2><h3 id="扰动的稳健性"><a href="#扰动的稳健性" class="headerlink" title="扰动的稳健性"></a>扰动的稳健性</h3><p>一个“好”的预测模型，不仅要在训练数据上表现良好，更重要的是能在未知数据上保持较高的准确度。经典的泛化理论认为，为了缩小训练和测试性能之间的差距，应追求模型的简单性</p><p>简单性可以通过多种形式体现：<font color='DarkViolet'>较低的模型维度、更小的参数范数，或是更平滑的函数行为</font></p><p>平滑性意味着模型对输入的微小变化不敏感——在图像分类中，轻微的像素噪声不应影响预测结果</p><p>1995年，克里斯托弗·毕晓普(Christopher Bishop)证明了在训练过程中向输入添加高斯噪声，与Tikhonov正则化(即$L_2$正则化)在数学上是等价的，这说明函数对输入噪声具有鲁棒性，本质上也是在约束其平滑性</p><p>2014年，斯里瓦斯塔瓦等人将这一思想推广到神经网络的内部层，提出在训练时向每一层的输出中注入随机噪声，以增强输入–输出映射的平滑性，这便是<strong>暂退法(dropout)</strong>，通过在前向传播时随机丢弃部分神经元的激活值来实现正则化，这已经成为训练神经网络的常用技术</p><p>为了避免引入偏差，dropout采用无偏噪声注入方式，每个中间激活值$h$以暂退概率$p$被置零，保留下来的放大为$h&#x2F;(1-p)$，$h’$表示为<br>$$<br>\begin{split}\begin{aligned}<br>h’ &#x3D;<br>\begin{cases}<br>    0 &amp; \text{ 概率为 } p \\<br>    \frac{h}{1-p} &amp; \text{ 其他情况}<br>\end{cases}<br>\end{aligned}\end{split}<br>$$<br>这样保证其期望值不变$E[h’] &#x3D; h$</p><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p>之前的多层感知机中带有1个隐藏层和5个隐藏单元，将暂退法应用到隐藏层，以$p$的概率将隐藏单元置为零，相当于每次训练时使用原网络的一个子网络</p><p>使得输出层的计算不能过度依赖于$h_1, \ldots, h_5$的任何一个元素，提高模型的泛化性</p><img src="https://zh.d2l.ai/_images/dropout2.svg" style="zoom:80%;" /><p>测试阶段不使用dropout，也无需缩放；若模型在多次随机遮盖后仍能给出一致预测，说明其具有良好的稳定性与鲁棒性</p><h3 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h3><p>要实现单层的暂退法函数，可以从均匀分布$U[0, 1]$中生成与该层神经元维度相同的随机张量，保留其中大于丢弃概率$p$的元素，其余置零</p><p><code>dropout_layer</code> 函数：以<code>dropout</code>的概率丢弃张量输入<code>X</code>中的元素，再将剩余部分除以<code>1.0-dropout</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dropout_layer</span>(<span class="params">X, dropout</span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt;= dropout &lt;= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 在本情况中，所有元素都被丢弃</span></span><br><span class="line">    <span class="keyword">if</span> dropout == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> torch.zeros_like(X)</span><br><span class="line">    <span class="comment"># 在本情况中，所有元素都被保留</span></span><br><span class="line">    <span class="keyword">if</span> dropout == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line">    mask = (torch.rand(X.shape) &gt; dropout).<span class="built_in">float</span>() <span class="comment"># 均匀分布丢弃</span></span><br><span class="line">    <span class="keyword">return</span> mask * X / (<span class="number">1.0</span> - dropout)</span><br></pre></td></tr></table></figure><p>将输入<code>X</code>通过暂退法操作，暂退概率分别为0、0.5和1来测试<code>dropout_layer</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>).reshape((<span class="number">2</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"><span class="built_in">print</span>(dropout_layer(X, <span class="number">0.</span>))</span><br><span class="line"><span class="built_in">print</span>(dropout_layer(X, <span class="number">0.5</span>))</span><br><span class="line"><span class="built_in">print</span>(dropout_layer(X, <span class="number">1.</span>))</span><br></pre></td></tr></table></figure><h4 id="定义模型参数"><a href="#定义模型参数" class="headerlink" title="定义模型参数"></a>定义模型参数</h4><p>同样使用Fashion-MNIST数据集，定义具有两个隐藏层的多层感知机，每个隐藏层包含256个单元</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num_inputs, num_outputs, num_hiddens1, num_hiddens2 = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span>, <span class="number">256</span></span><br></pre></td></tr></table></figure><h4 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h4><p>在网络中，通常在每个隐藏层的激活函数之后应用暂退法，并为不同层设置各自的暂退概率</p><p>通常在靠近输入层的位置使用较小的暂退概率，而在更深层使用较大的暂退概率，以在保留关键信息的同时增强模型的正则化效果</p><p>下面的模型将第一个和第二个隐藏层的暂退概率分别设置为0.2和0.5，并且暂退法只在训练期间有效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_inputs, num_outputs, num_hiddens1, num_hiddens2, is_training = <span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, <span class="variable language_">self</span>).__init__() <span class="comment"># 调用 父类 nn.Module 的构造函数</span></span><br><span class="line">        <span class="variable language_">self</span>.num_inputs = num_inputs</span><br><span class="line">        <span class="variable language_">self</span>.training = is_training</span><br><span class="line">        <span class="variable language_">self</span>.lin1 = nn.Linear(num_inputs, num_hiddens1)</span><br><span class="line">        <span class="variable language_">self</span>.lin2 = nn.Linear(num_hiddens1, num_hiddens2)</span><br><span class="line">        <span class="variable language_">self</span>.lin3 = nn.Linear(num_hiddens2, num_outputs)</span><br><span class="line">        <span class="variable language_">self</span>.relu = nn.ReLU()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        H1 = <span class="variable language_">self</span>.relu(<span class="variable language_">self</span>.lin1(X.reshape(-<span class="number">1</span>, <span class="variable language_">self</span>.num_inputs)))</span><br><span class="line">        <span class="comment"># 只有在训练模型时才使用dropout</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.training == <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 在第一个全连接层之后添加一个dropout层</span></span><br><span class="line">            H1 = dropout_layer(H1, dropout1)</span><br><span class="line">        H2 = <span class="variable language_">self</span>.relu(<span class="variable language_">self</span>.lin2(H1))</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.training == <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 在第二个全连接层之后添加一个dropout层</span></span><br><span class="line">            H2 = dropout_layer(H2, dropout2)</span><br><span class="line">        out = <span class="variable language_">self</span>.lin3(H2)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">dropout1, dropout2 = <span class="number">0.2</span>, <span class="number">0.5</span></span><br><span class="line">net = Net(num_inputs, num_outputs, num_hiddens1, num_hiddens2)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入层 → 全连接层1 → ReLU → Dropout1 → 全连接层2 → ReLU → Dropout2 → 输出层</span><br></pre></td></tr></table></figure><h4 id="训练和测试-1"><a href="#训练和测试-1" class="headerlink" title="训练和测试"></a>训练和测试</h4><p>类似于前面描述的多层感知机训练和测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, lr, batch_size = <span class="number">10</span>, <span class="number">0.5</span>, <span class="number">256</span></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size)</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr = lr)</span><br><span class="line">train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Epoch  1/10: loss=0.8763, train_acc=0.672, test_acc=0.768</span><br><span class="line">Epoch  2/10: loss=0.5306, train_acc=0.805, test_acc=0.801</span><br><span class="line">Epoch  3/10: loss=0.4581, train_acc=0.833, test_acc=0.835</span><br><span class="line">Epoch  4/10: loss=0.4245, train_acc=0.846, test_acc=0.846</span><br><span class="line">Epoch  5/10: loss=0.3993, train_acc=0.854, test_acc=0.813</span><br><span class="line">Epoch  6/10: loss=0.3813, train_acc=0.861, test_acc=0.859</span><br><span class="line">Epoch  7/10: loss=0.3660, train_acc=0.864, test_acc=0.846</span><br><span class="line">Epoch  8/10: loss=0.3554, train_acc=0.870, test_acc=0.841</span><br><span class="line">Epoch  9/10: loss=0.3444, train_acc=0.873, test_acc=0.864</span><br><span class="line">Epoch 10/10: loss=0.3317, train_acc=0.877, test_acc=0.840</span><br><span class="line">Final loss 0.332, train acc 0.877, test acc 0.840</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019193516180.png" alt="image-20251019193516180" style="zoom:67%;" /><h3 id="简洁实现-1"><a href="#简洁实现-1" class="headerlink" title="简洁实现"></a>简洁实现</h3><p>对于深度学习框架，只需在每个全连接层之后添加一个<code>Dropout</code>层，将暂退概率作为唯一的参数传递给它的构造函数</p><p>在训练时，<code>Dropout</code>层将根据指定的暂退概率随机丢弃上一层的输出(相当于下一层的输入)</p><p>在测试时，<code>Dropout</code>层仅传递数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dropout1, dropout2 = <span class="number">0.2</span>, <span class="number">0.5</span></span><br><span class="line">num_inputs, num_outputs, num_hiddens1, num_hiddens2 = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span>, <span class="number">256</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(num_inputs, num_hiddens1),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    <span class="comment"># 在第一个全连接层之后添加一个dropout层</span></span><br><span class="line">    nn.Dropout(dropout1),</span><br><span class="line">    nn.Linear(num_hiddens1, num_hiddens2),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    <span class="comment"># 在第二个全连接层之后添加一个dropout层</span></span><br><span class="line">    nn.Dropout(dropout2),</span><br><span class="line">    nn.Linear(num_hiddens2, num_outputs)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line">net.apply(init_weights)</span><br></pre></td></tr></table></figure><p>对模型进行训练和测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dropout1, dropout2 = <span class="number">0.2</span>, <span class="number">0.5</span></span><br><span class="line">num_inputs, num_outputs, num_hiddens1, num_hiddens2 = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span>, <span class="number">256</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(num_inputs, num_hiddens1),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    <span class="comment"># 在第一个全连接层之后添加一个dropout层</span></span><br><span class="line">    nn.Dropout(dropout1),</span><br><span class="line">    nn.Linear(num_hiddens1, num_hiddens2),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    <span class="comment"># 在第二个全连接层之后添加一个dropout层</span></span><br><span class="line">    nn.Dropout(dropout2),</span><br><span class="line">    nn.Linear(num_hiddens2, num_outputs)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line">net.apply(init_weights)</span><br><span class="line"></span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Epoch  1/10: loss=1.1567, train_acc=0.555, test_acc=0.721</span><br><span class="line">Epoch  2/10: loss=0.5841, train_acc=0.785, test_acc=0.797</span><br><span class="line">Epoch  3/10: loss=0.4915, train_acc=0.820, test_acc=0.750</span><br><span class="line">Epoch  4/10: loss=0.4529, train_acc=0.834, test_acc=0.831</span><br><span class="line">Epoch  5/10: loss=0.4177, train_acc=0.848, test_acc=0.847</span><br><span class="line">Epoch  6/10: loss=0.3963, train_acc=0.855, test_acc=0.847</span><br><span class="line">Epoch  7/10: loss=0.3803, train_acc=0.860, test_acc=0.857</span><br><span class="line">Epoch  8/10: loss=0.3637, train_acc=0.865, test_acc=0.861</span><br><span class="line">Epoch  9/10: loss=0.3565, train_acc=0.870, test_acc=0.859</span><br><span class="line">Epoch 10/10: loss=0.3455, train_acc=0.873, test_acc=0.856</span><br><span class="line">Final loss 0.346, train acc 0.873, test acc 0.856</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251019194335420.png" alt="image-20251019194335420" style="zoom: 67%;" /><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>暂退法在前向传播过程中，计算每一内部层的同时丢弃一些神经元</li><li>暂退法可以避免过拟合，它通常与控制权重向量的维数和大小结合使用的</li><li>暂退法将活性值替换为具有相同期望值的随机变量</li><li>暂退法仅在训练期间使用</li></ul><p>对比一下Dropout与权重衰减</p><table><thead><tr><th>正则化方式</th><th>控制复杂度的方式</th><th>直观效果</th><th>正则对象</th></tr></thead><tbody><tr><td>权重衰减</td><td>直接惩罚权重的$L_2$范数<br />抑制参数变大</td><td>让模型“更平滑”<br />权重分布更均匀</td><td>参数空间的正则化</td></tr><tr><td>暂退法</td><td>训练时随机屏蔽部分神经元输出<br />防止神经元共适应</td><td>让模型“更稀疏”<br />逼迫网络学习多种子结构</td><td>结构空间的正则化</td></tr></tbody></table><p>二者都能降低模型方差、增强泛化，但机制互补</p><p>同时使用暂退法和权重衰减不会互相抵消，但会出现正则化叠加的边际效应递减，反而可能导致欠拟合或性能下降</p><p>一般根据任务类型选择其一：</p><ul><li>Dropout → 对高维输入(如图像、文本)特别有效</li><li>$L_2$ → 对权重尺度敏感的任务(如回归或线性模型)常用</li></ul><h3 id="思考题-3"><a href="#思考题-3" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>如果将暂退法应用到权重矩阵的各个权重，而不是激活值，会发生什么？</p><p>如果把 Dropout 施加到权重矩阵上，模型会变成类似DropConnect(Wan et al., 2013)的形式，随机屏蔽神经元连接，而非神经元输出，它理论上更强，但训练更噪、更慢、不稳定</p></li></ol><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>已经学习了如何用小批量随机梯度下降训练模型，但实现过程中只考虑了通过前向传播(forward propagation)所涉及的计算，在计算梯度时，只调用了深度学习框架提供的反向传播函数，而不知其所以然</p><p>梯度的自动计算(自动微分)大大简化了深度学习算法的实现，现在来探讨反向传播的细节</p><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>前向传播(forward propagation或forward pass)指的是按顺序(从输入层到输出层)计算和存储神经网络中每层的结果</p><p>假设输入样本是$\mathbf{x}\in \mathbb{R}^d$，并且隐藏层不包括偏置项，这里的中间变量是<br>$$<br>\mathbf{z}&#x3D; \mathbf{W}^{(1)} \mathbf{x}<br>$$<br>其中$\mathbf{W}^{(1)} \in \mathbb{R}^{h \times d}$是隐藏层的权重参数，将中间变量$\mathbf{z}\in \mathbb{R}^h$通过激活函数后，得到长度为$h$的隐藏激活向量<br>$$<br>\mathbf{h}&#x3D; \phi (\mathbf{z})<br>$$<br>假设输出层的参数只有权重$\mathbf{W}^{(2)} \in \mathbb{R}^{q \times h}$，可以得到输出层变量，它是一个长度为$q$的向量<br>$$<br>\mathbf{o}&#x3D; \mathbf{W}^{(2)} \mathbf{h}<br>$$<br>假设损失函数为$l$，样本标签为$y$，单个数据样本的损失项<br>$$<br>L &#x3D; l(\mathbf{o}, y)<br>$$<br>根据$L_2$正则化的定义，给定超参数$\lambda$，正则化项为<br>$$<br>s &#x3D; \frac{\lambda}{2} \left(\mid\mid\mathbf{W}^{(1)}\mid\mid_F^2 + \mid\mid\mathbf{W}^{(2)}\mid\mid_F^2\right),<br>$$<br>模型在给定数据样本上的正则化损失为<br>$$<br>J &#x3D; L + s<br>$$<br>将$J$称为目标函数</p><h3 id="前向传播计算图"><a href="#前向传播计算图" class="headerlink" title="前向传播计算图"></a>前向传播计算图</h3><p>绘制计算图有助于可视化计算中操作符和变量的依赖关系</p><p>与上述简单网络相对应的计算图</p><p><img src="https://zh.d2l.ai/_images/forward.svg"></p><p>其中正方形表示变量，圆圈表示操作符</p><p>左下角表示输入，右上角表示输出</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>**反向传播(backward propagation或backpropagation)**指的是计算神经网络参数梯度的方法</p><p>该方法根据微积分中的链式规则，按相反的顺序从输出层到输入层遍历网络</p><p>算法存储了计算某些参数梯度时所需的任何中间变量(偏导数)</p><p>根据链式法则得到<br>$$<br>\begin{aligned}\frac{\partial J}{\partial \mathbf{W}^{(1)}}<br>&#x3D; \text{prod}\left(\frac{\partial J}{\partial \mathbf{z}}, \frac{\partial \mathbf{z}}{\partial \mathbf{W}^{(1)}}\right) + \text{prod}\left(\frac{\partial J}{\partial s}, \frac{\partial s}{\partial \mathbf{W}^{(1)}}\right)<br>&#x3D; \frac{\partial J}{\partial \mathbf{z}} \mathbf{x}^\top + \lambda \mathbf{W}^{(1)}\\<br>\frac{\partial J}{\partial \mathbf{W}^{(2)}}&#x3D; \text{prod}\left(\frac{\partial J}{\partial \mathbf{o}}, \frac{\partial \mathbf{o}}{\partial \mathbf{W}^{(2)}}\right) + \text{prod}\left(\frac{\partial J}{\partial s}, \frac{\partial s}{\partial \mathbf{W}^{(2)}}\right)&#x3D; \frac{\partial J}{\partial \mathbf{o}} \mathbf{h}^\top + \lambda \mathbf{W}^{(2)} \end{aligned}<br>$$</p><h3 id="训练神经网络"><a href="#训练神经网络" class="headerlink" title="训练神经网络"></a>训练神经网络</h3><p>在训练神经网络时，前向传播和反向传播相互依赖</p><p>以上述简单网络为例</p><p>前向传播期间计算正则项取决于模型参数$\mathbf{W}^{(1)}$和$\mathbf{W}^{(2)}$的当前值，是由优化算法根据最近迭代的反向传播给出的</p><p>反向传播期间参数的梯度计算，取决于由前向传播给出的隐藏变量$\mathbf{h}$的当前值</p><h2 id="稳定性和初始化"><a href="#稳定性和初始化" class="headerlink" title="稳定性和初始化"></a>稳定性和初始化</h2><p>初始化方案的选择在神经网络学习中起着举足轻重的作用，它对保持数值稳定性至关重要</p><p>选择哪个函数以及如何初始化参数可以决定优化算法收敛的速度有多快</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>考虑一个具有$L$层、输入$\mathbf{x}$和输出$\mathbf{o}$的深层网络，如果所有隐藏变量和输入都是向量，可以将$\mathbf{o}$关于任何一组参数$\mathbf{W}^{(l)}$的梯度写为下式<br>$$<br>\partial_{\mathbf{W}^{(l)}} \mathbf{o} &#x3D; \underbrace{\partial_{\mathbf{h}^{(L-1)}} \mathbf{h}^{(L)}}<em>{ \mathbf{M}^{(L)} \stackrel{\mathrm{def}}{&#x3D;}} \cdot \ldots \cdot \underbrace{\partial</em>{\mathbf{h}^{(l)}} \mathbf{h}^{(l+1)}}<em>{ \mathbf{M}^{(l+1)} \stackrel{\mathrm{def}}{&#x3D;}} \underbrace{\partial</em>{\mathbf{W}^{(l)}} \mathbf{h}^{(l)}}_{ \mathbf{v}^{(l)} \stackrel{\mathrm{def}}{&#x3D;}}.<br>$$<br>该梯度是$L-l$个矩阵$\mathbf{M}^{(L)} \cdot \ldots \cdot \mathbf{M}^{(l+1)}$与梯度向量$\mathbf{v}^{(l)}$的乘积，容易受到数值上下溢问题的影响</p><p>不稳定梯度也威胁到优化算法的稳定性</p><ul><li>梯度爆炸(gradient exploding)问题：参数更新过大，破坏了模型的稳定收敛</li><li>梯度消失(gradient vanishing)问题：参数更新过小，在每次更新时几乎不会移动，导致模型无法学习</li></ul><p>神经网络在参数化中存在<strong>对称性问题</strong>，隐藏层的多个单元可以通过权重重排获得相同的函数</p><p>若所有隐藏单元用相同参数初始化，它们在前向传播中输出相同激活，反向传播中获得相同梯度，训练过程无法打破这种对称性，网络退化为仅一个有效单元，表达能力大幅下降</p><p>虽然梯度下降无法打破这种对称性，但暂退法可通过随机扰动有效缓解这一问题</p><h3 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h3><p>解决上述问题的一种方法是进行参数初始化，适当的正则化也可以进一步提高稳定性</p><h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p>如果不指定初始化方法，框架将使用默认的随机初始化方法，对于中等难度的问题，这种方法通常很有效</p><p>根据不同层的类型，默认初始化方式也不相同</p><table><thead><tr><th>层类型</th><th>默认初始化</th><th>说明</th></tr></thead><tbody><tr><td><code>nn.Linear</code> <code>nn.Conv2d</code></td><td>Kaiming Uniform</td><td>适合 ReLU 系激活</td></tr><tr><td><code>nn.BatchNorm</code></td><td>权重&#x3D;1，偏置&#x3D;0</td><td>保持尺度一致</td></tr><tr><td><code>nn.Embedding</code></td><td>均匀分布 U(-1, 1)</td><td>向量随机初始化</td></tr><tr><td><code>nn.LSTM</code> <code>nn.GRU</code></td><td>Xavier Uniform(Glorot)</td><td>平衡输入与输出方差</td></tr></tbody></table><h4 id="Xavier初始化"><a href="#Xavier初始化" class="headerlink" title="Xavier初始化"></a>Xavier初始化</h4><p><strong>Xavier(Glorot)初始化</strong>是深度学习中最早、最经典的权重初始化方法之一</p><p>核心思想：让每层的输入和输出方差尽量相同，从而保持信号在网络中传播时的尺度稳定</p><p>为了让前向传播和反向传播都稳定<br>$$<br>Var(w)&#x3D;\frac{2}{n_{in}+n_{out}}<br>$$<br>$n_{in}$：该层输入单元数</p><p>$n_{out}$：该层输出单元数</p><p>使得输入信号在传播到下一层时既不会放大也不会衰减</p><p>提供了两种分布形式：均匀分布(Pytorch默认)和正态分布<br>$$<br>w \sim U\left(-\sqrt{\frac{6}{n_{in}+n_{out}}}, \sqrt{\frac{6}{n_{in}+n_{out}}}\right)<br>$$<br>尽管在其数学推理中“不存在非线性”的假设在神经网络中很容易被违反，但Xavier初始化方法在实践中被证明是有效的</p><h4 id="Kaiming初始化"><a href="#Kaiming初始化" class="headerlink" title="Kaiming初始化"></a>Kaiming初始化</h4><p><strong>Kaiming(He)初始化</strong>是一种专门为 ReLU 及其变体设计的权重初始化方法</p><p>核心思想：让每层的输出方差与输入方差保持一致，使信号在深层网络中既不过强也不过弱</p><p>如果输入是独立的零均值变量，而 ReLU 会把一半的输入变为 0，为了维持方差恒定需要满足<br>$$<br>Var(w)&#x3D;\frac{2}{n_{in}}<br>$$<br>提供了两种分布形式：均匀分布(Pytorch默认)和正态分布<br>$$<br>w \sim U\left(-\sqrt{\frac{6}{n_{i n}}}, \sqrt{\frac{6}{n_{i n}}}\right)<br>$$</p><h3 id="对称性问题"><a href="#对称性问题" class="headerlink" title="对称性问题"></a>对称性问题</h3><p>神经网络中的“对称性”往往意味着“参数冗余”</p><p>若多个单元、通道、时间步或模块在初始时完全相同，它们在训练中将始终保持相同，无法学习到互补特征</p><p>通过随机初始化、正则化或结构差异来打破对称性，是让网络具备表达力与泛化能力的关键</p><table><thead><tr><th>网络类型</th><th>对称性来源</th><th>后果</th><th>打破方法</th></tr></thead><tbody><tr><td>MLP</td><td>隐藏单元可交换</td><td>单元退化为相同功能</td><td>随机初始化、dropout</td></tr><tr><td>CNN</td><td>通道交换</td><td>特征图重复</td><td>随机初始化、BN</td></tr><tr><td>RNN&#x2F;LSTM</td><td>时间步相同</td><td>无时间差异</td><td>随机初始化、输入扰动</td></tr><tr><td>Transformer</td><td>注意力头可交换</td><td>多头退化为单头</td><td>独立头部初始化</td></tr><tr><td>Autoencoder</td><td>编解码镜像</td><td>恒等映射</td><td>独立参数、噪声</td></tr><tr><td>GAN</td><td>G&#x2F;D 对称博弈</td><td>模式坍塌</td><td>不同学习率、G&#x2F;D异步更新</td></tr></tbody></table><h2 id="分布偏移"><a href="#分布偏移" class="headerlink" title="分布偏移"></a>分布偏移</h2><p>在理想条件下，通常假设训练集和测试集都是从同一分布独立采样得到的(独立同分布)</p><p>但现实中，这个假设几乎总是被打破，于是模型在训练环境中表现很好，却在新环境下表现糟糕，这就是<strong>分布偏移（distribution shift）</strong></p><p>当这种分布差异是由外部环境变化（如天气、地域、设备差异等）导致的，也称之为<strong>环境偏移（environment shift）</strong></p><h3 id="分布偏移类型"><a href="#分布偏移类型" class="headerlink" title="分布偏移类型"></a>分布偏移类型</h3><h4 id="协变量偏移"><a href="#协变量偏移" class="headerlink" title="协变量偏移"></a>协变量偏移</h4><p>在不同分布偏移中，**协变量偏移（covariate shift）**可能是最为广泛研究的</p><p>假设：</p><ul><li>输入数据的分布$P(\mathbf{x})$改变了</li><li>但输入与标签之间的映射关系$$P(y\mid \mathbf{x})$$保持不变</li></ul><p>比如猫狗分类问题，训练使用真实拍摄图片，测试使用卡通图片</p><h4 id="标签偏移"><a href="#标签偏移" class="headerlink" title="标签偏移"></a>标签偏移</h4><p>**标签偏移（label shift）**描述了与协变量偏移相反的问题</p><p>假设：</p><ul><li>各类样本的比例$P(y)$发生变化</li><li>同一类别的样本外观（或特征分布）$$P(\mathbf{x} \mid y)$$不变</li></ul><p>当认为$y$导致$\mathbf{x}$时，标签偏移是一个合理的假设，例如预测患者的疾病，可能根据症状来判断</p><h4 id="概念偏移"><a href="#概念偏移" class="headerlink" title="概念偏移"></a>概念偏移</h4><p><strong>概念偏移&#x2F;条件偏移</strong>：$P(\mathbf{x})$和$P(y)$可能没发生改变，但$P(y\mid \mathbf x)$发生改变了</p><p>输入与标签的关系变了</p><p>比如不同地区对一个词的解释是不一样的，不同国家的交通指示不一样</p><h2 id="学习问题的分类法"><a href="#学习问题的分类法" class="headerlink" title="学习问题的分类法"></a>学习问题的分类法</h2><h3 id="批量学习"><a href="#批量学习" class="headerlink" title="批量学习"></a>批量学习</h3><p>在**批量学习（batch learning）**中，可以访问一组训练特征和标签${(\mathbf{x}_1, y_1), \ldots, (\mathbf{x}_n, y_n)}$，使用这些特性和标签训练$f(\mathbf{x})$，然后部署此模型来对来自同一分布的新数据进行评分，基本再也不会更新</p><h3 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h3><p>除了“批量”地学习，还可以单个“在线”学习数据$(\mathbf{x}_i, y_i)$</p><p>首先观测到$\mathbf{x}_i$，得出一个估计值$f(\mathbf{x}_i)$，当做到这一点后才观测到$y_i$，根据决定会得到奖励或损失</p><p>许多实际问题都属于这一类</p><p>在**在线学习（online learning）**中有以下的循环，在这个循环中给定新的观测结果会不断地改进模型<br>$$<br>\mathrm{model} ~ f_t \longrightarrow<br>\mathrm{data} ~ \mathbf{x}_t \longrightarrow<br>\mathrm{estimate} ~ f_t(\mathbf{x}_t) \longrightarrow<br>\mathrm{observation} ~ y_t \longrightarrow<br>\mathrm{loss} ~ l(y_t, f_t(\mathbf{x}<em>t)) \longrightarrow<br>\mathrm{model} ~ f</em>{t+1}<br>$$</p><h3 id="老虎机"><a href="#老虎机" class="headerlink" title="老虎机"></a>老虎机</h3><p>**老虎机（bandits）**是上述问题的一个特例，虽然在大多数学习问题中有一个连续参数化的函数$f$，</p><p>但在一个老虎机问题中，可以采取的行动是有限的，面对多个未知收益的选择，每次只能选择一个行动并获得反馈</p><p>探索与利用之间的权衡，常见贪心算法</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>**强化学习（reinforcement learning）**强调如何基于环境而行动，以取得最大化的预期利益</p><p>国际象棋、围棋、西洋双陆棋或星际争霸都是强化学习的应用实例</p><p>类似老虎机，但是强化学习的奖励是延迟的</p><p>与监督学习的区别</p><table><thead><tr><th>维度</th><th>监督学习</th><th>强化学习</th></tr></thead><tbody><tr><td>训练数据</td><td>已知输入–输出对</td><td>通过环境交互生成</td></tr><tr><td>目标</td><td>最小化预测误差</td><td>最大化长期回报</td></tr><tr><td>反馈</td><td>即时且确定</td><td>延迟且随机</td></tr><tr><td>学习方式</td><td>离线学习</td><td>在线学习（边探索边更新）</td></tr><tr><td>典型问题</td><td>分类 &#x2F; 回归</td><td>决策 &#x2F; 控制</td></tr></tbody></table><h2 id="Kaggle实践"><a href="#Kaggle实践" class="headerlink" title="Kaggle实践"></a>Kaggle实践</h2><p>Kaggle的房价预测比赛，此数据集由Bart de Cock于2011年收集，涵盖了2006-2010年期间亚利桑那州埃姆斯市的房价，它比哈里森和鲁宾菲尔德的波士顿房价数据集要大得多，也有更多的特征</p><h3 id="下载和缓存数据集"><a href="#下载和缓存数据集" class="headerlink" title="下载和缓存数据集"></a>下载和缓存数据集</h3><p>首先建立字典<code>DATA_HUB</code>，它可以将数据集名称的字符串映射到数据集相关的二元组上，这个二元组包含数据集的url和验证文件完整性的sha-1密钥，所有类似的数据集都托管在地址为<code>DATA_URL</code>的站点上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line">DATA_HUB = <span class="built_in">dict</span>()</span><br><span class="line">DATA_URL = <span class="string">&#x27;http://d2l-data.s3-accelerate.amazonaws.com/&#x27;</span></span><br></pre></td></tr></table></figure><p><code>download</code>函数用来下载数据集，如果缓存目录中已经存在此数据集文件，并且其sha-1与存储在<code>DATA_HUB</code>中的相匹配，将使用缓存的文件，以避免重复的下载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">name, cache_dir=<span class="string">&quot;data&quot;</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载一个DATA_HUB中的文件，返回本地文件名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> name <span class="keyword">in</span> DATA_HUB, <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 不存在于 <span class="subst">&#123;DATA_HUB&#125;</span>&quot;</span></span><br><span class="line">    url, sha1_hash = DATA_HUB[name]</span><br><span class="line">    os.makedirs(cache_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    fname = os.path.join(cache_dir, url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(fname): <span class="comment"># 如果文件存在</span></span><br><span class="line">        sha1 = hashlib.sha1() <span class="comment"># 计算哈希值，验证文件是否被篡改或损坏</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = f.read(<span class="number">1048576</span>) <span class="comment"># 每次从文件中读取1MB数据</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                sha1.update(data) <span class="comment"># 把刚读到的字节块加入到哈希计算中</span></span><br><span class="line">        <span class="keyword">if</span> sha1.hexdigest() == sha1_hash:</span><br><span class="line">            <span class="keyword">return</span> fname  <span class="comment"># 如果哈希值匹配则返回缓存文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;正在从<span class="subst">&#123;url&#125;</span>下载<span class="subst">&#123;fname&#125;</span>...&#x27;</span>)</span><br><span class="line">    r = requests.get(url, stream=<span class="literal">True</span>, verify=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line">    <span class="keyword">return</span> fname <span class="comment"># 返回本地文件路径</span></span><br></pre></td></tr></table></figure><p>还需实现两个实用函数：一个将下载并解压缩一个zip或tar文件，另一个是将使用的所有数据集从<code>DATA_HUB</code>下载到缓存目录中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download_extract</span>(<span class="params">name, folder=<span class="literal">None</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载并解压zip/tar文件&quot;&quot;&quot;</span></span><br><span class="line">    fname = download(name) <span class="comment"># 本地文件路径</span></span><br><span class="line">    <span class="comment"># 获取路径信息</span></span><br><span class="line">    base_dir = os.path.dirname(fname)</span><br><span class="line">    data_dir, ext = os.path.splitext(fname)</span><br><span class="line">    <span class="keyword">if</span> ext == <span class="string">&#x27;.zip&#x27;</span>:</span><br><span class="line">        fp = zipfile.ZipFile(fname, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> ext <span class="keyword">in</span> (<span class="string">&#x27;.tar&#x27;</span>, <span class="string">&#x27;.gz&#x27;</span>):</span><br><span class="line">        fp = tarfile.<span class="built_in">open</span>(fname, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">&#x27;只有zip/tar文件可以被解压缩&#x27;</span></span><br><span class="line">    fp.extractall(base_dir) <span class="comment"># 解压到base_dir</span></span><br><span class="line">    <span class="keyword">return</span> os.path.join(base_dir, folder) <span class="keyword">if</span> folder <span class="keyword">else</span> data_dir</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_all</span>():  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载DATA_HUB中的所有文件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> DATA_HUB:</span><br><span class="line">        download(name)</span><br></pre></td></tr></table></figure><h3 id="Kaggle"><a href="#Kaggle" class="headerlink" title="Kaggle"></a>Kaggle</h3><p><a href="https://www.kaggle.com/">Kaggle</a>是一个当今流行举办机器学习比赛的平台，每场比赛都以至少一个数据集为中心</p><p>在房价预测比赛页面的“Data”选项卡下可以找到数据集</p><h3 id="访问和读取数据集"><a href="#访问和读取数据集" class="headerlink" title="访问和读取数据集"></a>访问和读取数据集</h3><p>为方便起见可以使用上面定义的脚本下载并缓存Kaggle房屋数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_train&#x27;</span>] = (  <span class="comment">#@save</span></span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_train.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;585e9cc93e70b39160e7921475f9bcd7d31219ce&#x27;</span>)</span><br><span class="line"></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_test&#x27;</span>] = (  <span class="comment">#@save</span></span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_test.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fa19780a7b011d9b009e8bff8e99922a8ee2eb90&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将使用<code>pandas</code>读入并处理数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_data = pd.read_csv(download(<span class="string">&#x27;kaggle_house_train&#x27;</span>))</span><br><span class="line">test_data = pd.read_csv(download(<span class="string">&#x27;kaggle_house_test&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(train_data.shape) <span class="comment"># (1460, 81)</span></span><br><span class="line"><span class="built_in">print</span>(test_data.shape)  <span class="comment"># (1459, 80)</span></span><br></pre></td></tr></table></figure><p>训练数据集包括1460个样本，每个样本80个特征和1个标签，测试数据集包含1459个样本，每个样本80个特征</p><p>查看前四个和最后两个特征，以及相应标签（房价）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(train_data.iloc[<span class="number">0</span>:<span class="number">4</span>,[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,-<span class="number">3</span>,-<span class="number">2</span>,-<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   Id  MSSubClass MSZoning  LotFrontage SaleType SaleCondition  SalePrice</span><br><span class="line">0   1          60       RL         65.0       WD        Normal     208500</span><br><span class="line">1   2          20       RL         80.0       WD        Normal     181500</span><br><span class="line">2   3          60       RL         68.0       WD        Normal     223500</span><br><span class="line">3   4          70       RL         60.0       WD       Abnorml     140000</span><br></pre></td></tr></table></figure><p>可以看到，在每个样本中，第一个特征是ID，这有助于模型识别每个训练样本，但是并不携带任何信息，所以要删除该列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_features = pd.concat((train_data.iloc[:, <span class="number">1</span>:-<span class="number">1</span>], test_data.iloc[:, <span class="number">1</span>:]))</span><br></pre></td></tr></table></figure><p>训练集去掉<code>Id</code>和<code>SalePrice</code>，测试集只去掉<code>Id</code>列</p><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>在开始建模之前需要对数据进行预处理，需要将缺失值替换为相应特征的平均值</p><p><font color='DarkViolet'>为了将所有特征放在一个共同的尺度上，通过将特征重新缩放到零均值和单位方差来标准化数据</font><br>$$<br>x \leftarrow \frac{x - \mu}{\sigma}<br>$$</p><table><thead><tr><th>模型类型</th><th>是否依赖标准化</th><th>原因</th></tr></thead><tbody><tr><td>线性回归 &#x2F; 逻辑回归</td><td>必须</td><td>梯度更新受特征尺度影响</td></tr><tr><td>神经网络</td><td>强烈建议</td><td>有助于稳定训练、加快收敛</td></tr><tr><td>SVM &#x2F; KNN &#x2F; PCA</td><td>必须</td><td>这些算法都依赖特征间的距离</td></tr><tr><td>决策树 &#x2F; 随机森林</td><td>不需要</td><td>树模型只关心特征的相对大小或阈值分割，不受尺度影响</td></tr></tbody></table><p>标准化数据的原因：</p><ul><li>消除不同特征的量纲影响</li><li>让梯度下降更快、更稳定</li><li>避免某些特征主导模型学习</li></ul><p><code>number</code>类型数据处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选出所有数值类型的特征列</span></span><br><span class="line">numeric_features = all_features.select_dtypes(include=[np.number]).columns</span><br><span class="line"><span class="comment"># 对这些特征列进行标准化（减均值、除标准差）</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].apply(<span class="keyword">lambda</span> x: (x -x.mean()) / x.std())</span><br><span class="line"><span class="comment"># 在标准化数据之后，均值为0，因此可以将缺失值设置为0</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>离散数据处理：用独热编码替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># “Dummy_na=True”将“na”（缺失值）视为有效的特征值，并为其创建指示符特征</span></span><br><span class="line">all_features = pd.get_dummies(all_features, dummy_na=<span class="literal">True</span>) </span><br><span class="line">all_features = all_features.astype(<span class="built_in">float</span>)  <span class="comment"># 保证所有列都变成浮点型数值，可转为tensor</span></span><br><span class="line">all_features.shape  <span class="comment"># (2919, 330)</span></span><br></pre></td></tr></table></figure><p>转换后将样本特征从79个增加到330个</p><p>通过<code>values</code>属性，可以从<code>pandas</code>格式中提取NumPy格式，并将其转换为张量表示用于训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n_train = train_data.shape[<span class="number">0</span>]</span><br><span class="line">train_features = torch.tensor(all_features[<span class="number">0</span>:n_train].values, dtype=torch.float32)</span><br><span class="line">test_features = torch.tensor(all_features[n_train:].values, dtype=torch.float32)</span><br><span class="line">train_labels = torch.tensor(train_data.SalePrice.values.reshape(-<span class="number">1</span>, <span class="number">1</span>), dtype=torch.float32)</span><br></pre></td></tr></table></figure><h3 id="训练-2"><a href="#训练-2" class="headerlink" title="训练"></a>训练</h3><p>训练一个带有均方损失的线性模型，一般来说将线性模型将作为<strong>基线（baseline）模型</strong>，直观地知道最好的模型有超出简单的模型多少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.MSELoss() </span><br><span class="line">in_features = train_features.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_net</span>():</span><br><span class="line">    net = nn.Sequential(nn.Linear(in_features,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><p>房价就像股票价格一样，更关心的是相对误差$\frac{y - \hat{y}}{y}$而不是绝对误差</p><p>解决这个问题的一种方法是用价格预测的对数来衡量差异，事实上，这也是比赛中官方用来评价提交质量的误差指标</p><p>将$\mid\log y - \log \hat{y}\mid \leq \delta$ 转换为 $e^{-\delta} \leq \frac{\hat{y}}{y} \leq e^\delta$，使得预测价格的对数与真实标签价格的对数之间出现以下<strong>均方根误差RMSLE</strong><br>$$<br>\sqrt{\frac{1}{n}\sum_{i&#x3D;1}^n\left(\log y_i -\log \hat{y}_i\right)^2}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log_rmse</span>(<span class="params">net, features, labels</span>):</span><br><span class="line">    <span class="comment"># 为了在取对数时进一步稳定该值，将小于1的值设置为1</span></span><br><span class="line">    clipped_preds = torch.clamp(net(features), <span class="number">1</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)) <span class="comment"># 将张量的值限制在指定区间</span></span><br><span class="line">    rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(labels))) <span class="comment"># loss输入log</span></span><br><span class="line">    <span class="keyword">return</span> rmse.item() <span class="comment"># 转为float</span></span><br></pre></td></tr></table></figure><p>与前面的部分不同，训练函数将借助Adam优化器(后面讲)，Adam优化器的主要吸引力在于它对初始学习率不那么敏感</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net, train_features, train_labels, test_features, test_labels,</span></span><br><span class="line"><span class="params">          num_epochs, lr, weight_decay, batch_size</span>):</span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    train_iter = load_array((train_features, train_labels), batch_size)</span><br><span class="line">    <span class="comment"># 使用Adam优化算法</span></span><br><span class="line">    optimizer = torch.optim.Adam(net.parameters(),</span><br><span class="line">                                 lr=lr,</span><br><span class="line">                                 weight_decay=weight_decay)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X,y <span class="keyword">in</span> train_iter:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        train_ls.append(log_rmse(net, train_features, train_labels))</span><br><span class="line">        <span class="keyword">if</span> test_labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            test_ls.append(log_rmse(net, test_features, test_labels))</span><br><span class="line">    <span class="keyword">return</span> train_ls, test_ls</span><br></pre></td></tr></table></figure><h3 id="K折交叉验证-1"><a href="#K折交叉验证-1" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h3><p>K折交叉验证有助于模型选择和超参数调整</p><p>首先需要定义一个函数，在K折交叉验证过程中返回第$i$折的数据，具体来说就是它选择第$i$个切片作为验证数据,其余部分作为训练数据</p><p>这并不是处理数据的最有效方法，如果数据集大得多，完整地复制和拼接数据会带来显著的内存与计算开销</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_k_fold_data</span>(<span class="params">k, i, X, y</span>):</span><br><span class="line">    <span class="keyword">assert</span> k &gt; <span class="number">1</span></span><br><span class="line">    fold_size = X.shape[<span class="number">0</span>] // k <span class="comment"># 每折大小</span></span><br><span class="line">    X_train, y_train = <span class="literal">None</span>, <span class="literal">None</span> <span class="comment"># 初始化为空</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k): <span class="comment"># 循环划分每一折</span></span><br><span class="line">        idx = <span class="built_in">slice</span>(j * fold_size, (j + <span class="number">1</span>) * fold_size)</span><br><span class="line">        X_part, y_part = X[idx, :], y[idx] <span class="comment"># 对应每一折的内容</span></span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            X_valid, y_valid = X_part, y_part</span><br><span class="line">        <span class="keyword">elif</span> X_train <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            X_train, y_train = X_part, y_part</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = torch.cat([X_train, X_part], <span class="number">0</span>)</span><br><span class="line">            y_train = torch.cat([y_train, y_part], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, y_train, X_valid, y_valid</span><br></pre></td></tr></table></figure><p>在K折交叉验证中训练K次后，返回训练和验证误差的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">k_fold</span>(<span class="params">k, X_train, y_train, num_epochs, lr, weight_decay,</span></span><br><span class="line"><span class="params">           batch_size</span>):</span><br><span class="line">    train_l_sum, valid_l_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        data = get_k_fold_data(k, i, X_train, y_train)</span><br><span class="line">        net = get_net()  <span class="comment"># 创建网络</span></span><br><span class="line">        <span class="comment"># 训练当前折</span></span><br><span class="line">        train_ls, valid_ls = train(net, *data, num_epochs, lr,</span><br><span class="line">                                   weight_decay, batch_size)</span><br><span class="line">        <span class="comment"># 累加最后一个 epoch 的训练与验证误差</span></span><br><span class="line">        train_l_sum += train_ls[-<span class="number">1</span>]</span><br><span class="line">        valid_l_sum += valid_ls[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 只绘制第一折的训练曲线</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, label=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">            plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>), valid_ls, label=<span class="string">&#x27;valid&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">            plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">            plt.ylabel(<span class="string">&#x27;rmse&#x27;</span>)</span><br><span class="line">            plt.xlim(<span class="number">1</span>, num_epochs)</span><br><span class="line">            plt.yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">            plt.legend()</span><br><span class="line">            plt.grid(<span class="literal">True</span>)</span><br><span class="line">            plt.show()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;折 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>: 训练 log RMSE = <span class="subst">&#123;train_ls[-<span class="number">1</span>]:<span class="number">.4</span>f&#125;</span>, 验证 log RMSE = <span class="subst">&#123;valid_ls[-<span class="number">1</span>]:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> train_l_sum / k, valid_l_sum / k</span><br></pre></td></tr></table></figure><h3 id="模型选择-1"><a href="#模型选择-1" class="headerlink" title="模型选择"></a>模型选择</h3><p>找到合适的超参数通常需要较长时间，<font color='Violetred'>当数据量充足且超参数设置合理时，K 折交叉验证结果通常稳定</font></p><p>若超参数选择不当，验证误差可能失真，无法准确反映模型的真实性能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k, num_epochs, lr, weight_decay, batch_size = <span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">64</span></span><br><span class="line">train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr,</span><br><span class="line">                          weight_decay, batch_size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>-折验证: 平均训练log rmse: <span class="subst">&#123;<span class="built_in">float</span>(train_l):f&#125;</span>, &#x27;</span></span><br><span class="line">      <span class="string">f&#x27;平均验证log rmse: <span class="subst">&#123;<span class="built_in">float</span>(valid_l):f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里为什么lr设的这么大呢？因为对输入特征值做了标准化，使得特征值较小，同时输出值房价较大，所以nn的权重都较大，所以学习率要相应较大才能加快收敛速度</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251020141708112.png" alt="image-20251020141708112" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">折 1: 训练 log RMSE = 0.1705, 验证 log RMSE = 0.1562</span><br><span class="line">折 2: 训练 log RMSE = 0.1623, 验证 log RMSE = 0.1918</span><br><span class="line">折 3: 训练 log RMSE = 0.1637, 验证 log RMSE = 0.1679</span><br><span class="line">折 4: 训练 log RMSE = 0.1679, 验证 log RMSE = 0.1549</span><br><span class="line">折 5: 训练 log RMSE = 0.1626, 验证 log RMSE = 0.1825</span><br><span class="line">5-折验证: 平均训练log rmse: 0.165392, 平均验证log rmse: 0.170676</span><br></pre></td></tr></table></figure><p>有时一组超参数的训练误差可能非常低，但K折交叉验证的误差要高得多，这表明模型过拟合了</p><h3 id="提交Kaggle预测"><a href="#提交Kaggle预测" class="headerlink" title="提交Kaggle预测"></a>提交Kaggle预测</h3><p>使用所有数据对其进行训练，将预测保存在CSV文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_and_pred</span>(<span class="params">train_features, test_features, train_labels, test_data,</span></span><br><span class="line"><span class="params">                   num_epochs, lr, weight_decay, batch_size</span>):</span><br><span class="line">    net = get_net()</span><br><span class="line">    train_ls, _ = train(net, train_features, train_labels, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line">                        num_epochs, lr, weight_decay, batch_size)</span><br><span class="line">    plt.figure(figsize=(<span class="number">6</span>,<span class="number">4</span>))</span><br><span class="line">    plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, label=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;log rmse&#x27;</span>)</span><br><span class="line">    plt.xlim(<span class="number">1</span>, num_epochs)</span><br><span class="line">    plt.yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;训练log rmse：<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将网络应用于测试集。</span></span><br><span class="line">    preds = net(test_features).detach().numpy()</span><br><span class="line">    <span class="comment"># 将其重新格式化以导出到Kaggle</span></span><br><span class="line">    test_data[<span class="string">&#x27;SalePrice&#x27;</span>] = pd.Series(preds.reshape(<span class="number">1</span>, -<span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">    submission = pd.concat([test_data[<span class="string">&#x27;Id&#x27;</span>], test_data[<span class="string">&#x27;SalePrice&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">    submission.to_csv(<span class="string">&#x27;submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_and_pred(train_features, test_features, train_labels, test_data,</span><br><span class="line">               num_epochs, lr, weight_decay, batch_size)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">训练log rmse：0.162767</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251020142631646.png" alt="image-20251020142631646" style="zoom: 80%;" /><p>可以提交预测到Kaggle上，并查看在测试集上的预测与实际房价（标签）的比较情况</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>真实数据通常混合了不同的数据类型，需要进行预处理</li><li>常用的预处理方法：将实值数据重新缩放为零均值和单位方法；用均值替换缺失值</li><li>将类别特征转化为指标特征，可以把这个特征当作一个独热向量来对待</li><li>可以使用折交叉验证来选择模型并调整超参数</li><li>对数对于相对误差很有用</li></ul><p>当然，目前写的就是很简单的baseline，可优化空间非常多</p><h3 id="思考题-4"><a href="#思考题-4" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>用平均值替换缺失值总是好主意吗？</p><p>用平均值填补缺失只在<strong>缺失完全随机</strong>的情况下合理，若缺失模式与特征或标签有关（非随机缺失），平均值填补会掩盖数据结构、引入系统性偏差，让模型学到错误的统计关系</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性神经网络</title>
      <link href="/posts/31940.html"/>
      <url>/posts/31940.html</url>
      
        <content type="html"><![CDATA[<p>从经典算法————线性神经网络开始，介绍神经网络的基础知识</p><p>经典统计学习技术中的线性回归和softmax回归可以视为线性神经网络</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><p>**回归(regression)**是能为一个或多个自变量与因变量之间关系建模的一类方法</p><p>在机器学习领域中的大多数任务通常都与**预测(prediction)**有关，但不是所有的预测都是回归问题</p><p><font color='Violetred'>线性回归基于两个简单假设</font></p><ul><li>自变量$\mathbf{x}$和因变量$y$之间的关系是线性的，即$y$可以表示为$\mathbf{x}$中元素的加权和，通常允许包含观测值的一些噪声</li><li>任何噪声都比较正常，如噪声遵循正态分布</li></ul><p>为了开发一个能预测房价的模型，需要收集一个真实的数据集，包括房屋的销售价格、面积和房龄，该数据集称为<strong>训练集(training set)</strong>，每行数据称为<strong>样本(sample)</strong></p><p>把试图预测的目标(房屋价格)称为<strong>标签(label)或目标(target)</strong>，预测所依据的自变量(面积和房龄)称为<strong>特征(feature)</strong></p><p>通常使用$n$来表示数据集中的样本数，对索引为$i$的样本，其输入表示为$\mathbf{x}^{(i)} &#x3D; [x_1^{(i)}, x_2^{(i)}]^\top$，其对应的标签是$y^{(i)}$</p><h4 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h4><p>根据线性假设，价格表示为<br>$$<br>\mathrm{price} &#x3D; w_{\mathrm{area}} \cdot \mathrm{area} + w_{\mathrm{age}} \cdot \mathrm{age} + b.<br>$$<br>$w_{\mathrm{area}}$和$w_{\mathrm{age}}$称为权重，权重决定了每个特征对预测值的影响，$b$称为<strong>偏置(bias)</strong></p><p>这个式子是输入特征的<strong>仿射变换(affine transformation)</strong>，即通过加权和对特征进行<strong>线性变换(linear transformation)</strong>，并通过偏置项来进行<strong>平移(translation)</strong></p><p><font color='DarkViolet'>给定一个数据集，目标是寻找模型的权重$\mathbf{w}$和偏置$b$</font></p><p>输入包含$d$个特征时，将预测结果$\hat{y}$表示为<br>$$<br>\hat{y} &#x3D; w_1  x_1 + … + w_d  x_d + b.<br>$$<br>将所有特征放到向量$\mathbf{x} \in \mathbb{R}^d$，并将所有权重放到向量$\mathbf{w} \in \mathbb{R}^d$中，可以用点积形式来简洁地表达模型<br>$$<br>\hat{y} &#x3D; \mathbf{w}^\top \mathbf{x} + b.<br>$$<br>用矩阵$\mathbf{X} \in \mathbb{R}^{n \times d}$可以很方便地引用整个数据集的$n$个样本，每一行是一个样本，每一列是一种特征</p><p>预测值$\hat{\mathbf{y}} \in \mathbb{R}^n$通过矩阵-向量乘法表示为<br>$$<br>\color{purple} {\hat{\mathbf{y}}} &#x3D; \mathbf{X} \mathbf{w} + b<br>$$<br>无论使用什么手段来观察特征$\mathbf{X}$和标签$\mathbf{y}$都可能会出现少量的观测误差</p><p>因此即使确信特征与标签的潜在关系是线性的，也会加入一个噪声项来考虑观测误差带来的影响</p><p>在开始寻找最好的模型参数$\mathbf{w}$和$b$之前，需要确定两项</p><ul><li>模型质量的度量方式</li><li>能够更新模型以提高模型预测质量的方法</li></ul><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>**损失函数(loss function)**能够量化目标的实际值与预测值之间的差距，通常选择非负数作为损失，且数值越小表示损失越小，完美预测时的损失为0</p><p><font color='DarkViolet'>回归问题中最常用的损失函数是均方误差函数</font>，样本$i$的预测值为$\hat{y}^{(i)}$，其真实标签为$y^{(i)}$时，平方误差表示为<br>$$<br>l^{(i)}(\mathbf{w}, b) &#x3D; \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2.<br>$$<br>常数1&#x2F;2不会带来本质的差别，但这样方便后续求导</p><p>计算在训练集$n$个样本上的<strong>均方误差</strong><br>$$<br>L(\mathbf{w}, b) &#x3D;\frac{1}{n}\sum_{i&#x3D;1}^n l^{(i)}(\mathbf{w}, b) &#x3D;\frac{1}{n} \sum_{i&#x3D;1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2&#x3D;\frac{1}{n}\mid\mid \mathbf y-\mathbf X \mathbf w\mid\mid^2<br>$$</p><h4 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h4><p>线性回归的解可以用一个公式简单地表达出来，这类解叫作<strong>解析解(analytical solution)</strong></p><p>可以直接通过代数公式求出最优解，不需要迭代算法(如梯度下降)</p><p>将损失关于$\mathbf{w}$的导数设为0，得到解析解</p><p>计算过程</p><ol><li><p>先把损失函数展开<br>$$<br>L(\mathbf w,b)&#x3D;(\mathbf y-\mathbf X \mathbf w)^{\top}(\mathbf y-\mathbf X \mathbf w)<br>$$</p></li><li><p>对$\mathbf w$求导，并令导数为零(最小值点的一阶导数为零)<br>$$<br>\frac{\partial L}{\partial \mathbf w}&#x3D;-2 \mathbf X^{\top}(\mathbf y-\mathbf X \mathbf w)&#x3D;0<br>$$</p></li><li><p>移项得<br>$$<br>\mathbf X^{\top} \mathbf X \mathbf w&#x3D;\mathbf X^{\top} \mathbf y<br>$$</p></li><li><p>当$\mathbf X^{\top} \mathbf X $ 可逆时，求得解析解<br>$$<br>\mathbf{w}^* &#x3D; (\mathbf X^\top \mathbf X)^{-1}\mathbf X^\top \mathbf{y}.<br>$$</p></li></ol><p>但并不是所有的问题都存在解析解</p><p>解析解对问题的限制很严格，导致它无法广泛应用在深度学习里</p><h4 id="随机梯度下降SGD"><a href="#随机梯度下降SGD" class="headerlink" title="随机梯度下降SGD"></a>随机梯度下降SGD</h4><p><strong>随机梯度下降SGD</strong>几乎可以优化所有深度学习模型，它通过在损失函数递减的方向上更新参数来降低误差</p><p>最简单的用法是计算损失函数关于模型参数的导数，但计算量可能很大，通常会随机抽取一小批样本，这种变体叫做<strong>小批量随机梯度下降(minibatch stochastic gradient descent)</strong></p><p>在每次迭代中，首先随机抽样一个小批量，由<strong>批量大小(batch size)<strong>为$\mid \mathcal{B}\mid $个的训练样本组成的，计算平均损失关于模型参数的导数，将梯度乘以</strong>学习率$\eta$(learning rate)</strong>，并从当前参数的值中减掉<br>$$<br>(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b).<br>$$<br>使得参数沿着让误差变小的方向移动</p><p>算法的步骤如下：</p><ol><li>初始化模型参数的值，如随机初始化</li><li>从数据集中随机抽取小批量样本且在负梯度的方向上更新参数，并不断迭代</li></ol><p>对于均方损失和仿射变换可以写成<br>$$<br>\begin{split}\begin{aligned} \mathbf{w} &amp;\leftarrow \mathbf{w} -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{\mathbf{w}} l^{(i)}(\mathbf{w}, b) &#x3D; \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right),\\<br>b &amp;\leftarrow b -  \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_b l^{(i)}(\mathbf{w}, b)  &#x3D; b - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right). \end{aligned}\end{split}<br>$$<br>批量大小和学习率的值通常是手动预先指定，而不是通过模型训练得到的</p><p><font color='Violetred'>可以调整但不在训练过程中更新的参数称为超参数</font><strong>(hyperparameter)</strong>，调参是选择超参数的过程</p><p><font color='Violetred'>超参数通常是根据训练迭代结果来调整的</font>，而训练迭代结果是在独立的**验证数据集(validation dataset)**上评估得到的</p><p>线性回归是在整个域中只有一个最小值的学习问题，但是对像深度神经网络这样复杂的模型来说，损失平面上通常包含多个最小值。更难做到的是找到一组参数，这组参数能够在从未见过的数据上实现较低的损失，这一挑战被称为<strong>泛化(generalization)</strong></p><h3 id="矢量化加速"><a href="#矢量化加速" class="headerlink" title="矢量化加速"></a>矢量化加速</h3><p>训练模型时，经常希望能够同时处理整个小批量的样本，为了实现这一点，需要对计算进行矢量化， 从而利用线性代数库，而不是在Python中编写开销高昂的for循环</p><p>因为频繁对运行时间进行基准测试，需要定义一个计时器类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;记录多次运行时间&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.times = [] <span class="comment"># 保存每次运行的耗时</span></span><br><span class="line">        <span class="variable language_">self</span>.start()    <span class="comment"># 初始化时就自动调用start()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;启动计时器&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.tik = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;停止计时器并将时间记录在列表中&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.times.append(time.time() - <span class="variable language_">self</span>.tik)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.times[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">avg</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回平均时间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.times) / <span class="built_in">len</span>(<span class="variable language_">self</span>.times)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回时间总和&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.times)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cumsum</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回累计时间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> np.array(<span class="variable language_">self</span>.times).cumsum().tolist()</span><br></pre></td></tr></table></figure><p>现在可以对工作负载进行基准测试</p><p>使用for循环，每次执行一位的加法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10000</span></span><br><span class="line">a = torch.ones(n)</span><br><span class="line">b = torch.ones(n)</span><br><span class="line">c = torch.zeros(n)</span><br><span class="line">timer = Timer()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    c[i] = a[i] + b[i]</span><br><span class="line"><span class="string">f&#x27;<span class="subst">&#123;timer.stop():<span class="number">.5</span>f&#125;</span> sec&#x27;</span></span><br><span class="line"><span class="comment"># 输出&#x27;0.06851 sec&#x27;</span></span><br></pre></td></tr></table></figure><p>使用重载的+运算符来计算按元素的和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer.start()</span><br><span class="line">d = a + b</span><br><span class="line"><span class="string">f&#x27;<span class="subst">&#123;timer.stop():<span class="number">.5</span>f&#125;</span> sec&#x27;</span></span><br><span class="line"><span class="comment"># 输出&#x27;0.00000 sec&#x27;</span></span><br></pre></td></tr></table></figure><p>矢量化代码通常会带来数量级的加速</p><h3 id="正态分布与平方损失"><a href="#正态分布与平方损失" class="headerlink" title="正态分布与平方损失"></a>正态分布与平方损失</h3><p><strong>正态分布(normal distribution)<strong>也称为</strong>高斯分布(Gaussian distribution)</strong>，和线性回归之间的关系很密切</p><p>若随机变量$x$具有均值$\mu$和方差$\sigma^2$，其正态分布概率密度函数如下<br>$$<br>p(x) &#x3D; \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (x - \mu)^2\right).<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">normal</span>(<span class="params">x, mu, sigma</span>):</span><br><span class="line">    p = <span class="number">1</span> / np.sqrt(<span class="number">2</span> * np.pi * sigma**<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> p * np.exp(-<span class="number">0.5</span> / sigma**<span class="number">2</span> * (x - mu)**<span class="number">2</span>)</span><br><span class="line">x = np.arange(-<span class="number">7</span>, <span class="number">7</span>, <span class="number">0.01</span>)</span><br><span class="line">params = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> mu, sigma <span class="keyword">in</span> params:</span><br><span class="line">    plt.plot(x, normal(x, mu, sigma), label=<span class="string">f&#x27;$\mu$=<span class="subst">&#123;mu&#125;</span>, $\sigma$=<span class="subst">&#123;sigma&#125;</span>&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;p(x)&#x27;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510141622.webp" alt="202510141622" style="zoom:67%;" /><p>改变均值会产生沿轴的偏移，增加方差将会分散分布、降低其峰值</p><p>假设了观测中包含噪声，其中噪声服从正态分布$\epsilon \sim \mathcal{N}(0, \sigma^2)$<br>$$<br>y &#x3D; \mathbf{w}^\top \mathbf{x} + b + \epsilon<br>$$<br>通过给定的$\mathbf{x}$观测到特定$y$的<strong>似然(likelihood)</strong><br>$$<br>P(y \mid \mathbf{x}) &#x3D; \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (y - \mathbf{w}^\top \mathbf{x} - b)^2\right).<br>$$<br>根据<font color='DarkViolet'>极大似然估计法(MLE)</font>，参数$\mathbf{w}$和$b$的最优值是使整个数据集似然最大的值<br>$$<br>P(\mathbf y \mid \mathbf X) &#x3D; \prod_{i&#x3D;1}^{n} p(y^{(i)}|\mathbf{x}^{(i)}).<br>$$<br>由于历史原因，优化通常是说最小化而不是最大化，所以改为<strong>最小化负对数似然</strong>$-\log P(\mathbf y \mid \mathbf X)$</p><p>$$<br>-\log P(\mathbf y \mid \mathbf X) &#x3D; \sum_{i&#x3D;1}^n \frac{1}{2} \log(2 \pi \sigma^2) + \frac{1}{2 \sigma^2} \left(y^{(i)} - \mathbf{w}^\top \mathbf{x}^{(i)} - b\right)^2<br>$$<br>第一项与$\mathbf{w},b$无关；第二项除了系数，其余部分与平方方误差相同，所以<font color='DarkViolet'>在高斯噪声的假设下，最小化平方误差等价于对线性模型的极大似然估计</font></p><h3 id="从线性回归到深度网络"><a href="#从线性回归到深度网络" class="headerlink" title="从线性回归到深度网络"></a>从线性回归到深度网络</h3><p>将线性回归模型描述为一个神经网络</p><p><img src="https://zh.d2l.ai/_images/singleneuron.svg"></p><p>该图只显示连接模式，即只显示每个输入如何连接到输出，隐去了权重和偏置的值</p><p>由于模型重点在发生计算的地方，所以通常在计算层数时不考虑输入层，图中神经网络的层数为1</p><p>可以将线性回归模型视为仅由单个人工神经元组成的神经网络，或称为<strong>单层神经网络</strong></p><p>对于线性回归，每个输入都与每个输出相连，将这种变换(图中输出层)称为<strong>全连接层(fully-connected layer)</strong></p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>假设有一些数据$x_1, \ldots, x_n \in \mathbb{R}$，目标是找到一个常数$b$，使最小化$\sum_i (x_i - b)^2$</p><ul><li>找到最优值$b$的解析解</li><li>这个问题及其解与正态分布有什么关系</li></ul><p>$$<br>\begin{aligned}<br>&amp;f^{\prime}(b)&#x3D;\sum_{i&#x3D;1}^n 2\left(b-x_i\right)&#x3D;2\left(n b-\sum_i x_i\right)&#x3D;0 \Rightarrow b^*&#x3D;\frac{1}{n} \sum_{i&#x3D;1}^n x_i&#x3D;\bar{x} .<br>\end{aligned}<br>$$</p><p>二阶导$f^{\prime \prime}(b)&#x3D;2 n&gt;0$，因此这是唯一全局最小值</p><p><font color='Violetred'>所以最小二乘下，最优常数就是样本均值</font></p><p>若数据独立同分布于$\mathcal{N}(\mu , \sigma^2)$，极大化似然就等价于最小化平方和，因此MLE的$\mu$就是$\bar x$，这解释了为什么“最小二乘”天然匹配“高斯噪声”</p><p>如果把损失从$L_2$改为$L_1$范数，最优常数会变成中位数</p></li><li><p>用矩阵和向量表示法写出优化问题</p><p>带上偏置$b$的写法<br>$$<br>\tilde {\mathbf X} &#x3D; [\mathbf X \quad \mathbf 1] \in \mathbb{R}^{n\times (d+1)},\tilde {\mathbf w} &#x3D;  [\mathbf w^\top\quad b]^\top<br>$$</p></li><li><p>损失对$w$的梯度<br>$$<br>\nabla_{\mathbf w} L&#x3D;-2 \mathbf X^{\top}(\mathbf y-\mathbf X \mathbf w) \rightarrow \nabla^2_{\mathbf w} L &#x3D; 2\mathbf X^{\top} \mathbf X<br>$$<br>二阶导数大于等于0</p></li><li><p>什么时候使用随机梯度下降更好？这种方法何时会失效？</p><p>样本数量大，特征维度也大时使用随机梯度下降更好，深度神经网络训练几乎都是用 SGD 及其变种</p><p>学习率&#x2F;调度不当，损失函数过于崎岖时将失效</p></li><li><p>假定控制附加噪声的噪声模型是指数分布$p(\epsilon) &#x3D; \frac{1}{2} \exp(-|\epsilon|)$</p><ul><li><p>写出模型$-\log P(\mathbf y \mid \mathbf X)$下数据的负对数似然<br>$$<br>P(y \mid \mathbf{x}) &#x3D; \frac{1}{2}\exp (-\mid y - \mathbf{w}^\top \mathbf{x} - b \mid)<br>$$<br>负对数似然<br>$$<br>-\log P(\mathbf y \mid \mathbf X) &#x3D;  n\log2 + \sum_{i&#x3D;1}^n\mid y - \mathbf{w}^\top \mathbf{x} - b \mid<br>$$<br>常数项忽略以后等价于最小化 L1 回归损失</p></li><li><p>提出一种随机梯度下降算法来解决这个问题。哪里可能出错？</p><p>L1 在 0 处有“拐点”，$\operatorname{sgn}(r)$会在正负之间反复切换，如果学习率不衰减就会持续震荡，导致无法收敛</p></li></ul></li></ol><h2 id="线性回归的底层实现"><a href="#线性回归的底层实现" class="headerlink" title="线性回归的底层实现"></a>线性回归的底层实现</h2><p>虽然深度学习框架几乎可以自动化地进行所有这些工作，但从零开始实现可以确保知道自己在做什么</p><h3 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h3><p>将根据带有噪声的线性模型构造一个数据集，合成数据集是一个矩阵$\mathbf{X}\in \mathbb{R}^{1000 \times 2}$</p><p>使用线性模型参数$\mathbf{w} &#x3D; [2, -3.4]^\top$，$b &#x3D; 4.2$以及噪声$\varepsilon $生成数据集及其标签</p><p>$\epsilon$可以视为模型预测和标签时的潜在观测误差，假设服从均值为0的正态分布，标准差为0.01</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w, b, num_examples</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成y=Xw+b+噪声&quot;&quot;&quot;</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w)))</span><br><span class="line">    y = torch.matmul(X, w) + b <span class="comment"># 等价于 X @ w + b，在高维推荐matmul</span></span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)</span><br><span class="line">    <span class="keyword">return</span> X, y.reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>通过生成第二个特征<code>features[:, 1]</code>和<code>labels</code>的散点图，可以直观观察到两者之间的线性关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要从张量换为numpy</span></span><br><span class="line">plt.scatter(features[:,<span class="number">1</span>].detach().numpy(), labels.detach().numpy(),s=<span class="number">5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251014173316948.png" alt="image-20251014173316948" style="zoom:67%;" /><h3 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h3><p>训练模型时要对数据集进行遍历，每次抽取一小批量样本，并使用它们来更新模型</p><p>有必要定义一个函数，该函数能打乱数据集中的样本并以小批量方式获取数据</p><p>定义一个<code>data_iter</code>函数，该函数接收批量大小、特征矩阵和标签向量作为输入，生成大小为<code>batch_size</code>的小批量，每个小批量包含一组特征和标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span><br><span class="line">    num_examples = <span class="built_in">len</span>(features) <span class="comment"># 统计样本数</span></span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples)) <span class="comment"># 创建索引列表</span></span><br><span class="line">    <span class="comment"># 这些样本是随机读取的，没有特定的顺序</span></span><br><span class="line">    random.shuffle(indices)  <span class="comment"># 打乱索引顺序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_examples, batch_size): <span class="comment"># 遍历样本</span></span><br><span class="line">        <span class="comment"># 获得按batch_size大小获取随机索引</span></span><br><span class="line">        batch_indices = torch.tensor(  <span class="comment"># 张量索引为了减少隐式拷贝</span></span><br><span class="line">            indices[i: <span class="built_in">min</span>(i + batch_size, num_examples)]) </span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices], labels[batch_indices] <span class="comment"># 逐次返回</span></span><br></pre></td></tr></table></figure><p>利用GPU并行运算的优势，处理合理大小的“小批量”</p><p>每个样本都可以并行地进行模型计算，且每个样本损失函数的梯度也可以被并行计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">    <span class="built_in">print</span>(X, <span class="string">&#x27;\n&#x27;</span>, y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>当运行迭代时，会连续地获得不同的小批量，直至遍历完整个数据集</p><p>但这种迭代的执行效率很低，因为需要把所有数据读入，并且执行大量的随机内存访问</p><p>在深度学习框架中实现的内置迭代器效率要高得多，它可以处理存储在文件中的数据和数据流提供的数据</p><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>通过从均值为0、标准差为0.01的正态分布中采样随机数来初始化权重，并将偏置初始化为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(<span class="number">2</span>,<span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>之后更新这些参数，直到这些参数足够拟合数据，每次更新都需要计算损失函数关于模型参数的梯度，有了这个梯度，就可以向减小损失的方向更新每个参数</p><p>根据之前引入的自动微分来计算梯度(<code>requires_grad=True</code>)</p><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>将模型的输入和参数同模型的输出关联起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linreg</span>(<span class="params">X, w, b</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性回归模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> torch.matmul(X, w) + b</span><br></pre></td></tr></table></figure><h3 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><p>定义损失函数是重中之重，这里使用之前描述的平方损失函数</p><p>需要将真实值<code>y</code>的形状转换为和预测值<code>y_hat</code>的形状相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">squared_loss</span>(<span class="params">y_hat, y</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;平方损失&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="number">2</span> / <span class="number">2</span></span><br><span class="line">    <span class="comment"># 这里reshape是为了避免出现广播 </span></span><br></pre></td></tr></table></figure><h3 id="定义优化算法"><a href="#定义优化算法" class="headerlink" title="定义优化算法"></a>定义优化算法</h3><p>线性回归有解析解，但其实大部分模型是没有解析解的，这里利用小批量梯度下降</p><p>使用从数据集中随机抽取的一个小批量，然后根据参数计算损失的梯度，朝着减少损失的方向更新参数，该函数接受模型参数集合、学习速率和批量大小作为输入</p><ul><li>每一步更新的大小由学习速率<code>lr</code>决定</li><li>计算的损失是一个批量样本的总和，用批量大小(<code>batch_size</code>)来规范化步长</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params, lr, batch_size</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;小批量随机梯度下降&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment"># 以下操作不追踪梯度，优化步骤常用</span></span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            <span class="comment"># param.grad PyTorch 自动计算得到的梯度</span></span><br><span class="line">            param -= lr * param.grad / batch_size</span><br><span class="line">            param.grad.zero_()  <span class="comment"># 清除梯度累积，结尾 _ 表示这是原地操作</span></span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>已经准备好了模型训练所有需要的要素，可以实现主要的训练过程部分了</p><p>将执行以下循环：</p><ul><li>初始化参数</li><li>重复以下训练，直到完成<ol><li>计算梯度$\mathbf{g} \leftarrow \partial_{(\mathbf{w},b)} \frac{1}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} l(\mathbf{x}^{(i)}, y^{(i)}, \mathbf{w}, b)$</li><li>更新参数$(\mathbf{w}, b) \leftarrow (\mathbf{w}, b) - \eta \mathbf{g}$</li></ol></li></ul><p>在每个迭代周期(epoch)中，使用<code>data_iter</code>函数遍历整个数据集，并将训练数据集中所有样本都使用一次(假设样本数能够被批量大小整除)</p><p>在该例子中迭代周期个数<code>num_epochs</code>和学习率<code>lr</code>都是超参数，分别设为3和0.03</p><p>设置超参数很棘手，需要通过反复试验进行调整</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lr = <span class="number">0.03</span>         <span class="comment"># 学习率</span></span><br><span class="line">num_epochs = <span class="number">3</span>    <span class="comment"># 迭代次数</span></span><br><span class="line">batch_size = <span class="number">10</span>   <span class="comment"># 小样本数</span></span><br><span class="line">net = linreg      <span class="comment"># 模型函数(线性回归 y = Xw + b)</span></span><br><span class="line">loss = squared_loss   <span class="comment"># 损失函数(平方损失)</span></span><br><span class="line"><span class="comment"># 初始化随机参数</span></span><br><span class="line">w = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(<span class="number">2</span>,<span class="number">1</span>), requires_grad=<span class="literal">True</span>) </span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 根据真实参数创建含噪样本</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        l = loss(net(X, w, b), y) <span class="comment"># net前向传播，计算预测值</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        <span class="comment"># 因为l形状是(batch_size,1)，而不是一个标量</span></span><br><span class="line">        <span class="comment"># l中的所有元素被加到一起，并以此计算关于[w,b]的梯度</span></span><br><span class="line">        sgd([w, b], lr, batch_size)  <span class="comment"># 使用参数的梯度更新参数</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment"># 性能评估不追踪梯度</span></span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean()):f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">epoch 1, loss 0.025137</span><br><span class="line">epoch 2, loss 0.000085</span><br><span class="line">epoch 3, loss 0.000046</span><br></pre></td></tr></table></figure><p>对比之前设置的真实参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w的估计误差: <span class="subst">&#123;true_w - w.reshape(true_w.shape)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;b的估计误差: <span class="subst">&#123;true_b - b&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w的估计误差: tensor([1.0513e-03, 6.3181e-05], grad_fn=&lt;SubBackward0&gt;)</span><br><span class="line">b的估计误差: tensor([0.0004], grad_fn=&lt;RsubBackward1&gt;)</span><br></pre></td></tr></table></figure><p>在机器学习中，通常不太关心恢复真正的参数，而更关心如何高度准确预测参数</p><p>即使是在复杂的优化问题上，随机梯度下降通常也能找到非常好的解，因为在深度网络中存在许多参数组合能够实现高度精确的预测</p><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>如果将权重初始化为零，会发生什么，算法仍然有效吗？</p><p>像线性回归这种问题，因为损失函数是凸函数，梯度在所有方向上都是对称的，不管初始点在哪，梯度下降都会沿着唯一方向走到全局最优</p><p>但在神经网络这种多层模型里就不行了，如果权重都初始化为0，那么所有的神经元都一样，梯度也完全一样，就会出现对称性问题，陷入死局</p><table><thead><tr><th>模型类型</th><th>全零初始化后果</th><th>原因</th></tr></thead><tbody><tr><td>线性回归</td><td>可行</td><td>损失函数是凸的，无对称问题</td></tr><tr><td>逻辑回归</td><td>可行</td><td>一层模型，不存在多通道对称性</td></tr><tr><td>神经网络(多层)</td><td>失败</td><td>神经元对称、梯度相同、学习停滞</td></tr></tbody></table></li><li><p>计算二阶导数时可能会遇到什么问题？这些问题可以如何解决？</p><p>只在第一次求导时指定 <code>create_graph=True</code>，PyTorch 才会保留梯度计算图，从而允许继续求导</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor(<span class="number">4.0</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x ** <span class="number">3</span></span><br><span class="line">y.backward(create_graph=<span class="literal">True</span>) <span class="comment"># 保留梯度计算图</span></span><br><span class="line"><span class="built_in">print</span>(x.grad) <span class="comment"># 输出48 3x^2=48符合</span></span><br><span class="line">grad_x = x.grad.clone() <span class="comment"># 不能&quot;=&quot;，只是赋地址，grad.zero_()清掉了</span></span><br><span class="line">x.grad.zero_() <span class="comment"># 避免梯度累加，因为我只看二阶导梯度</span></span><br><span class="line">grad_x.backward() <span class="comment"># 再次反向传播</span></span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br></pre></td></tr></table></figure></li><li><p>为什么在<code>squared_loss</code>函数中需要使用<code>reshape</code>函数？</p><p><code>y_hat</code>的形状可能是 <code>(batch_size, 1)</code> 或 <code>(batch_size,)</code></p><p><code>y</code>的形状常常是 <code>(batch_size,)</code></p><p>如果直接计算可能会出现广播机制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_hat.shape = (<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">y.shape     = (<span class="number">3</span>,)</span><br></pre></td></tr></table></figure><p>广播后变为(3,3)的矩阵计算，这肯定是不对的</p><p>显式地让 <code>y</code> 的形状与 <code>y_hat</code> 完全一致，确保预测值和真实值形状一致，从而进行逐元素平方损失计算</p></li><li><p>尝试使用不同的学习率，观察损失函数值下降的快慢</p><p>学习率越大，损失函数下降越快</p></li><li><p>如果样本个数不能被批量大小整除，<code>data_iter</code>函数的行为会有什么变化？</p><table><thead><tr><th>情况</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>保留不满批次</td><td>所有样本都用上</td><td>最后一批大小不一致，梯度波动略大</td></tr><tr><td>丢弃不满批次</td><td>批次形状一致，利于并行</td><td>一部分样本没被训练</td></tr></tbody></table></li></ol><h2 id="线性回归的简洁实现"><a href="#线性回归的简洁实现" class="headerlink" title="线性回归的简洁实现"></a>线性回归的简洁实现</h2><p>由于数据迭代器、损失函数、优化器和神经网络层很常用，现代深度学习库已经实现了这些组件</p><p>生成数据集一般没有特殊的封装函数，毕竟大部分情况下数据都是已经获取好，读入即可</p><h3 id="读取数据集-1"><a href="#读取数据集-1" class="headerlink" title="读取数据集"></a>读取数据集</h3><p>可以调用PyTorch框架中现有的API来读取数据，将<code>features</code>和<code>labels</code>作为API的参数传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_array</span>(<span class="params">data_arrays, batch_size, is_train=<span class="literal">True</span></span>):</span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)</span><br><span class="line">    <span class="keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)</span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line">data_iter = load_array((features,labels), batch_size, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="定义模型-1"><a href="#定义模型-1" class="headerlink" title="定义模型"></a>定义模型</h3><p>对于标准深度学习模型，可以使用框架的预定义好的层，只需关注使用哪些层来构造模型，而不必关注层的实现细节</p><p>首先定义一个模型变量<code>net</code>，它是一个<code>Sequential</code>类的实例</p><p><code>Sequential</code>类将多个层串联在一起，当给定输入数据时，<code>Sequential</code>实例将数据传入到第一层，然后将第一层的输出作为第二层的输入，以此类推</p><p>当前单层连接所有输入，所以为全连接层</p><p>在PyTorch中，全连接层在<code>Linear</code>类中定义，将两个参数传递到<code>nn.Linear</code>中</p><ul><li><p>参数1指定输入特征形状，即2</p></li><li><p>参数2指定输出特征形状，输出特征形状为单个标量，因此为1</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">2</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="初始化模型参数-1"><a href="#初始化模型参数-1" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>在使用<code>net</code>之前，需要初始化模型参数，如在线性回归模型中的权重和偏置</p><p>深度学习框架通常有预定义的方法来初始化参数</p><p>在这里指定每个权重参数应该从均值为0、标准差为0.01的正态分布中随机采样，偏置参数将初始化为零</p><p>通过<code>net[0]</code>选择网络中的第一个图层，然后使用<code>weight.data</code>和<code>bias.data</code>方法访问参数，还可以使用替换方法<code>normal_</code>和<code>fill_</code>来重写参数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net[<span class="number">0</span>].weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">net[<span class="number">0</span>].bias.data.fill_(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="定义损失函数-1"><a href="#定义损失函数-1" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><p>计算均方损失使用的是<code>MSELoss</code>类，也称为均方$L_2$范数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.MSELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure><p>参数<code>reduction</code></p><ul><li>默认<code>mean</code>，对所有元素的损失取平均值，<font color='DarkViolet'>最常用，标准化损失</font>  $ \frac{1}{n} \sum_{i}\left(x_{i}-y_{i}\right)^{2}$</li><li><code>none</code>，不进行任何聚合，返回与输入相同形状的逐元素损失 $(x_{i}-y_{i})^{2}$</li><li><code>sum</code>，对所有元素的损失求和，希望损失值与样本规模成比例，常出现于最大似然  $\sum_{i}\left(x_{i}-y_{i}\right)^{2}$</li></ul><h3 id="定义优化算法-1"><a href="#定义优化算法-1" class="headerlink" title="定义优化算法"></a>定义优化算法</h3><p>小批量随机梯度下降算法是一种优化神经网络的标准工具，PyTorch在<code>optim</code>模块中实现了该算法的许多变种</p><p>当实例化一个<code>SGD</code>实例时，要指定优化的参数(可通过<code>net.parameters()</code>从模型中获得)以及优化算法所需的超参数字典</p><p>小批量随机梯度下降只需要设置<code>lr</code>值，这里设置为0.03</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.03</span>)</span><br></pre></td></tr></table></figure><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><p>通过深度学习框架的高级API来实现，只需要相对较少的代码</p><p>不必单独分配参数、不必定义损失函数，也不必手动实现小批量随机梯度下降</p><p>当有了所有的基本组件，训练过程代码与从零开始实现时所做的非常相似</p><p>对于每一个小批量，会进行以下步骤</p><ol><li>通过调用<code>net(X)</code>生成预测并计算损失<code>l</code>(前向传播)</li><li>通过进行反向传播来计算梯度</li><li>通过调用优化器来更新模型参数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        l = loss(net(X) ,y)</span><br><span class="line">        trainer.zero_grad() <span class="comment"># 在每个 batch 训练前清空上一次的梯度</span></span><br><span class="line">        l.backward()        <span class="comment"># 反向传播，自动计算损失 l 对所有参数的梯度</span></span><br><span class="line">        <span class="comment"># 如果要访问参数的梯度</span></span><br><span class="line">        <span class="comment"># net.weight.grad</span></span><br><span class="line">        <span class="comment"># net.bias.grad</span></span><br><span class="line">        trainer.step()      <span class="comment"># 根据刚刚算出的梯度，更新模型参数</span></span><br><span class="line">    <span class="comment"># 在每个 epoch 结束后，重新计算整个数据集上的损失</span></span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l:f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">epoch 1, loss 0.000252</span><br><span class="line">epoch 2, loss 0.000100</span><br><span class="line">epoch 3, loss 0.000102</span><br></pre></td></tr></table></figure><p>访问训练出的权重和偏置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w = net[<span class="number">0</span>].weight.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w的估计误差：&#x27;</span>, true_w - w.reshape(true_w.shape))</span><br><span class="line">b = net[<span class="number">0</span>].bias.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b的估计误差：&#x27;</span>, true_b - b)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w的估计误差： tensor([0.0014, 0.0002])</span><br><span class="line">b的估计误差： tensor([0.0005])</span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>所有损失函数都在 <code>torch.nn</code> 中实现为类</p><p>回归问题的损失函数：</p><table><thead><tr><th>损失函数</th><th>说明</th><th>默认公式</th></tr></thead><tbody><tr><td><code>nn.MSELoss()</code></td><td>均方误差(Mean Squared Error)</td><td>$\frac{1}{n}\sum(y - \hat{y})^2$</td></tr><tr><td><code>nn.L1Loss()</code></td><td>平均绝对误差(Mean Absolute Error)</td><td>$\frac{1}{n}\sum\mid y- \hat y \mid $</td></tr><tr><td><code>nn.SmoothL1Loss()</code></td><td>平滑版 L1，融合 L1 与 L2 优点</td><td>对小误差用平方<br />大误差用绝对值</td></tr><tr><td><code>nn.HuberLoss()</code></td><td>类似 SmoothL1，可设阈值 δ 控制</td><td>兼顾稳健性与可导性</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>在PyTorch中，<code>data</code>模块提供了数据处理工具，<code>nn</code>模块定义了大量的神经网络层和常见损失函数</li><li>可以通过<code>_</code>结尾的方法将参数替换，从而初始化参数</li></ul><h2 id="softmax回归的概念"><a href="#softmax回归的概念" class="headerlink" title="softmax回归的概念"></a>softmax回归的概念</h2><p><strong>分类</strong>这个词可描述两个有微妙差别的问题：</p><ol><li>只对样本的“硬性”类别感兴趣，即属于哪个类别</li><li>希望得到“软性”类别，即得到属于每个类别的概率</li></ol><p>这两者的界限往往很模糊，因为即使只关心硬类别，仍然使用软类别的模型</p><h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>从一个图像分类问题开始，假设每次输入是一个$2\times 2$的灰度图像，可以用一个标量表示每个像素值，每个图像对应四个特征$x_1, x_2, x_3, x_4$，假设每个图像属于类别“猫”“鸡”和“狗”中的一个</p><p>接下来要考虑如何表示标签，最直接的想法是选择$y \in {1, 2, 3}$来分别表示${\text{狗}, \text{猫}, \text{鸡}}$，这是在计算机上存储此类信息的有效方法，但这种方法需要类别间有一些自然顺序</p><p>但是一般的分类问题并不与类别之间的自然顺序有关，所以需要利用<strong>独热编码(one-hot encoding)</strong></p><p>独热编码是一个向量，它的分量和类别一样多，类别对应的分量设置为1，其他所有分量设置为0</p><p>在例子中，标签$y$将是一个三维向量，其中$(1, 0, 0)$对应于“猫”、$(0, 1, 0)$对应于“鸡”、$(0, 0, 1)$对应于“狗”<br>$$<br>y \in {(1, 0, 0), (0, 1, 0), (0, 0, 1)}.<br>$$</p><h3 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h3><p>为了估计所有可能类别的条件概率，需要一个有多个输出的模型，每个类别对应一个输出</p><p>为了解决线性模型的分类问题，需要和输出一样多的仿射函数，每个输出对应于它自己的仿射函数</p><p>回到简单例子中，有4个特征和3个可能的输出类别，将需要12个标量来表示权重(带下标的$w$)，3个标量来表示偏置(带下标的$b$)</p><p>为每个输入计算三个未规范化的预测<br>$$<br>\begin{split}\begin{aligned}<br>o_1 &amp;&#x3D; x_1 w_{11} + x_2 w_{12} + x_3 w_{13} + x_4 w_{14} + b_1,\\<br>o_2 &amp;&#x3D; x_1 w_{21} + x_2 w_{22} + x_3 w_{23} + x_4 w_{24} + b_2,\\<br>o_3 &amp;&#x3D; x_1 w_{31} + x_2 w_{32} + x_3 w_{33} + x_4 w_{34} + b_3.<br>\end{aligned}\end{split}<br>$$<br>和线性回归一样，softmax回归也是一个单层神经网络且输出层也是全连接层</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/softmaxreg.svg" alt="softmaxreg"  /><p>为了更简洁地表达模型，仍然使用线性代数符号，通过向量形式表达为$\mathbf{o} &#x3D; \mathbf{W} \mathbf{x} + \mathbf{b}$</p><p>权重在一个$3 \times 4$的矩阵中，对于给定数据样本的特征$\mathbf{x}$，输出是由权重与输入特征进行矩阵-向量乘法再加上偏置得到的</p><h3 id="全连接层的参数开销"><a href="#全连接层的参数开销" class="headerlink" title="全连接层的参数开销"></a>全连接层的参数开销</h3><p>在深度学习中，全连接层无处不在，但是全连接层可能有很多可学习的参数</p><p>对于任何具有$d$个输入和$q$个输出的全连接层，参数开销为$\mathcal{O}(dq)$，但通过低秩分解将矩阵拆分，引入一个中间的低维隐空间，用较少的参数去近似原始映射</p><p>此时参数数量从$dq$下降为$dn+nq&#x3D;O(\frac{dq}{n})$(当$n\ll d,q$时)</p><p>其中超参数$n$可以灵活指定，但是需要平衡参数节约和模型有效性</p><h3 id="softmax运算"><a href="#softmax运算" class="headerlink" title="softmax运算"></a>softmax运算</h3><p>为了得到预测结果将设置一个阈值，如选择具有最大概率的标签</p><p>希望模型的输出$\hat{y}_j$可以视为属于类$j$的概率，然后选择具有最大输出值的类别$\operatorname*{argmax}_j y_j$作为预测</p><p>能否将未规范化的预测$o$直接视作我们感兴趣的输出呢？这肯定是不行的，将线性层的输出直接视为概率时存在一些问题：</p><ul><li>没有限制输出总和为1</li><li>根据输入不同，输出可能为负值</li></ul><p>这已经违反了概率基本公理</p><p>要将输出视为概率，必须保证在任何数据上的输出都是非负的且总和为1</p><p>此外，需要一个训练的目标函数，来激励模型精准地估计概率</p><p>比如在分类器输出0.5的所有样本中，希望这些样本是刚好有一半实际上属于预测的类别，这个属性叫做<strong>校准(calibration)</strong></p><p>在选择模型理论基础上发明的softmax函数能够将未规范化的预测变换为非负数并且总和为1，同时让模型保持可导的性质</p><p><font color='Violetred'>首先对每个未规范化的预测求幂(这样可以确保输出非负)，再让每个求幂后的结果除以它们的总和</font><br>$$<br>\hat{\mathbf{y}} &#x3D; \mathrm{softmax}(\mathbf{o})\quad \text{其中}\quad \hat{y}_j &#x3D; \frac{\exp(o_j)}{\sum_k \exp(o_k)}<br>$$<br>这样$\hat{\mathbf{y}}$可以视为一个正确的概率分布</p><p>softmax运算不会改变未规范化的预测之间的大小次序，只会确定分配给每个类别的概率，所以仍然可以用下式来选择最有可能的类别<br>$$<br>\operatorname*{argmax}_j \hat y_j &#x3D; \operatorname*{argmax}_j o_j.<br>$$</p><h3 id="小批量样本的矢量化"><a href="#小批量样本的矢量化" class="headerlink" title="小批量样本的矢量化"></a>小批量样本的矢量化</h3><p>假设读取了一个批量的样本$\mathbf{X}$，其中特征维度(输入数量)为$d$，批量大小为$n$，并假设在输出中有$q$个类别</p><p>那么小批量样本的特征为$\mathbf{X} \in \mathbb{R}^{n \times d}$，权重为$\mathbf{W} \in \mathbb{R}^{d \times q}$，偏置为$\mathbf{b} \in \mathbb{R}^{1\times q}$</p><p>softmax回归的矢量计算表达式为：<br>$$<br>\begin{split}\begin{aligned} \mathbf{O} &amp;&#x3D; \mathbf{X} \mathbf{W} + \mathbf{b}, \\ \hat{\mathbf{Y}} &amp; &#x3D; \mathrm{softmax}(\mathbf{O}). \end{aligned}\end{split}<br>$$<br>相对于一次处理一个样本，小批量样本的矢量化加快了$\mathbf{X},\mathbf{W}$的矩阵-向量乘法</p><p>由于$\mathbf{X}$中的每一行代表一个数据样本，那么softmax运算可以按行执行</p><p>这里的偏置依旧会触发广播机制，小批量的未规范化预测$\mathbf{O}$和输出概率$\hat{\mathbf{Y}}$都是形状为$n \times q$的矩阵</p><h3 id="损失函数-1"><a href="#损失函数-1" class="headerlink" title="损失函数"></a>损失函数</h3><p>需要一个损失函数来度量预测的效果，将使用最大似然估计，这与在线性回归中的方法相同</p><h4 id="对数似然"><a href="#对数似然" class="headerlink" title="对数似然"></a>对数似然</h4><p>softmax函数给出了一个向量$\hat{\mathbf{y}}$，可以将其视为“对给定任意输入$\mathbf{x}$的每个类的条件概率”</p><p>假设整个数据集${\mathbf{X}, \mathbf{Y}}$具有$n$个样本，其中索引$i$的样本由特征向量$\mathbf{x}^{(i)}$和独热标签向量$\mathbf{y}^{(i)}$组成</p><p>可以将估计值与实际值进行比较<br>$$<br>P(\mathbf{Y} \mid \mathbf{X}) &#x3D; \prod_{i&#x3D;1}^n P(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)}).<br>$$<br>根据最大似然估计，最大化$P(\mathbf{Y} \mid \mathbf{X})$相当于最小化负对数似然<br>$$<br>-\log P(\mathbf{Y} \mid \mathbf{X}) &#x3D; \sum_{i&#x3D;1}^n -\log P(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)})<br>&#x3D; \sum_{i&#x3D;1}^n l(\mathbf{y}^{(i)}, \hat{\mathbf{y}}^{(i)}),<br>$$<br>其中，对于任何标签$\mathbf{y}$和模型预测$\hat{\mathbf{y}}$，损失函数为<br>$$<br>l(\mathbf{y}, \hat{\mathbf{y}}) &#x3D; - \sum_{j&#x3D;1}^q y_j \log \hat{y}_j.<br>$$<br>通常被称为<strong>交叉熵损失(cross-entropy loss)</strong></p><ul><li>由于$\mathbf{y}$是一个长度为$q$的独热编码向量，所以除了一个项以外的所有项$j$都消失了</li><li>由于所有$\hat{y}_j$都是预测的概率，所以对数永远不会大于0</li></ul><p>如果正确预测实际标签，即$P(\mathbf{y} \mid \mathbf{x})&#x3D;1$，则损失函数不能进一步最小化，但是基本不会出现</p><p>因为数据集中可能存在标签噪声(比如某些样本可能被误标)</p><h4 id="softmax及其导数"><a href="#softmax及其导数" class="headerlink" title="softmax及其导数"></a>softmax及其导数</h4><p>利用softmax的定义得到<br>$$<br>\begin{split}\begin{aligned}<br>l(\mathbf{y}, \hat{\mathbf{y}}) &amp;&#x3D;  - \sum_{j&#x3D;1}^q y_j \log \frac{\exp(o_j)}{\sum_{k&#x3D;1}^q \exp(o_k)} \\<br>&amp;&#x3D; \sum_{j&#x3D;1}^q y_j \log \sum_{k&#x3D;1}^q \exp(o_k) - \sum_{j&#x3D;1}^q y_j o_j\\<br>&amp;&#x3D; \log \sum_{k&#x3D;1}^q \exp(o_k) - \sum_{j&#x3D;1}^q y_j o_j.<br>\end{aligned}\end{split}<br>$$<br>考虑相对于任何未规范化的预测$o_j$的导数得到<br>$$<br>\partial_{o_j} l(\mathbf{y}, \hat{\mathbf{y}}) &#x3D; \frac{\exp(o_j)}{\sum_{k&#x3D;1}^q \exp(o_k)} - y_j &#x3D; \mathrm{softmax}(\mathbf{o})_j - y_j &#x3D; \hat y_j-y_j<br>$$<br>发现导数是softmax模型分配的概率与实际发生的情况(由独热标签向量表示)之间的差异</p><p>这与之前在回归中看到的非常相似，其中梯度是观测值与预估值之间的差异</p><p>这不是巧合，<font color='DarkViolet'>在任何指数族分布模型中，对数似然的梯度正是由此得出的</font></p><h4 id="交叉熵损失"><a href="#交叉熵损失" class="headerlink" title="交叉熵损失"></a>交叉熵损失</h4><p>对于标签$\mathbf{y}$可以使用与以前相同的表示形式，唯一的区别是现在用一个概率向量表示，而不是仅包含二元项的向量</p><p>使用交叉熵来定义损失<br>$$<br>\begin{align*}<br>l(\mathbf{y}, \hat{\mathbf{y}})<br>&#x3D; -\sum_{j&#x3D;1}^q y_j \log \hat y_j<br>&#x3D; \log \sum_{k&#x3D;1}^q \exp(o_k) - \sum_{j&#x3D;1}^q y_j o_j<br>\end{align*}<br>$$<br>它是所有标签分布的预期损失值，<font color='DarkViolet'>是分类问题最常用的损失之一</font></p><h3 id="从信息论看交叉熵"><a href="#从信息论看交叉熵" class="headerlink" title="从信息论看交叉熵"></a>从信息论看交叉熵</h3><h4 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h4><p>信息论的核心思想是量化数据中的信息内容，该数值被称为分布的<strong>熵(entropy)</strong><br>$$<br>H[P] &#x3D; \sum_j - P(j) \log P(j).<br>$$<br>信息论的基本定理之一指出，为了对从分布$p$中随机抽取的数据进行编码，至少需要“$H[P]$纳特(nat)”对其进行编码</p><p>注意，这里的 “纳特”相当于比特(bit)，但是对数底为$e$而非2，1纳特约为1.44比特<br>$$<br>\frac{1}{\log(2)} \approx 1.44<br>$$</p><h4 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h4><p>如果一个数据流很容易预测，那它就很容易压缩</p><p><font color='Violetred'>信息量小 &#x3D; 可预测性强 &#x3D; 可压缩性高</font></p><p>如果不能完全预测每一个事件，有时可能会感到“惊异”，克劳德·香农决定用信息量来量化这种惊异程度</p><p>$$<br>\log \frac{1}{P(j)} &#x3D; -\log P(j)<br>$$<br>在观察一个事件$j$时赋予它主观概率$P(j)$，概率越低惊异会更大，该事件的信息量也就更大</p><p><font color='Violetred'>当考虑所有可能事件时，信息量的期望就是熵</font></p><h4 id="再看交叉熵"><a href="#再看交叉熵" class="headerlink" title="再看交叉熵"></a>再看交叉熵</h4><p>可以把交叉熵想象为“主观概率为$Q$的观察者在看到根据概率$P$生成的数据时的预期惊异”</p><p>当$P&#x3D;Q$时，交叉熵达到最低，在这种情况下，从$P$到$Q$的交叉熵是$H(P, P)&#x3D; H(P)$，没有额外的惊讶</p><p>可以从两方面来考虑交叉熵分类目标：</p><ol><li>最大化观测数据的似然</li><li>最小化传达标签所需的惊异(压缩)</li></ol><h3 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h3><p>计算softmax交叉熵损失的二阶导数，并计算$\mathrm{softmax}(\mathbf{o})$给出的分布方差，并与上面计算的二阶导数匹配</p><p>对梯度再求一次导得到<br>$$<br>\frac{\partial^2 l}{\partial o_i \partial o_j}&#x3D;\frac{\partial}{\partial o_j}\left(\hat y_i-y_i\right)&#x3D;\frac{\partial \hat y_i}{\partial o_j}<br>$$<br>Softmax的导数公式是<br>$$<br>\frac{\partial \hat y_i}{\partial o_j}&#x3D;\hat y_i\left(\delta_{i j}-\hat y_j\right)<br>$$<br>所以二阶导矩阵(Hessian)为<br>$$<br>H_{i j}&#x3D;\hat y_i\left(\delta_{i j}-\hat y_j\right)<br>$$<br>即<br>$$<br>H&#x3D;\operatorname{diag}(\hat{\mathbf{y}})-\hat{\mathbf{y}} \hat{\mathbf{y}}^{\top}<br>$$<br>对于一个类别分布(多项分布)的协方差<br>$$<br>\operatorname{Cov}[\hat{\mathbf{y}}]&#x3D;\operatorname{diag}(\hat{\mathbf{y}})-\hat{\mathbf{y}} \hat{\mathbf{y}}^{\top}<br>$$<br>会发现这正好和上面的 Hessian 完全一样！</p><h2 id="图像分类数据集"><a href="#图像分类数据集" class="headerlink" title="图像分类数据集"></a>图像分类数据集</h2><p>MNIST数据集(LeCun <em>et al.</em>, 1998)是图像分类中广泛使用的数据集之一，但作为基准数据集过于简单，将使用类似但更复杂的Fashion-MNIST数据集 (Xiao <em>et al.</em>, 2017)</p><p>Fashion-MNIST由10个类别的图像组成，每个类别由训练数据集中的6000张图像和测试数据集中的1000张图像组成，因此训练集和测试集分别包含60000和10000张图像</p><p>先导入一部分包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision <span class="comment"># 图像数据 + 图像模型 + 图像处理</span></span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data <span class="comment"># 数据加载接口</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms <span class="comment"># 图像数据预处理与增强</span></span><br></pre></td></tr></table></figure><h3 id="常用数据集"><a href="#常用数据集" class="headerlink" title="常用数据集"></a>常用数据集</h3><p>分类任务数据集(Image Classification)</p><table><thead><tr><th>数据集名称</th><th>用途</th></tr></thead><tbody><tr><td><strong>MNIST</strong></td><td>手写数字识别，灰度图(28×28)</td></tr><tr><td><strong>FashionMNIST</strong></td><td>服装分类任务，灰度图(28×28)</td></tr><tr><td><strong>CIFAR10</strong></td><td>10类彩色小图(32×32)，经典视觉分类</td></tr><tr><td><strong>CIFAR100</strong></td><td>CIFAR10 的扩展(100 类)</td></tr><tr><td><strong>ImageNet</strong></td><td>大规模分类基准，1000 类</td></tr><tr><td><strong>STL10</strong></td><td>类似 CIFAR，但图像更高分辨率(96×96)</td></tr><tr><td><strong>SVHN</strong></td><td>街景数字识别(彩色数字)</td></tr><tr><td><strong>Caltech101 &#x2F; 256</strong></td><td>多种物体类别图像</td></tr></tbody></table><h3 id="读取数据集-2"><a href="#读取数据集-2" class="headerlink" title="读取数据集"></a>读取数据集</h3><p>可以通过框架中的内置函数将Fashion-MNIST数据集下载并读取到内存中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trans = transforms.ToTensor()</span><br><span class="line">mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><code>transforms.ToTensor()</code>：把一张PIL图片(NumPy数组)转换成张量(Tensor)，并把像素值从<code>[0, 255]</code>映射到<code>[0, 1]</code>之间，图像的维度从<code>(H, W, C)</code>变为<code>(C, H, W)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mnist_train[<span class="number">0</span>][<span class="number">0</span>].shape <span class="comment"># torch.Size([1, 28, 28])</span></span><br></pre></td></tr></table></figure><p>Fashion-MNIST中包含的10个类别，以下函数用于在数字标签索引及其文本名称之间进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_fashion_mnist_labels</span>(<span class="params">labels</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回Fashion-MNIST数据集的文本标签&quot;&quot;&quot;</span></span><br><span class="line">    text_labels = [<span class="string">&#x27;t-shirt&#x27;</span>, <span class="string">&#x27;trouser&#x27;</span>, <span class="string">&#x27;pullover&#x27;</span>, <span class="string">&#x27;dress&#x27;</span>, <span class="string">&#x27;coat&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;sandal&#x27;</span>, <span class="string">&#x27;shirt&#x27;</span>, <span class="string">&#x27;sneaker&#x27;</span>, <span class="string">&#x27;bag&#x27;</span>, <span class="string">&#x27;ankle boot&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> [text_labels[<span class="built_in">int</span>(i)] <span class="keyword">for</span> i <span class="keyword">in</span> labels]</span><br></pre></td></tr></table></figure><p>现在可以创建一个函数来可视化这些样本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_images</span>(<span class="params">imgs, num_rows, num_cols, titles=<span class="literal">None</span>, scale=<span class="number">1.5</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制图像列表&quot;&quot;&quot;</span></span><br><span class="line">    figsize = (num_cols * scale, num_rows * scale)</span><br><span class="line">    fig, axes = plt.subplots(num_rows, num_cols, figsize=figsize)</span><br><span class="line">    axes = axes.flatten()</span><br><span class="line">    <span class="keyword">for</span> i, (ax, img) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axes, imgs)):</span><br><span class="line">        <span class="keyword">if</span> torch.is_tensor(img):</span><br><span class="line">            <span class="comment"># 图片张量</span></span><br><span class="line">            ax.imshow(img.numpy())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># PIL图片</span></span><br><span class="line">            ax.imshow(img)</span><br><span class="line">        ax.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> titles:</span><br><span class="line">            ax.set_title(titles[i])</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    <span class="keyword">return</span> axes</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iter() 把它变成迭代器</span></span><br><span class="line"><span class="comment"># next() 取出其中的第一批数据</span></span><br><span class="line">X, y = <span class="built_in">next</span>(<span class="built_in">iter</span>(data.DataLoader(mnist_train, batch_size=<span class="number">18</span>))) </span><br><span class="line"><span class="comment"># 默认情况下X的形状是[18,1,28,28]，但是现在不需要通道1</span></span><br><span class="line">show_images(X.reshape(<span class="number">18</span>, <span class="number">28</span>, <span class="number">28</span>), <span class="number">2</span>, <span class="number">9</span>, titles=get_fashion_mnist_labels(y));</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510152255.png" alt="202510152255" style="zoom: 50%;" /><h3 id="读取小批量"><a href="#读取小批量" class="headerlink" title="读取小批量"></a>读取小批量</h3><p>通过内置数据迭代器，可以随机打乱所有样本，并在每次迭代中读取一小批量数据，大小为<code>batch_size</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_dataloader_workers</span>():  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用4个进程来读取数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">train_iter = data.DataLoader(</span><br><span class="line">    mnist_train,          <span class="comment"># 数据集</span></span><br><span class="line">    batch_size,           <span class="comment"># 每批样本数量</span></span><br><span class="line">    shuffle=<span class="literal">True</span>,         <span class="comment"># 打乱数据顺序(提高泛化性)</span></span><br><span class="line">    num_workers=get_dataloader_workers()  <span class="comment"># 并行加载线程数</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>利用之前定义的定时器类来计时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timer = Timer()</span><br><span class="line"><span class="keyword">for</span> X,y <span class="keyword">in</span> train_iter:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;timer.stop():<span class="number">.2</span>f&#125;</span> seconds&quot;</span>) </span><br><span class="line"><span class="comment"># 4.32 seconds</span></span><br></pre></td></tr></table></figure><h3 id="整合所有组件"><a href="#整合所有组件" class="headerlink" title="整合所有组件"></a>整合所有组件</h3><p>定义<code>load_data_fashion_mnist</code>函数，用于获取和读取Fashion-MNIST数据集</p><p>这个函数返回训练集和验证集的数据迭代器</p><p>此外这个函数还接受一个可选参数<code>resize</code>，用来将图像大小调整为另一种形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_dataloader_workers</span>():  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用4个进程来读取数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_fashion_mnist</span>(<span class="params">batch_size, resize=<span class="literal">None</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载Fashion-MNIST数据集，然后将其加载到内存中&quot;&quot;&quot;</span></span><br><span class="line">    trans = [transforms.ToTensor()]</span><br><span class="line">    <span class="keyword">if</span> resize: <span class="comment"># 如果传入了 resize 参数，先进行一个图像尺寸调整操作</span></span><br><span class="line">        trans.insert(<span class="number">0</span>, transforms.Resize(resize))</span><br><span class="line">    trans = transforms.Compose(trans) <span class="comment"># 把多个图像变换组合成一个整体</span></span><br><span class="line">    mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">        root=<span class="string">&quot;data&quot;</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">    mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">        root=<span class="string">&quot;data&quot;</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 返回两个加载器</span></span><br><span class="line">    <span class="keyword">return</span> (data.DataLoader(mnist_train, batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                            num_workers=get_dataloader_workers()),</span><br><span class="line">            data.DataLoader(mnist_test, batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">                            num_workers=get_dataloader_workers()))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_iter, test_iter = load_data_fashion_mnist(<span class="number">32</span>, resize=<span class="number">64</span>)</span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">    <span class="built_in">print</span>(X.shape, X.dtype, y.shape, y.dtype)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([32, 1, 64, 64]) torch.float32 torch.Size([32]) torch.int64</span><br></pre></td></tr></table></figure><p>如果减少<code>batch_size</code>(如减少到1)是否会影响读取性能？</p><p>当然，会让 I&#x2F;O 频率变高、CPU 多进程效率下降、GPU 并行利用率变差</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">timer = Timer()</span><br><span class="line"><span class="keyword">for</span> bs <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">16</span>,<span class="number">64</span>,<span class="number">256</span>]:</span><br><span class="line">    timer.start()</span><br><span class="line">    train_iter = data.DataLoader(mnist_train, batch_size=bs, shuffle=<span class="literal">True</span>,num_workers=get_dataloader_workers())</span><br><span class="line">    <span class="keyword">for</span> X,y <span class="keyword">in</span> train_iter:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    total_time = timer.stop()  <span class="comment"># 得到这次的总时间</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;batch size: <span class="subst">&#123;bs&#125;</span>, total time: <span class="subst">&#123;total_time:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="softmax回归的底层实现"><a href="#softmax回归的底层实现" class="headerlink" title="softmax回归的底层实现"></a>softmax回归的底层实现</h2><p>使用刚刚引入的Fashion-MNIST数据集，并设置数据迭代器的批量大小为256</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size)</span><br></pre></td></tr></table></figure><h3 id="初始化模型参数-2"><a href="#初始化模型参数-2" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>现在暂时只把每个像素位置看作一个特征，原始数据集中的每个样本都是$28 \times 28$的图像，展平每个图像看作长度为784的向量</p><p>在softmax回归中，输出与类别一样多，所以网络输出维度为10</p><p>权重构建为$784 \times 10$的矩阵，偏置将构成一个$1 \times 10$的行向量，将使用正态分布初始化权重，偏置初始化为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_inputs = <span class="number">784</span></span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">W = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(num_inputs, num_outputs), requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(num_outputs, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="定义softmax"><a href="#定义softmax" class="headerlink" title="定义softmax"></a>定义softmax</h3><p>当调用<code>sum</code>运算符时，可以指定保持在原始张量的轴数，而不折叠求和的维度</p><p>实现softmax由三个步骤组成：</p><ol><li>对每个项求幂(使用<code>exp</code>)</li><li>对每一行求和(小批量中每个样本是一行)，得到每个样本的规范化常数</li><li>将每一行除以其规范化常数，确保结果的和为1</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">X</span>):</span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition  <span class="comment"># 这里应用了广播机制</span></span><br></pre></td></tr></table></figure><p>对于任何随机输入，将每个元素变成一个非负数，并且依据概率原理，每行总和为1</p><p>虽然这在数学上看起来是正确的，但在代码实现中有点草率，矩阵中的非常大或非常小的元素可能造成数值上溢或下溢</p><blockquote><p>因为计算机中并不是用“数学上的实数”，而是用<strong>浮点数</strong>，可表示范围有限，如果x很大或者很小，分子分母都可能出现inf，导致出现NaN，这对于训练神经网络是灾难</p></blockquote><p>如何解决这个问题呢？</p><p>对 softmax 的每一行向量减去它的最大值，不影响结果，却能避免溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">X</span>):</span><br><span class="line">    X_max = X.<span class="built_in">max</span>(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>).values</span><br><span class="line">    X_exp = torch.exp(X - X_max)</span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition</span><br></pre></td></tr></table></figure><p>$$<br>\operatorname{softmax}\left(x_{i}\right)&#x3D;\frac{e^{x_{i}}}{\sum_{j} e^{x_{j}}}&#x3D;\frac{e^{x_{i}-\max (x)}}{\sum_{j} e^{x_{j}-\max (x)}}<br>$$</p><p>数值上完全等价，但避免了 <code>exp(大数)</code> 的爆炸</p><h3 id="定义模型-2"><a href="#定义模型-2" class="headerlink" title="定义模型"></a>定义模型</h3><p>神经网络要求输入是二维的 <code>(batch_size, feature_dim)</code></p><p>将数据传递到模型之前，使用<code>reshape</code>函数将每张原始图像展平为向量</p><p>定义输入如何通过网络映射到输出<br>$$<br>\color{purple} {\hat{\mathbf{y}}} &#x3D; \mathbf{X} \mathbf{w} + b<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">net</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="keyword">return</span> softmax(torch.matmul(X.reshape((-<span class="number">1</span>, W.shape[<span class="number">0</span>])), W) + b)</span><br><span class="line"><span class="comment"># X从 (batch_size, 1, 28, 28) 被展平为 (batch_size, W.shape[0])</span></span><br><span class="line"><span class="comment"># 点乘后矩阵大小为(batch_size, 10)</span></span><br><span class="line"><span class="comment"># b被广播为(batch_size, 10)</span></span><br></pre></td></tr></table></figure><h3 id="定义损失函数-2"><a href="#定义损失函数-2" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><p>引入交叉熵损失函数，深度学习中最常见的损失函数，因为目前分类问题的数量远远超过回归问题的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    <span class="keyword">return</span> - torch.log(y_hat[<span class="built_in">range</span>(<span class="built_in">len</span>(y_hat)), y]) <span class="comment"># 批量索引y_hat[i, y[i]]</span></span><br></pre></td></tr></table></figure><blockquote><p>这里也会出现一个定义问题，假如<code>y_hat</code>(预测概率)非常接近 0，会因为浮点误差导致变成0，出现inf</p></blockquote><p>可以给log加一个小常数避免数值溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    eps = <span class="number">1e-8</span></span><br><span class="line">    <span class="keyword">return</span> -torch.log(y_hat[<span class="built_in">range</span>(<span class="built_in">len</span>(y_hat)), y] + eps)</span><br></pre></td></tr></table></figure><p>这里用到多维索引，一次性指定所有维度的索引，不需要逐层访问</p><h3 id="分类精度"><a href="#分类精度" class="headerlink" title="分类精度"></a>分类精度</h3><p>给定预测概率分布<code>y_hat</code>，必须输出硬预测(hard prediction)时，通常选择预测概率最高的类，分类精度即正确预测数量与总预测数量之比</p><p>虽然直接优化精度可能很困难(因为精度的计算不可导)，但精度通常是最关心的性能衡量标准</p><p>如果<code>y_hat</code>是矩阵，那么假定第二个维度存储每个类的预测分数，使用<code>argmax</code>获得每行中最大元素的索引来获得预测类别，然后将预测类别与真实<code>y</code>元素进行比较</p><p>结果是一个包含0(错)和1(对)的张量，最后求和会得到正确预测的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_hat, y</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算预测正确的数量&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(y_hat.shape) &gt; <span class="number">1</span> <span class="keyword">and</span> y_hat.shape[<span class="number">1</span>] &gt; <span class="number">1</span>: <span class="comment"># 判断是否是多分类概率输出</span></span><br><span class="line">        y_hat = y_hat.argmax(axis=<span class="number">1</span>) <span class="comment"># 取出预测概率最大的类别索引</span></span><br><span class="line">    cmp = y_hat.<span class="built_in">type</span>(y.dtype) == y   <span class="comment"># == 保证数据类型一致</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(cmp.<span class="built_in">type</span>(y.dtype).<span class="built_in">sum</span>())  <span class="comment"># 把bool转为数值求sum，转为float方便后续</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_hat = torch.tensor([[<span class="number">0.1</span>, <span class="number">0.9</span>, <span class="number">0.0</span>], [<span class="number">0.8</span>, <span class="number">0.1</span>, <span class="number">0.1</span>], [<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.4</span>]])</span><br><span class="line">y = torch.tensor([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">accuracy(y_hat, y)  <span class="comment"># 输出3.0，因为都匹配上了</span></span><br></pre></td></tr></table></figure><p>对于任意数据迭代器<code>data_iter</code>可访问的数据集，可以评估在任意模型<code>net</code>的精度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accumulator</span>:  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;在n个变量上累加&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>): <span class="comment"># n表示多少个变量</span></span><br><span class="line">        <span class="variable language_">self</span>.data = [<span class="number">0.0</span>] * n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, *args</span>):  <span class="comment"># *args 允许同时传入多个值，但个数必须等于n</span></span><br><span class="line">        <span class="comment"># zip(self.data, args) 会把当前累计值与新输入配对相加</span></span><br><span class="line">        <span class="variable language_">self</span>.data = [a + <span class="built_in">float</span>(b) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="variable language_">self</span>.data, args)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data = [<span class="number">0.0</span>] * <span class="built_in">len</span>(<span class="variable language_">self</span>.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>): <span class="comment"># 配置索引访问</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[idx]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_accuracy</span>(<span class="params">net, data_iter</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算在指定数据集上模型的精度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, torch.nn.Module): <span class="comment"># 判断 net 是否是 PyTorch 模型</span></span><br><span class="line">        net.<span class="built_in">eval</span>()  <span class="comment"># 将模型设置为评估模式，数值更稳定</span></span><br><span class="line">    metric = Accumulator(<span class="number">2</span>)  <span class="comment"># 正确预测数、预测总数</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment"># 禁用梯度计算</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            <span class="comment"># 累积预测正确数量与样本总数</span></span><br><span class="line">            metric.add(accuracy(net(X), y), y.numel())</span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><p>对于优化函数，使用之前定义的小批量随机梯度下降来优化模型的损失函数，设置学习率为0.1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params, lr, batch_size</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;小批量随机梯度下降&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment"># 以下操作不追踪梯度，优化步骤常用</span></span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            <span class="comment"># param.grad PyTorch 自动计算得到的梯度</span></span><br><span class="line">            param -= lr * param.grad / batch_size</span><br><span class="line">            param.grad.zero_()  <span class="comment"># 清除梯度累积，结尾 _ 表示这是原地操作</span></span><br></pre></td></tr></table></figure><h3 id="训练-2"><a href="#训练-2" class="headerlink" title="训练"></a>训练</h3><p>首先定义一个函数来训练一个迭代周期，<code>updater</code>是更新模型参数的常用函数，它接受批量大小作为参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_epoch_ch3</span>(<span class="params">net, train_iter, loss, updater</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;训练模型一个迭代周期&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将模型设置为训练模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, torch.nn.Module):</span><br><span class="line">        net.train()</span><br><span class="line">    <span class="comment"># 训练损失总和、训练准确度总和、样本数</span></span><br><span class="line">    metric = Accumulator(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">        <span class="comment"># 计算梯度并更新参数</span></span><br><span class="line">        y_hat = net(X)</span><br><span class="line">        l = loss(y_hat, y)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(updater, torch.optim.Optimizer):</span><br><span class="line">            <span class="comment"># 使用PyTorch内置的优化器和损失函数</span></span><br><span class="line">            updater.zero_grad()</span><br><span class="line">            l.mean().backward()</span><br><span class="line">            updater.step()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 使用定制的优化器和损失函数</span></span><br><span class="line">            l.<span class="built_in">sum</span>().backward()</span><br><span class="line">            updater(X.shape[<span class="number">0</span>])</span><br><span class="line">        metric.add(<span class="built_in">float</span>(l.<span class="built_in">sum</span>()), accuracy(y_hat, y), y.numel())</span><br><span class="line">    <span class="comment"># 返回平均训练损失和训练精度</span></span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">2</span>], metric[<span class="number">1</span>] / metric[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>定义一个在动画中绘制数据的类<code>Animator</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animator</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在动画中绘制数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, xlabel=<span class="literal">None</span>, ylabel=<span class="literal">None</span>, legend=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 xlim=<span class="literal">None</span>, ylim=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 xscale=<span class="string">&#x27;linear&#x27;</span>, yscale=<span class="string">&#x27;linear&#x27;</span>,</span></span><br><span class="line"><span class="params">                 fmts=(<span class="params"><span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;m--&#x27;</span>, <span class="string">&#x27;g-.&#x27;</span>, <span class="string">&#x27;r:&#x27;</span></span>),</span></span><br><span class="line"><span class="params">                 nrows=<span class="number">1</span>, ncols=<span class="number">1</span>, figsize=(<span class="params"><span class="number">8</span>, <span class="number">6</span></span>)</span>):</span><br><span class="line">        <span class="comment"># 创建绘图窗口</span></span><br><span class="line">        <span class="keyword">if</span> legend <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            legend = []</span><br><span class="line">        <span class="variable language_">self</span>.fig, <span class="variable language_">self</span>.axes = plt.subplots(nrows, ncols, figsize=figsize)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若只有一个子图，统一处理为列表</span></span><br><span class="line">        <span class="keyword">if</span> nrows * ncols == <span class="number">1</span>:</span><br><span class="line">            <span class="variable language_">self</span>.axes = [<span class="variable language_">self</span>.axes]</span><br><span class="line">        <span class="variable language_">self</span>.X, <span class="variable language_">self</span>.Y, <span class="variable language_">self</span>.fmts = <span class="literal">None</span>, <span class="literal">None</span>, fmts</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 坐标轴设置函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">set_axes</span>():</span><br><span class="line">            ax = <span class="variable language_">self</span>.axes[<span class="number">0</span>]</span><br><span class="line">            ax.set_xlabel(xlabel)</span><br><span class="line">            ax.set_ylabel(ylabel)</span><br><span class="line">            ax.set_xscale(xscale)</span><br><span class="line">            ax.set_yscale(yscale)</span><br><span class="line">            <span class="keyword">if</span> xlim: ax.set_xlim(xlim)</span><br><span class="line">            <span class="keyword">if</span> ylim: ax.set_ylim(ylim)</span><br><span class="line">            <span class="keyword">if</span> legend: ax.legend(legend)</span><br><span class="line">            ax.grid(<span class="literal">True</span>)</span><br><span class="line">        <span class="variable language_">self</span>.config_axes = set_axes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;增量绘制多条曲线&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(y, <span class="string">&quot;__len__&quot;</span>):</span><br><span class="line">            y = [y]</span><br><span class="line">        n = <span class="built_in">len</span>(y)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(x, <span class="string">&quot;__len__&quot;</span>):</span><br><span class="line">            x = [x] * n</span><br><span class="line">        <span class="comment"># 初始化 X, Y 容器</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.X:</span><br><span class="line">            <span class="variable language_">self</span>.X = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.Y:</span><br><span class="line">            <span class="variable language_">self</span>.Y = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 添加数据点</span></span><br><span class="line">        <span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(x, y)):</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> b <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="variable language_">self</span>.X[i].append(a)</span><br><span class="line">                <span class="variable language_">self</span>.Y[i].append(b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;训练结束后绘制最终曲线&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.axes[<span class="number">0</span>].cla()</span><br><span class="line">        <span class="keyword">for</span> x, y, fmt <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="variable language_">self</span>.X, <span class="variable language_">self</span>.Y, <span class="variable language_">self</span>.fmts):</span><br><span class="line">            <span class="variable language_">self</span>.axes[<span class="number">0</span>].plot(x, y, fmt)</span><br><span class="line">        <span class="variable language_">self</span>.config_axes()</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure><p>实现一个训练函数，它会在<code>train_iter</code>访问到的训练数据集上训练一个模型<code>net</code></p><p>该训练函数将会运行多个迭代周期，在每个迭代周期结束时，利用<code>test_iter</code>访问到的测试数据集对模型进行评估，最后利用<code>Animator</code>类来可视化训练过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_ch3</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, updater</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;训练模型&quot;&quot;&quot;</span></span><br><span class="line">    animator = Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], ylim=[<span class="number">0.3</span>, <span class="number">0.9</span>],</span><br><span class="line">                        legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_metrics = train_epoch_ch3(net, train_iter, loss, updater)</span><br><span class="line">        test_acc = evaluate_accuracy(net, test_iter)</span><br><span class="line">        train_loss, train_acc = train_metrics</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;epoch+<span class="number">1</span>:&gt;2d&#125;</span>/<span class="subst">&#123;num_epochs&#125;</span>: &quot;</span></span><br><span class="line">              <span class="string">f&quot;loss=<span class="subst">&#123;train_loss:<span class="number">.4</span>f&#125;</span>, train_acc=<span class="subst">&#123;train_acc:<span class="number">.3</span>f&#125;</span>, test_acc=<span class="subst">&#123;test_acc:<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, train_metrics + (test_acc,))</span><br><span class="line">    train_loss, train_acc = train_metrics</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Final loss <span class="subst">&#123;train_loss:<span class="number">.3</span>f&#125;</span>, train acc <span class="subst">&#123;train_acc:<span class="number">.3</span>f&#125;</span>, test acc <span class="subst">&#123;test_acc:<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    animator.show()  <span class="comment"># 在最后绘图</span></span><br></pre></td></tr></table></figure><p>启动代码部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">lr = <span class="number">0.1</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size)</span><br><span class="line">num_inputs = <span class="number">784</span></span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">W = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(num_inputs, num_outputs), requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(num_outputs, requires_grad=<span class="literal">True</span>)</span><br><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line">train_ch3(net, train_iter, test_iter, cross_entropy, num_epochs, updater)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final loss 0.448, train acc 0.847, test acc 0.830</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510171327.webp" alt="202510171327" style="zoom:67%;" /><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>现在训练已经完成，模型已经准备好对图像进行分类预测</p><p>给定一系列图像将比较它们的实际标签(文本输出的第一行)和模型预测(文本输出的第二行)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict_ch3</span>(<span class="params">net, test_iter, n=<span class="number">6</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;预测标签&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> test_iter:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    trues = get_fashion_mnist_labels(y)</span><br><span class="line">    preds = get_fashion_mnist_labels(net(X).argmax(axis=<span class="number">1</span>))</span><br><span class="line">    titles = [true +<span class="string">&#x27;\n&#x27;</span> + pred <span class="keyword">for</span> true, pred <span class="keyword">in</span> <span class="built_in">zip</span>(trues, preds)]</span><br><span class="line">    show_images(</span><br><span class="line">        X[<span class="number">0</span>:n].reshape((n, <span class="number">28</span>, <span class="number">28</span>)), <span class="number">1</span>, n, titles=titles[<span class="number">0</span>:n])</span><br><span class="line"></span><br><span class="line">predict_ch3(net, test_iter)  <span class="comment"># 刚刚已经训练好模型的w和b了，直接调用即可</span></span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510171334.webp" alt="202510171334" style="zoom: 80%;" /><p>训练softmax回归循环模型与训练线性回归模型非常相似：先读取数据，再定义模型和损失函数，然后使用优化算法训练模型，大多数常见的深度学习模型都有类似的训练过程</p><h3 id="练习题-3"><a href="#练习题-3" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>返回概率最大的分类标签总是最优解吗？例如，医疗诊断场景下可以这样做吗？</p><p>softmax 只考虑“哪个更可能”，却不知道“这个决策带来的后果”，所以这些领域往往要引入<strong>阈值决策(decision threshold)</strong>，而不是简单地取 <code>argmax</code></p></li><li><p>假设使用softmax回归来预测下一个单词，可选取的单词数目过多可能会带来哪些问题?</p><table><thead><tr><th>问题类别</th><th>产生原因</th><th>后果</th><th>解决方法</th></tr></thead><tbody><tr><td>计算量爆炸</td><td>词表太大，每次都要算所有词的 exp</td><td>训练极慢</td><td>Hierarchical Softmax, Sampled Softmax</td></tr><tr><td>数值不稳定</td><td>exp(大数) 溢出, exp(小数) 下溢</td><td>NaN、梯度消失</td><td>减最大值、Log-Softmax</td></tr><tr><td>内存消耗高</td><td>最后一层参数量随词表线性增长</td><td>显存不足</td><td>参数分片、低秩分解、稀疏更新</td></tr><tr><td>模型不平衡</td><td>高频词梯度主导</td><td>泛化差</td><td>采样修正、词频平衡</td></tr></tbody></table></li></ol><h2 id="softmax回归的简洁实现"><a href="#softmax回归的简洁实现" class="headerlink" title="softmax回归的简洁实现"></a>softmax回归的简洁实现</h2><p>通过深度学习框架的高级API也能更方便地实现softmax回归模型，继续使用Fashion-MNIST数据集，并保持批量大小为256</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size)</span><br></pre></td></tr></table></figure><h3 id="初始化模型参数-3"><a href="#初始化模型参数-3" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>softmax回归的输出层是一个全连接层，为了实现模型，只需在<code>Sequential</code>中添加一个带有10个输出的全连接层，仍然以均值0和标准差0.01随机初始化权重</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PyTorch不会隐式地调整输入的形状</span></span><br><span class="line"><span class="comment"># 因此在线性层前定义了展平层(flatten)，来调整网络输入的形状</span></span><br><span class="line">net = nn.Sequential(nn.Flatten(), nn.Linear(<span class="number">784</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights)</span><br></pre></td></tr></table></figure><h3 id="softmax的实现"><a href="#softmax的实现" class="headerlink" title="softmax的实现"></a>softmax的实现</h3><p>在底层实现时考虑到可以从所有$o_k$中减去$\max(o_k)$避免上溢，这是可行的，但是可能$o_j - \max(o_k)$具有较大的负值，$\exp(o_j - \max(o_k))$可能会出现下溢的情况，使得$\log(\hat y_j)$为-inf</p><p>通过将softmax和交叉熵结合在一起，可以避免反向传播过程中可能会困扰的数值稳定性问题<br>$$<br>\begin{split}\begin{aligned}<br>\log{(\hat y_j)} &amp; &#x3D; \log\left( \frac{\exp(o_j - \max(o_k))}{\sum_k \exp(o_k - \max(o_k))}\right) \\<br>&amp; &#x3D; \log{(\exp(o_j - \max(o_k)))}-\log{\left( \sum_k \exp(o_k - \max(o_k)) \right)} \\<br>&amp; &#x3D; o_j - \max(o_k) -\log{\left( \sum_k \exp(o_k - \max(o_k)) \right)}.<br>\end{aligned}\end{split}<br>$$<br>这样就没有将softmax概率传递到损失函数中，而是在交叉熵损失函数中传递未规范化的预测，在同一过程中同时得到 softmax 和它的对数，以避免数值溢出并提高计算效率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="优化算法-1"><a href="#优化算法-1" class="headerlink" title="优化算法"></a>优化算法</h3><p>使用学习率为0.1的小批量随机梯度下降作为优化算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><h3 id="训练-3"><a href="#训练-3" class="headerlink" title="训练"></a>训练</h3><p>训练函数仍用之前定义的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line">train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)</span><br></pre></td></tr></table></figure><p>和以前一样，这个算法使结果收敛到一个相当高的精度，而且这次的代码比之前更精简了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final loss 0.448, train acc 0.849, test acc 0.811</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510171427.webp" alt="202510171427" style="zoom:67%;" /><p>在图上会发现一个现象，第10轮的精度比第9轮的下降了，意味着模型已经开始拟合噪声，而非通用特征，也就是常说的<strong>过拟合(overfitting)</strong></p><p>在这个例子中Fashion-MNIST并不是很复杂，使用的模型参数却有784个，网络太过复杂化，就容易陷入过拟合</p><p>过拟合的解决在多层感知机部分讲解</p>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习预备知识</title>
      <link href="/posts/48513.html"/>
      <url>/posts/48513.html</url>
      
        <content type="html"><![CDATA[<p>学习路径按照 <a href="https://zh.d2l.ai/index.html">《动手学深度学习》</a></p><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p><strong>数字</strong></p><ul><li>$x$ ：标量</li><li>$\mathbf{x}$ ：向量</li><li>$\mathbf{X}$ ：矩阵</li><li>$\mathsf{X}$：张量</li><li>$\mathrm{I}$：单位矩阵</li><li>$x_i,[\mathbf{x}]_i$ ：向量 $\mathbf{x}$ 第 $i$ 个元素</li><li>$x_{i j},[\mathbf{X}]_{i j}$ ：矩阵 $\mathbf{X}$ 第 $i$ 行第 $j$ 列的元素</li></ul><p><strong>集合论</strong></p><ul><li>$\mathcal{X}$ ：集合</li><li>$\mathbb{Z}$ ：整数集合</li><li>$\mathbb{R}$ ：实数集合</li><li>$\mathbb{R}^n: n$ 维实数向量集合</li><li>$\mathbb{R}^{a \times b}$ ：包含 $a$ 行和 $b$ 列的实数矩阵集合</li><li>$\mathcal{A} \cup \mathcal{B}$ ：集合 $\mathcal{A}$ 和 $\mathcal{B}$ 的并集</li><li>$\mathcal{A} \cap \mathcal{B}$ ：集合 $\mathcal{A}$ 和 $\mathcal{B}$ 的交集</li><li>$\mathcal{A} \backslash \mathcal{B}$ ：集合 $\mathcal{A}$ 与集合 $\mathcal{B}$ 相减， $\mathcal{B}$ 关于 $\mathcal{A}$ 的相对补集</li></ul><p><strong>函数和运算符</strong></p><ul><li>$f(\cdot)$ ：函数</li><li>$\log (\cdot)$ ：自然对数</li><li>$\exp (\cdot)$ ：指数函数</li><li>$\mathbf{1}_{\boldsymbol{\chi}}$ ：指示函数</li><li>$(\cdot)^{\top}$ ：向量或矩阵的转置</li><li>$\mathbf{X}^{-1}$ ：矩阵的逆</li><li>$\odot$ ：按元素相乘</li><li>$[\cdot, \cdot]$ ：连结</li><li>$|\mathcal{X}|$ ：集合的基数</li><li>$|\cdot|_p: L_p$ 正则</li><li>$|\cdot|: L_2$ 正则</li><li>$\langle\mathbf{x}, \mathbf{y}\rangle$ ：向量 $\mathbf{x}$ 和 $\mathbf{y}$ 的点积</li><li>$\sum$ ：连加</li><li>$\Pi $：连乘 </li><li>$\stackrel{\mathrm{def}}{&#x3D;}$：定义</li></ul><p><strong>微积分</strong></p><ul><li>$\frac{d y}{d x}$ ：$y$ 关于 $x$ 的导数</li><li>$\frac{\partial y}{\partial x}$ ：$y$ 关于 $x$ 的偏导数</li><li>$\nabla_{\mathbf{x}} y$ ：$y$ 关于向量 $\mathbf{x}$ 的梯度</li><li>$\int_a^b f(x) d x$ ：$f$ 在 $a$ 到 $b$ 区间上关于 $x$ 的定积分</li><li>$\int f(x) d x$ ：$f$ 关于 $x$ 的不定积分</li></ul><p><strong>概率与信息论</strong></p><ul><li>$P(\cdot)$ ：概率分布</li><li>$z \sim P$ ：随机变量 $z$ 具有概率分布 $P$</li><li>$P(X \mid Y): X \mid Y$ 的条件概率</li><li>$p(x)$ ：概率密度函数</li><li>$E_x[f(x)]$ ：函数 $f$ 对 $x$ 的数学期望</li><li>$X \perp Y$ ：随机变量 $X$ 和 $Y$ 是独立的</li><li>$X \perp Y \mid Z$ ：随机变量 $X$ 和 $Y$ 在给定随机变量 $Z$ 的条件下是独立的</li><li>$\operatorname{Var}(X)$ ：随机变量 $X$ 的方差</li><li>$\sigma_X$ ：随机变量 $X$ 的标准差</li><li>$\operatorname{Cov}(X, Y)$ ：随机变量 $X$ 和 $Y$ 的协方差</li><li>$\rho(X, Y)$ ：随机变量 $X$ 和 $Y$ 的相关性</li><li>$H(X)$ ：随机变量 $X$ 的熵</li><li>$D_{\mathrm{KL}}(P | Q): P$ 和 $Q$ 的KL－散度</li></ul><p><strong>复杂度</strong></p><ul><li>$\mathcal{O}$ ：大 O 标记</li></ul><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><p>这一部分和numpy很相像，但不同的是用torch来实现</p><p>张量表示一个由数值组成的数组，这个数组可能有多个维度</p><ul><li><p>具有一个轴的张量对应数学上的<strong>向量(vector)</strong></p></li><li><p>具有两个轴的张量对应数学上的<strong>矩阵(matrix)</strong></p></li><li><p>具有两个轴以上的张量没有特殊的数学名称</p></li></ul><p>和numpy的写法基本一致，具体的回头看<a href="/posts/60233.html" title="python基础">python基础</a></p><p>创建一个行向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br></pre></td></tr></table></figure><p>可以通过<code>shape</code>来访问张量(沿每个轴的长度)的形状，如果想要知道张量中元素的总数，需要通过<code>numel()</code>来访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.shape</span><br><span class="line">x.numel()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([12])</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>可以通过<code>cat</code>来实现多个张量**连结(concatenate)**在一起，只需要提供张量列表，并给出沿哪个轴连结(0为列，1为行)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">12</span>, dtype=torch.<span class="built_in">float</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">Y = torch.tensor([[<span class="number">2.0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">torch.cat((X,Y),dim=<span class="number">0</span>),torch.cat((X,Y),dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(tensor([[ 0.,  1.,  2.,  3.],</span><br><span class="line">         [ 4.,  5.,  6.,  7.],</span><br><span class="line">         [ 8.,  9., 10., 11.],</span><br><span class="line">         [ 2.,  1.,  4.,  3.],</span><br><span class="line">         [ 1.,  2.,  3.,  4.],</span><br><span class="line">         [ 4.,  3.,  2.,  1.]]),</span><br><span class="line"> tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],</span><br><span class="line">         [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],</span><br><span class="line">         [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]]))</span><br></pre></td></tr></table></figure><h3 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h3><p>即使形状不同，仍然可以通过调用**广播机制(broadcasting mechanism)**来执行按元素操作</p><p>工作方式如下：</p><ol><li>通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状；</li><li>对生成的数组执行按元素操作</li></ol><p>在大多数情况下将沿着数组中长度为1的轴进行广播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">a + b</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tensor([[0, 1],</span><br><span class="line">        [1, 2],</span><br><span class="line">        [2, 3]])</span><br></pre></td></tr></table></figure><h3 id="节省内存"><a href="#节省内存" class="headerlink" title="节省内存"></a>节省内存</h3><p>运行一些操作可能会导致为新结果分配内存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before = <span class="built_in">id</span>(Y)</span><br><span class="line">Y = Y + X</span><br><span class="line"><span class="built_in">id</span>(Y) == before <span class="comment"># 输出False</span></span><br></pre></td></tr></table></figure><p>主要是因为py自发会创造新地址</p><p>在机器学习中可能有数百兆的参数，并且在一秒内多次更新所有参数，通常情况下希望原地执行这些更新；如果不原地更新，其他引用仍然会指向旧的内存位置，可以导致旧参数的引用</p><p><font color='Violetred'>可以使用切片表示&#x2F;复合赋值将操作的结果分配给先前分配的数组</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = torch.zeros_like(Y)  <span class="comment"># 假设Z之前已经被创造</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(Z):&#x27;</span>, <span class="built_in">id</span>(Z))</span><br><span class="line">Z[:] = X + Y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(Z):&#x27;</span>, <span class="built_in">id</span>(Z))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id(Z): 1655337054096</span><br><span class="line">id(Z): 1655337054096</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before = <span class="built_in">id</span>(Y)</span><br><span class="line">Y += X</span><br><span class="line"><span class="built_in">id</span>(Y) == before <span class="comment"># 输出True</span></span><br></pre></td></tr></table></figure><h3 id="转化为其它对象"><a href="#转化为其它对象" class="headerlink" title="转化为其它对象"></a>转化为其它对象</h3><p>PyTorch <code>tensor</code> 和 NumPy <code>ndarray</code> 相互转化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">n = t.numpy()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">t = torch.from_numpy(n)</span><br></pre></td></tr></table></figure><p>转化后torch张量和numpy数组将共享底层内存，就地操作更改一个张量也会同时更改另一个张量</p><p><code>tensor</code>可以调用<code>item</code>函数转为标量或利用Python内置转化函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">3.5</span>])</span><br><span class="line">a, a.item(), <span class="built_in">float</span>(a), <span class="built_in">int</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensor([3.5000]), 3.5, 3.5, 3)</span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>在Python中常用的数据分析工具中，通常使用<code>pandas</code>，可以与张量兼容</p><h3 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h3><p>首先创建一个人工数据集，并存储在CSV(逗号分隔值)文件 <code>./data/house_tiny.csv</code>中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.makedirs(<span class="string">&quot;data&quot;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">&#x27;data&#x27;</span>,<span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="comment"># 列名</span></span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="comment"># 每行表示一个数据样本</span></span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>要从创建的CSV文件中加载原始数据集，导入<code>pandas</code>包并调用<code>read_csv</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   NumRooms Alley   Price</span><br><span class="line">0       NaN  Pave  127500</span><br><span class="line">1       2.0   NaN  106000</span><br><span class="line">2       4.0   NaN  178100</span><br><span class="line">3       NaN   NaN  140000</span><br></pre></td></tr></table></figure><h3 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h3><p><font color='DarkViolet'>“NaN”项代表缺失值</font>，为了处理缺失的数据，典型的方法包括插值法和删除法，其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值</p><p>这里使用插值法(不然没数据了都)，通过位置索引<code>iloc</code>，将<code>data</code>分成<code>inputs</code>和<code>outputs</code>，其中前者为<code>data</code>的前两列，而后者为<code>data</code>的最后一列</p><p>对于<code>inputs</code>中NumRooms缺少的数值，用同一列的均值替换“NaN”项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inputs, outputs = data.iloc[:,<span class="number">0</span>:<span class="number">2</span>], data.iloc[:,<span class="number">2</span>]</span><br><span class="line">inputs = inputs.fillna(inputs.mean(numeric_only=<span class="literal">True</span>)) <span class="comment"># 要加上numeric_only，不然报错</span></span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure><p>对于<code>inputs</code>中“巷子类型”(“Alley”)列，只接受两种类型的类别值“Pave”和“NaN”，<code>pandas</code>可以把字符串换为独热编码(one-hot encoding)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputs = pd.get_dummies(inputs,dummy_na=<span class="literal">True</span>) <span class="comment"># 把字符串换为独热编码(one-hot encoding)</span></span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   NumRooms  Alley_Pave  Alley_nan</span><br><span class="line">0       3.0        True      False</span><br><span class="line">1       2.0       False       True</span><br><span class="line">2       4.0       False       True</span><br><span class="line">3       3.0       False       True</span><br></pre></td></tr></table></figure><h3 id="转换为张量格式"><a href="#转换为张量格式" class="headerlink" title="转换为张量格式"></a>转换为张量格式</h3><p>现在<code>inputs</code>和<code>outputs</code>中的所有条目都是数值类型，它们可以转换为张量格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先从pandas对象转为numpy对象，保证浮点数，再转为tensor</span></span><br><span class="line">X = torch.tensor(inputs.to_numpy(dtype=<span class="built_in">float</span>))</span><br><span class="line">Y = torch.tensor(outputs.to_numpy(dtype=<span class="built_in">float</span>))</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[3., 1., 0.],</span><br><span class="line">        [2., 0., 1.],</span><br><span class="line">        [4., 0., 1.],</span><br><span class="line">        [3., 0., 1.]], dtype=torch.float64)</span><br><span class="line">tensor([127500., 106000., 178100., 140000.], dtype=torch.float64)</span><br></pre></td></tr></table></figure><h3 id="删除缺失值最多的列"><a href="#删除缺失值最多的列" class="headerlink" title="删除缺失值最多的列"></a>删除缺失值最多的列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">drop_col</span>(<span class="params">data</span>):</span><br><span class="line">    num = data.isna().<span class="built_in">sum</span>() <span class="comment"># 统计每列的缺失值数量</span></span><br><span class="line">    col_to_drop = num.idxmax() <span class="comment"># 找出缺失最多的列名</span></span><br><span class="line">    data = data.drop(columns=[col_to_drop]) <span class="comment"># 删除对应列</span></span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="comment"># return data</span></span><br></pre></td></tr></table></figure><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p>仅包含一个数值被称为<strong>标量(scalar)</strong>，标量由只有一个元素的张量表示</p><p>采用了数学表示法，其中标量变量由普通小写字母表示(例如，$x,y$和$z$),用$\mathbb{R}$表示所有(连续)实数标量的空间</p><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>向量可以被视为标量值组成的列表，标量值被称为向量的<strong>元素(element)<strong>或</strong>分量(component)</strong></p><p>在数学表示法中，<font color='DarkViolet'>向量通常记为粗体、小写的符号</font>(例如，$\mathbf{x},\mathbf{y}$和$\mathbf{z}$)</p><p>通过一维张量表示向量，一般来说，张量可以具有任意长度，取决于机器的内存限制</p><p>类似于普通的Python数组</p><p>长度：<code>len(x)</code>，对于一个二阶及以上张量，<code>len</code>只会输出其第0个维度大小</p><p>形状：<code>x.shape</code></p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><font color='DarkViolet'>矩阵通常用粗体、大写字母来表示</font>(例如$\mathbf{X},\mathbf{Y},\mathbf{Z}$)，在代码中表示为具有两个轴的张量</p><p>数学表示法使$\mathbf{A} \in \mathbb{R}^{m \times n}$来表示矩阵$\mathbf{A}$，其由$m$行和$n$列的实值标量组成<br>$$<br>\begin{split}\mathbf{A}^\top &#x3D;<br>\begin{bmatrix}<br>    a_{11} &amp; a_{21} &amp; \dots  &amp; a_{m1} \\<br>    a_{12} &amp; a_{22} &amp; \dots  &amp; a_{m2} \\<br>    \vdots &amp; \vdots &amp; \ddots  &amp; \vdots \\<br>    a_{1n} &amp; a_{2n} &amp; \dots  &amp; a_{mn}<br>\end{bmatrix}\end{split}<br>$$<br>行列数相等的矩阵被称为<strong>方阵(square matrix)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>).reshape(<span class="number">5</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 0,  1,  2,  3],</span><br><span class="line">        [ 4,  5,  6,  7],</span><br><span class="line">        [ 8,  9, 10, 11],</span><br><span class="line">        [12, 13, 14, 15],</span><br><span class="line">        [16, 17, 18, 19]])</span><br></pre></td></tr></table></figure><p>交换矩阵的行和列称为矩阵的<strong>转置(transpose)</strong>，通常用$\mathbf{a}^\top$来表示矩阵的转置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.T</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 0,  4,  8, 12, 16],</span><br><span class="line">        [ 1,  5,  9, 13, 17],</span><br><span class="line">        [ 2,  6, 10, 14, 18],</span><br><span class="line">        [ 3,  7, 11, 15, 19]])</span><br></pre></td></tr></table></figure><p>如果$\mathbf{B}&#x3D;\mathbf{A}^\top$，则对于任意$i$和$j$，都有$b_{ij}&#x3D;a_{ji}$</p><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><p>张量是描述具有任意数量轴的$n$维数组的通用方法，向量是一阶张量，矩阵是二阶张量</p><p><font color='DarkViolet'>张量用特殊字体的大写字母表示</font>(例如$\mathsf{X},\mathsf{Y},\mathsf{Z}$)，索引机制与矩阵类似</p><p>图像以$n$维数组形式出现，其中3个轴对应于高度、宽度，以及一个通道(channel)轴，用于表示颜色通道(红色、绿色和蓝色)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tensor([[[ 0,  1,  2,  3],</span><br><span class="line">         [ 4,  5,  6,  7],</span><br><span class="line">         [ 8,  9, 10, 11]],</span><br><span class="line"></span><br><span class="line">        [[12, 13, 14, 15],</span><br><span class="line">         [16, 17, 18, 19],</span><br><span class="line">         [20, 21, 22, 23]]])</span><br></pre></td></tr></table></figure><h3 id="Hadamard积"><a href="#Hadamard积" class="headerlink" title="Hadamard积"></a>Hadamard积</h3><p>任何按元素的一元运算都不会改变其操作数的形状</p><p>给定具有相同形状的任意两个张量，任何按元素二元运算的结果都将是相同形状的张量</p><p><font color='Violetred'>两个矩阵的按元素乘法称为Hadamard积</font><strong>(Hadamard product)</strong>(数学符号$\odot$)</p><blockquote><p>要和后面的点积区分开来，点积更像是线性代数课程上讲的矩阵乘法，Hadamard积是矩阵元素的操作</p></blockquote><p>矩阵$\mathbf{A}$和$\mathbf{B}$的Hadamard积为<br>$$<br>\begin{split}\mathbf{A} \odot \mathbf{B} &#x3D;<br>\begin{bmatrix}<br>    a_{11}  b_{11} &amp; a_{12}  b_{12} &amp; \dots  &amp; a_{1n}  b_{1n} \\<br>    a_{21}  b_{21} &amp; a_{22}  b_{22} &amp; \dots  &amp; a_{2n}  b_{2n} \\<br>    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>    a_{m1}  b_{m1} &amp; a_{m2}  b_{m2} &amp; \dots  &amp; a_{mn}  b_{mn}<br>\end{bmatrix}\end{split}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = A.clone()</span><br><span class="line">A*B</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[  0,   1,   4,   9],</span><br><span class="line">        [ 16,  25,  36,  49],</span><br><span class="line">        [ 64,  81, 100, 121],</span><br><span class="line">        [144, 169, 196, 225],</span><br><span class="line">        [256, 289, 324, 361]])</span><br></pre></td></tr></table></figure><h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><p>对任意张量进行的一个有用的操作是计算其元素的和</p><p>数学表示法使用符号$\sum$表示求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.shape, A.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(torch.Size([5, 4]), tensor(190.))</span><br></pre></td></tr></table></figure><p>默认情况下，调用求和函数会沿所有的轴降低张量的维度，使它变为一个标量，还可以指定张量沿哪一个轴来通过求和降低维度</p><p>为了通过求和所有行的元素来降维(轴0)，可以在调用函数时指定<code>axis=0</code>， 由于输入矩阵沿0轴降维以生成输出向量，因此输入轴0的维数在输出形状中消失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A_sum_axis0 = A.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">A_sum_axis0, A_sum_axis0.shape</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensor([40, 45, 50, 55]), torch.Size([4]))</span><br></pre></td></tr></table></figure><p>为什么是这个结果呢，因为0轴(行轴)降维，各行的元素被累加压缩，所以输出的每个元素是行元素相加的结果</p><p>同理，指定<code>axis=1</code>将通过汇总所有列的元素降维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A_sum_axis1 = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">A_sum_axis1, A_sum_axis1.shape</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensor([ 6., 22., 38., 54., 70.]), torch.Size([5]))</span><br></pre></td></tr></table></figure><blockquote><p>注意结果，因为降维了，没有行的概念，从想法上列压缩，剩下的是行，但其实最后的结果是一维张量</p></blockquote><p>axis可以输入多个轴，对于二阶向量输入<code>[0,1]</code>等价于对矩阵的所有元素进行求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="built_in">sum</span>(axis=[<span class="number">0</span>, <span class="number">1</span>])  <span class="comment"># 结果和A.sum()相同</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor(190.)</span><br></pre></td></tr></table></figure><p><strong>平均值(mean或average)</strong>，通过将总和除以元素总数来计算平均值，也可以指定轴</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.mean(), A.<span class="built_in">sum</span>() / A.numel()  <span class="comment"># 所有元素平均值</span></span><br><span class="line">A.mean(axis=<span class="number">0</span>), A.<span class="built_in">sum</span>(axis=<span class="number">0</span>) / A.shape[<span class="number">0</span>]  <span class="comment"># 行平均值</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(tensor(9.5000), tensor(9.5000))</span><br><span class="line">(tensor([ 8.,  9., 10., 11.]), tensor([ 8.,  9., 10., 11.]))</span><br></pre></td></tr></table></figure><h4 id="非降维求和"><a href="#非降维求和" class="headerlink" title="非降维求和"></a>非降维求和</h4><p>有时在调用函数来计算总和或均值时保持轴数不变会很有用，加入<code>keepdims</code>参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum_A = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">sum_A</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 6.],</span><br><span class="line">        [22.],</span><br><span class="line">        [38.],</span><br><span class="line">        [54.],</span><br><span class="line">        [70.]])</span><br></pre></td></tr></table></figure><p>由于<code>sum_A</code>在对每行进行求和后仍保持两个轴，可以通过广播将<code>A</code>除以<code>sum_A</code>，实现对每行元素除以行平均数，如果没有<code>keepdims</code>将报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A / sum_A</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[0.0000, 0.1667, 0.3333, 0.5000],</span><br><span class="line">        [0.1818, 0.2273, 0.2727, 0.3182],</span><br><span class="line">        [0.2105, 0.2368, 0.2632, 0.2895],</span><br><span class="line">        [0.2222, 0.2407, 0.2593, 0.2778],</span><br><span class="line">        [0.2286, 0.2429, 0.2571, 0.2714]])</span><br></pre></td></tr></table></figure><p>如果想沿某个轴计算<code>A</code>元素的累积总和，可以调用<code>cumsum</code>函数，不会沿任何轴降低输入张量的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.cumsum(axis=<span class="number">0</span>) <span class="comment"># 按行计算</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 0.,  1.,  2.,  3.],</span><br><span class="line">        [ 4.,  6.,  8., 10.],</span><br><span class="line">        [12., 15., 18., 21.],</span><br><span class="line">        [24., 28., 32., 36.],</span><br><span class="line">        [40., 45., 50., 55.]])</span><br></pre></td></tr></table></figure><h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h3><p>给定两个向量$\mathbf{x},\mathbf{y}\in\mathbb{R}^d$，<strong>点积(dot product)</strong>$\mathbf{x}^\top\mathbf{y} $(或$\langle\mathbf{x},\mathbf{y}\rangle$) 是相同位置的按元素乘积的和<br>$$<br>\mathbf{x}^\top \mathbf{y} &#x3D; \sum_{i&#x3D;1}^{d} x_i y_i<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>,dtype=torch.float32)</span><br><span class="line">y = torch.ones(<span class="number">4</span>,dtype=torch.float32)</span><br><span class="line">x, y, x@y</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensor([0., 1., 2., 3.]), tensor([1., 1., 1., 1.]), tensor(6.))</span><br></pre></td></tr></table></figure><p>点积在很多场合都很有用，给定一组由向量$\mathbf{x} \in \mathbb{R}^d$表示的值，和一组由$\mathbf{w} \in \mathbb{R}^d$表示的权重，$\mathbf{x}$中的值根据权重$\mathbf{w}$的加权和，可以表示为点积$\mathbf{x}^\top \mathbf{w}$</p><p>当权重为非负数且和为1$\left(\sum_{i&#x3D;1}^{d}{w_i}&#x3D;1\right)$，点积表示<strong>加权平均(weighted average)</strong></p><p>将两个向量规范化得到单位长度后，点积表示它们夹角的余弦</p><h3 id="矩阵-向量积"><a href="#矩阵-向量积" class="headerlink" title="矩阵-向量积"></a>矩阵-向量积</h3><p>之前定义的$\mathbf{A} \in \mathbb{R}^{m \times n}$和向量$\mathbf{x} \in \mathbb{R}^n$，将矩阵$\mathbf{A}$用它的行向量表示<br>$$<br>\begin{split}\mathbf{A}&#x3D;<br>\begin{bmatrix}<br>\mathbf{a}^\top_{1} \\<br>\mathbf{a}^\top_{2} \\<br>\vdots \\<br>\mathbf{a}^\top_m \\<br>\end{bmatrix}\end{split}<br>$$<br>其中每个$\mathbf{a}^\top_{i} \in \mathbb{R}^n$都是行向量，表示矩阵的第$i$行，矩阵向量积是一个长度为$m$的列向量，其第$i$个元素是点积$\mathbf{a}^\top_i \mathbf{x}$</p><blockquote><p>在深度学习中一般把以列向量为准，转置符号表示这是一个行向量，这样就很容易思考了</p></blockquote><p>$$<br>\begin{split}\mathbf{A}\mathbf{x}<br>&#x3D; \begin{bmatrix}<br>\mathbf{a}^\top_{1} \\<br>\mathbf{a}^\top_{2} \\<br>\vdots \\<br>\mathbf{a}^\top_m \<br>\end{bmatrix}\mathbf{x}<br>&#x3D; \begin{bmatrix}<br> \mathbf{a}^\top_{1} \mathbf{x}  \\<br> \mathbf{a}^\top_{2} \mathbf{x} \\<br>\vdots\\<br> \mathbf{a}^\top_{m} \mathbf{x}\<br>\end{bmatrix}\end{split}<br>$$<br>可以把一个矩阵$\mathbf{A} \in \mathbb{R}^{m \times n}$乘法看作一个从$\mathbb{R}^{n}$到$\mathbb{R}^{m}$向量的转换，这些转换是非常有用的，例如可以用方阵的乘法来表示旋转</p><p>在代码中**矩阵-向量积(matrix–vector product)**使用<code>mv</code>函数表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.mv(input, vec) → Tensor</span><br></pre></td></tr></table></figure><ul><li><p><code>input</code> 必须是二维张量(shape &#x3D; <code>(m, n)</code>)</p></li><li><p><code>vec</code> 必须是一维张量(shape &#x3D; <code>(n,)</code>)</p></li><li><p>返回结果是一个一维张量(shape &#x3D; <code>(m,)</code>)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y = torch.mv(A, x) <span class="comment"># 要求输入的数据类型相同</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([14, 32])</span><br></pre></td></tr></table></figure><p>$$<br>\left[\begin{array}{lll}<br>1 &amp; 2 &amp; 3 \\<br>4 &amp; 5 &amp; 6<br>\end{array}\right]\left[\begin{array}{l}<br>1 \\<br>2 \\<br>3<br>\end{array}\right]&#x3D;\left[\begin{array}{l}<br>1 \times 1+2 \times 2+3 \times 3 \\<br>4 \times 1+5 \times 2+6 \times 3<br>\end{array}\right]&#x3D;\left[\begin{array}{l}<br>14 \\<br>32<br>\end{array}\right]<br>$$</p><h3 id="矩阵-矩阵乘法"><a href="#矩阵-矩阵乘法" class="headerlink" title="矩阵-矩阵乘法"></a>矩阵-矩阵乘法</h3><p>假设有两个矩阵$\mathbf{A} \in \mathbb{R}^{n \times k}$ 和 $\mathbf{B} \in \mathbb{R}^{k \times m}$<br>$$<br>\begin{split}\mathbf{A}&#x3D;\begin{bmatrix}<br> a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1k} \\<br> a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2k} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br> a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nk} \\<br>\end{bmatrix},\quad<br>\mathbf{B}&#x3D;\begin{bmatrix}<br> b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1m} \\<br> b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2m} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br> b_{k1} &amp; b_{k2} &amp; \cdots &amp; b_{km} \\<br>\end{bmatrix}.\end{split}<br>$$<br>用行向量$\mathbf{a}^\top_{i} \in \mathbb{R}^k$表示矩阵$\mathbf{A}$的第$i$行，并让列向量$\mathbf{b}_{j} \in \mathbb{R}^k$作为矩阵$\mathbf{B}$的第$j$列</p><p>要生成矩阵积$\mathbf{C} &#x3D; \mathbf{A}\mathbf{B}$，最简单的方法是考虑$\mathbf{A}$的行向量和$\mathbf{B}$的列向量，$\mathbf{B}&#x3D;<br>\begin{bmatrix}<br>\mathbf{b}_1 &amp; \mathbf{b}_2 &amp; \cdots &amp; \mathbf{b}_m<br>\end{bmatrix}$</p><p>将每个元素$c_{ij}$计算为点积$\mathbf{a}^\top_i \mathbf{b}_j$</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-10-12_15-00-44.webp" alt="Snipaste_2025-10-12_15-00-44" style="zoom: 67%;" /><p>将矩阵-矩阵乘法看作简单地执行$m$次矩阵-向量积，并将结果拼接在一起，形成一个$n \times m$矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>).reshape((<span class="number">5</span>,<span class="number">4</span>)).<span class="built_in">float</span>()</span><br><span class="line">B = torch.ones(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">torch.mm(A,B)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 6.,  6.,  6.],</span><br><span class="line">        [22., 22., 22.],</span><br><span class="line">        [38., 38., 38.],</span><br><span class="line">        [54., 54., 54.],</span><br><span class="line">        [70., 70., 70.]])</span><br></pre></td></tr></table></figure><p><font color='Violetred'>要与Hadamard积区别开，矩阵乘法并不是按元素乘法</font></p><h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><p>非正式地说，向量的范数是表示一个向量有多大，不涉及维度，而是分量的大小</p><p>向量范数是将向量映射到标量的函数$f$</p><p>给定任意向量$\mathbf{x}$，向量范数要满足一些属性</p><ul><li><p>$$<br>f(\alpha \mathbf{x}) &#x3D; |\alpha| f(\mathbf{x}).<br>$$</p></li><li><p>$$<br>f(\mathbf{x} + \mathbf{y}) \leq f(\mathbf{x}) + f(\mathbf{y}).<br>$$</p></li><li><p>$$<br>f(\mathbf{x}) \geq 0.<br>$$</p></li></ul><p>范数听起来很像距离的度量</p><p>欧几里得距离是一个$L_2$范数<br>$$<br>\mid \mid \mathbf{x}\mid \mid_2 &#x3D; \sqrt{\sum_{i&#x3D;1}^n x_i^2},<br>$$<br>在$L_2$范数中常常省略下标2，也就是$\mid \mid \mathbf{x}\mid \mid$等价于$\mid \mid \mathbf{x}\mid \mid_2$</p><p>代码中可以直接用<code>norm</code>计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = torch.tensor([<span class="number">3.0</span>, -<span class="number">4.0</span>])</span><br><span class="line">torch.norm(u)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor(5.)</span><br></pre></td></tr></table></figure><p>深度学习中更经常地使用$L_2$范数的平方，也会经常遇到$L_1$范数，它表示为向量元素的绝对值之和<br>$$<br>\mid \mid \mathbf{x}\mid \mid_1 &#x3D; \sum_{i&#x3D;1}^n \left|x_i \right|.<br>$$<br>与$L_2$范数相比，$L_1$范数受异常值的影响较小，将绝对值函数和按元素求和组合起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.<span class="built_in">abs</span>(u).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor(7.)</span><br></pre></td></tr></table></figure><p>$L_2$范数和$L_1$范数都是更一般的$L_p$范数的特例<br>$$<br>\mid \mid\mathbf{x}\mid \mid_p &#x3D; \left(\sum_{i&#x3D;1}^n \left|x_i \right|^p \right)^{1&#x2F;p}.<br>$$<br>类似于向量的$L_2$范数，<font color='DarkViolet'>矩阵$\mathbf{X} \in \mathbb{R}^{m \times n}$的Frobenius范数(Frobenius norm)</font>是矩阵元素平方和的平方根：<br>$$<br>\mid \mid\mathbf{X}\mid \mid_F &#x3D; \sqrt{\sum_{i&#x3D;1}^m \sum_{j&#x3D;1}^n x_{ij}^2}.<br>$$<br>Frobenius范数满足向量范数的所有性质，就像是矩阵形向量的$L_2$范数</p><p>仍然调用<code>norm</code>函数计算矩阵的Frobenius范数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.norm(torch.ones((<span class="number">4</span>, <span class="number">9</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor(6.)</span><br></pre></td></tr></table></figure><h4 id="范数和目标"><a href="#范数和目标" class="headerlink" title="范数和目标"></a>范数和目标</h4><p>在深度学习中经常试图解决优化问题：最大化分配给观测数据的概率; 最小化预测和真实观测之间的距离，用向量表示物品(如单词、产品或新闻文章)，以便最小化相似项目之间的距离，最大化不同项目之间的距离</p><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><h3 id="导数和微分"><a href="#导数和微分" class="headerlink" title="导数和微分"></a>导数和微分</h3><p>在深度学习中，通常选择对于模型参数可微的损失函数。简而言之，对于每个参数，如果把这个参数增加或减少一个无穷小的量，可以知道损失会以多快的速度增加或减少</p><p>假设有一个函数$f: \mathbb{R} \rightarrow \mathbb{R}$，其输入和输出都是标量。如果$f$的导数存在，这个极限被定义为<br>$$<br>f’(x) &#x3D; \lim_{h \rightarrow 0} \frac{f(x+h) - f(x)}{h}.<br>$$<br>如果$f’(a)$存在，则称在处是**可微(differentiable)**的，导数$f’(x)$解释为相对于$x$的瞬时变化率</p><p>给定$y&#x3D;f(x)$，其中$x$和$y$分别是函数的自变量和因变量，以下表达式是等价的<br>$$<br>f’(x) &#x3D; y’ &#x3D; \frac{dy}{dx} &#x3D; \frac{df}{dx} &#x3D; \frac{d}{dx} f(x) &#x3D; Df(x) &#x3D; D_x f(x)<br>$$<br>其中符号$\frac{d}{dx}$和$D$是微分运算符，表示微分操作</p><ul><li>$DC &#x3D; 0$($C$为常数)</li><li>$Dx^n &#x3D; nx^{n-1}$</li><li>$De^x &#x3D; e^x$</li><li>$D\ln(x) &#x3D; 1&#x2F;x$</li></ul><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><p>设$y &#x3D; f(x_1, x_2, \ldots, x_n)$是一个具有$n$个变量的函数，$y$关于第$i$个参数$x_i$的**偏导数(partial derivative)**为<br>$$<br>\frac{\partial y}{\partial x_i} &#x3D; \lim_{h \rightarrow 0} \frac{f(x_1, \ldots, x_{i-1}, x_i+h, x_{i+1}, \ldots, x_n) - f(x_1, \ldots, x_i, \ldots, x_n)}{h}.<br>$$<br>对于偏导数的表示，以下是等价的：<br>$$<br>\frac{\partial y}{\partial x_i} &#x3D; \frac{\partial f}{\partial x_i} &#x3D; f_{x_i} &#x3D; f_i &#x3D; D_i f &#x3D; D_{x_i} f.<br>$$</p><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>可以连结一个多元函数对其所有变量的偏导数，以得到该函数的**梯度(gradient)**向量</p><p>设函数$f:\mathbb{R}^n\rightarrow\mathbb{R}$的输入是一个$n$维向量$\mathbf{x}&#x3D;[x_1,x_2,\ldots,x_n]^\top$，并且输出是一个标量</p><p>函数$f(\mathbf{x})$相对于$\mathbf{x}$的梯度是一个包含$n$个偏导数的向量<br>$$<br>\nabla_{\mathbf{x}} f(\mathbf{x}) &#x3D; \bigg[\frac{\partial f(\mathbf{x})}{\partial x_1}, \frac{\partial f(\mathbf{x})}{\partial x_2}, \ldots, \frac{\partial f(\mathbf{x})}{\partial x_n}\bigg]^\top<br>$$<br>$\nabla_{\mathbf{x}} f(\mathbf{x})$通常在没有歧义时被$\nabla f(\mathbf{x})$取代</p><p>在微分多元函数时经常使用以下规则：(python默认分子布局，结论改写成分子布局的形式)</p><ul><li><p>对于所有$\mathbf{A} \in \mathbb{R}^{m \times n}$，都有$\nabla_{\mathbf{x}} \mathbf{A} \mathbf{x} &#x3D; \mathbf{A}$</p></li><li><p>对于所有$\mathbf{A} \in \mathbb{R}^{n \times m}$，都有$\nabla_{\mathbf{x}} \mathbf{x}^\top \mathbf{A} &#x3D; \mathbf{A}^\top$</p></li><li><p>对于所有$\mathbf{A} \in \mathbb{R}^{n \times n}$，都有$\nabla_{\mathbf{x}} \mathbf{x}^\top \mathbf{A} \mathbf{x} &#x3D; (\mathbf{A} + \mathbf{A}^\top)\mathbf{x}$</p><p>如果$\mathbf{A}$对称，则导数更简化为$\nabla_{\mathbf{x}} \mathbf{x}^\top \mathbf{A} \mathbf{x} &#x3D;2\mathbf{A}\mathbf{x}$，这是神经网络里常见的“平方损失”形式</p></li><li><p>$\nabla_{\mathbf{x}} \mid\mid\mathbf{x} \mid\mid^2 &#x3D; \nabla_{\mathbf{x}} \mathbf{x}^\top \mathbf{x} &#x3D; 2\mathbf{x}$</p></li></ul><p>对于任何矩阵$\mathbf{X}$，都有$\nabla_{\mathbf{X}} |\mathbf{X} |_F^2 &#x3D; 2\mathbf{X}$</p><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><p>假设函数$y&#x3D;f(u)$和$u&#x3D;g(x)$都是可微的<br>$$<br>\frac{dy}{dx} &#x3D; \frac{dy}{du} \frac{du}{dx}<br>$$</p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>绘制函数$y &#x3D; f(x) &#x3D; x^3 - \frac{1}{x}$和其在$x &#x3D; 1$处切线的图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">3</span> - <span class="number">1</span>/x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fp</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>*x**<span class="number">2</span> + <span class="number">1</span>/x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tangent line: y = m(x - x1) + y1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tangent</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> m*(x - x1) + y1</span><br><span class="line"></span><br><span class="line">x1 = <span class="number">1.0</span></span><br><span class="line">y1 = f(x1)</span><br><span class="line">m = fp(x1)</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0.1</span>,<span class="number">2</span>,<span class="number">400</span>)</span><br><span class="line">plt.plot(x,f(x),label=<span class="string">r&quot;$y=x^3-\frac&#123;1&#125;&#123;x&#125;$&quot;</span>)</span><br><span class="line">plt.plot(x,tangent(x),label=<span class="string">&quot;Tangent&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">plt.title(<span class="string">r&quot; $y=x^3-\frac&#123;1&#125;&#123;x&#125;$ Tangent in $x=1$ &quot;</span>)</span><br><span class="line">plt.scatter([x1], [y1], s=<span class="number">40</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510121636.webp" alt="202510121636" style="zoom: 67%;" /></li><li><p>函数$f(\mathbf{x}) &#x3D; \mid\mid\mathbf{x}\mid\mid$的梯度是什么?<br>$$<br>\mid\mid x\mid\mid&#x3D;\left(x^{\top} x\right)^{1 &#x2F; 2}\\<br>\nabla\mid\mid x\mid\mid&#x3D;2 x\cdot\frac{1}{2}\left(x^{\top} x\right)^{-1 &#x2F; 2}  &#x3D;\frac{x}{\mid\mid x \mid\mid}<br>$$<br>矢量L2范数关于矢量自身的梯度是与矢量方向相同的单位矢量</p></li><li><p>尝试写出函数$u &#x3D; f(x, y, z)$，其中$x &#x3D; x(a, b)$，$y &#x3D; y(a, b)$，$z &#x3D; z(a, b)$的链式法则<br>$$<br>\begin{aligned}<br>&amp; \frac{\partial u}{\partial a}&#x3D;f_x \frac{\partial x}{\partial a}+f_y \frac{\partial y}{\partial a}+f_z \frac{\partial z}{\partial a} \\<br>&amp; \frac{\partial u}{\partial b}&#x3D;f_x \frac{\partial x}{\partial b}+f_y \frac{\partial y}{\partial b}+f_z \frac{\partial z}{\partial b}<br>\end{aligned}<br>$$</p><p>其中 $f_x, f_y, f_z$ 都在 $(x(a, b), y(a, b), z(a, b))$ 处取值</p></li></ol><h2 id="自动微分"><a href="#自动微分" class="headerlink" title="自动微分"></a>自动微分</h2><p>求导是几乎所有深度学习优化算法的关键步骤，但对于复杂的模型，手工进行更新是一件很痛苦的事情(而且经常容易出错)</p><p>深度学习框架通过自动计算导数，即**自动微分(automatic differentiation)**来加快求导</p><p>根据设计好的模型，系统会构建一个<strong>计算图(computational graph)</strong>，来跟踪计算是哪些数据通过哪些操作组合起来产生输出。自动微分使系统能够随后反向传播梯度</p><p>**反向传播(backpropagate)**意味着跟踪整个计算图，填充关于每个参数的偏导数</p><h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><p>求导之前需要一个地方来存储梯度，并且不会在每次对一个参数求导时都分配新的内存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>,dtype=torch.float32,requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># requires_grad 启动用于追踪梯度，注意需要float类型</span></span><br><span class="line">x.grad  <span class="comment"># 默认值是None</span></span><br></pre></td></tr></table></figure><p>计算y</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">2</span> * x@x  <span class="comment"># tensor(28., grad_fn=&lt;DotBackward0&gt;)</span></span><br></pre></td></tr></table></figure><p>通过调用反向传播函数来自动计算<code>y</code>关于<code>x</code>每个分量的梯度，并打印这些梯度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y.backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([ 0.,  4.,  8., 12.])</span><br></pre></td></tr></table></figure><p>函数$y&#x3D;2\mathbf{x}^{\top}\mathbf{x}$关于$\mathbf{x}$的梯度应为$4\mathbf{x}$，符合</p><p>计算<code>x</code>的另一个函数的导数前，<font color='DarkViolet'>要记得清除梯度</font>，不然梯度会累积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x.grad.zero_() <span class="comment"># 清除累积</span></span><br><span class="line">y = x.<span class="built_in">sum</span>()</span><br><span class="line">y.backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([1., 1., 1., 1.])</span><br></pre></td></tr></table></figure><p><code>backward</code> 做的是向量–雅可比积，<font color='DarkViolet'>根据链式法则乘上局部雅可比矩阵</font></p><p>若 <code>y</code> 是标量，数学上反向传播的起点只有一个数，默认就是 1，不需要专门输入</p><p>若 <code>y</code> 是张量，上游梯度是一个与 <code>y</code> 同形状的张量$v$，如果不告诉它$v$是什么无法计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y.backward(torch.ones_like(y)) <span class="comment"># 选择全1方向</span></span><br></pre></td></tr></table></figure><p>因为<code>sum</code>的雅可比就是全1，所以常这么写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y.<span class="built_in">sum</span>().backward()</span><br><span class="line"><span class="comment"># == y.backward( torch.ones_like(y) )</span></span><br></pre></td></tr></table></figure><h3 id="非标量变量的反向传播"><a href="#非标量变量的反向传播" class="headerlink" title="非标量变量的反向传播"></a>非标量变量的反向传播</h3><p>当<code>y</code>不是标量时，向量<code>y</code>关于向量<code>x</code>的导数的最自然解释是一个矩阵</p><p>对于高阶和高维的<code>y</code>和<code>x</code>，求导的结果可以是一个高阶张量</p><p>对非标量调用backward需要传入一个gradient参数，该参数指定微分函数关于self的梯度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x * <span class="number">3</span></span><br><span class="line">z = y ** <span class="number">2</span></span><br><span class="line">z.<span class="built_in">sum</span>().backward()</span><br><span class="line"><span class="comment"># z.backward() # 非标量输出反向传播时如果没有指定gradient将会报错</span></span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[18., 18.],</span><br><span class="line">        [18., 18.]])</span><br></pre></td></tr></table></figure><h3 id="分离计算"><a href="#分离计算" class="headerlink" title="分离计算"></a>分离计算</h3><p>有时希望将某些计算移动到记录的计算图之外</p><p>假设<code>y</code>是作为<code>x</code>的函数计算的，而<code>z</code>则是作为<code>y</code>和<code>x</code>的函数计算的</p><p>想计算<code>z</code>关于<code>x</code>的梯度，但由于某种原因，希望将<code>y</code>视为一个常数，并且只考虑到<code>x</code>在<code>y</code>被计算后发挥的作用</p><p>可以分离<code>y</code>来返回一个新变量<code>u</code>，该变量与<code>y</code>具有相同的值，但丢弃计算图中如何计算<code>y</code>的任何信息，梯度不会向后流经<code>u</code>到<code>x</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x*x</span><br><span class="line">u = y.detach() <span class="comment"># 分离出一个新的张量，但共享相同的数据存储</span></span><br><span class="line">z = u * x</span><br><span class="line">z.<span class="built_in">sum</span>().backward()</span><br><span class="line"><span class="built_in">print</span>(x.grad == u)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[True, True],</span><br><span class="line">        [True, True]])</span><br></pre></td></tr></table></figure><p>同时也可以在<code>y</code>上调用反向传播，得到<code>y=x*x</code>关于的<code>x</code>的导数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y.<span class="built_in">sum</span>().backward()</span><br><span class="line"><span class="built_in">print</span>(x.grad == <span class="number">2</span>*x)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[True, True],</span><br><span class="line">        [True, True]])</span><br></pre></td></tr></table></figure><h3 id="控制流的梯度计算"><a href="#控制流的梯度计算" class="headerlink" title="控制流的梯度计算"></a>控制流的梯度计算</h3><p>使用自动微分的一个好处是，即使构建函数的计算图需要通过Python控制流(例如，条件、循环或任意函数调用)，仍然可以计算得到的变量的梯度</p><p>在下面的代码中，<code>while</code>循环的迭代次数和<code>if</code>语句的结果都取决于输入<code>a</code>的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>):</span><br><span class="line">    b = a*<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> b.norm()&lt;<span class="number">1000</span>:</span><br><span class="line">        b = b*<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> b.<span class="built_in">sum</span>() &gt; <span class="number">0</span>:</span><br><span class="line">        c = b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = <span class="number">100</span> *b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">a.grad.zero_()</span><br><span class="line">a = torch.randn(size=(), requires_grad=<span class="literal">True</span>) <span class="comment"># () 标量，没有维度</span></span><br><span class="line">d = f(a)</span><br><span class="line">d.backward() <span class="comment"># 标量无所谓</span></span><br><span class="line"><span class="built_in">print</span>(a.grad == d/a)</span><br><span class="line"><span class="comment"># tensor(True)</span></span><br></pre></td></tr></table></figure><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>为什么计算二阶导数比一阶导数的开销要更大？</p><p>设有函数$f:\mathbb{R}^{n}\rightarrow \mathbb{R}$</p><p>一阶导数是一个长度为$n$的向量，PyTorch的默认方式是使用反向模式自动微分(reverse-mode AD)，只要做一次反向传播，就能得到整个梯度向量</p><p>二阶导数是一个$n\times n$的矩阵(Hessian(海森矩阵))，要完整求出Hessian，就得重复计算一阶梯度$n$次，每次对不同的分量求导</p><p>复杂度从$O(n)$变成了$O(n^2)$</p></li><li><p>在控制流的例子中，计算<code>d</code>关于<code>a</code>的导数，如果将变量<code>a</code>更改为随机向量或矩阵，会发生什么？</p><p>将会报错，因为没有此时不是标量了，没有指定gradient将会报错，改成这个比较稳定，标量或者张量都不会出现报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.<span class="built_in">sum</span>().backward()</span><br></pre></td></tr></table></figure></li><li><p>使$f(x)&#x3D;\sin(x)$，绘制$f(x)$和$\frac{df(x)}{dx}$的图像，其中后者不使用$f’(x)&#x3D;\cos(x)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = torch.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi,<span class="number">100</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">fx = torch.sin(x)</span><br><span class="line">fx.<span class="built_in">sum</span>().backward()</span><br><span class="line">dfx = x.grad</span><br><span class="line">plt.plot(x.detach().numpy(),fx.detach().numpy(),label=<span class="string">&quot;f(x)=sin(x)&quot;</span>)</span><br><span class="line">plt.plot(x.detach().numpy(), dfx.detach().numpy(), label=<span class="string">&quot;dfx&quot;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510122256.webp" alt="202510122256" style="zoom: 67%;" /></li></ol><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><p>简单地说，机器学习就是做出预测</p><h3 id="基本概率论"><a href="#基本概率论" class="headerlink" title="基本概率论"></a>基本概率论</h3><p>检查骰子的唯一方法是多次投掷并记录结果</p><p>对于每个骰子将观察到${1, \ldots, 6}$中的一个值，对于每个值，一种自然的方法是将它出现的次数除以投掷的总次数，即此**事件(event)**概率的估计值</p><p>**大数定律(law of large numbers)**指出：随着投掷次数的增加，这个估计值会越来越接近真实的潜在概率</p><p>在统计学中，把从概率分布中抽取样本的过程称为<strong>抽样(sampling)</strong>，笼统来说可以把**分布(distribution)**看作对事件的概率分配</p><p>将概率分配给一些离散选择的分布称为<strong>多项分布(multinomial distribution)</strong></p><p>为了抽取一个样本，即掷骰子，只需传入一个概率向量，输出是另一个相同长度的向量，它在索引处的值是采样结果中出现的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fair_probs = torch.ones([<span class="number">6</span>]) / <span class="number">6</span> <span class="comment"># 分配概率</span></span><br><span class="line">multinomial.Multinomial(<span class="number">1</span>, fair_probs).sample() <span class="comment"># 进行采样</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([0., 0., 0., 1., 0., 0.])</span><br></pre></td></tr></table></figure><p>希望从同一分布中生成多个样本，如果用Python的for循环来完成这个任务，速度会慢得惊人</p><p>因此使用深度学习框架的函数同时抽取多个样本，得到想要的任意形状的独立样本数组</p><p>可以统计1000次投掷后，每个数字被投中了多少次，计算相对频率，以作为真实概率的估计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fair_probs = torch.ones([<span class="number">6</span>]) / <span class="number">6</span></span><br><span class="line">fre = <span class="number">1000</span></span><br><span class="line">counts = multinomial.Multinomial(fre, fair_probs).sample()</span><br><span class="line">counts/fre</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([0.1750, 0.1640, 0.1520, 0.1710, 0.1610, 0.1770])</span><br></pre></td></tr></table></figure><p>也可以看到这些概率如何随着时间的推移收敛到真实概率，进行500组实验，每组抽取10个样品</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.distributions <span class="keyword">import</span> multinomial <span class="comment"># 概率分布模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> ipywidgets <span class="keyword">import</span> interact, IntSlider</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simulate_dice</span>(<span class="params">n=<span class="number">10</span>, m=<span class="number">500</span></span>):</span><br><span class="line">    fair_probs = torch.ones([<span class="number">6</span>]) / <span class="number">6</span></span><br><span class="line">    counts = multinomial.Multinomial(n, fair_probs).sample((m,))</span><br><span class="line">    cum_counts = counts.cumsum(dim=<span class="number">0</span>)</span><br><span class="line">    estimates = cum_counts/cum_counts.<span class="built_in">sum</span>(dim=<span class="number">1</span>,keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        plt.plot(estimates[:,i].numpy(), label=<span class="string">f&quot;P(die=<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>)&quot;</span>)</span><br><span class="line">    plt.axhline(y=<span class="number">0.167</span>, color=<span class="string">&quot;black&quot;</span>, linestyle=<span class="string">&quot;dashed&quot;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Groups of experiments&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Estimated probability&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">f&quot;n=<span class="subst">&#123;n&#125;</span>, m=<span class="subst">&#123;m&#125;</span>&quot;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"><span class="comment"># 定义交互</span></span><br><span class="line">interact(</span><br><span class="line">    simulate_dice,</span><br><span class="line">    n = IntSlider(value = <span class="number">10</span>, <span class="built_in">min</span>=<span class="number">1</span>, <span class="built_in">max</span>=<span class="number">30</span>, step=<span class="number">1</span>, description=<span class="string">&quot;n(per group num)&quot;</span>),</span><br><span class="line">    m = IntSlider(value = <span class="number">500</span>, <span class="built_in">min</span>=<span class="number">100</span>, <span class="built_in">max</span>=<span class="number">1000</span>, step=<span class="number">1</span>, description=<span class="string">&quot;m(group num)&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-10-14_10-24-30.webp" alt="Snipaste_2025-10-14_10-24-30" style="zoom:50%;" /><p>小n每组信息很少，每次抽样波动巨大；大n每组本身就是一个小样本集，波动明显减弱，样本方差减小，单次实验更接近期望</p><p>增大m结果会更接近理论值</p><h4 id="概率论公理"><a href="#概率论公理" class="headerlink" title="概率论公理"></a>概率论公理</h4><p>在给定的样本空间$\mathcal{S}$中，事件$\mathcal{A}$的概率，表示为$P(\mathcal{A})$，满足以下属性：</p><ul><li>对于任意事件$\mathcal{A}$，其概率从不会是负数，即$P(\mathcal{A}) \geq 0$</li><li>整个样本空间的概率为1，即$P(\mathcal{S}) &#x3D; 1$</li><li>对于**互斥(mutually exclusive)**事件，任意一个可数序列$\mathcal{A}_1, \mathcal{A}<em>2, \ldots$，序列中任意一个事件发生的概率等于它们各自发生的概率之和，即$P(\bigcup</em>{i&#x3D;1}^{\infty} \mathcal{A}<em>i) &#x3D; \sum</em>{i&#x3D;1}^{\infty} P(\mathcal{A}_i)$</li></ul><h4 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h4><p>随机变量几乎可以是任何数量，并且它可以在随机实验的一组可能性中取一个值</p><p>考虑一个随机变量$X$，其值在掷骰子的样本空间$\mathcal{S}&#x3D;{1,2,3,4,5,6}$中，可以将事件“看到一个5”表示为${X&#x3D;5}$或$X&#x3D;5$，其概率表示为$P({X&#x3D;5})$或$P(X&#x3D;5)$</p><p>**离散(discrete)<strong>随机变量(如骰子的每一面)和</strong>连续(continuous)**随机变量(如人的体重和身高)之间存在微妙的区别</p><p>将这个看到某个数值的可能性量化为**密度(density)**更为合适</p><h3 id="处理多个随机变量"><a href="#处理多个随机变量" class="headerlink" title="处理多个随机变量"></a>处理多个随机变量</h3><p>当处理多个随机变量时，会有若干个变量是我们感兴趣的</p><h4 id="联合概率"><a href="#联合概率" class="headerlink" title="联合概率"></a>联合概率</h4><p>对于$P(A&#x3D;a,B&#x3D;b)$回答：$A&#x3D;a$和$B&#x3D;b$同时满足的概率是多少？</p><p>对于任何$a$和$b$的取值，必然满足$P(A &#x3D; a, B&#x3D;b) \leq P(A&#x3D;a)$，同时发生的概率一定不大于单独事件的发生概率</p><h4 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h4><p>联合概率的不等式带出<br>$$<br>0 \leq \frac{P(A&#x3D;a, B&#x3D;b)}{P(A&#x3D;a)} \leq 1<br>$$<br>称这个比率为<strong>条件概率(conditional probability)</strong>，并用$P(B&#x3D;b \mid A&#x3D;a)$表示它</p><h4 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h4><p>使用条件概率的定义可以得出统计学中最有用的方程之一：Bayes定理(Bayes’ theorem)</p><p>根据乘法法则(multiplication rule)可得到<font color='DarkViolet'>$P(A, B) &#x3D; P(B \mid A) P(A)$</font>，根据对称性，可得到$P(A, B) &#x3D; P(A \mid B) P(B)$</p><p>假设$P(B)&gt;0$，求解条件概率<br>$$<br>P(A \mid B) &#x3D; \frac{P(B \mid A) P(A)}{P(B)}<br>$$</p><h4 id="边际化"><a href="#边际化" class="headerlink" title="边际化"></a>边际化</h4><p>为了能进行事件概率求和，需要求和法则(sum rule)，即$B$的概率相当于计算的所有可能选择，并将所有选择的联合概率聚合在一起：<br>$$<br>P(B) &#x3D; \sum_{A} P(A, B)<br>$$<br>这也称为<strong>边际化(marginalization)</strong>，边际化结果的概率或分布称为边际概率或边际分布</p><h4 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h4><p>如果两个随机变量$A$和$B$是独立的，意味着事件$A$的发生跟事件$B$的发生无关</p><p>在这种情况下，统计学家通常将这一点表述为$A \perp B$</p><p>根据贝叶斯定理，马上就能同样得到$P(A \mid B) &#x3D; P(A)$，在所有其他情况下，称$A$和$B$依赖</p><p>根据条件分布$P(A \mid B) &#x3D; \frac{P(A, B)}{P(B)} &#x3D; P(A)$，等价于$P(A, B) &#x3D; P(A)P(B)$，因此两个随机变量是独立的，当且仅当两个随机变量的联合分布是其各自分布的乘积</p><p>给定另一个随机变量$C$时，两个随机变量$A$和$B$是<strong>条件独立的(conditionally independent)</strong>，当且仅当$P(A, B \mid C) &#x3D; P(A \mid C)P(B \mid C)$，这个情况表示为$A \perp B \mid C$</p><h3 id="概念应用"><a href="#概念应用" class="headerlink" title="概念应用"></a>概念应用</h3><p>假设一个医生对患者进行艾滋病病毒(HIV)测试，如果患者健康但测试显示他患病，这个概率只有1%；如果患者真正感染HIV，它永远不会检测不出</p><p>使用$D_1$来表示诊断结果(如果阳性为1，如果阴性为0)，$H$来表示感染艾滋病病毒的状态(如果阳性为1，如果阴性为0)，条件概率表中表示：</p><table><thead><tr><th>条件概率</th><th>$H&#x3D;1$</th><th>$H&#x3D;0$</th></tr></thead><tbody><tr><td>$P(D_1 &#x3D; 1 \mid H)$</td><td>1</td><td>0.01</td></tr><tr><td>$P(D_1 &#x3D; 0 \mid H)$</td><td>0</td><td>0.99</td></tr></tbody></table><p>每列的加和都是1(但每行的加和不是)，因为条件概率需要总和为1，就像概率一样</p><p>现在要计算如果测试出来呈阳性，患者感染HIV的概率，即$P(H &#x3D; 1 \mid D_1 &#x3D; 1)$</p><p>根据贝叶斯定理<br>$$<br>P(H &#x3D; 1 \mid D_1 &#x3D; 1)&#x3D; \frac{P(D_1&#x3D;1 \mid H&#x3D;1) P(H&#x3D;1)}{P(D_1&#x3D;1)}<br>$$<br>假设人口总体是相当健康的$P(H&#x3D;1) &#x3D; 0.0015$，可以求出$P(D_1 &#x3D; 1) $<br>$$<br>\begin{split}\begin{aligned}<br>P(D_1 &#x3D; 1) &#x3D;&amp; P(D_1&#x3D;1, H&#x3D;0) + P(D_1&#x3D;1, H&#x3D;1)  \\<br>&#x3D;&amp; P(D_1&#x3D;1 \mid H&#x3D;0) P(H&#x3D;0) + P(D_1&#x3D;1 \mid H&#x3D;1) P(H&#x3D;1) \\<br>&#x3D;&amp; 0.011485.<br>\end{aligned}\end{split}<br>$$<br>因此得到<br>$$<br>\begin{aligned}<br>P(H &#x3D; 1 \mid D_1 &#x3D; 1)&#x3D; \frac{P(D_1&#x3D;1 \mid H&#x3D;1) P(H&#x3D;1)}{P(D_1&#x3D;1)} &#x3D; 0.1306 \end{aligned}<br>$$<br>尽管使用了非常准确的测试，患者实际上患有艾滋病的几率只有13.06%，概率可能是违反直觉的</p><p>患者会要求医生进行另一次测试来确定病情，第二个测试具有不同的特性，它不如第一个测试那么精确</p><table><thead><tr><th>条件概率</th><th>H&#x3D;1</th><th>H&#x3D;0</th></tr></thead><tbody><tr><td>$P(D_2 &#x3D; 1 \mid H)$</td><td>0.98</td><td>0.03</td></tr><tr><td>$P(D_2 &#x3D; 0 \mid H)$</td><td>0.02</td><td>0.97</td></tr></tbody></table><p>不幸的是，第二次测试也显示阳性，通过假设条件独立性来计算出应用Bayes定理的必要概率</p><p>计算目标为<br>$$<br>\begin{split}\begin{aligned}<br>P(H &#x3D; 1 \mid D_1 &#x3D; 1, D_2 &#x3D; 1)<br>&#x3D; \frac{P(D_1 &#x3D; 1, D_2 &#x3D; 1 \mid H&#x3D;1) P(H&#x3D;1)}{P(D_1 &#x3D; 1, D_2 &#x3D; 1)}<br>\end{aligned}\end{split}<br>$$<br>两次检测都为阳性实际上没感染的概率<br>$$<br>\begin{split}\begin{aligned}<br>P(D_1 &#x3D; 1, D_2 &#x3D; 1 \mid H &#x3D; 0) &#x3D; P(D_1 &#x3D; 1 \mid H &#x3D; 0) P(D_2 &#x3D; 1 \mid H &#x3D; 0)<br>&#x3D; 0.0003<br>\end{aligned}\end{split}<br>$$<br>两次检测都为阳性实际上感染的概率<br>$$<br>\begin{split}\begin{aligned}<br>P(D_1 &#x3D; 1, D_2 &#x3D; 1 \mid H &#x3D; 1) &#x3D; P(D_1 &#x3D; 1 \mid H &#x3D; 1) P(D_2 &#x3D; 1 \mid H &#x3D; 1)<br>&#x3D; 0.98<br>\end{aligned}\end{split}<br>$$<br>现在可以应用边际化和乘法规则<br>$$<br>\begin{split}\begin{aligned}<br>P(D_1 &#x3D; 1, D_2 &#x3D; 1)<br>&#x3D;&amp; P(D_1 &#x3D; 1, D_2 &#x3D; 1, H &#x3D; 0) + P(D_1 &#x3D; 1, D_2 &#x3D; 1, H &#x3D; 1)  \\<br>&#x3D;&amp; P(D_1 &#x3D; 1, D_2 &#x3D; 1 \mid H &#x3D; 0)P(H&#x3D;0) + P(D_1 &#x3D; 1, D_2 &#x3D; 1 \mid H &#x3D; 1)P(H&#x3D;1)\\<br>&#x3D;&amp; 0.00176955<br>\end{aligned}\end{split}<br>$$<br>鉴于存在两次阳性检测，患者患有艾滋病的概率为<br>$$<br>\begin{split}\begin{aligned}<br>P(H &#x3D; 1 \mid D_1 &#x3D; 1, D_2 &#x3D; 1)<br>&#x3D; \frac{P(D_1 &#x3D; 1, D_2 &#x3D; 1 \mid H&#x3D;1) P(H&#x3D;1)}{P(D_1 &#x3D; 1, D_2 &#x3D; 1)}<br>&#x3D; 0.8307<br>\end{aligned}\end{split}<br>$$<br>第二次测试能够对患病的情况获得更高的信心，尽管第二次检验比第一次检验的准确性要低得多</p><h3 id="期望和方差"><a href="#期望和方差" class="headerlink" title="期望和方差"></a>期望和方差</h3><p>一个随机变量$X$的**期望(expectation)**表示为<br>$$<br>E[X] &#x3D; \sum_{x} x P(X &#x3D; x)<br>$$<br>当函数$f(x)$的输入是从分布$P$中抽取的随机变量时，$f(x)$的期望值为<br>$$<br>E_{x \sim P}[f(x)] &#x3D; \sum_x f(x) P(x)<br>$$<br>在许多情况下，希望衡量随机变量$X$与其期望值的偏置，这可以通过方差来量化<br>$$<br>\mathrm{Var}[X] &#x3D; E\left[(X - E[X])^2\right] &#x3D;E[X^2] - E[X]^2<br>$$<br>随机变量函数的方差衡量当从该随机变量分布中采样不同值时，函数值偏离该函数的期望的程度<br>$$<br>\mathrm{Var}[f(x)] &#x3D; E\left[\left(f(x) - E[f(x)]\right)^2\right]<br>$$</p><h3 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>给定两个概率为$ P(\mathcal{A}) $和$P(\mathcal{B})$的事件，计算$P(\mathcal{A} \cup \mathcal{B})$和$P(\mathcal{A} \cap \mathcal{B})$的上限和下限(韦恩图)</p><p>假设$ P(\mathcal{A}) &#x3D;p, P(\mathcal{B})&#x3D;q $</p><p>$P(\mathcal{A} \cup \mathcal{B})&#x3D;p+q-P(\mathcal{A} \cap \mathcal{B})$：</p><p>两个事件越独立越大(交集小)，下界在交集大(一个尽量包含另一个)时取得<br>$$<br>\mathrm{max}(p,q)\le P(\mathcal{A} \cup \mathcal{B})\le \mathrm{min}(1,p+q)<br>$$<br>$P(\mathcal{A} \cap \mathcal{B})&#x3D;p+q-P(\mathcal{A} \cup \mathcal{B})$：</p><p>上界不能超过小的那个事件，下界由全集限制<br>$$<br>\mathrm{max}(0,p+q-1) \le P(\mathcal{A} \cap \mathcal{B}) \le \mathrm{min}(p,q)<br>$$</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20251014105211207.png" alt="image-20251014105211207" style="zoom: 67%;" /></li><li><p>假设有一系列随机变量$A,B,C$，其中$B$只依赖于$A$，而$C$只依赖于$B$，能简化联合概率  $P(A,B,C)$吗?</p><p>马尔可夫链的关键性质是“无记忆性”，对于$A,B,C$它们形成了马尔可夫链<br>$$<br>A\rightarrow B \rightarrow C<br>$$<br>那么可以简化为<br>$$<br>P(A,B,C)&#x3D;P(A)P(B\mid A)P(C\mid B)<br>$$<br>而不是一般情况下的<br>$$<br>P(A,B,C)&#x3D;P(A)P(B\mid A)P(C\mid A,B)<br>$$<br>因为$C$不直接依赖$A$</p><p>未来的演化不依赖更早的历史，只依赖当下的状态</p></li></ol><h2 id="文档查询"><a href="#文档查询" class="headerlink" title="文档查询"></a>文档查询</h2><p><strong>查找模块中的所有函数和类</strong>：利用<code>dir</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(torch.distributions))</span><br></pre></td></tr></table></figure><p>通常可以忽略以<code>__</code>开始和结束的函数，它们是Python中的特殊对象，或以<code>_</code>开始的函数，它们通常是内部函数</p><p><strong>查找特定函数和类的用法</strong>：调用<code>help</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(torch.ones)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows安装ROCm</title>
      <link href="/posts/22642.html"/>
      <url>/posts/22642.html</url>
      
        <content type="html"><![CDATA[<p>因为电脑是A卡，所以想着能不能用ROCm来利用GPU，结果是WSL没法穿透到非pro显卡</p><h2 id="WSL安装"><a href="#WSL安装" class="headerlink" title="WSL安装"></a>WSL安装</h2><p>WSL是先决条件，启动终端管理员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install -d Ubuntu-22.04</span><br></pre></td></tr></table></figure><p>路径说明(默认安装在C盘)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\&lt;User&gt;\AppData\Local\Packages\</span><br><span class="line">└── CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc\</span><br><span class="line">    ├── LocalCache\</span><br><span class="line">    ├── LocalState\</span><br><span class="line">    │   ├── ext4.vhdx     ← 这是 Linux 的虚拟磁盘</span><br><span class="line">    │   ├── rootfs\</span><br><span class="line">    │   └── temp\</span><br><span class="line">    ├── Settings\</span><br><span class="line">    ├── SystemAppData\</span><br><span class="line">    └── AppData\</span><br></pre></td></tr></table></figure><p>可能会出现报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。</span><br><span class="line">To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span><br><span class="line">See &quot;man sudo_root&quot; for details.</span><br></pre></td></tr></table></figure><p>在 windows 的<code>C:\User\&lt;你的用户名&gt;\</code> 下创建一个<code>.wslconfig</code>，内部写入如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual</span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=true</span><br><span class="line">firewall=true</span><br><span class="line">autoProxy=true</span><br><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>再次启动 wsl，不再弹出上述提示</p><h2 id="AMD-HIP-SDK"><a href="#AMD-HIP-SDK" class="headerlink" title="AMD HIP SDK"></a>AMD HIP SDK</h2><p>运行 PowerShell 管理员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ComputerInfo | Format-Table CsSystemType,OSName,OSDisplayVersion</span><br></pre></td></tr></table></figure><p>查看自己的电脑系统版本</p><p>下载SDK：<a href="https://www.amd.com/en/developer/resources/rocm-hub/hip-sdk.html"><strong>AMD HIP SDK for Windows</strong></a></p><p>默认已都勾选Full，下滑到显示驱动程序，勾选 Install，安装类型 full install，安装完成后要重启一次</p><h2 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h2><p>安装AMD统一驱动程序包存储库和安装程序脚本</p><p><a href="https://rocm.docs.amd.com/projects/radeon-ryzen/en/latest/docs/install/installrad/wsl/install-radeon.html"><strong>参考官方安装教程</strong></a></p><p>重启后重新打开WSL</p><p>根据不同ubuntu版本进行下载，这里用的是22.04的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">wget https://repo.radeon.com/amdgpu-install/6.4.2.1/ubuntu/jammy/amdgpu-install_6.4.60402-1_all.deb</span><br><span class="line">sudo apt install ./amdgpu-install_6.4.60402-1_all.deb</span><br></pre></td></tr></table></figure><p>运行以下命令以安装开源图形和 ROCm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amdgpu-install -y --usecase=wsl,rocm --no-dkms</span><br></pre></td></tr></table></figure><p>安装后验证检查，检查 GPU 是否列为代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rocminfo</span><br></pre></td></tr></table></figure><p>预期输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">*******</span><br><span class="line">Agent 2</span><br><span class="line">*******</span><br><span class="line">  Name:                    gfx1101</span><br><span class="line">  Marketing Name:          AMD Radeon RX 7700 XT</span><br><span class="line">  Vendor Name:             AMD</span><br><span class="line">  [...]</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h2 id="torch安装"><a href="#torch安装" class="headerlink" title="torch安装"></a>torch安装</h2><p>AMD 建议在使用 ROCm 进行机器学习开发时使用 PIP 安装方法创建 PyTorch 环境</p><p>需要下载python3.12(不过默认已经下的就是3.12)</p><p>输入命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip -y</span><br></pre></td></tr></table></figure><p>更新pip wheel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade pip wheel</span><br></pre></td></tr></table></figure><p>选择适用的 Ubuntu 版本并输入命令以安装 Torch 和 Torchvision 以支持 ROCm AMD GPU</p><p>同样22.04版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.radeon.com/rocm/manylinux/rocm-rel-6.4.2/torch-2.6.0%2Brocm6.4.2.git76481f7c-cp310-cp310-linux_x86_64.whl</span><br><span class="line">wget https://repo.radeon.com/rocm/manylinux/rocm-rel-6.4.2/torchvision-0.21.0%2Brocm6.4.2.git4040d51f-cp310-cp310-linux_x86_64.whl</span><br><span class="line">wget https://repo.radeon.com/rocm/manylinux/rocm-rel-6.4.2/pytorch_triton_rocm-3.2.0%2Brocm6.4.2.git7e948ebf-cp310-cp310-linux_x86_64.whl</span><br><span class="line">wget https://repo.radeon.com/rocm/manylinux/rocm-rel-6.4.2/torchaudio-2.6.0%2Brocm6.4.2.gitd8831425-cp310-cp310-linux_x86_64.whl</span><br><span class="line">pip3 uninstall torch torchvision pytorch-triton-rocm</span><br><span class="line">pip3 install torch-2.6.0+rocm6.4.2.git76481f7c-cp310-cp310-linux_x86_64.whl torchvision-0.21.0+rocm6.4.2.git4040d51f-cp310-cp310-linux_x86_64.whl torchaudio-2.6.0+rocm6.4.2.gitd8831425-cp310-cp310-linux_x86_64.whl pytorch_triton_rocm-3.2.0+rocm6.4.2.git7e948ebf-cp310-cp310-linux_x86_64.whl</span><br></pre></td></tr></table></figure><p>需要时间比较久(不知道为啥网速上不去)</p><p><strong>验证 PyTorch 安装</strong></p><ul><li><p>验证是否安装了 Pytorch 并检测到 GPU 计算设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c &#x27;import torch&#x27; 2&gt; /dev/null &amp;&amp; echo &#x27;Success&#x27; || echo &#x27;Failure&#x27;</span><br></pre></td></tr></table></figure><p>预期输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Success</span><br></pre></td></tr></table></figure></li><li><p>输入命令以测试 GPU 是否可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c &#x27;import torch; print(torch.cuda.is_available())&#x27;</span><br></pre></td></tr></table></figure><p>预期输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure><p>但是到这里非常抽象，我的7700xt不能被识别，直接炸了</p></li></ul><p>事已至此，先用cpu跑吧</p><p>在anaconda的虚拟环境中下载torch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install torch torchvision</span><br></pre></td></tr></table></figure><p>验证安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">print(torch.__version__)  #输出torch版本</span><br><span class="line"># 2.4.1+cpu</span><br></pre></td></tr></table></figure><h2 id="集成vscode"><a href="#集成vscode" class="headerlink" title="集成vscode"></a>集成vscode</h2><p>如果显卡能够穿透WSL，因为Linux的图形化并不是很好，如果想要在windows上工作可以利用vscode，在vscode的拓展程序里面搜索WSL，并安装</p><p>安装后点击vscode的左下角的绿色标志，然后选择<code>“connect to wsl”</code>，等待一会及连接上了</p><p>选择打开文件夹，就可以操作子系统的文件了</p><p>这样非常方便，可以在windows系统上操作linux系统的文件</p><p>新建Terminal，可以使用命令行工具执行快捷命令</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🛠️基础工具 </tag>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习引言</title>
      <link href="/posts/31974.html"/>
      <url>/posts/31974.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>机器学习算法：一个灵活的程序算法，其输出由许多参数(parameter)决定，使用数据集来确定当下的“最佳参数集”，这些参数通过某种性能度量方式来达到完成任务的最佳性能</p><p>任一调整参数后的程序被称为模型(model)，通过操作参数而生成的所有不同程序(输入-输出映射)的集合称为模型族，使用数据集来选择参数的元程序被称为学习算法</p><p>在开始用机器学习算法解决问题之前，必须精确地定义问题，确定输入(input)和输出(output)的性质，并选择合适的模型族</p><p>训练过程通常包含如下步骤：</p><ol><li>从一个随机初始化参数的模型开始，这个模型基本没有“智能”；</li><li>获取一些数据样本(例如，音频片段以及对应的是或否标签)；</li><li>调整参数，使模型在这些样本中表现得更好；</li><li>重复第(2)步和第(3)步，直到模型在任务中的表现令人满意</li></ol><img src="https://zh.d2l.ai/_images/ml-loop.svg" style="zoom: 80%;" /><h2 id="机器学习中的关键组件"><a href="#机器学习中的关键组件" class="headerlink" title="机器学习中的关键组件"></a>机器学习中的关键组件</h2><p>无论什么类型的机器学习问题，都会遇到这些组件：</p><ol><li>可以用来学习的数据(data)；</li><li>如何转换数据的模型(model)；</li><li>一个目标函数(objective function)，用来量化模型的有效性；</li><li>调整模型参数以优化目标函数的算法(algorithm)</li></ol><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>每个数据集由一个个样本组成，大多时候它们遵循独立同分布</p><p>通常每个样本由一组称为特征的属性组成，机器学习模型会根据这些属性进行预测</p><p>当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的维数。固定长度的特征向量是一个方便的属性，它可以用来量化学习大量样本。但并不是所有的数据都可以用“固定长度”的向量表示</p><p>与传统机器学习方法相比，深度学习的一个主要优势是可以处理不同长度的数据</p><p>仅仅拥有海量的数据是不够的，还需要正确的数据，警惕垃圾数据带来的后果</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>大多数机器学习会涉及到数据的转换</p><p>深度学习与经典方法的区别主要在于：前者关注功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换，因此被称为深度学习</p><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>在机器学习中，需要定义模型优劣程度的度量，这个度量在大多数情况是“可优化”的，被称之为目标函数；目标函数希望优化到最低点，因为越低越好，所以也称为损失函数</p><ul><li><font color='DarkViolet'>当任务在试图预测数值时，最常见的损失函数是平方误差</font>(squared error)，即预测值与实际值之差的平方；</li><li><font color='DarkViolet'>当试图解决分类问题时，最常见的目标函数是最小化错误率</font>，即预测与实际情况不符的样本比例</li></ul><p>可用数据集通常可以分成两部分：训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型</p><p>测试性能可能会显著偏离训练性能，当一个模型在训练集上表现良好，但不能推广到测试集时，这个模型被称为过拟合(overfitting)的</p><h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><p>大多流行的优化算法通常基于一种基本方法——梯度下降</p><p>梯度下降法都会检查每个参数，看看如果仅对该参数进行少量变动，训练集损失会朝哪个方向移动，在可以减少损失的方向上优化参数</p><h2 id="各种机器学习问题"><a href="#各种机器学习问题" class="headerlink" title="各种机器学习问题"></a>各种机器学习问题</h2><p>列出一些常见的机器学习问题和应用</p><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>监督学习(supervised learning)擅长在“给定输入特征”的情况下预测标签。每个“特征-标签”对都称为一个样本(example)。有时即使标签是未知的，样本也可以指代输入特征。目标是生成一个模型，能够将任何输入特征映射到标签(即预测)</p><p>一个具体的例子：假设需要预测患者的心脏病是否会发作，那么观察结果“心脏病发作”或“心脏病没有发作”将是样本的标签。输入特征可能是生命体征，如心率、舒张压和收缩压等</p><p>监督学习<font color='DarkViolet'>用概率论术语来说，希望预测“给定输入特征的标签”的条件概率</font></p><p>监督学习的学习过程一般可以分为三大步骤：</p><ol><li>从已知大量数据样本中随机选取一个子集，为每个样本获取真实标签。有时这些样本已有标签(例如，患者是否在下一年内康复?)；有时，这些样本可能需要被人工标记(例如，图像分类)。这些输入和相应的标签一起构成了训练数据集；</li><li>选择有监督的学习算法，它将训练数据集作为输入，并输出一个“已完成学习的模型”；</li><li>将之前没有见过的样本特征放到这个“已完成学习的模型”中，使用模型的输出作为相应标签的预测</li></ol><p>整个监督学习过程如图所示</p><img src="https://zh.d2l.ai/_images/supervised-learning.svg" alt="https://zh.d2l.ai/_images/supervised-learning.svg" style="zoom: 80%;" /><h4 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h4><p>回归(regression)是最简单的监督学习任务之一，当标签取任意数值时称之为回归问题</p><p>判断回归问题的一个很好的经验法则是，任何有关“有多少”的问题很可能就是回归问题</p><p>比如：</p><ul><li>这个手术需要多少小时；</li><li>在未来6小时，这个镇会有多少降雨量；</li><li>预测用户对一部电影的评分</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>虽然回归模型可以很好地解决“有多少”的问题，但是很多问题并非如此</p><p>“哪一个”的问题叫做分类(classification)问题</p><p>分类问题希望模型能够预测样本属于哪个类别，最简单的分类问题只有两类，被称之为二项分类(binomial classification)，比如猫狗分类</p><p>当有两个以上的类别时，把这个问题称为多项分类(multiclass classification)问题，比如手写字符识别</p><p><font color='DarkViolet'>与解决回归问题不同，分类问题的常见损失函数被称为交叉熵</font></p><p>如果分类用于寻找层次结构将更复杂，通常被称为层次分类(hierarchical classification)</p><h4 id="标记问题"><a href="#标记问题" class="headerlink" title="标记问题"></a>标记问题</h4><p>有些分类问题很适合于二项分类或多项分类，但如果输入有多种类别的内容，分类器可能束手无策</p><p>学习预测不相互排斥的类别的问题称为多标签分类(multi-label classification)</p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>不仅仅希望输出一个类别或一个实值，在信息检索领域希望对一组项目进行排序</p><p>以网络搜索为例，目标不是简单的“查询(query)-网页(page)”分类，而是在海量搜索结果中找到用户最需要的那部分</p><p>一种可能的解决方案：首先为集合中的每个元素分配相应的相关性分数，然后检索评级最高的元素</p><h4 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h4><p>另一类与搜索和排名相关的问题是推荐系统(recommender system)，它的目标是向特定用户进行“个性化”推荐</p><p>在某些应用中，客户会提供明确反馈，表达他们对特定产品的喜爱程度，例如，亚马逊上的产品评级和评论</p><p>在其他一些情况下，客户会提供隐性反馈，例如，某用户跳过播放列表中的某些歌曲，这可能说明这些歌曲对此用户不大合适</p><p>推荐系统会为“给定用户和物品”的匹配性打分，这个“分数”可能是估计的评级或购买的概率</p><p>推荐系统的缺陷：</p><ul><li>用户更倾向于给他们感觉强烈的事物打分，例如，在五分制电影评分中，会有许多五星级和一星级评分，但三星级却明显很少</li><li>有可能形成反馈循环：推荐系统首先会优先推送一个购买量较大(可能被认为更好)的商品，然而目前用户的购买习惯往往是遵循推荐算法，但学习算法并不总是考虑到这一细节，进而更频繁地被推荐</li></ul><h4 id="序列学习"><a href="#序列学习" class="headerlink" title="序列学习"></a>序列学习</h4><p>以上大多数问题都具有固定大小的输入和产生固定大小的输出</p><p>在这些情况下，模型只会将输入作为生成输出的“原料”，而不会“记住”输入的具体内容</p><p>如果输入的样本之间没有任何关系，以上模型可能完美无缺，但是如果输入是连续的，模型可能就需要拥有“记忆”功能</p><p>序列学习需要摄取输入序列或预测输出序列，或两者兼而有之，输入和输出都是可变长度的序列</p><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>监督学习需要向模型提供巨大数据集：每个样本包含特征和相应标签值</p><p>数据中不含有“目标”的机器学习问题通常被为无监督学习(unsupervised learning)</p><p>无监督学习面对的主要问题：</p><ul><li>聚类(clustering)问题</li><li>主成分分析(principal component analysis)问题</li><li>因果关系(causality)和概率图模型(probabilistic graphical models)问题</li><li>生成对抗性网络(generative adversarial networks)</li></ul><h3 id="与环境互动"><a href="#与环境互动" class="headerlink" title="与环境互动"></a>与环境互动</h3><p>不管是监督学习还是无监督学习都会预先获取大量数据，然后启动模型，不再与环境交互，被称为离线学习(offline learning)</p><p>对于监督学习，从环境中收集数据的过程类似于</p><img src="https://zh.d2l.ai/_images/data-collection.svg" style="zoom:80%;" /><ul><li>优点：孤立地进行模式识别，不受干扰</li><li>缺点：解决的问题相当有限</li></ul><p>与预测不同，“与真实环境互动”实际上会影响环境</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>可能包括应用到机器人、对话系统，甚至开发视频游戏的人工智能(AI)</p><p>深度强化学习(deep reinforcement learning)将深度学习应用于强化学习的问题</p><p>突破性的深度Q网络(Q-network)在雅达利游戏中仅使用视觉输入就击败了人类，以及 AlphaGo 程序在棋盘游戏围棋中击败了世界冠军，是两个突出强化学习的例子</p><p>在强化学习问题中，智能体(agent)在一系列的时间步骤上与环境交互在每个特定时间点，智能体从环境接收一些观察(observation)，并且必须选择一个动作(action)，然后通过某种机制(有时称为执行器)将其传输回环境，最后智能体从环境中获得奖励(reward)</p><p><font color='DarkViolet'>强化学习的目标是产生一个好的策略(policy)</font></p><img src="https://zh.d2l.ai/_images/rl-environment.svg" style="zoom: 80%;" /><ul><li>当环境可被完全观察到时，强化学习问题被称为马尔可夫决策过程(markov decision process)</li><li>当状态不依赖于之前的操作时，我们称该问题为上下文赌博机(contextual bandit problem)</li><li>当没有状态，只有一组最初未知回报的可用动作时，这个问题就是经典的多臂赌博机(multi-armed bandit problem)</li></ul><h2 id="机器学习与深度学习"><a href="#机器学习与深度学习" class="headerlink" title="机器学习与深度学习"></a>机器学习与深度学习</h2><p>机器学习与深度学习属于从属关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">机器学习(Machine Learning)</span><br><span class="line">│    ├── 传统机器学习(Regression, SVM, Tree, etc.)</span><br><span class="line">│    └── 深度学习(Deep Learning)</span><br><span class="line">│         └── 神经网络（CNN, RNN, Transformer...）</span><br></pre></td></tr></table></figure><table><thead><tr><th>层面</th><th>传统机器学习</th><th>深度学习</th></tr></thead><tbody><tr><td>特征</td><td>人工定义</td><td>自动学习</td></tr><tr><td>表达能力</td><td>有限(浅层)</td><td>极强(深层非线性)</td></tr><tr><td>数据需求</td><td>少量即可</td><td>需要大量数据</td></tr><tr><td>可解释性</td><td>强</td><td>弱(黑箱)</td></tr><tr><td>计算需求</td><td>CPU 足够</td><td>需要 GPU</td></tr><tr><td>泛化能力</td><td>容易过拟合高维数据</td><td>训练得当，能学到高层抽象特征</td></tr><tr><td>典型算法</td><td>SVM、KNN、决策树</td><td>CNN、RNN、Transformer</td></tr><tr><td>典型应用</td><td>数据回归</td><td>图像识别、语音识别、自然语言理解</td></tr></tbody></table><p>假设要让模型识别“猫”：</p><ul><li>**机器学习：**告诉模型看耳朵、眼睛、胡须、毛发颜色，模型靠这些指标判断是否是猫</li><li><strong>深度学习</strong>：只给它图片，模型自己发现特征</li></ul><p>区别的本质在于“特征获取方式”</p><ul><li>传统机器学习依赖人工特征(人告诉机器看什么)</li><li>深度学习能自动从原始数据中学习多层抽象特征</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合理论</title>
      <link href="/posts/18299.html"/>
      <url>/posts/18299.html</url>
      
        <content type="html"><![CDATA[<p>$R_{SRH}$是<code>Shockley-Read-Hall</code>复合速率，是硅基半导体的主要复合机制，这种复合过程涉及半导体禁带隙中的陷阱<br>$$<br>R_{SRH}&#x3D;\frac{np-n_i^2}{\tau_p(n+n_1)+\tau_n(p+p_1)}<br>$$<br>其中$n_i$是本征载流子浓度(未掺杂半导体中的载流子浓度)，$\tau_n$和$\tau_p$是载流子寿命，$n_1$和$p_1$是陷阱能级对应的载流子浓度</p><p>如果陷阱能级位于带隙的中间(模型中假设是这种情况)，那么$n_1$和$p_1$等于$n_i$，这时候分母最小，复合效率最高，所以“中间态陷阱”是最容易引起复合的，这是材料缺陷最致命的原因之一</p><p>如果陷阱能级靠近导带或价带，则对应的一种载流子更容易被捕获，但另一种更难，从而降低整体复合率</p><p><font color='Violetred'>SRH公式在平衡状态、小注入、大注入或陷阱能级对称时会简化</font></p><h2 id="平衡状态"><a href="#平衡状态" class="headerlink" title="平衡状态"></a>平衡状态</h2><p>此时载流子浓度为其平衡浓度，$n&#x3D;n_0,p&#x3D;p_0,n_0p_0&#x3D;n_i^2$，分子为0，$R_{SRH}&#x3D;0$，即复合率等于产生率，系统处于热平衡</p><h2 id="小注入"><a href="#小注入" class="headerlink" title="小注入"></a>小注入</h2><p><strong>非平衡载流子远小于多数载流子</strong></p><p>n型半导体为例，$n_0\approx N_D,p_0&#x3D;n_i^2&#x2F;n_0$ 且 $\Delta n&#x3D;\Delta p \ll n_0$，总浓度$n&#x3D;n_0+\Delta n \approx n_0 ,p&#x3D;p_0+\Delta p $</p><p>分子：$n p-n_i^2 \approx n_0\left(p_0+\Delta p\right)-n_i^2&#x3D;\left(n_0 p_0-n_i^2\right)+n_0 \Delta p&#x3D;n_0 \Delta p$</p><p>分母：$n \approx n_0$ 是多数载流子浓度，$n\gg p, n_1, p_1$，分母中$\tau_p\left(n+n_1\right)$ 项将起主导作用，因此分母近似为$\tau_p n \approx \tau_p n_0$<br>$$<br>R_{S R H} \approx \frac{n_0 \Delta p}{\tau_p n_0}&#x3D;\frac{\Delta p}{\tau_p}<br>$$</p><p>p型半导体同理<br>$$<br>R_{SRH}\approx \frac{\Delta n}{\tau _n}<br>$$<br>物理意义：在小注入时，复合速率由过剩少数载流子的浓度和少数载流子寿命决定，复合过程的瓶颈在于捕获稀有的少数载流子，一旦少数载流子被陷阱捕获，周围有大量的多数载流子可以迅速完成复合</p><h2 id="大注入"><a href="#大注入" class="headerlink" title="大注入"></a>大注入</h2><p><strong>非平衡载流子浓度超过了背景掺杂浓度</strong></p><p>n型半导体为例，$\Delta n&#x3D;\Delta p \gg n_0$ 且 $\Delta n&#x3D;\Delta p \gg p_0$，总浓度$n&#x3D;n_0+\Delta n \approx \Delta n, p&#x3D;p_0+\Delta p \approx \Delta p&#x3D;\Delta n$</p><p>分子：$n p-n_i^2 \approx(\Delta n)(\Delta p)-n_i^2 \approx(\Delta n)^2$ (高注入下 $\Delta n \gg n_i$ )</p><p>分母：$\tau_p\left(n+n_1\right)+\tau_n\left(p+p_1\right) \approx \tau_p(\Delta n)+\tau_n(\Delta p)$，由于 $\Delta n&#x3D;\Delta p$ ，分母变为 $\left(\tau_p+\tau_n\right) \Delta n$<br>$$<br>R_{S R H} \approx \frac{(\Delta n)^2}{\left(\tau_p+\tau_n\right) \Delta n}&#x3D;\frac{\Delta n}{\tau_p+\tau_n}<br>$$</p><p>物理意义：在大注入下，电子和空穴的浓度都很大且近似相等，复合过程不再受限于某一种少数载流子，而是同时取决于电子和空穴的捕获过程，此时有效的复合寿命变成了$\tau_{e f f}&#x3D;\tau_p+ \tau_n$</p><h2 id="陷阱能级对称"><a href="#陷阱能级对称" class="headerlink" title="陷阱能级对称"></a>陷阱能级对称</h2><p>最有效的复合中心通常是对称的，陷阱能级位于禁带中央，即 $E_t&#x3D;E_i$</p><p>陷阱对电子和空穴的俘获能力相同，即俘获寿命相等 $\tau_n&#x3D;\tau_p&#x3D;\tau_0$</p><p>当 $E_t&#x3D;E_i$ 时有 $n_1&#x3D;n_i e^{\left(E_t-E_i\right) &#x2F; k T}&#x3D;n_i$ 和 $p_1&#x3D;n_i e^{\left(E_i-E_t\right) &#x2F; k T}&#x3D;n_i$</p><p>将这些条件代入完整公式</p><p>$$<br>R_{S R H}&#x3D;\frac{n p-n_i^2}{\tau_0\left(n+n_i\right)+\tau_0\left(p+n_i\right)}&#x3D;\frac{n p-n_i^2}{\tau_0\left(n+p+2 n_i\right)}<br>$$</p><p>物理意义：这个简化的公式清晰地表明，复合率不仅取决于偏离平衡的程度(分子)，还与总的载流子浓度(分母中的 $n+p$ )有关<br>最重要的推论：位于禁带中央($E_t&#x3D;E_i$)的陷阱是最有效的复合中心，因为对于给定的注入水平(即固定的 $n p$ 乘积)，分母中的 $n+p$ 项在 $n&#x3D;p$ 时有最小值，而 $n_1$ 和 $p_1$ 在 $E_t&#x3D;E_i$ 时也最小(等于$n_i$)，这使得整个分母最小化，从而得到最大的复合速率</p><p>这就是为什么像金Au 、铜Cu这样的杂质在硅中是寿命杀手，因为它们会在硅的禁带中央附近引入深能级陷阱</p><h2 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h2><table><thead><tr><th>状态</th><th>物理条件</th><th>简化公式</th><th>关键物理意义</th></tr></thead><tbody><tr><td>热平衡</td><td>无外部激励, $n&#x3D;n_0,p&#x3D;p_0$</td><td>$R_{SRH}&#x3D;0$</td><td>复合与生成速率相等，净速率为零</td></tr><tr><td>低注入 (n型)</td><td>$\Delta p≪n_0$</td><td>$R_{SRH}\approx\Delta p&#x2F;\tau_p$</td><td>复合由少数载流子（空穴）决定</td></tr><tr><td>低注入 (p型)</td><td>$\Delta n≪p_0$</td><td>$R_{SRH}\approx\Delta n&#x2F;\tau_n$</td><td>复合由少数载流子（电子）决定</td></tr><tr><td>高注入</td><td>$\Delta n&#x3D;\Delta p\gg n_0,p_0$</td><td>$R_{SRH}\approx\Delta n&#x2F;(\tau_n+\tau_p)$</td><td>复合由电子和空穴共同决定，有效寿命为两者之和</td></tr><tr><td>对称陷阱</td><td>$E_t&#x3D;E_i,\tau_n&#x3D;\tau_p&#x3D;\tau_0$</td><td>$R_{SRH}&#x3D;\frac{n p-n_i^2}{\tau_0\left(n+p+2 n_i\right)}$</td><td>禁带中央的陷阱是最高效的复合中心</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 🥼半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COMSOL光电器件仿真</title>
      <link href="/posts/59657.html"/>
      <url>/posts/59657.html</url>
      
        <content type="html"><![CDATA[<h2 id="COMSOL内置物理参数"><a href="#COMSOL内置物理参数" class="headerlink" title="COMSOL内置物理参数"></a>COMSOL内置物理参数</h2><table><thead><tr><th>描述</th><th>名称</th><th>值</th></tr></thead><tbody><tr><td>重力加速度</td><td>g_const</td><td>9.80665[m&#x2F;s^2]</td></tr><tr><td>阿伏加德罗常数</td><td>N_A_const</td><td>6.02214076e23[1&#x2F;mol]</td></tr><tr><td>玻尔兹曼常数</td><td>k_B_const</td><td>1.380649e-23[J&#x2F;K]</td></tr><tr><td>真空特性阻抗<br />(自由空间阻抗)</td><td>Z0_const</td><td>376.73031346177066[ohm]</td></tr><tr><td>电子质量</td><td>me_const</td><td>9.10938291e-31[kg]</td></tr><tr><td>元电荷</td><td>e_const</td><td>1.602176634e-19[C]</td></tr><tr><td>法拉第常数</td><td>F_const</td><td>96485.3365[C&#x2F;mol]</td></tr><tr><td>精细结构常数</td><td>alpha_const</td><td>7.29735298e-3</td></tr><tr><td>万有引力常数</td><td>G_const</td><td>6.67384e-11[<code>m^3/(kg*s^2)</code>]</td></tr><tr><td>理想气体摩尔体积<br />(273.15K,1atm)</td><td>V_m_const</td><td>2.2413968e-2[m^3&#x2F;mol]</td></tr><tr><td>中子质量</td><td>mn_const</td><td>1.674927351e-27[kg]</td></tr><tr><td>真空磁导率(磁常数)</td><td>mu0_const</td><td><code>2*alpha_const*h_const/c_const/e_const/e_const</code></td></tr><tr><td>真空介电常数</td><td>epsilon0_const</td><td>1&#x2F;mu0_const&#x2F;c_const&#x2F;c_const</td></tr><tr><td>普朗克常数</td><td>h_const</td><td>6.62607015e-34[J*s]</td></tr><tr><td>普朗克常数除以2pi</td><td>hbar_const</td><td>1.05457172533629e-34[J*s]</td></tr><tr><td>质子质量</td><td>mp_const</td><td>1.672621777e-27[kg]</td></tr><tr><td>真空中的光速</td><td>c_const</td><td>299792458[m&#x2F;s]</td></tr><tr><td>玻尔兹曼常数</td><td>sigma_const</td><td>5.670373e-8[<code>W/(m^2*K^4)</code>]</td></tr><tr><td>通用气体常数</td><td>R_const</td><td>8.3144621[J&#x2F;(mol*K)]</td></tr><tr><td>维恩位移定律常数</td><td>b_const</td><td>2.8977721e-3[m*K]</td></tr></tbody></table><h2 id="一维PN结"><a href="#一维PN结" class="headerlink" title="一维PN结"></a>一维PN结</h2><p><a href="https://cn.comsol.com/model/pn-junction-1d-14621">官网链接</a></p><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>阳极接触与p型区相邻，阴极与n型区连接，基于麦克斯韦方程和玻耳兹曼方程推导出载流子输运的半导体模型(基于稳态问题)：</p><p><strong>半导体中的高斯定理(泊松方程)</strong></p><p>描述电场与电荷密度的关系<br>$$<br>\begin{aligned} \nabla \cdot(\varepsilon \nabla V)&#x3D;-q\left(p-n+N_{D}^{+}-N_{A}^{-}\right)  \end{aligned}<br>$$<br>左边是电位移矢量($D&#x3D;\varepsilon E &#x3D; -\varepsilon  \nabla V$)的散度，反映电场的通量(电荷)，欠个负号</p><p>右边是负的电荷密度，$\rho &#x3D; q\left(p-n+N_{D}^{+}-N_{A}^{-}\right)$是半导体中的总(+)电荷密度</p><p>在半导体的耗尽区，无自由载流子，但有电离的施主和受主，方程简化为：<br>$$<br>\begin{aligned}\nabla \cdot(\varepsilon \nabla V) &#x3D; -q(N_D^{+} - N_A^{-}) \end{aligned}<br>$$<br>这与耗尽区的电荷分布一致(耗尽区的电荷由电离杂质决定)</p><p><strong>电流连续性方程</strong></p><p>描述载流子电流密度与SRH净复合率的关系($\nabla\cdot \vec J &#x3D; -\partial \rho &#x2F;\partial t$)，是电荷守恒定律的体现</p><p>正值表示净流出，负值表示净流入，所以右侧负号<br>$$<br>\begin{aligned}<br>\nabla \cdot \vec J_n&#x3D;-q R_{SRH} \qquad<br>\nabla \cdot \vec J_p&#x3D;q R_{SRH}<br>\end{aligned}<br>$$</p><p>左边是载流子电流密度的散度，反映载流子数量的变化</p><p>当$R_{SRH}&gt;0$(净复合)时，电子在某处减少(被复合)，所以必须有电子电流汇入以补充，电流密度散度为负；对空穴来说，复合意味着空穴也减少，但由于空穴带正电，所以符号方向相反</p><p>在该案例中假设$R_{SRH}$是电子和空穴复合的唯一来源</p><blockquote><p>$R_{SRH}$是<code>Shockley-Read-Hall</code>复合速率，是硅基半导体的主要复合机制</p><p>$R_{SRH} $理论详细见<a href="/posts/18299.html" title="复合理论">复合理论</a></p></blockquote><p>假设等温、非简并半导体具有恒定的能带结构，电子流和空穴流表示为<br>$$<br>\begin{aligned}<br>\vec J_n  &#x3D;-n q \mu_{n} \nabla V+\mu_n k_B T \nabla n \qquad<br>\vec J_p  &#x3D;-p q \mu_{p} \nabla V-\mu_p k_B T \nabla p<br>\end{aligned}<br>$$<br>第一项为漂移电流，这部分由电场$E&#x3D;-\nabla V$引起<br>$$<br>\begin{aligned}<br>\vec J_{n,drift}&#x3D;qn\mu_nE \qquad<br>\vec J_{p,drift}&#x3D;qp\mu_pE<br>\end{aligned}<br>$$<br>第二项为扩散电流，来源于浓度梯度<br>$$<br>\begin{aligned}\vec J_{n, diff}&#x3D;\mu_n k_B T \nabla n \qquad \vec J_{p, diff}&#x3D;-\mu_p k_B T \nabla p \end{aligned}<br>$$<br>可以用爱因斯坦关系式写的更熟悉些<br>$$<br>\begin{aligned} D_n &#x3D;\mu_n \frac{k_B T}{q}\qquad  D_p&#x3D;\mu_p \frac{k_B T}{q} \end{aligned}<br>$$<br>得到<br>$$<br>\begin{aligned}\vec J_{n, diff}&#x3D;q D_n \nabla n \qquad \vec J_{p, diff}&#x3D;-q D_p \nabla p \end{aligned}<br>$$<br>负号来自于电流方向与$\nabla p$方向相反</p><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><p>本例模型模拟p-n结在反向、平衡和正向偏压下的特性，模拟的结长度为$5\mu m$，p型掺杂侧和n型掺杂侧的净掺杂浓度均为$1\times 10^{15}cm^{-3}$</p><p>模型中还添加了Shockley-Read-Hall复合特征，用于模拟通常在间接带隙半导体(例如硅，本例模型中使用的材料)中发生的复合</p><p>模型采用文献中使用的材料参数，并比较不同偏压条件下(-4V、0V和0.5V)计算出的载流子浓度分布与参考文献中的相应结果</p><blockquote><p>Kramer K M, Hitchon W N. Semiconductor devices: A simulation approach with CDROM[M]. Prentice Hall PTR, 1997.</p></blockquote><p>使用两种不同的离散化方法来求解模型：有限元(FEM)对数形式离散法和有限体积(FVM)离散法</p><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p><strong>全局定义</strong></p><table><thead><tr><th>名称</th><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>Va</td><td><code>bias*sweep</code></td><td>外加电压</td></tr><tr><td>Tl</td><td>300[K]</td><td>晶格温度</td></tr><tr><td>Na</td><td>1e15[1&#x2F;cm^3]</td><td>受主浓度</td></tr><tr><td>Nd</td><td>1e15[1&#x2F;cm^3]</td><td>施主浓度</td></tr><tr><td>epsilonr_param</td><td>11.8</td><td>相对介电常数</td></tr><tr><td>Eg0_param</td><td>1.12[V]</td><td>带隙</td></tr><tr><td>chi0_param</td><td>4.05[V]</td><td>电子亲和能</td></tr><tr><td>Ni</td><td>1.25e10[1&#x2F;cm^3]</td><td>本征载流子浓度</td></tr><tr><td>Nc_param</td><td><code>Ni*exp(Eg0_param*e_const/(2*k_B_const*Tl))</code></td><td>导带态密度</td></tr><tr><td>Nv_param</td><td><code>Ni*exp(Eg0_param*e_const/(2*k_B_const*Tl))</code></td><td>价带态密度</td></tr><tr><td>taun_param</td><td>1e-6[s]</td><td>电子寿命</td></tr><tr><td>taup_param</td><td>taun_param</td><td>空穴寿命</td></tr><tr><td>bias</td><td>-4[V]</td><td>器件偏压</td></tr><tr><td>sweep</td><td>1</td><td>偏压的扫描参数</td></tr></tbody></table><p>相对介电常数：11.8 是硅的典型值</p><p>硅的带隙：1.12eV，温度升高时带隙会略微减小，但这里假定为常数</p><p>电子亲和能：4.05 eV 是硅的典型值</p><p>掺杂浓度：$N_a$与$N_d$两个值设为相等，说明这是一个对称的 P–N 结，简化分析</p><p>本征载流子浓度：纯硅在300K时电子与空穴的平衡浓度$1.25\times 10^{10} cm^{-3}$(典型值)</p><p>导带态密度与价带态密度：来自于统计力学近似<br>$$<br>n_i^2 &#x3D; N_c N_v e^{-E_g &#x2F; (kT)}<br>$$<br>在该模型中简化，将$N_c&#x3D;N_v$，实际上取决于电子空穴有效质量<br>$$<br>N_c &#x3D; 2 \left(\frac{2\pi m_n^* k T}{h^2}\right)^{3&#x2F;2}\qquad  N_v &#x3D; 2 \left(\frac{2\pi m_p^* k T}{h^2}\right)^{3&#x2F;2}<br>$$<br>一般来说在硅中$N_v&#x2F;N_c \approx 0.37$</p><p>300K时的大概数值为<br>$$<br>N_c \approx 2.8 \times 10^{19} \mathrm{c m}^{-3} \qquad N_{v} \approx1 . 0 4 \times1 0^{1 9} \mathrm{c m}^{-3}<br>$$</p><hr><p><strong>局部变量</strong></p><p>Kramer迁移率模型</p><p>列出电子的，空穴的类似</p><table><thead><tr><th>名称</th><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>A1n</td><td><code>1430[cm^2/(V*s)]</code></td><td>A1参数</td></tr><tr><td>B1n</td><td><code>-2.2[1]</code></td><td>B1参数(无量纲)</td></tr><tr><td>MUln</td><td><code>A1n*(Tl/300[K])^B1n</code></td><td>MU1参数，<strong>晶格散射主导时</strong>电子的迁移率</td></tr><tr><td>Ain</td><td><code>4.61e17[1/(V*s*cm)]</code></td><td>Ai参数(经验拟合常数)<br />描述掺杂浓度和温度对迁移率的影响</td></tr><tr><td>Bin</td><td><code>1.52e15[1/(K^2*cm^3)]</code></td><td>Bi 参数(同Ai)</td></tr><tr><td>MUin</td><td><code>(Ain*(Tl/1[K])^(1.5)/Ntot)/(log(1+Bin*Tl^2/Ntot)-Bin*Tl^2/(Ntot+Bin*Tl^2))</code></td><td>MUi 参数，杂质散射的迁移率</td></tr><tr><td>Xn</td><td><code>sqrt(6*MUln/MUin)</code></td><td>X 参数，控制两种散射机制的权重关系</td></tr><tr><td>mu_n</td><td><code>MUln*(1.025/(1+(Xn/1.68)^1.43)-0.025)</code></td><td>电子迁移率，平滑函数，保证在两种散射机制之间过渡连续</td></tr><tr><td>Ntot</td><td><code>semi.Naminus+semi.Ndplus</code></td><td>电离杂质总数</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">温度 Tl → 晶格散射项 MUl</span><br><span class="line">掺杂浓度 Ntot + 温度 → 杂质散射项 MUi</span><br><span class="line">两者通过 X 参数融合 → 最终迁移率 μ</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>主要操作跟官方教程走就行，这里讲一下一些操作的原因</p><p><strong>在半导体的设置窗口中，单击以展开离散化栏，从公式列表中选择有限元，对数公式(线性形函数)</strong></p><p>当势能差很大(例如在P-N结耗尽区)，电子或空穴浓度呈<font color='DarkViolet'>指数分布变化</font></p><p>普通有限元法若直接用线性形函数去近似 $n$ 与 $V$ 的空间分布，就会产生数值扩散或假振荡，因为线性插值函数无法精确捕捉指数曲线</p><p>对数公式是一种特殊的有限元离散方法，它在单元级的插值中对浓度采用了对数形式，使得在局部指数变化时仍能保持高精度和数值稳定性</p><p>对数有限元形式的线性形函数其实仍然使用一阶单元，但在离散时会对变量进行指数变换(或称对数平均)，从而让电荷输运的对称性得到保持，不会因离散误差而破坏电流连续性</p><p><strong>右键单击组件1 &gt; 几何 1 并选择线段间隔</strong>  </p><p>线段间隔决定了坐标轴上的区间范围，相当于设定了“模拟器件的物理尺寸”</p><p>每个间隔的端点会自动成为几何点，而这些点通常就是金属接触或电势边界的位置，所以线段间隔的定义也直接影响了后续边界条件的指定</p><p><strong>插值</strong></p><p><code>Kramer Eq V</code>：平衡偏压(0 V)下的参考电势分布</p><p><code>Kramer Fwd V</code>：正向偏压(+0.5 V)下的参考电势分布</p><p><code>Kramer Rev V</code>：反向偏压(–4 V)下的参考电势分布</p><p><code>Kramer Eq n</code>, <code>Kramer Eq p</code> 等：对应条件下电子与空穴浓度的参考分布</p><p>是用来导入文献参考结果的电势分布函数，以便将 COMSOL 的计算结果与理论或参考结果进行对比验证，像是一条真值曲线，用于测试模型是否解得正确</p><p><strong>在定义工具栏中单击非局部耦合，然后选择积分</strong>  </p><p>相当于做了一个基准电势归零的操作，让电势曲线的零点始终在边界1处，从而得到相对电势分布</p><p><strong>定位到迁移率模型，从列表中选择用户定义，输入”mu_n” “mu_p”</strong>  </p><p>变为变量，不再是常量，迁移率就会随着温度场或掺杂分布变化而自动更新</p><p><strong>陷阱辅助复合</strong>  </p><p>硅类半导体载流子复合的主要物理机制，在直接带隙材料(如GaAs)中，电子和空穴可以通过辐射复合(直接跃迁)，但在硅这类间接带隙材料中，这种直接跃迁的概率非常低</p><p><strong>复制半导体(semi)</strong></p><p>方便后面添加第二个研究，不冲突</p><p><strong>研究展开研究扩展栏，选中辅助扫描复选框，从扫描类型列表中选择所有组合，添加</strong></p><table><thead><tr><th>参数名称</th><th>参数值列表</th><th>参数单位</th></tr></thead><tbody><tr><td>bias(器件偏压)</td><td>-4 0 0.5</td><td>V</td></tr><tr><td>sweep(逐渐提高偏压的扫描参数)</td><td>0 1</td><td></td></tr></tbody></table><p>这是给有限元法准备的扫描参数，在后续选择不同电压条件的时候需要考虑第一个还是最后一个</p><p><strong>在线结果图的设置窗口中， 定位到 x 轴数据栏，从参数列表中选择表达式，在表达式文本框中键入“x”</strong></p><p>默认可能是参数值或者索引，需要把表达式改成<code>x</code>，让COMSOL以几何坐标为横轴绘制物理分布</p><p>(原来图上范围为0-5，改完之后变为-2.5~2.5)</p><p>图例改成FE是因为FE是有限元法的简称</p><p><strong>结果&gt;电势节点，然后单击线结果图1，y轴数据栏在表达式文本框中键入“V-intop1(V)”</strong></p><p>把整个器件的电势分布减去某个积分算出来的参考电位，从而得到相对电势</p><p><strong><code>V</code></strong> ：电势场，从物理场中求解所得</p><p><code>intop1(...)</code> ：积分算符，在定义阶段创建的“非局部耦合&gt;积分”节点生成的，换算成为相对电势</p><p><strong>添加研究</strong>  </p><p>为了比较有限元对数形式与有限体积法，需要更改离散方法，并添加第二个研究，用新的选择重新求解模型</p><p>FVM内置了物理导向的指数插值，对电势差的敏感性比 FEM 小得多，不需要电压逐渐升高，因此Va的期望值可以直接在辅助扫描中设置</p><table><thead><tr><th>参数名称</th><th>参数值列表</th><th>参数单位</th></tr></thead><tbody><tr><td>Va (外加电压)</td><td>-4 0 0.5</td><td>V</td></tr></tbody></table><p>在后续选择不同电压条件的时候使用列表索引</p><p><strong>添加线结果图3、4、5</strong></p><p>引入参考文献插值解用于对比结果</p><h2 id="GaAs光电二极管"><a href="#GaAs光电二极管" class="headerlink" title="GaAs光电二极管"></a>GaAs光电二极管</h2><h3 id="模型定义-1"><a href="#模型定义-1" class="headerlink" title="模型定义"></a>模型定义</h3><p>模拟一个简单的矩形砷化镓 PIN 结构，顶面上有一个 p 型接触，在底面上有一个 n 型接触 </p><p>顶部是p⁺ – p – i 结构，底部是 n – n⁺ 结构，中间约0.7$\mu m$为本征层</p><p>由于导带和价带的倾斜特性：导带能量在 p 接触端最高，在 n 接触端最低</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20221226170804681_2025.webp" alt="image-20221226170804681_2025" style="zoom: 50%;" /><p>当一个光子被吸收并产生电子—空穴对时，电子会被电场驱动向 n 接触端运动，而空穴则朝相反方向移动到 p 接触端</p><p>在该结构中，p 接触端接地，n 接触端施加 2 V 电压，使其处于反向偏置状态(reverse bias)</p><p>对于给定波长的入射光，输出电流与光照强度成线性关系</p><p>反向偏置不仅会增大能带的倾斜度，还会扩大耗尽层的宽度，从而缩短响应时间，但这也会增加暗电流</p><ul><li><p><strong>半导体接口</strong>用于定义器件的掺杂分布和电接触区域</p></li><li><p><strong>电磁波，频域接口</strong>用于定义入射的电磁辐射</p></li><li><p><strong>光跃迁节点</strong>配置两个接口之间的耦合</p></li></ul><p>该模型采用直接带隙模型来计算吸收过程，对于本模型所使用的 GaAs 材料而言，这是一种合理的近似</p><p>利用材料内电子空穴对的自发复合寿命，确定导带与价带中具有相同波矢状态的相互作用强度，从而计算自发辐射和受激辐射</p><p>频域计算通过引入一个额外的维度来表示，从而可以将某些特性可视化为光子能量的函数，这使得可以绘制自发辐射光谱</p><p>光子的吸收不仅在载流子连续性方程中引入了电子和空穴的生成项，还会引起材料极化率的变化</p><p>在模型构建树中的多物理场节点下，通过“半导体-电磁波耦合”实现两个接口的自动耦合，将电磁波频域接口中计算得到的电场用作半导体接口中吸收过程的输入，同时根据半导体接口计算出的结果修正电磁波接口中的材料极化率，以反映由载流子行为引起的变化</p><p>模型中执行波长扫描，其中入射光的功率保持恒定，波长范围为 875 nm 到 475 nm</p><p>砷化镓材料的带隙为1.424 eV，相当于约 872 nm 的波长</p><h3 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h3><p><font color='Violetred'>二维模型，请特别注意涉及面外厚度的参数</font></p><table><thead><tr><th>名称</th><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>w_dom</td><td>5[um]</td><td>宽度</td></tr><tr><td>h_dom</td><td>1[um]</td><td>厚度</td></tr><tr><td>V_n</td><td>2[V]</td><td>n 型接触电压</td></tr><tr><td>V_p</td><td>0[V]</td><td>p 型接触电压</td></tr><tr><td>hbar0</td><td>h_const&#x2F;(2*pi)</td><td>无弧度单位的hbar</td></tr><tr><td>lda0</td><td>870[nm]</td><td>入射波长</td></tr><tr><td>f0</td><td>c_const&#x2F;lda0</td><td>入射频率</td></tr><tr><td>omega0</td><td><code>2*pi*1[rad]*f0</code></td><td>入射角频率</td></tr><tr><td>E_ph</td><td>f0*h_const</td><td>入射光子能量</td></tr><tr><td>n0</td><td>3.5</td><td>GaAs折射率(实部)</td></tr><tr><td>tau</td><td>2[ns]</td><td>自发寿命</td></tr><tr><td>d0</td><td>1[um]</td><td>半导体接口的面外厚度<br />(波动光学接口中默认为 1 m)</td></tr><tr><td>Pin</td><td>10[uW]</td><td>面外厚度 d0 &#x3D; 1 um 时的入射功率</td></tr></tbody></table><p>波长：870nm，光子能量约为1.425eV，接近带隙，吸收&#x2F;反射都会很敏感</p><p>面外厚度：在二维仿真中，功率单位通常是W&#x2F;m，引入一个面外厚度使得入射功率可以换算为总功率</p><p>自发寿命：代表电子–空穴对平均存在的时间，寿命越长，复合速率越低，说明材料缺陷较少或复合为辐射型，2ns是GaAs的典型辐射寿命</p><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p><strong>设置掺杂</strong></p><p>解析掺杂模型：用数学函数在器件内部定义“本底掺杂”以及主体的 p 区 &#x2F; n 区的掺杂分布(例如常数、线性、指数或高斯型)，常用于描述器件的主体结结构和掺杂梯度</p><p>几何掺杂模型：直接在几何区域上画上高掺杂层(例如在器件顶部&#x2F;底部靠近金属的那一层做 p⁺ &#x2F; n⁺)，用于模拟为了改善金属接触而刻意做的极浅&#x2F;薄高掺杂层</p><p><strong>三个p掺杂区</strong></p><p>定义从器件上方(金属接触)到内部的三个连续区域</p><ul><li><p>恒定的 p 型掺杂 → 主体 p 区(保证耗尽区宽度与光吸收)</p><p>解析掺杂模型，浓度$N_{A0}&#x3D;1\times 14cm^{-3}$(较低)，代表p主体层或i区延伸部分</p></li><li><p>p 型掺杂 → 渐变过渡层(连接主体与接触)</p><p>解析掺杂模型，浓度提高到$N_{A0}&#x3D;1\times 18cm^{-3}$，用来建立结区电场的 p 侧</p><p>从<code>(0，0.9*h_dom)</code>开始(顶部10%)，与主体层形成一个平滑的掺杂过渡</p><p>$d_j$代表扩散过渡区域的厚度，用于平滑边界</p></li><li><p>p⁺ 型掺杂 → 高掺杂接触层(实现低阻欧姆接触)</p><p>几何掺杂模型，浓度提高到$N_{A0}&#x3D;1\times 20cm^{-3}$，属于极高掺杂层</p><p>用于与金属接触形成欧姆接触，被定义在器件最上方、厚度约<code>0.1h_dom</code>的区域</p></li></ul><p>五个掺杂区</p><table><thead><tr><th>区域</th><th>类型</th><th>掺杂浓度</th><th>模型类型</th></tr></thead><tbody><tr><td>恒定的 p 型掺杂</td><td>受主</td><td>1e14 cm⁻³</td><td>解析(背景 p)</td></tr><tr><td>p 型掺杂</td><td>受主</td><td>1e18 cm⁻³</td><td>解析(主体 p)</td></tr><tr><td>p⁺ 型掺杂</td><td>受主</td><td>1e20 cm⁻³</td><td>几何(接触层)</td></tr><tr><td>n 型掺杂</td><td>施主</td><td>1e18 cm⁻³</td><td>解析(主体 n)</td></tr><tr><td>n⁺ 型掺杂</td><td>施主</td><td>1e20 cm⁻³</td><td>几何(接触层)</td></tr></tbody></table><p>中间的 i 区是几乎未掺杂或极轻 p 型，用恒定的 p 型掺杂表示背景掺杂就足够，不需要恒定n型掺杂</p><p><strong>材料折射率虚部设为0</strong></p><p>在电磁学中<br>$$<br>\tilde{n}&#x3D;n+i \kappa<br>$$<br>实部决定光传播速度(折射)；虚部$\kappa$决定光吸收</p><p>在这个 PIN 光电二极管模型中，光吸收不是通过折射率虚部来建模的，而是由半导体物理接口自身的“光跃迁”节点计算得到的，再设一个非零虚部，反而会重复计算吸收，所以这里设为0</p><p><strong>从求解的电场分量列表中选择面外矢量</strong></p><p>因为模型是二维(x–y 平面)的，实际的光沿y传播方向</p><p>为了在二维模型中表示一个三维平面波的传播，电场当作面外分量(z方向震荡)</p><p>这是一种常见的简化，称为 TE 模式(横电模式)</p><p><strong>边界 1 和 4 设置为“周期性条件”</strong></p><p>由于模型是二维的(只考虑垂直方向变化)，相当于假设在水平方向上无限延伸，这样光场不会在侧边泄露，也避免了侧壁反射</p><p><strong>映射分布设置</strong></p><p>边界3上设为1保持水平方向一致，边界1上设为500表示y方向分为500区间来分析</p><p><strong>积分1的定义</strong></p><p>非局部积分耦合，在整个半导体域上对各种物理量进行积分</p><p><strong>绘图参数</strong></p><p><code>semi.Nd</code> —— 表示施主掺杂浓度</p><p><code>semi.Na</code> —— 表示受主掺杂浓度</p><p>因为x轴反转弧长了，所以在绘图时y是从顶部开始</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🥼半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟摄像头构建</title>
      <link href="/posts/29316.html"/>
      <url>/posts/29316.html</url>
      
        <content type="html"><![CDATA[<p>电脑没有摄像头想用手机替代一下，就有了这个博客</p><p>需要下载两个软件，exe的是电脑的，apk的是手机的</p><p><a href="https://pan.quark.cn/s/7abf93ef69b4">下载链接</a> 提取码：PwAD</p><p>安装好后手机通过和电脑同一个WIFI或者USB连接即可</p><p>USB连接需要打开开发者模式，开启USB调试功能，注意检查手机和电脑的USB连接驱动哦，不同手机的解决方案不太一样，但是现在手机正常都会自动安装驱动</p><p>如果成功启用，在windows+X打开设备管理器，在照相机里会有一个<code>Iriun Webcam</code></p><p>到此就可以使用啦~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🛠️基础工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV基础</title>
      <link href="/posts/12373.html"/>
      <url>/posts/12373.html</url>
      
        <content type="html"><![CDATA[<p>OpenCV 是一个功能强大、应用广泛的计算机视觉库，提供了大量的计算机视觉算法和图像处理工具，广泛应用于图像和视频的处理、分析以及机器学习领域</p><p>使用pip安装是最简单和直接的方法，只需要在命令行中输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><p>安装后导入包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br></pre></td></tr></table></figure><h2 id="图像理论"><a href="#图像理论" class="headerlink" title="图像理论"></a>图像理论</h2><p>图像在计算机中本质上是以数字矩阵的形式存储的，其核心概念包括像素网格和颜色通道</p><p><strong>像素网格:</strong></p><ul><li>像素(pixel)：图片的最小单元，每个像素有位置(行、列)和颜色值</li><li>分辨率：宽×高(例如1920×1080)，表示像素矩阵的尺寸</li><li>像素矩阵：一张图片在内存里通常就是一个二维或三维数组(矩阵)，<font color='Violetred'>H行xW列(x3or4通道)</font>，坐标系通常是左上角为原点(行号向下增大)</li></ul><p><strong>颜色与通道:</strong></p><ul><li>RGB：最常见，基于人眼感知颜色的方式，每个像素由3个通道(红、绿、蓝)组合成颜色</li><li>RGBA：RGB + Alpha(透明度)，Alpha 通道决定像素的透明程度</li><li>灰度：只有一个通道(亮度)，常用公式把 RGB 转成灰度：<code>Y = 0.299 R + 0.587 G + 0.114 B</code>(ITU标准) <font color='Violetred'>0为黑，255为白</font></li><li>CMYK：印刷领域(青、品红、黄、黑)，基于减色法</li><li>YCbCr：主要用于JPEG，RGB转YCbCr，再对Cb、Cr下采样(4:2:0常见)，再做DCT压缩</li></ul><p><code>Pillow/Matplotlib</code>用RGB顺序，<font color='Violetred'>OpenCV默认用BGR</font>，注意转换</p><p><strong>位深与数据类型:</strong></p><ul><li><p>常见：8位每通道(uint8)，范围0–255，RGB24(3×8&#x3D;24 位)是最常见的普通图像</p></li><li><p>高精度：16位每通道(uint16)，范围0–65535，或32位浮点(float32)用于科学&#x2F;HDR</p></li></ul><p><strong>常见的存储方式：</strong></p><table><thead><tr><th>格式</th><th>压缩方式</th><th>是否有损</th><th>支持透明度</th><th>特点与应用场景</th></tr></thead><tbody><tr><td>BMP</td><td>无</td><td>无损</td><td>支持</td><td>简单直白，文件大</td></tr><tr><td>PNG</td><td>DEFLATE</td><td>无损</td><td>支持 Alpha</td><td>体积比BMP小<br />常用于需要透明的图形</td></tr><tr><td>GIF</td><td>LZW</td><td>无损</td><td>1 位透明</td><td>支持简单动画，但颜色数少</td></tr><tr><td>SVG</td><td>XML，可GZIP</td><td>无损</td><td>支持 Alpha</td><td>无限缩放不失真<br />图标&#x2F;插画&#x2F;图表</td></tr><tr><td>JPEG</td><td>DCT+量化</td><td>有损</td><td>不支持</td><td>照片最常用格式，高压缩比<br />反复保存会劣化</td></tr><tr><td>TIFF</td><td>多种</td><td>均可</td><td>支持</td><td>专业图像格式，高位深<br />摄影、医学、印刷常用</td></tr><tr><td>WebP</td><td>VP8&#x2F;VP8L压缩</td><td>均可</td><td>支持 Alpha</td><td>压缩比优于JPEG&#x2F;PNG，Web 常见</td></tr></tbody></table><h2 id="代码性能评估"><a href="#代码性能评估" class="headerlink" title="代码性能评估"></a>代码性能评估</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">start = cv2.getTickCount()</span><br><span class="line"><span class="comment"># 这里写测试代码...</span></span><br><span class="line">end = cv2.getTickCount()</span><br><span class="line"><span class="built_in">print</span>((end - start) / cv2.getTickFrequency())</span><br></pre></td></tr></table></figure><p>也可以用 time 模块计时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.clock()</span><br><span class="line"><span class="comment"># 这里写测试代码...</span></span><br><span class="line">end = time.clock()</span><br><span class="line"><span class="built_in">print</span>(end - start)</span><br></pre></td></tr></table></figure><p>数据元素少时用 Python 语法，数据元素多时用 Numpy</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">z = np.uint8([<span class="number">10</span>])</span><br><span class="line">start = cv2.getTickCount()</span><br><span class="line">y = z*z*z <span class="comment"># 5.46e-05(最慢）</span></span><br><span class="line"><span class="comment"># y = x*x*x # 2.14e-05</span></span><br><span class="line"><span class="comment"># y = x**3 # 4.55e-05</span></span><br><span class="line">end = cv2.getTickCount()</span><br><span class="line"><span class="built_in">print</span>((end - start) / cv2.getTickFrequency())</span><br></pre></td></tr></table></figure><h2 id="图像基础操作"><a href="#图像基础操作" class="headerlink" title="图像基础操作"></a>图像基础操作</h2><p><strong>读取图片</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;Lena.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 读取保护</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot load image&quot;</span>)</span><br><span class="line">    exit()</span><br></pre></td></tr></table></figure><p>参数1：图片的文件名</p><p>参数2：读入方式，省略即采用默认值</p><ul><li><code>cv2.IMREAD_COLOR</code>：彩色图，默认值(1)</li><li><code>cv2.IMREAD_GRAYSCALE</code>：灰度图(0)</li><li><code>cv2.IMREAD_UNCHANGED</code>：包含透明通道的彩色图(-1)</li></ul><p><strong>显示图片</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&quot;Lena&quot;</span>,img) <span class="comment"># 参数1是窗口的名字，参数2是要显示的图片</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  <span class="comment"># 等待键盘输入(毫秒)，0 表示无限等待</span></span><br><span class="line"><span class="comment"># plt.imshow(img, &#x27;gray&#x27;) # 也可以用plt的imshow</span></span><br></pre></td></tr></table></figure><p><strong>保存图片</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&quot;Lena_gray.bmp&quot;</span>,img)</span><br></pre></td></tr></table></figure><p>可以传入第三个参数：</p><ul><li><code>cv2.IMWRITE_JPEG_QUALITY</code>：jpg 质量控制，取值 0~100，值越大质量越好，默认为 95</li><li><code>cv2.IMWRITE_PNG_COMPRESSION</code>：png 质量控制，取值 0~9，值越大压缩比越高，默认为 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&#x27;img_jpg20.jpg&#x27;</span>,img, [<span class="built_in">int</span>(cv2.IMWRITE_JPEG_QUALITY), <span class="number">20</span>]) <span class="comment"># 9.74kB</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;img_jpg100.jpg&#x27;</span>,img, [<span class="built_in">int</span>(cv2.IMWRITE_JPEG_QUALITY), <span class="number">100</span>]) <span class="comment"># 137kB</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;img_png.png&#x27;</span>,img) <span class="comment"># 134kB</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;img_png9.png&#x27;</span>,img,[<span class="built_in">int</span>(cv2.IMWRITE_PNG_COMPRESSION),<span class="number">9</span>]) <span class="comment"># 132kB</span></span><br></pre></td></tr></table></figure><h3 id="图像矩阵"><a href="#图像矩阵" class="headerlink" title="图像矩阵"></a>图像矩阵</h3><p>OpenCV读进来的图像是NumPy数组，shape通常是<code>(H, W, C)</code>，可以通过<code>img.shape</code>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height, width, channels = img.shape</span><br><span class="line"><span class="comment"># img 是灰度图的话：height, width = img.shape</span></span><br></pre></td></tr></table></figure><p>图像是由像素组成的矩阵，每个像素都有一个或多个值，表示颜色或灰度</p><p><font color='Violetred'>OpenCV默认的颜色空间为BGR</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;LenaRGB.bmp&quot;</span>,<span class="number">1</span>)</span><br><span class="line">px = img[<span class="number">99</span>,<span class="number">99</span>]  </span><br><span class="line"><span class="built_in">print</span>(px)  <span class="comment"># 输出BGR[79 59 177]</span></span><br><span class="line">px_blue = img[<span class="number">99</span>,<span class="number">99</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(px_blue) <span class="comment"># 输出B 79</span></span><br></pre></td></tr></table></figure><p>ROI(Region of Interest)：利用<code>:</code>，也就是numpy的切片，将图片中的区域裁切出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取脸部 ROI</span></span><br><span class="line">face = img[<span class="number">239</span>:<span class="number">388</span>, <span class="number">238</span>:<span class="number">356</span>]</span><br><span class="line">cv2.imshow(<span class="string">&quot;face&quot;</span>,face)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h3><p>OpenCV 支持多种颜色空间的转换，通过<code>cv2.cvtColor(img, code)</code></p><p>常用转化<code>code</code>：</p><ul><li><code>cv2.COLOR_BGR2GRAY</code>: BGR彩色 -&gt; 灰度</li><li><code>cv2.COLOR_BGR2RGB</code>: BGR彩色 -&gt; RGB彩色(用于Matplotlib等显示)</li><li><code>cv2.COLOR_BGR2HSV</code>: BGR彩色 -&gt; HSV(色相、饱和度、亮度)</li><li><code>cv2.COLOR_GRAY2BGR</code>: 灰度 -&gt; BGR彩色 (单通道转三通道)</li></ul><p>颜色通道的分离与合并：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分离通道</span></span><br><span class="line">b, g, r = cv2.split(image)</span><br><span class="line"><span class="comment"># 合并通道</span></span><br><span class="line">merged_image = cv2.merge([b, g, r])</span><br></pre></td></tr></table></figure><p>单通道显示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;LenaRGB.bmp&quot;</span>,<span class="number">1</span>)</span><br><span class="line">b, g, r = cv2.split(img)</span><br><span class="line"><span class="comment"># 单通道保留，其他置零</span></span><br><span class="line">zeros = np.zeros_like(b)</span><br><span class="line">blue_img = cv2.merge([b, zeros, zeros])   <span class="comment"># 蓝色图</span></span><br><span class="line">green_img = cv2.merge([zeros, g, zeros])  <span class="comment"># 绿色图</span></span><br><span class="line">red_img = cv2.merge([zeros, zeros, r])    <span class="comment"># 红色图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(blue_img)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">plt.imshow(green_img)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">plt.imshow(red_img)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509241324.webp" alt="202509241324" style="zoom:67%;" /><h4 id="RGB-调色板"><a href="#RGB-调色板" class="headerlink" title="RGB 调色板"></a>RGB 调色板</h4><p>首先需要知道如何创建滑动条(滑块最小值固定为0)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(trackbarName, windowName, value, max_value ,call_back)</span><br></pre></td></tr></table></figure><p>实现一个 RGB 的调色板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 创建一个黑色的画布</span></span><br><span class="line">img = np.zeros((<span class="number">300</span>,<span class="number">500</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;RGB Palette&quot;</span>)</span><br><span class="line"><span class="comment"># 创建三个滑动条，分别对应 R/G/B</span></span><br><span class="line">cv2.createTrackbar(<span class="string">&quot;R&quot;</span>,<span class="string">&quot;RGB Palette&quot;</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">&quot;G&quot;</span>,<span class="string">&quot;RGB Palette&quot;</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;RGB Palette&quot;</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 读取滑动条的值</span></span><br><span class="line">    r = cv2.getTrackbarPos(<span class="string">&quot;R&quot;</span>, <span class="string">&quot;RGB Palette&quot;</span>)</span><br><span class="line">    g = cv2.getTrackbarPos(<span class="string">&quot;G&quot;</span>, <span class="string">&quot;RGB Palette&quot;</span>)</span><br><span class="line">    b = cv2.getTrackbarPos(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;RGB Palette&quot;</span>)</span><br><span class="line">    <span class="comment"># 更新画布颜色(注意 OpenCV 是 BGR 顺序)</span></span><br><span class="line">    img[:] = [b, g, r]</span><br><span class="line">    <span class="comment"># 显示结果</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;RGB Palette&quot;</span>, img)</span><br><span class="line">    <span class="comment"># 按下 ESC 键退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p><font color='Violetred'>在cv2的函数中输入的一般是(w,h)，虽然在numpy输出的shape是(h,w)</font></p><h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><p><code>cv2.warpAffine()</code>：仿射变换是一种保持直线和比例关系的线性几何变换</p><p>长度&#x2F;角度可能变化，但相对位置关系不变</p><p>常见的仿射变换包括：缩放、翻转、平移、旋转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.warpAffine(img, M, dsize)</span><br></pre></td></tr></table></figure><p>其中<code>M</code>是变换矩阵，<code>dsize</code>是输出图像大小<code>(width, height)</code></p><p>变换矩阵可以通过<code>cv2.getAffineTransform()</code>求得，只需要知道变换前后对应三个点的坐标即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;Lena.bmp&quot;</span>)</span><br><span class="line">rows, cols = img.shape[:<span class="number">2</span>] <span class="comment"># 获取原图(height, width)</span></span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>, <span class="number">50</span>], [<span class="number">100</span>, <span class="number">50</span>], [<span class="number">50</span>, <span class="number">200</span>]])  <span class="comment"># 原图 3 点</span></span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">150</span>, <span class="number">50</span>], [<span class="number">100</span>, <span class="number">250</span>]]) <span class="comment"># 目标 3 点</span></span><br><span class="line"><span class="comment"># 生成变换矩阵</span></span><br><span class="line">M = cv2.getAffineTransform(pts1, pts2)</span><br><span class="line">dst = cv2.warpAffine(img, M, (cols*<span class="number">2</span>, rows*<span class="number">2</span>)) <span class="comment"># 输入(width,height)</span></span><br><span class="line">plt.imshow(dst,<span class="string">&#x27;gray&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/20259242130.webp" alt="20259242130" style="zoom: 67%;" /><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p><code>cv2.resize()</code>：调整图像大小(放大或缩小)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定尺寸(width,height)</span></span><br><span class="line">resized_img = cv2.resize(img, (new_width,new_height))</span><br><span class="line"><span class="comment"># 按比例缩小</span></span><br><span class="line">scale_factor = <span class="number">0.5</span></span><br><span class="line">resized_img = cv2.resize(img, <span class="literal">None</span>, fx=scale_factor, fy=scale_factor, interpolation=cv2.INTER_AREA)</span><br></pre></td></tr></table></figure><p><code>interpolation</code>(插值方法)：</p><ul><li><code>cv2.INTER_LINEAR</code> 双线性(默认，放大推荐)</li><li><code>cv2.INTER_AREA</code> 区域插值(缩小推荐)</li><li><code>cv2.INTER_CUBIC</code> 三次插值(更平滑，慢)</li><li><code>cv2.INTER_NEAREST</code> 最近邻(最快，但可能马赛克)</li></ul><h4 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h4><p><code>cv2.flip()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flipped_img = cv2.flip(image, flip_code)  </span><br><span class="line"><span class="comment"># flip_code: 0 (垂直翻转), 1 (水平翻转), -1 (双向翻转)</span></span><br></pre></td></tr></table></figure><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p>使用仿射变换函数<code>cv2.warpAffine()</code></p><p>需要定义一个变换矩阵，$tx ,ty$是向$x$和$y$方向平移的距离，$M&#x3D;[[1,0,t_x],[0,1,t_y]]$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(h, w) = img.shape[:<span class="number">2</span>]  <span class="comment"># 输出高与宽</span></span><br><span class="line"><span class="comment"># 向右移100像素，向下移50像素</span></span><br><span class="line">translation_matrix = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>]])  </span><br><span class="line">shifted_img = cv2.warpAffine(img, translation_matrix, (w, h))</span><br></pre></td></tr></table></figure><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>使用仿射变换函数<code>cv2.warpAffine()</code></p><p>绕某个点旋转，可伴随缩放，也需要定义一个变换矩阵</p><p>通过<code>cv2.getRotationMatrix2D()</code>函数来生成这个矩阵，该函数有三个参数</p><ul><li>参数1：图片的旋转中心(一般是<code>(w//2,h//2)</code>)</li><li>参数2：旋转角度(正：逆时针，负：顺时针)</li><li>参数3：缩放比例，0.5 表示缩小一半</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">center = (w//<span class="number">2</span>, h//<span class="number">2</span>)</span><br><span class="line">rotation_matrix = cv2.getRotationMatrix2D(center, <span class="number">45</span>, <span class="number">0.5</span>)</span><br><span class="line">rotated_img = cv2.warpAffine(img, rotation_matrix, (w, h))</span><br></pre></td></tr></table></figure><h3 id="图像加减法"><a href="#图像加减法" class="headerlink" title="图像加减法"></a>图像加减法</h3><p>相加减两幅图片的形状(高度&#x2F;宽度&#x2F;通道数)必须相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = cv2.add(img1, img2) <span class="comment"># 相加</span></span><br><span class="line">result = cv2.subtract(img1, img2)  <span class="comment"># 相减</span></span><br></pre></td></tr></table></figure><p>numpy中可以直接用 <code>res = img + img1</code> 相加，但这两者的结果并不相同</p><p>如果像素值相加后超过255，OpenCV 会自动将其截断为255(注意，必须是二维矩阵)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.uint8([[<span class="number">250</span>]]) <span class="comment"># 注意是 2D</span></span><br><span class="line">y = np.uint8([[<span class="number">10</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cv2.add:&quot;</span>, cv2.add(x, y))  <span class="comment"># [[255]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;numpy + :&quot;</span>, x + y)  <span class="comment"># [[4]]</span></span><br></pre></td></tr></table></figure><h3 id="图像位运算"><a href="#图像位运算" class="headerlink" title="图像位运算"></a>图像位运算</h3><p>图像位运算是将两幅图像的每个像素值转为二进制以后进行位操作</p><p><font color='Violetred'>图像必须是相同大小和通道数，否则不能直接做按位运算</font></p><p>主要用于<strong>二值图像处理</strong>以及<strong>掩膜运算</strong>(掩膜mask是对一幅图片进行局部的遮挡)</p><table><thead><tr><th align="left">函数</th><th align="left">功能</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left"><code>cv2.bitwise_and(img1,img2)</code></td><td align="left">按位与操作</td><td align="left">掩膜交集</td></tr><tr><td align="left"><code>cv2.bitwise_or(img1,img2)</code></td><td align="left">按位或操作</td><td align="left">掩膜并集</td></tr><tr><td align="left"><code>cv2.bitwise_not(img)</code></td><td align="left">按位取反操作</td><td align="left">反转掩膜</td></tr><tr><td align="left"><code>cv2.bitwise_xor(img1,img2)</code></td><td align="left">按位异或操作</td><td align="left">掩膜并集-交集</td></tr></tbody></table><p>利用<strong>图片自身按位与</strong>，<font color='Violetred'>掩膜上为255的保留原值，为0的区域置0</font></p><h4 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">&quot;LenaRGB.bmp&quot;</span>, <span class="number">1</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">&quot;OpenCV_logo_no_text.png&quot;</span>, <span class="number">1</span>)</span><br><span class="line">img2 = cv2.resize(img2,(img1.shape[<span class="number">1</span>],img1.shape[<span class="number">0</span>])) <span class="comment"># 匹配大小</span></span><br><span class="line"><span class="comment"># 转灰度图好创建掩膜</span></span><br><span class="line">img2_gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)</span><br><span class="line">plt.imshow(img2_gray, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509241712.webp" alt="202509241712" style="zoom: 67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建掩膜</span></span><br><span class="line"><span class="comment"># 主体掩膜，背景全0，主体255，保留主体</span></span><br><span class="line">_, mask = cv2.threshold(img2_gray, <span class="number">10</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 反转，背景掩膜，主体为0，背景255，保留背景</span></span><br><span class="line">mask_inv = cv2.bitwise_not(mask)</span><br><span class="line"><span class="comment"># 保留img1的背景</span></span><br><span class="line">img1_bg = cv2.bitwise_and(img1, img1, mask=mask_inv) <span class="comment"># 自身取与</span></span><br><span class="line"><span class="comment"># 提取img2主体</span></span><br><span class="line">img2_fg = cv2.bitwise_and(img2, img2, mask=mask) <span class="comment"># 自身取与</span></span><br><span class="line">res = cv2.add(img1_bg,img2_fg)  <span class="comment"># 加法融合</span></span><br><span class="line"><span class="comment"># cv2.imshow(&quot;result&quot;, res)</span></span><br><span class="line"><span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">res = cv2.cvtColor(res, cv2.COLOR_BGR2RGB)</span><br><span class="line">plt.imshow(res)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509241257.webp" alt="202509241257" style="zoom: 67%;" /><h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h4><p><font color='Violetred'>按位或并不等同于图像叠加</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">&quot;Lena.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">&quot;OpenCV_logo_no_text.png&quot;</span>, <span class="number">0</span>)</span><br><span class="line">img2 = cv2.resize(img2,(img1.shape[<span class="number">1</span>],img1.shape[<span class="number">0</span>])) <span class="comment"># 匹配大小</span></span><br><span class="line">res1 = cv2.bitwise_or(img1, img2) <span class="comment"># 无法形成透明效果</span></span><br><span class="line">res2 = cv2.addWeighted(img1, <span class="number">0.5</span>, img2, <span class="number">0.5</span>, <span class="number">0</span>) <span class="comment"># 产生自然的图像融合</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.imshow(res1, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(res2,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509241733.webp" alt="202509241733" style="zoom: 80%;" /><h2 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h2><h3 id="阿尔法混合-加权混合"><a href="#阿尔法混合-加权混合" class="headerlink" title="阿尔法混合(加权混合)"></a>阿尔法混合(加权混合)</h3><p>图像混合就是把两张图像的像素值按照一定比例组合<br>$$<br>dst(x,y) &#x3D; \alpha \cdot img1(x,y) + \beta \cdot img2(x,y) + \gamma<br>$$<br>$\gamma$ 为一个偏移量(调亮&#x2F;调暗整体效果用)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">&quot;Barbara.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">&quot;Baboon.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># # 调整两张图大小一致</span></span><br><span class="line">img2 = cv2.resize(img2,(img1.shape[<span class="number">1</span>],img1.shape[<span class="number">0</span>])) </span><br><span class="line"><span class="comment"># 做一个淡入淡出</span></span><br><span class="line"><span class="keyword">for</span> alpha <span class="keyword">in</span> np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>):</span><br><span class="line">    beta = <span class="number">1</span> - alpha</span><br><span class="line">    blended = cv2.addWeighted(img1, alpha, img2, beta, <span class="number">0</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;Blending&quot;</span>, blended)</span><br><span class="line">    cv2.waitKey(<span class="number">200</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="拉普拉斯金字塔融合"><a href="#拉普拉斯金字塔融合" class="headerlink" title="拉普拉斯金字塔融合"></a>拉普拉斯金字塔融合</h3><p>如果直接把两张图拼接，边界很明显：</p><ul><li>颜色&#x2F;亮度突变</li><li>纹理不连续</li></ul><p>即使用线性渐变(alpha blending)，仍可能出现模糊边界或鬼影</p><p>金字塔融合的核心思想：在不同的尺度(分辨率)上融合图像</p><p><font color='Violetred'>适合那些既要平滑过渡，又要细节自然的场景，但是会损失细节</font></p><p>图像金字塔有两种：<strong>高斯金字塔</strong>和<strong>拉普拉斯金字塔</strong></p><p>高斯金字塔中较高层中的每个像素都是由其下一层中的5个像素以高斯权重贡献形成的</p><p>对于$M\times N$的图像，通过<code>cv.pyrDown()</code>[下采样]变成$M&#x2F;2\times N&#x2F;2$，获得金字塔的上层<br>$$<br>G_0,G_1,G_2,\cdots,G_n<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建高斯金字塔</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_gaussian_pyramid</span>(<span class="params">img, level=<span class="number">6</span></span>): <span class="comment"># 这里level=最高层数</span></span><br><span class="line">    G = img.copy()</span><br><span class="line">    gp = [G]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level):</span><br><span class="line">        G = cv2.pyrDown(G)</span><br><span class="line">        gp.append(G)</span><br><span class="line">    <span class="comment"># gp: G0,G1...Gn </span></span><br><span class="line">    <span class="keyword">return</span> gp</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/funingna.png&quot;</span>, <span class="number">0</span>)</span><br><span class="line">gp = generate_gaussian_pyramid(img, level=<span class="number">5</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gp)):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>)</span><br><span class="line">    plt.imshow(gp[i], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">f&quot;G<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509261408.webp" alt="202509261408" style="zoom: 67%;" /><p>拉普拉斯金字塔由高斯金字塔该层与上层<code>cv.pyrUp()</code>[上采样]之间的差值形成<br>$$<br>L_i &#x3D; G_i - \mathrm{Expand}(G_{i+1})<br>$$</p><p>也可以写成(代码循环常这么写)<br>$$<br>L_{i-1} &#x3D; G_{i-1}-\mathrm{Expand}(G_{i})<br>$$<br>循环到高斯金字塔的最后一层时，没有更小的高斯层了，无法继续计算，就直接保留高斯金字塔的最小层图像(将$G_n$放到$L_n$的位置)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建拉普拉斯金字塔</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_laplacian_pyramid</span>(<span class="params">gp</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(gp)</span><br><span class="line">    lp = [gp[N-<span class="number">1</span>]] <span class="comment"># 最高层直接放入，没有上层了</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span> ,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        GE = cv2.pyrUp(gp[i])</span><br><span class="line">        <span class="comment"># resize 这步是因为如果图像的size不是偶数，上填充或下填充后尺寸不匹配</span></span><br><span class="line">        GE = cv2.resize(GE,(gp[i-<span class="number">1</span>].shape[<span class="number">1</span>],gp[i-<span class="number">1</span>].shape[<span class="number">0</span>]))</span><br><span class="line">        L = cv2.subtract(gp[i-<span class="number">1</span>], GE)</span><br><span class="line">        lp.append(L)</span><br><span class="line">    <span class="comment"># lp: Gn,Ln-1,...L0    </span></span><br><span class="line">    <span class="keyword">return</span> lp </span><br></pre></td></tr></table></figure><p>需要注意的是，由于计算的时候是从Gn开始计算，所以生成的拉普拉斯金字塔列表是反转过来的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lp = generate_laplacian_pyramid(gp)</span><br><span class="line">lp = lp[::-<span class="number">1</span>] <span class="comment"># 反转，最高层放在末尾</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lp)):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>)</span><br><span class="line">    plt.imshow(lp[i],cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">f&quot;L<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509261409.webp" alt="202509261409" style="zoom: 67%;" /><p>融合两张图片的拉普拉斯金字塔，获得最终图的拉普拉斯金字塔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 融合两个拉普拉斯金字塔(简单拼接，各取一半)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">blend_half</span>(<span class="params">lpA, lpB</span>):</span><br><span class="line">    LS = []</span><br><span class="line">    <span class="keyword">for</span> la, lb <span class="keyword">in</span> <span class="built_in">zip</span>(lpA, lpB):</span><br><span class="line">        rows, cols, dpt = la.shape</span><br><span class="line">        ls = np.hstack((la[:,:cols//<span class="number">2</span>], lb[:, cols//<span class="number">2</span>:]))</span><br><span class="line">        LS.append(ls)</span><br><span class="line">    <span class="keyword">return</span> LS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 融合两个拉普拉斯金字塔(渐变拼接)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">blend_gradient</span>(<span class="params">lpA, lpB</span>):</span><br><span class="line">    LS = []</span><br><span class="line">    <span class="keyword">for</span> la, lb <span class="keyword">in</span> <span class="built_in">zip</span>(lpA, lpB):</span><br><span class="line">        rows, cols, dpt = la.shape</span><br><span class="line">        <span class="comment"># 维度大小为3, 维度1为1，维度2自动计算，维度3为1</span></span><br><span class="line">        mask = np.linspace(<span class="number">1</span>, <span class="number">0</span>, cols).reshape(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 从左到右渐变</span></span><br><span class="line">        mask = np.repeat(mask, rows, axis=<span class="number">0</span>)</span><br><span class="line">        ls = la * mask + lb * (<span class="number">1</span>-mask)</span><br><span class="line">        LS.append(ls.astype(np.uint8))</span><br><span class="line">    <span class="keyword">return</span> LS</span><br></pre></td></tr></table></figure><p>重建图样<strong>从最小的高斯图(最高层)开始，逐层往大推</strong><br>$$<br>G_i &#x3D; L_i+\mathrm{Expand}(G_{i+1})<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从拉普拉斯金字塔重建图像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reconstruct_from_laplacian</span>(<span class="params">LS</span>):</span><br><span class="line">    G = LS[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(LS)):</span><br><span class="line">        GE = cv2.pyrUp(G)</span><br><span class="line">        GE = cv2.resize(GE,(LS[i].shape[<span class="number">1</span>],LS[i].shape[<span class="number">0</span>])) <span class="comment"># 匹配尺寸</span></span><br><span class="line">        G = cv2.add(GE, LS[i])</span><br><span class="line">    <span class="keyword">return</span> G</span><br></pre></td></tr></table></figure><p>因为在生成拉普拉斯金字塔时把Gn放在了列表头部，所以就不需要反转了！</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = reconstruct_from_laplacian(lp[::-<span class="number">1</span>]) <span class="comment"># 反转回来，叠加从最高层开始</span></span><br><span class="line">plt.imshow(res, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/2025092614010.webp" alt="2025092614010" style="zoom: 67%;" /><p>官方demo：苹果+橘子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apple = cv2.imread(<span class="string">&quot;imgs/apple.jpg&quot;</span>, <span class="number">1</span>)</span><br><span class="line">orange = cv2.imread(<span class="string">&quot;imgs/orange.jpg&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 创建高斯金字塔</span></span><br><span class="line">gpA = generate_gaussian_pyramid(apple)</span><br><span class="line">gpB = generate_gaussian_pyramid(orange)</span><br><span class="line"><span class="comment"># 创建拉普拉斯金字塔</span></span><br><span class="line">lpA = generate_laplacian_pyramid(gpA)</span><br><span class="line">lpB = generate_laplacian_pyramid(gpB)</span><br><span class="line"><span class="comment"># 融合拉普拉斯金字塔</span></span><br><span class="line">LS = blend_half(lpA, lpB)</span><br><span class="line"><span class="comment"># LS = blend_gradient(lpA, lpB)</span></span><br><span class="line"><span class="comment"># 从拉普拉斯金字塔重建图像(从最小图样开始)</span></span><br><span class="line">blended = reconstruct_from_laplacian(LS)</span><br><span class="line"><span class="comment"># 直接拼接图样</span></span><br><span class="line">direct = np.hstack((apple[:, :apple.shape[<span class="number">1</span>]//<span class="number">2</span>],</span><br><span class="line">                    orange[:, orange.shape[<span class="number">1</span>]//<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509261401.webp" alt="202509261401" style="zoom:67%;" /><h2 id="图像平滑"><a href="#图像平滑" class="headerlink" title="图像平滑"></a>图像平滑</h2><p>首先讲一下图像噪声，常见噪声如下：</p><ul><li>高斯噪声：常见于传感器噪声，整幅图像像素轻微抖动、模糊，$n\sim N(\mu,\sigma^2)$，高斯滤波效果最好</li><li>椒盐噪声：像素随机变成黑点(0)或白点(255)，常见于图像传输干扰，数据丢包，中值滤波效果最好</li></ul><h3 id="卷积填充"><a href="#卷积填充" class="headerlink" title="卷积填充"></a>卷积填充</h3><p>用3×3的核对6×6的图像进行卷积，得到的是4×4的图，图片缩小了</p><p>可以把原图扩充一圈，再卷积，这个操作叫填充padding</p><p>OpenCV中有好几种填充方式，都使用<code>cv2.copyMakeBorder()</code>函数实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.copyMakeBorder(</span><br><span class="line">    src,                  <span class="comment"># 输入图像</span></span><br><span class="line">    top,                  <span class="comment"># 上边界填充像素数</span></span><br><span class="line">    bottom,               <span class="comment"># 下边界填充像素数</span></span><br><span class="line">    left,                 <span class="comment"># 左边界填充像素数</span></span><br><span class="line">    right,                <span class="comment"># 右边界填充像素数</span></span><br><span class="line">    borderType,           <span class="comment"># 边界填充类型</span></span><br><span class="line">    [, value]             <span class="comment"># CONSTANT类型使用的颜色值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中固定值填充和<font color='Violetred'>默认填充(镜像填充)</font>最常用</p><table><thead><tr><th>填充类型 (borderType)</th><th>描述</th></tr></thead><tbody><tr><td><code>cv2.BORDER_REFLECT_101</code><br />(<code>cv2.BORDER_DEFAULT</code>)</td><td>镜像填充(不包含边界像素)</td></tr><tr><td><code>cv2.BORDER_CONSTANT</code></td><td>固定值填充，用 <code>value</code> 指定颜色</td></tr><tr><td><code>cv2.BORDER_REPLICATE</code></td><td>复制边缘像素，边界处像素往外扩展</td></tr><tr><td><code>cv2.BORDER_REFLECT</code></td><td>镜像反射边界(包含边界像素)</td></tr><tr><td><code>cv2.BORDER_WRAP</code></td><td>环绕填充，从另一边取值</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建3x3测试矩阵(使用ASCII值)</span></span><br><span class="line">matrix = np.array([</span><br><span class="line">    [<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>],    <span class="comment"># a,b,c</span></span><br><span class="line">    [<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>], <span class="comment"># d,e,f</span></span><br><span class="line">    [<span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>]  <span class="comment"># g,h,i</span></span><br><span class="line">], dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_border</span>(<span class="params">matrix, border_type, name</span>):</span><br><span class="line">    padded = cv2.copyMakeBorder(matrix, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, border_type)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n<span class="subst">&#123;name&#125;</span>:&quot;</span>)</span><br><span class="line">    rows, cols = padded.shape</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        row_chars = []  <span class="comment"># 存储打印字符</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            ch = <span class="built_in">chr</span>(padded[i, j])  <span class="comment"># 将数字转为chr类型</span></span><br><span class="line">            <span class="comment"># 判断是否属于原矩阵区域</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> &lt;= i &lt; <span class="number">2</span> + matrix.shape[<span class="number">0</span>] <span class="keyword">and</span> <span class="number">2</span> &lt;= j &lt; <span class="number">2</span> + matrix.shape[<span class="number">1</span>]:</span><br><span class="line">                row_chars.append(<span class="string">f&quot;\033[31m<span class="subst">&#123;ch&#125;</span>\033[0m&quot;</span>)  <span class="comment"># 红色</span></span><br><span class="line">                <span class="comment"># \033[31m → 设置红色  \033[0m → 重置回默认颜色</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row_chars.append(ch)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(row_chars))  <span class="comment"># 把 row_chars 里的字符用空格拼接成一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试不同填充方式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始矩阵:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a b c\nd e f\ng h i&quot;</span>)</span><br><span class="line"></span><br><span class="line">print_border(matrix, cv2.BORDER_CONSTANT, <span class="string">&quot;BORDER_CONSTANT&quot;</span>)</span><br><span class="line">print_border(matrix, cv2.BORDER_REPLICATE, <span class="string">&quot;BORDER_REPLICATE&quot;</span>)</span><br><span class="line">print_border(matrix, cv2.BORDER_REFLECT, <span class="string">&quot;BORDER_REFLECT&quot;</span>)</span><br><span class="line">print_border(matrix, cv2.BORDER_REFLECT_101, <span class="string">&quot;BORDER_REFLECT_101 (DEFAULT)&quot;</span>)</span><br><span class="line">print_border(matrix, cv2.BORDER_WRAP, <span class="string">&quot;BORDER_WRAP&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="卷积滤波"><a href="#卷积滤波" class="headerlink" title="卷积滤波"></a>卷积滤波</h3><p>卷积滤波就是用一个核(kernel, mask, filter)在图像上滑动，对每个位置进行加权求和，生成新的像素值<br>$$<br>g(x,y)&#x3D;\sum_{i&#x3D;-k}^k\sum_{j&#x3D;-k}^kf(x+i,y+j)\cdot h(i,j)<br>$$<br>通用卷积函数<code>cv2.filter2D()</code>,可以用任意核</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.filter2D(img, ddepth, kernel)</span><br></pre></td></tr></table></figure><ul><li><code>ddepth</code>：输出图像深度(<code>-1</code>表示和输入一样)</li></ul><p>常用于图像锐化操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.array([[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                   [-<span class="number">1</span>,<span class="number">5</span>,-<span class="number">1</span>],</span><br><span class="line">                   [<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>]], np.float32)</span><br><span class="line">sharpened = cv2.filter2D(img, -<span class="number">1</span>, kernel)</span><br></pre></td></tr></table></figure><p>均值滤波、高斯滤波、中值滤波、双边滤波都属于卷积滤波，不过python都有对应的函数，不使用<code>filter2D</code>来实现</p><table><thead><tr><th>方法</th><th>特点</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>均值滤波</td><td>平均邻域</td><td>简单</td><td>模糊边缘严重</td></tr><tr><td>高斯滤波</td><td>高斯加权</td><td>平滑自然</td><td>仍有模糊</td></tr><tr><td>中值滤波</td><td>取中值</td><td>对椒盐噪声好</td><td>模糊细节</td></tr><tr><td>双边滤波</td><td>空间+像素相似度</td><td>边缘保留最好</td><td>计算量大</td></tr></tbody></table><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>均值滤波是一种最简单的滤波处理，将图像中每个像素的值替换为其周围像素的平均值，可以有效地去除噪声，但可能会导致图像变得模糊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>)) <span class="comment"># (5,5)为滤波核的大小</span></span><br></pre></td></tr></table></figure><h3 id="高斯滤波🔥"><a href="#高斯滤波🔥" class="headerlink" title="高斯滤波🔥"></a>高斯滤波🔥</h3><p>卷积核是一个二维高斯函数，邻域中心权重大，越远权重越小</p><p>对随机噪声(高斯噪声)效果比较好，边缘比均值滤波保留得更自然</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>) </span><br><span class="line"><span class="comment"># 第三个参数为高斯核的标准差，如果为0，则根据核大小自动计算</span></span><br></pre></td></tr></table></figure><h3 id="中值滤波🔥"><a href="#中值滤波🔥" class="headerlink" title="中值滤波🔥"></a>中值滤波🔥</h3><p>中值滤波是一种非线性平滑处理方法，将图像中每个像素的值替换为其周围像素的中值</p><p>中值滤波在去除椒盐噪声(即图像中随机出现的黑白点)时非常有效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.medianBlur(img, <span class="number">5</span>)  </span><br><span class="line"><span class="comment"># 第二个参数为滤波核大小，必须为奇数</span></span><br></pre></td></tr></table></figure><h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>双边滤波是一种非线性的平滑处理方法，结合了空间邻近度和像素值相似度</p><p>考虑空间距离 + 像素值差异，既能平滑噪声，又能保留边缘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.bilateralFilter(img, <span class="number">9</span>, <span class="number">75</span>, <span class="number">75</span>)</span><br><span class="line"><span class="comment"># 第二个参数为滤波核大小，不一定奇数</span></span><br><span class="line"><span class="comment"># 第三个参数为颜色空间的标准差，控制像素值相似度的权重</span></span><br><span class="line"><span class="comment"># 第四个参数为坐标空间的标准差，控制空间距离的权重</span></span><br></pre></td></tr></table></figure><h3 id="噪声添加与消除"><a href="#噪声添加与消除" class="headerlink" title="噪声添加与消除"></a>噪声添加与消除</h3><p><code>skimage.util.random_noise</code>是一个方便函数，可以直接给图像添加多种常见噪声</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.util <span class="keyword">import</span> random_noise</span><br><span class="line">gaussian_noise = random_noise(img, mode=<span class="string">&#x27;gaussian&#x27;</span>, mean=<span class="number">0</span>, var=<span class="number">0.01</span>) <span class="comment"># 高斯噪声</span></span><br><span class="line">sp_noise = random_noise(img, mode=<span class="string">&#x27;s&amp;p&#x27;</span>, amount=<span class="number">0.02</span>) <span class="comment"># 椒盐噪声</span></span><br></pre></td></tr></table></figure><p><code>random_noise</code> 返回的图像是 浮点型，范围在 [0,1]，所以需要转回OpenCV常用的<code>uint8</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gaussian_noise = (gaussian_noise * <span class="number">255</span>).astype(np.uint8)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.util <span class="keyword">import</span> random_noise</span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&quot;LenaRGB.bmp&quot;</span>,<span class="number">1</span>)</span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line"><span class="comment"># 添加高斯噪声</span></span><br><span class="line">gaussian_noise = random_noise(img, mode=<span class="string">&#x27;gaussian&#x27;</span>, var=<span class="number">0.01</span>)  <span class="comment"># var 控制噪声强度</span></span><br><span class="line">gaussian_noise = (gaussian_noise * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"><span class="comment"># 添加椒盐噪声</span></span><br><span class="line">sp_noise = random_noise(img, mode=<span class="string">&#x27;s&amp;p&#x27;</span>, amount=<span class="number">0.02</span>)  <span class="comment"># amount 控制噪声比例</span></span><br><span class="line">sp_noise = (sp_noise * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"><span class="comment"># 显示带噪声图样</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(gaussian_noise)</span><br><span class="line">plt.title(<span class="string">&quot;Gaussian Noise&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(sp_noise)</span><br><span class="line">plt.title(<span class="string">&quot;S&amp;P Noise&quot;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509252044.webp" alt="202509252044" style="zoom: 50%;" /><p>通过各种滤波方式可以对噪声进行去除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高斯噪声处理</span></span><br><span class="line">gauss_mean = cv2.blur(gaussian_noise, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">gauss_gaussian = cv2.GaussianBlur(gaussian_noise, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">gauss_median = cv2.medianBlur(gaussian_noise, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509252045.webp" alt="202509252045" style="zoom:50%;" /><p>均值滤波会平滑图像，使得图像稍微模糊一些，高斯滤波并不能完全去除高斯噪声</p><p>这是因为它只是一个低通滤波器，主要削弱高频分量，高斯噪声的高频部分会被削弱，但低频部分的噪声依然保留，所以它不能“专门去掉高斯噪声”，而只是做了一次模糊平均</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 椒盐噪声处理</span></span><br><span class="line">sp_mean = cv2.blur(sp_noise, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">sp_gaussian = cv2.GaussianBlur(sp_noise, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">sp_median = cv2.medianBlur(sp_noise, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509252046.webp" alt="202509252046" style="zoom: 50%;" /><p>可以看到中值滤波对椒盐噪声的处理非常好，基本恢复原图的状态了</p><h2 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h2><h3 id="固定阈值分割"><a href="#固定阈值分割" class="headerlink" title="固定阈值分割"></a>固定阈值分割</h3><p>将灰度图像二值化或多阈值化，通过<code>cv2.threshold()</code>来实现阈值分割</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.threshold(img, thresh, maxval, <span class="built_in">type</span>)</span><br></pre></td></tr></table></figure><p><code>thresh</code>: 阈值</p><p><code>maxval</code>: 当像素值超过阈值时赋予的新值[用于<code>THRESH_BINARY</code>]，一般为255</p><p><code>type</code>：阈值类型(最重要)</p><table><thead><tr><th>阈值类型</th><th>高于阈值</th><th>低于阈值</th><th>应用</th></tr></thead><tbody><tr><td><code>cv2.THRESH_BINARY</code>(二值化)</td><td>赋值为 <code>maxval</code></td><td>赋值为 0</td><td>前景白、背景黑</td></tr><tr><td><code>cv2.THRESH_BINARY_INV</code>(反二值化)</td><td>赋值为 0</td><td>赋值为 <code>maxval</code></td><td>背景白、前景黑</td></tr><tr><td><code>cv2.THRESH_TRUNC</code>(截断)</td><td>截断成阈值</td><td>保持原值</td><td>限制高光</td></tr><tr><td><code>cv2.THRESH_TOZERO</code></td><td>保持原值</td><td>赋值为 0</td><td>滤掉低强度背景</td></tr><tr><td><code>cv2.THRESH_TOZERO_INV</code></td><td>赋值为 0</td><td>保持原值</td><td>滤掉高亮区域</td></tr></tbody></table><p>返回<code>retval</code>, <code>dst</code></p><ul><li><code>retval</code>: 实际使用的阈值(在使用 <code>THRESH_OTSU</code> 或 <code>THRESH_TRIANGLE</code> 时特别有用)</li><li><code>dst</code>: 阈值化后的图像</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv2.imread(<span class="string">&quot;gradient_gray.png&quot;</span>, <span class="number">0</span>)</span><br><span class="line">_, dst1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">_, dst2 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">_, dst3 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TRUNC)</span><br><span class="line">_, dst4 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO)</span><br><span class="line">_, dst5 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO_INV)</span><br><span class="line">titles = [<span class="string">&#x27;Original&#x27;</span>, <span class="string">&#x27;BINARY&#x27;</span>, <span class="string">&#x27;BINARY_INV&#x27;</span>, <span class="string">&#x27;TRUNC&#x27;</span>, <span class="string">&#x27;TOZERO&#x27;</span>, <span class="string">&#x27;TOZERO_INV&#x27;</span>]</span><br><span class="line">images = [img, dst1, dst2, dst3, dst4, dst5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(images[i], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i], fontsize=<span class="number">8</span>)</span><br><span class="line">    plt.xticks([]), plt.yticks([])  <span class="comment"># 隐藏坐标轴</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20250922215427237.png" alt="image-20250922215427237" style="zoom: 80%;" /><h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><p><code>cv2.adaptiveThreshold()</code>自适应阈值会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thresholded_image = cv2.adaptiveThreshold(img, maxval, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, block_size, C)</span><br></pre></td></tr></table></figure><p><code>maxval</code>：最大阈值，一般为 255</p><ul><li>参数3：小区域阈值的计算方式<ul><li><code>ADAPTIVE_THRESH_MEAN_C</code>：小区域内取均值</li><li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：小区域内加权求和，权重是个高斯核</li></ul></li><li>参数4：阈值方法，只能使用<code>THRESH_BINARY</code>、<code>THRESH_BINARY_INV</code></li><li>参数5：小区域的面积(正方形)，输入边长(像素)</li><li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;Cameraman.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">_, dst1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">dst2 = cv2.adaptiveThreshold(img,<span class="number">255</span>,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">4</span>)</span><br><span class="line">dst3 = cv2.adaptiveThreshold(img,<span class="number">255</span>,cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">4</span>)</span><br><span class="line">titles = [<span class="string">&#x27;Original&#x27;</span>, <span class="string">&#x27;BINARY(127)&#x27;</span>, <span class="string">&#x27;Adaptive Mean&#x27;</span>, <span class="string">&#x27;Adaptive Gaussian&#x27;</span>]</span><br><span class="line">images = [img, dst1, dst2, dst3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(images[i], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i], fontsize=<span class="number">8</span>)</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/autothreshold.png" alt="autothreshold" style="zoom: 80%;" /><h3 id="Otsu’s阈值"><a href="#Otsu’s阈值" class="headerlink" title="Otsu’s阈值"></a>Otsu’s阈值</h3><p>在前面<code>cv2.threshold()</code> 用的是固定阈值，比如<code>thresh=127</code></p><p>在很多场景下，图像亮度分布不均匀，固定阈值效果不好</p><p>Otsu’s方法是一种<font color='Violetred'>自适应阈值选择算法</font>，通过分析图像灰度直方图，自动确定最佳分割阈值</p><p>核心思想是最大化前景(目标)与背景之间的类间方差</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thresh_val, otsu_img = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU) </span><br><span class="line"><span class="comment"># 写法基本固定，第2个参数必须设为0，真正的阈值由算法计算</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;Cameraman.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">_, dst1 = cv2.threshold(img , <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">_, dst2 = cv2.threshold(img, <span class="number">0</span> , <span class="number">255</span>, cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><br><span class="line">imgs = [img, dst1, dst2]</span><br><span class="line">titles = [<span class="string">&quot;Original&quot;</span>, <span class="string">&quot;BINARY(127)&quot;</span>, <span class="string">&quot;OTSU&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(imgs[i], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509252101.webp" alt="202509252101" style="zoom:67%;" /><h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>图像边缘检测是计算机视觉和图像处理中的一项基本任务，它用于识别图像中亮度变化明显的区域，这些区域通常对应于物体的边界</p><p>边缘检测通常基于<strong>梯度</strong>(Gradient)，它表示图像强度变化的方向和大小</p><ul><li><p>一维情况下：边缘 &#x3D; 信号一阶导数极大值位置</p></li><li><p>二维情况下<br>$$<br>\nabla f(x,y)&#x3D;\left[\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}\right]<br>$$<br>梯度幅值(边缘强度)<br>$$<br>G&#x3D;\sqrt{\left(\frac{\partial f}{\partial x}\right)^2+\left(\frac{\partial f}{\partial y}\right)^2}<br>$$<br>梯度方向<br>$$<br>\theta &#x3D; \arctan\left(\frac{\partial f}{\partial y}&#x2F;\frac{\partial f}{\partial x}\right)<br>$$</p></li></ul><p>常用的梯度算子如下：</p><table><thead><tr><th align="left">算法</th><th>核心</th><th align="left">适用场景</th><th>缺点</th></tr></thead><tbody><tr><td align="left">Sobel算子</td><td>一阶导数(差分)+平滑</td><td align="left">检测水平和垂直边缘</td><td>边缘定位精度一般，特别是对斜向边缘不够准确</td></tr><tr><td align="left">Scharr算子</td><td>优化的Sobel</td><td align="left">检测细微的边缘</td><td>计算量略高于Sobel，低分辨率图片差别不大</td></tr><tr><td align="left">Laplacian算子</td><td>二阶导数</td><td align="left">检测边缘和角点</td><td>对噪声非常敏感，检测结果往往是“双边缘”</td></tr></tbody></table><h3 id="数值转化"><a href="#数值转化" class="headerlink" title="数值转化"></a>数值转化</h3><p>常见算子通常用 <code>CV_64F</code> 或 <code>CV_32F</code> 保存结果，计算出来的结果是<code>float</code>类型，包含负数</p><p>OpenCV的<code>imshow</code>和Matplotlib的<code>imshow(cmap=&quot;gray&quot;)</code> 都假定数据范围在<code>[0,255]</code>(或 <code>[0,1]</code>浮点)</p><p>如果直接显示<code>float</code>图像，会导致数据被自动线性拉伸，结果和实际数值分布不符</p><p>如果为了清晰判断与分析边缘，需要对其进行<code>cv2.convertScaleAbs()</code>处理，这样能保证边缘效果直观可见</p><p>如果后续还需要进行一些运算，就不能取<code>cv2.convertScaleAbs()</code>，因为符号信息在一些算法里是有意义的，此时保留<code>float</code> 原始结果更合理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnitude = cv2.magnitude(sobelx, sobely)  <span class="comment"># 准确梯度幅值</span></span><br></pre></td></tr></table></figure><h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p>Sobel算子是一种基于梯度的边缘检测算子，它通过计算图像在水平和垂直方向上的梯度来检测边缘，结合了高斯平滑和微分操作，因此对噪声具有一定的抑制作用</p><p>水平方向卷积核 [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]</p><p>垂直方向卷积核 [[-1, -2, -1], [0, 0, 0], [1, 2, 1]]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;Lena.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># sobel输出的是float64，包含负数</span></span><br><span class="line">sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)  <span class="comment"># x方向</span></span><br><span class="line">sobely = cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)  <span class="comment"># y方向</span></span><br><span class="line"><span class="comment"># 将输出转换为 CV_8U 图像(绝对值)，丢掉“方向信息”</span></span><br><span class="line">sobelx_abs = cv2.convertScaleAbs(sobelx)</span><br><span class="line">sobely_abs = cv2.convertScaleAbs(sobely)</span><br><span class="line"><span class="comment"># 添加两个方向梯度来近似梯度(不是精确的计算)</span></span><br><span class="line">grad = cv2.addWeighted(sobelx_abs, <span class="number">0.5</span>, sobely_abs, <span class="number">0.5</span>, <span class="number">0</span>)  <span class="comment"># 常用</span></span><br><span class="line"><span class="comment"># 准确的梯度幅值</span></span><br><span class="line">sobel = cv2.magnitude(sobelx, sobely)</span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.imshow(sobelx_abs, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Sobelx&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.imshow(sobely, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Sobely&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.imshow(grad, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Approx gradient&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.imshow(sobel_abs, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Amplitude gradient&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202592511.webp" alt="202592511" style="zoom:80%;" /><h3 id="Scharr算子"><a href="#Scharr算子" class="headerlink" title="Scharr算子"></a>Scharr算子</h3><p>是Sobel的改进版，权重更大，在小核(3×3)时效果优于 Sobel</p><p>水平方向卷积核 [[-3, 0, 3], [-10, 0, 10], [-3, 0, 3]]</p><p>垂直方向卷积核 [[-3, -10, -3], [0, 0, 0], [3, 10, 3]]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scharrx = cv2.Scharr(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>) <span class="comment"># 核大小不可调，只支持3*3</span></span><br><span class="line">scharry = cv2.Scharr(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a>Laplacian算子</h3><p>Laplacian算子是一种二阶微分算子，它通过计算图像的二阶导数来检测边缘，但对噪声比较敏感，因此通常在使用之前会对图像进行高斯平滑处理</p><p>卷积核 [[0, 1, 0], [1, -4, 1], [0, 1, 0]]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laplacian = cv2.Laplacian(img, cv2.CV_64F, ksize=<span class="number">1</span>, scale=<span class="number">1</span>, borderType=cv2.BORDER_DEFAULT)</span><br></pre></td></tr></table></figure><ul><li><p><code>ksize</code>：Laplacian核的大小，默认为 1</p><p>并不是代表卷积核大小为1，而是最基本的二阶差分算子<br>$$<br>f_{xx}(x,y)&#x3D;f(x+1,y)+f(x-1,y)-2f(x,y)\<br>f_{yy}(x,y)&#x3D;f(x,y+1)+f(x,y-1)-2f(x,y)<br>$$<br>Laplacian就变成了一个固定的 3×3 卷积核</p></li><li><p><code>scale</code>：缩放因子，默认为 1</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;Lena.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">laplacian = cv2.Laplacian(img, cv2.CV_64F,ksize=<span class="number">3</span>)</span><br><span class="line">laplacian_abs = cv2.convertScaleAbs(laplacian)</span><br><span class="line">plt.imshow(laplacian_abs, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509251429.webp" alt="202509251429" style="zoom:80%;" /><h3 id="Canny边缘检测🔥"><a href="#Canny边缘检测🔥" class="headerlink" title="Canny边缘检测🔥"></a>Canny边缘检测🔥</h3><p><font color='Violetred'>稳定、精确，最常用</font></p><p>由John F. Canny提出，主要包括以下几个步骤：</p><ol><li>噪声抑制：使用高斯滤波器对图像进行平滑处理，以减少噪声的影响</li><li>计算梯度：使用Sobel算子计算图像的梯度幅值和方向</li><li>非极大值抑制(NMS)：沿着梯度方向，保留局部梯度最大的像素点，删除不被认为是边缘一部分的像素，只有细线候选边缘将保留</li><li>双阈值检测：使用两个阈值(低阈值和高阈值)来确定真正的边缘<ul><li>如果像素梯度高于高阈值，则该像素被接受为边缘</li><li>如果像素梯度值低于下限阈值，则将其拒绝</li><li>如果像素梯度介于两个阈值之间，则只有当它连接到高于上限阈值的像素时，才会被接受</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edges = cv2.Canny(img, threshold1, threshold2, apertureSize=<span class="number">3</span>, L2gradient=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><code>img</code>：必须是单通道的灰度图像</p><p><code>threshold1</code>：低阈值越低，检测到的候选点越多，但噪声也会增多</p><p><code>threshold2</code>：高阈值越高，检测到的边缘越少，但更可靠，高阈值通常是低阈值的2-3倍</p><p><code>apertureSize</code>：Sobel算子的孔径大小，默认为3</p><p><code>L2gradient</code>：是否使用 L2 范数计算梯度幅值，默认为 False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;LEna.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">edges = cv2.Canny(img, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">plt.imshow(edges, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509242233.webp" alt="202509242233" style="zoom:80%;" /><h4 id="创建滑动条"><a href="#创建滑动条" class="headerlink" title="创建滑动条"></a>创建滑动条</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">img = cv2.imread(<span class="string">&quot;Lena.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># img = cv2.resize(img,None,fx=0.1, fy=0.1)</span></span><br><span class="line">plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;Canny Edge Detection&quot;</span>)</span><br><span class="line"><span class="comment"># 创建滑动条，分别对应 threshold1, threshold2</span></span><br><span class="line">cv2.createTrackbar(<span class="string">&quot;threshold1&quot;</span>,<span class="string">&quot;Canny Edge Detection&quot;</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">&quot;threshold2&quot;</span>,<span class="string">&quot;Canny Edge Detection&quot;</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    threshold1 = cv2.getTrackbarPos(<span class="string">&quot;threshold1&quot;</span>, <span class="string">&quot;Canny Edge Detection&quot;</span>)</span><br><span class="line">    threshold2 = cv2.getTrackbarPos(<span class="string">&quot;threshold2&quot;</span>, <span class="string">&quot;Canny Edge Detection&quot;</span>)</span><br><span class="line">    edges = cv2.Canny(img, threshold1, threshold2)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;Canny Edge Detection&quot;</span>, edges)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>: <span class="comment"># 按esc退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h4 id="自适应阈值设置"><a href="#自适应阈值设置" class="headerlink" title="自适应阈值设置"></a>自适应阈值设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于图像中值自动设置阈值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">auto_canny</span>(<span class="params">img, sigma=<span class="number">0.33</span></span>):</span><br><span class="line">    <span class="comment"># 计算图像中值</span></span><br><span class="line">    v = np.median(img)</span><br><span class="line">    <span class="comment"># 自动设置阈值</span></span><br><span class="line">    lower = <span class="built_in">int</span>(<span class="built_in">max</span>(<span class="number">0</span>, (<span class="number">1.0</span> - sigma) * v))</span><br><span class="line">    upper = <span class="built_in">int</span>(<span class="built_in">min</span>(<span class="number">255</span>, (<span class="number">1.0</span> + sigma) * v))</span><br><span class="line">    edges = cv2.Canny(img, lower, upper)</span><br><span class="line">    <span class="keyword">return</span> edges, lower, upper</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;Lena.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">adaptive_edges, lower, upper = auto_canny(img)</span><br><span class="line">plt.imshow(adaptive_edges, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;threshold1: <span class="subst">&#123;lower&#125;</span>, threshold2: <span class="subst">&#123;upper&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># threshold1: 86, threshold2: 171</span></span><br></pre></td></tr></table></figure><h4 id="Otsu计算最佳阈值"><a href="#Otsu计算最佳阈值" class="headerlink" title="Otsu计算最佳阈值"></a>Otsu计算最佳阈值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Otsu方法计算最佳阈值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">otsu_canny</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="comment"># 计算Otsu阈值</span></span><br><span class="line">    otsu_thresh, _ = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">    <span class="comment"># 设置Canny阈值</span></span><br><span class="line">    lower = <span class="built_in">int</span>(otsu_thresh * <span class="number">0.5</span>)  <span class="comment"># 确保阈值为整数</span></span><br><span class="line">    upper = <span class="built_in">int</span>(otsu_thresh)        <span class="comment"># 确保阈值为整数</span></span><br><span class="line">    edges = cv2.Canny(img, lower, upper)</span><br><span class="line">    <span class="keyword">return</span> edges, lower, upper</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;Lena.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">otsu_edges, lower, upper = otsu_canny(img)</span><br><span class="line">plt.imshow(otsu_edges, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;threshold1: <span class="subst">&#123;lower&#125;</span>, threshold2: <span class="subst">&#123;upper&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># threshold1: 58, threshold2: 117</span></span><br></pre></td></tr></table></figure><h3 id="实时边缘检测"><a href="#实时边缘检测" class="headerlink" title="实时边缘检测"></a>实时边缘检测</h3><p>结合滑动条，控制Canny的两个阈值，视频部分后面章节具体讲</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">cv2.namedWindow(<span class="string">&quot;Overlay&quot;</span>) <span class="comment"># 创建窗口</span></span><br><span class="line"><span class="comment"># 创建滑动条，分别对应 threshold1, threshold2</span></span><br><span class="line">cv2.createTrackbar(<span class="string">&quot;threshold1&quot;</span>,<span class="string">&quot;Overlay&quot;</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">&quot;threshold2&quot;</span>,<span class="string">&quot;Overlay&quot;</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line"><span class="comment"># 读取视频</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">&quot;camera_vedio.mp4&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read() </span><br><span class="line">    <span class="comment"># ret: 标识符，表示是否成功读取</span></span><br><span class="line">    <span class="comment"># frame: 当前帧图像</span></span><br><span class="line">    threshold1 = cv2.getTrackbarPos(<span class="string">&quot;threshold1&quot;</span>, <span class="string">&quot;Overlay&quot;</span>)</span><br><span class="line">    threshold2 = cv2.getTrackbarPos(<span class="string">&quot;threshold2&quot;</span>, <span class="string">&quot;Overlay&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret: <span class="comment"># 视频结束</span></span><br><span class="line">        <span class="comment"># break # 结束</span></span><br><span class="line">        cap.<span class="built_in">set</span>(cv2.CAP_PROP_POS_FRAMES, <span class="number">0</span>)  <span class="comment"># 重置到第0帧</span></span><br><span class="line">        <span class="keyword">continue</span>   <span class="comment"># 跳过这次循环，重新读</span></span><br><span class="line">    gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY) <span class="comment"># Canny需要灰度图像</span></span><br><span class="line">    edges = cv2.Canny(gray, threshold1, threshold2)</span><br><span class="line">    edges_color = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR) <span class="comment"># 转到3通道才能叠加</span></span><br><span class="line">    overlay = cv2.addWeighted(frame, <span class="number">0.8</span>, edges_color, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;Overlay&quot;</span>, overlay)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>: <span class="comment"># 按esc退出，每帧停留30ms</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>或者也可以利用edges实现掩膜上色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="string">&quot;camera_vedio.mp4&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret: <span class="comment"># 视频结束</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    edges = cv2.Canny(gray, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">    mask = edges &gt; <span class="number">0</span></span><br><span class="line">    frame[mask] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>] <span class="comment"># 掩膜上色</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;Edges on Original&quot;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="形态变换"><a href="#形态变换" class="headerlink" title="形态变换"></a>形态变换</h2><p>形态学变换是一些基于图像形状的简单操作，它通常在二值图像上执行</p><p>它需要两个输入，一个是原始图像，第二个称为结构元素或内核，它决定操作的性质</p><p>两种基本的形态学算子是<font color='Violetred'>腐蚀和膨胀</font></p><table><thead><tr><th align="left"><strong>操作</strong></th><th align="left"><strong>函数</strong></th><th align="left"><strong>应用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>腐蚀</strong></td><td align="left"><code>cv2.erode()</code></td><td align="left">去除噪声、分离物体</td></tr><tr><td align="left"><strong>膨胀</strong></td><td align="left"><code>cv2.dilate()</code></td><td align="left">连接断裂的物体、填充空洞</td></tr><tr><td align="left"><strong>开运算</strong></td><td align="left"><code>cv2.morphologyEx()</code></td><td align="left">去除小物体、平滑物体边界</td></tr><tr><td align="left"><strong>闭运算</strong></td><td align="left"><code>cv2.morphologyEx()</code></td><td align="left">填充小孔洞、连接邻近物体</td></tr><tr><td align="left"><strong>形态学梯度</strong></td><td align="left"><code>cv2.morphologyEx()</code></td><td align="left">提取物体边缘</td></tr></tbody></table><h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><p>腐蚀操作是一种缩小图像中前景对象的过程，其原理是在原图的小区域内取局部最小值，小区域内有一个是0该像素点就为0(用numpy实现就是遍历选一个region取其中min)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.erode(img, kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>kernel</code>: 结构元素，可以自定义或使用 <code>cv2.getStructuringElement()</code> 生成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 矩形结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 椭圆结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 十字形结构</span></span><br></pre></td></tr></table></figure><img src="https://cos.codec.wang/cv2_morphological_struct_element.jpg" alt="getStructuringElement" style="zoom: 80%;" /></li><li><p><code>iterations</code>: 腐蚀操作的次数，默认为1</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/j.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 定义结构元素</span></span><br><span class="line">erosion = cv2.erode(img, kernel, iterations=<span class="number">1</span>)</span><br><span class="line">plt.imshow(erosion,cmap=<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>膨胀操作与腐蚀相反，它是一种扩大图像中前景对象的过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.dilate(src, kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/j.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line">dilate = cv2.dilate(img, kernel, iterations=<span class="number">1</span>)</span><br><span class="line">plt.imshow(dilate,cmap=<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h3><p>开运算只是<font color='Violetred'>先腐蚀后膨胀</font>的另一种说法，用于去除小的白色噪声点</p><p><code>cv2.MORPH_OPEN</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.util <span class="keyword">import</span> random_noise</span><br><span class="line">img = cv2.imread(<span class="string">&quot;imgs/j.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建一个黑色背景存放椒盐噪声</span></span><br><span class="line">noise_full = random_noise(np.zeros_like(img), mode=<span class="string">&#x27;s&amp;p&#x27;</span>, amount=<span class="number">0.01</span>)</span><br><span class="line">noise_full = (noise_full * <span class="number">255</span>).astype(np.uint8)  <span class="comment"># 转回 0-255</span></span><br><span class="line"><span class="comment"># 选取图片中黑色部分产生椒盐噪声</span></span><br><span class="line">mask = (img == <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 生成对应图</span></span><br><span class="line">sp_noise = img.copy()</span><br><span class="line">sp_noise[mask] = noise_full[mask]</span><br><span class="line"><span class="comment"># 开运算</span></span><br><span class="line"><span class="built_in">open</span> = cv2.morphologyEx(sp_noise, cv2.MORPH_OPEN, kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(sp_noise, cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(<span class="built_in">open</span>,cmap=<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509261440.png" alt="202509261440" style="zoom: 67%;" /><h3 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h3><p>闭运算是开运算的逆运算，<font color='Violetred'>先膨胀后腐蚀</font>，用于填充白色区域内部的小黑洞</p><p><code>cv2.MORPH_CLOSE</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.util <span class="keyword">import</span> random_noise</span><br><span class="line">img = cv2.imread(<span class="string">&quot;imgs/j.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建一个白色背景存放椒盐噪声</span></span><br><span class="line">white_bg = np.ones_like(img, dtype=np.float32)</span><br><span class="line">noise_full = random_noise(white_bg, mode=<span class="string">&#x27;s&amp;p&#x27;</span>, amount=<span class="number">0.01</span>)</span><br><span class="line">noise_full = (noise_full * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"><span class="comment"># 选取图片中白色部分产生椒盐噪声</span></span><br><span class="line">mask = (img == <span class="number">255</span>)</span><br><span class="line"><span class="comment"># 生成对应图</span></span><br><span class="line">sp_noise = img.copy()</span><br><span class="line">sp_noise[mask] = noise_full[mask]</span><br><span class="line"><span class="comment"># 开运算</span></span><br><span class="line">close = cv2.morphologyEx(sp_noise, cv2.MORPH_CLOSE, kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(sp_noise, cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(close,cmap=<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509261446.png" alt="202509261446" style="zoom:67%;" /><h3 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h3><p>形态学梯度是膨胀图像与腐蚀图像的差值，主要用于提取图像中前景对象的边缘</p><p><code>cv2.MORPH_GRADIENT</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/j.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line">gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)</span><br><span class="line">plt.imshow(gradient, cmap=<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20250926145056930.png" alt="image-20250926145056930" style="zoom: 67%;" /><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>一般常见的图像处理流程：</p><ol><li><p>读取+灰度化：减少计算量，很多算子只需要单通道；特殊情况保持彩色(比如分割 RGB&#x2F;HSV特征)</p></li><li><p>降噪(平滑)：均值滤波&#x2F;高斯滤波&#x2F;中值滤波，让后续边缘检测或分割更稳定</p></li><li><p>增强(对比度提升，锐化)：直方图均衡化&#x2F;CLAHE → 提升对比度；卷积或Unsharp Mask → 突出细节；[<font color='Violetred'>会造成噪声加剧</font>]</p></li><li><p>阈值分割：固定阈值、Otsu、自适应阈值，得到前景&#x2F;背景的mask</p></li><li><p>边缘检测：Canny(最主要)，可直接基于分割结果做轮廓提取</p><table><thead><tr><th>方法</th><th>结果特点</th><th>适用场景</th></tr></thead><tbody><tr><td>灰度图做边缘检测</td><td>包含更多细节(比如纹理)，但噪声多</td><td>需要提取细微边缘(如纹理、阴影)</td></tr><tr><td>阈值图做边缘检测</td><td>轮廓更简洁(闭合)，噪声少</td><td>需要提取物体轮廓(如零件、数字)</td></tr></tbody></table></li><li><p>形态学处理：膨胀&#x2F;腐蚀：强化结构特征；形态学梯度：得到轮廓；开&#x2F;闭运算：去小噪点&#x2F;填小孔洞[<font color='Violetred'>针对的是二值图</font>，无论阈值分割还是边缘检测得到的结果都是二值图]</p></li></ol><p>这些步骤并不是固定且必须的</p><p><strong>图像增强</strong>：读取 → 灰度化 → 去噪&#x2F;平滑 → 对比度&#x2F;亮度增强 → 锐化</p><p><strong>图像恢复</strong>：读取 → 灰度化 → 退化模型估计 → 去噪&#x2F;去模糊 → 恢复图像</p><p><strong>图像分割</strong>：读取 → 灰度化 → <font color='Violetred'>阈值分割或边缘检测</font> → 形态学处理 → 区域标记</p><p><strong>特征提取</strong>：读取 → 灰度化 → 平滑 → 边缘&#x2F;角点检测 → 特征提取</p><h2 id="图像轮廓"><a href="#图像轮廓" class="headerlink" title="图像轮廓"></a>图像轮廓</h2><p>轮廓可以简单地解释为连接所有连续点(沿边界)的曲线，这些点具有相同的颜色或强度</p><blockquote><p>轮廓和边缘很像，不过<strong>轮廓是连续的，边缘并不全都连续</strong></p></blockquote><p>轮廓是用于形状分析和对象检测与识别的有用工具</p><p>为了获得更高的精度，需要使用二值图像</p><p><font color='Violetred'>寻找轮廓是针对白色物体的，一定要保证物体是白色，而背景是黑色</font></p><p>主要流程及函数：</p><table><thead><tr><th><strong>步骤</strong></th><th><strong>函数</strong></th></tr></thead><tbody><tr><td>图像预处理(转灰度)</td><td><code>cv2.cvtColor()</code></td></tr><tr><td>二值化处理</td><td><code>cv2.threshold()</code></td></tr><tr><td>查找轮廓</td><td><code>cv2.findContours()</code></td></tr><tr><td>绘制轮廓</td><td><code>cv2.drawContours()</code></td></tr><tr><td>计算轮廓面积</td><td><code>cv2.contourArea()</code></td></tr><tr><td>计算轮廓周长</td><td><code>cv2.arcLength()</code></td></tr><tr><td>计算边界矩形</td><td><code>cv2.boundingRect()</code></td></tr><tr><td>计算最小外接矩形</td><td><code>cv2.minAreaRect()</code></td></tr><tr><td>计算最小外接圆</td><td><code>cv2.minEnclosingCircle()</code></td></tr><tr><td>多边形逼近</td><td><code>cv2.approxPolyDP()</code></td></tr></tbody></table><p>代码框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/match_shape.jpg&quot;</span>,<span class="number">1</span>)   <span class="comment"># 存为彩色</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) <span class="comment"># 转灰度，使得灰度和彩色图样都可</span></span><br><span class="line">_, thresh = cv2.threshold(gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY+cv2.THRESH_OTSU) <span class="comment"># 二值化</span></span><br><span class="line">contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)  <span class="comment"># 查找轮廓</span></span><br><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)      <span class="comment"># 在原图上绘制轮廓(绿色)</span></span><br></pre></td></tr></table></figure><h3 id="寻找轮廓"><a href="#寻找轮廓" class="headerlink" title="寻找轮廓"></a>寻找轮廓</h3><p><code>cv2.findContours()</code>用于在二值图像中查找轮廓</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contours, hierarchy = cv2.findContours(</span><br><span class="line">    image,             <span class="comment"># 输入图像(必须是二值或边缘图像)</span></span><br><span class="line">    mode,              <span class="comment"># 轮廓检索模式</span></span><br><span class="line">    method             <span class="comment"># 轮廓近似方法</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p><code>mode</code>: 轮廓检索模式，常用的有：</p><ul><li><code>cv2.RETR_EXTERNAL</code>&#x2F;1: 只检测最外层轮廓</li><li><code>cv2.RETR_LIST</code>&#x2F;2: 检测所有轮廓，但不建立层次关系</li><li><code>cv2.RETR_TREE</code>&#x2F;3: 检测所有轮廓，并建立完整的层次结构(常用)</li><li><code>cv2.RETR_CCOMP</code>：把所有的轮廓只分为2个层级，不是外层的就是里层的</li></ul></li><li><p><code>method</code>: 轮廓近似方法，常用的有：</p><ul><li><p><code>cv2.CHAIN_APPROX_NONE</code>&#x2F;1: 存储所有的轮廓点，轮廓很密</p></li><li><p><code>cv2.CHAIN_APPROX_SIMPLE</code>&#x2F;2: 压缩水平、垂直和对角线段，只保留端点(常用)</p><p>第一张图像显示使用cv.CHAIN_APPROX_NONE获得的点(734)</p><p>第二张图像显示了使用cv.CHAIN_APPROX_SIMPLE获得的点(4)</p></li></ul><p><img src="https://docs.opencv.ac.cn/4.11.0/none.jpg"></p></li></ul><p><strong>返回值</strong>:</p><ul><li><code>contours</code>: 检测到的轮廓列表，以数组形式存储，记录了每条轮廓的所有像素点的坐标</li><li><code>hierarchy</code>: 轮廓的层次结构信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/2&amp;5.png&quot;</span>,<span class="number">1</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, binary = cv2.threshold(gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><br><span class="line">contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure><h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><p><code>cv2.drawContours()</code>用于在图像上绘制检测到的轮廓</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, contourIdx, color, thickness)</span><br></pre></td></tr></table></figure><ul><li><code>contours</code>: 轮廓列表</li><li><code>contourIdx</code>: 要绘制的轮廓索引，如果为负数，则绘制所有轮廓</li><li><code>thickness</code>：线宽，设为-1时将填充轮廓</li></ul><p>无返回值，直接在输入图像上绘制轮廓</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)) <span class="comment"># 绘制所有轮廓</span></span><br><span class="line">cv2.drawContours(img, contours, <span class="number">3</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)) <span class="comment"># 绘制第四个轮廓</span></span><br></pre></td></tr></table></figure><p>但很多情况下，会以以下方式绘制单个轮廓</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt = contours[<span class="number">3</span>]</span><br><span class="line">cv2.drawContours(img, [cnt], <span class="number">0</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>))  <span class="comment"># 绘制第四个轮廓</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Contours&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271112.png" alt="202509271112" style="zoom:67%;" /><h3 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h3><p><strong>轮廓属性</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">M = cv2.moments(cnt)</span><br></pre></td></tr></table></figure><p>图像矩可以帮助计算一些特征，例如轮廓的质心：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cx = <span class="built_in">int</span>(M[<span class="string">&#x27;m10&#x27;</span>]/M[<span class="string">&#x27;m00&#x27;</span>])</span><br><span class="line">cy = <span class="built_in">int</span>(M[<span class="string">&#x27;m01&#x27;</span>]/M[<span class="string">&#x27;m00&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(cx,cy) <span class="comment"># 379 445</span></span><br></pre></td></tr></table></figure><p>轮廓的面积：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt) </span><br><span class="line">area = M[<span class="string">&#x27;m00&#x27;</span>]</span><br></pre></td></tr></table></figure><p>计算轮廓的周长或弧长：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length = cv2.arcLength(cnt, <span class="literal">True</span>)   <span class="comment"># True 表示闭合</span></span><br></pre></td></tr></table></figure><h4 id="边界矩形"><a href="#边界矩形" class="headerlink" title="边界矩形"></a>边界矩形</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>) <span class="comment"># 绘制矩形函数，输入两个对角点</span></span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271212.png" alt="202509271212" style="zoom:67%;" /><h4 id="最小外接矩形"><a href="#最小外接矩形" class="headerlink" title="最小外接矩形"></a>最小外接矩形</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rect = cv2.minAreaRect(cnt) <span class="comment"># 返回一个旋转矩形</span></span><br><span class="line">box = cv2.boxPoints(rect)   <span class="comment"># 把旋转矩阵的信息转换成4个角点坐标，即轮廓</span></span><br><span class="line">box = box.astype(<span class="built_in">int</span>)       <span class="comment"># 转回int对象，不然报错</span></span><br><span class="line">cv2.drawContours(img, [box], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>),<span class="number">2</span>) <span class="comment"># 图上绘制轮廓</span></span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271412.png" alt="202509271412" style="zoom:67%;" /><h4 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x,y), radius = cv2.minEnclosingCircle(cnt) <span class="comment"># 返回圆心坐标以及半径</span></span><br><span class="line">center = (<span class="built_in">int</span>(x),<span class="built_in">int</span>(y))  <span class="comment"># 转回int对象，不然报错</span></span><br><span class="line">radius = <span class="built_in">int</span>(radius)      <span class="comment"># 转回int对象，不然报错</span></span><br><span class="line">cv2.circle(img,center,radius,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271442.png" alt="202509271442" style="zoom:67%;" /><h4 id="椭圆拟合"><a href="#椭圆拟合" class="headerlink" title="椭圆拟合"></a>椭圆拟合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/2&amp;5.png&quot;</span>,<span class="number">1</span>)</span><br><span class="line">ellipse = cv2.fitEllipse(cnt) <span class="comment"># 返回椭圆内切的旋转矩阵</span></span><br><span class="line">cv2.ellipse(img,ellipse,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271513.png" alt="202509271513" style="zoom:67%;" /><h4 id="多边形逼近"><a href="#多边形逼近" class="headerlink" title="多边形逼近"></a>多边形逼近</h4><p>根据指定的精度将轮廓形状逼近到具有较少顶点的另一个形状，这是<a href="https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">Douglas-Peucker算法</a>的一种实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">approx = cv2.approxPolyDP(cnt, epsilon, <span class="literal">True</span>)  <span class="comment"># 返回近似后的多边形点集(轮廓)</span></span><br></pre></td></tr></table></figure><ul><li><code>epsilon</code>：轮廓到逼近轮廓的最大距离，值越小，近似越精确</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/2&amp;5.png&quot;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    epsilon = <span class="number">0.01</span>*cv2.arcLength(contour,<span class="literal">True</span>) <span class="comment"># 一般取轮廓长度的1/10作为精度</span></span><br><span class="line">    approx = cv2.approxPolyDP(contour,epsilon,<span class="literal">True</span>) <span class="comment"># True表示闭合曲线</span></span><br><span class="line">    cv2.drawContours(img,[approx],<span class="number">0</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271447.png" alt="202509271447" style="zoom:67%;" /><h4 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h4><p>在二维平面里，给定一组点，凸包就是能把这些点“包”起来的最小凸多边形</p><p>凸包看起来类似于轮廓逼近，但并非如此(在某些情况下，两者可能提供相同的结果)</p><p><font color='Violetred'>凸包的边界都是凸的，没有凹进去的部分</font></p><p>OpenCV 提供了 <code>cv2.convexHull</code> 来计算凸包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(points[, hull[, clockwise[, returnPoints]]])</span><br></pre></td></tr></table></figure><p><code>points</code>：输入点集(通常是 <code>contour</code>)</p><p><code>hull</code>：输出索引，通常避免使用它</p><p><code>clockwise</code>：方向标志，<code>True</code> 表示顺时针，<code>False</code> 表示逆时针</p><p><code>returnPoints</code>：<code>True</code>(默认)：返回点坐标;<code>False</code>：返回的是点的索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/2&amp;5.png&quot;</span>,<span class="number">1</span>)</span><br><span class="line">hull = cv2.convexHull(cnt)  <span class="comment"># 返回点坐标，即轮廓</span></span><br><span class="line">cv2.drawContours(img,[hull],<span class="number">0</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271512.png" alt="202509271512" style="zoom:67%;" /><p>如果想查找凸性缺陷，则需要将 returnPoints 设置为 <code>False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># True 返回</span></span><br><span class="line">[[[<span class="number">390</span> <span class="number">289</span>]]</span><br><span class="line"> [[<span class="number">395</span> <span class="number">290</span>]]</span><br><span class="line"> [[<span class="number">399</span> <span class="number">291</span>]]</span><br><span class="line"> ...]</span><br><span class="line"><span class="comment"># False 返回 </span></span><br><span class="line">[[<span class="number">521</span>]</span><br><span class="line"> [<span class="number">519</span>]</span><br><span class="line"> [<span class="number">517</span>]</span><br><span class="line"> ...]</span><br><span class="line"><span class="built_in">print</span>(cnt[hull[:<span class="number">3</span>]])</span><br><span class="line">[[[[<span class="number">390</span> <span class="number">289</span>]]]</span><br><span class="line"> [[[<span class="number">395</span> <span class="number">290</span>]]]</span><br><span class="line"> [[[<span class="number">399</span> <span class="number">291</span>]]]]</span><br></pre></td></tr></table></figure><p>可以通过<code>cv.isContourConvex()</code>判断曲线是否为凸</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_convex = cv2.isContourConvex(cnt)</span><br></pre></td></tr></table></figure><h3 id="轮廓属性"><a href="#轮廓属性" class="headerlink" title="轮廓属性"></a>轮廓属性</h3><p><strong>长宽比</strong>：边界矩形的宽高比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x,y,w,h = cv.boundingRect(cnt)</span><br><span class="line">aspect_ratio = w/h  <span class="comment"># 宽高比</span></span><br></pre></td></tr></table></figure><p><strong>范围</strong>：轮廓面积与边界矩形面积的比值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">area = cv.contourArea(cnt)</span><br><span class="line">x,y,w,h = cv.boundingRect(cnt)</span><br><span class="line">rect_area = w*h</span><br><span class="line">extent = area/rect_area <span class="comment"># 范围</span></span><br></pre></td></tr></table></figure><p><strong>实体度</strong>：轮廓面积与其凸包面积的比值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(cnt)</span><br><span class="line">hull_area = cv2.contourArea(hull)</span><br><span class="line">solidity = area/hull_area <span class="comment"># 实体度</span></span><br></pre></td></tr></table></figure><p><strong>等效直径</strong>：与轮廓面积相同的圆的直径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equi_diameter = np.sqrt(<span class="number">4</span>*area/np.pi)</span><br></pre></td></tr></table></figure><p><strong><font color='Violetred'>掩模</font></strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mask = np.zeros(gray.shape,np.uint8) <span class="comment"># 构建同图片的全0数组</span></span><br><span class="line">cv2.drawContours(mask,[cnt],<span class="number">0</span>,<span class="number">255</span>,-<span class="number">1</span>) <span class="comment"># 在其上绘制轮廓，用白色填充轮廓内容</span></span><br><span class="line"><span class="comment"># 相当于获得了一个二值掩膜</span></span><br><span class="line">pixelpoints = np.transpose(np.nonzero(mask)) <span class="comment"># 记得转置</span></span><br><span class="line"><span class="comment"># pixelpoints = cv2.findNonZero(mask) # 结果相同</span></span><br></pre></td></tr></table></figure><p>Numpy以**(行，列)<strong>格式给出坐标，而OpenCV以</strong>(x,y)**格式给出坐标</p><p>获得掩膜以后可以利用它进行一些计算</p><p>最大值、最小值及其位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_val, max_val, min_loc, max_loc = cv.minMaxLoc(gray, mask = mask) <span class="comment"># 只可以灰度</span></span><br></pre></td></tr></table></figure><p>平均颜色或平均强度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean_val = cv.mean(img, mask = mask) <span class="comment"># 可输入三通道图样</span></span><br></pre></td></tr></table></figure><p><strong>极值点</strong>:</p><p>极值点是指对象的最高点、最低点、最右点和最左点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">leftmost   = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">0</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">rightmost  = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">0</span>].argmax()][<span class="number">0</span>])</span><br><span class="line">topmost    = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">1</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">bottommost = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">1</span>].argmax()][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">cv2.circle(img, leftmost,   <span class="number">8</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), -<span class="number">1</span>)   <span class="comment"># 红色</span></span><br><span class="line">cv2.circle(img, rightmost,  <span class="number">8</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), -<span class="number">1</span>)   <span class="comment"># 绿色</span></span><br><span class="line">cv2.circle(img, topmost,    <span class="number">8</span>, (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), -<span class="number">1</span>)   <span class="comment"># 蓝色</span></span><br><span class="line">cv2.circle(img, bottommost, <span class="number">8</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>), -<span class="number">1</span>) <span class="comment"># 黄色</span></span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509271613.png" alt="202509271613" style="zoom:67%;" /><h3 id="简单案例-数硬币"><a href="#简单案例-数硬币" class="headerlink" title="简单案例(数硬币)"></a>简单案例(数硬币)</h3><p>写一个函数，统计图像中“物体的数量和面积分布”（比如数硬币）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_objects</span>(<span class="params">img_path, show = <span class="literal">False</span>, min_area=<span class="number">100</span></span>):</span><br><span class="line">    img = cv2.imread(img_path)</span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 阈值分割</span></span><br><span class="line">    _ , thresh = cv2.threshold(gray, <span class="number">20</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">    <span class="comment"># 开运算去除噪声点</span></span><br><span class="line">    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">7</span>, <span class="number">7</span>))</span><br><span class="line">    <span class="built_in">open</span> = cv2.morphologyEx(thresh, cv2.MORPH_OPEN,kernel)</span><br><span class="line">    <span class="comment"># 找轮廓</span></span><br><span class="line">    contours, _ = cv2.findContours(<span class="built_in">open</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 统计面积和数量</span></span><br><span class="line">    areas = []</span><br><span class="line">    valid_contours = []</span><br><span class="line">    <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:</span><br><span class="line">        area = cv2.contourArea(cnt)</span><br><span class="line">        <span class="keyword">if</span> area &gt;= min_area:</span><br><span class="line">            areas.append(area)</span><br><span class="line">            valid_contours.append(cnt)</span><br><span class="line"></span><br><span class="line">    object_num = <span class="built_in">len</span>(valid_contours)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> show:</span><br><span class="line">        cv2.drawContours(img, valid_contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line">        cv2.imshow(<span class="string">&#x27;Objects&#x27;</span>, img)</span><br><span class="line">        <span class="comment"># 创建空白画布画轮廓</span></span><br><span class="line">        contour_img = np.zeros_like(img)</span><br><span class="line">        cv2.drawContours(contour_img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line">        cv2.imshow(<span class="string">&#x27;Contours&#x27;</span>, contour_img)</span><br><span class="line"></span><br><span class="line">        cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object_num, areas</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    object_num, areas = count_objects(<span class="string">&#x27;imgs/coins.webp&#x27;</span>,<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;The num of coins: <span class="subst">&#123;object_num&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;The area of each coin: <span class="subst">&#123;areas&#125;</span> &quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h3><p><code>cv2.matchShapes()</code>可以检测两个形状之间的相似度，返回值越小，越相似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/match_shape.jpg&quot;</span>,<span class="number">1</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, thresh = cv2.threshold(gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><br><span class="line">contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">cnt_a, cnt_b, cnt_c = contours[<span class="number">0</span>], contours[<span class="number">1</span>], contours[<span class="number">2</span>]</span><br><span class="line">cv2.drawContours(img, [cnt_a], <span class="number">0</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">cv2.drawContours(img, [cnt_b], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">cv2.drawContours(img, [cnt_c], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_a, cnt_b, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.4185301853277106</span></span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_a, cnt_c, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.41705272670009474</span></span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_c, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.0014774586276158352</span></span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20250927161329110.png" alt="image-20250927161329110" style="zoom:67%;" /><p>bc的输出最低，根据颜色，bc对应绿色和红色，符合预期</p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>在图像处理中，直方图是一种非常重要的工具，它可以帮助我们了解图像的像素分布情况</p><p>三个主要概念：</p><ul><li><p><strong>BIN（区间）</strong>: 如果统计<code>0~255</code>每个像素值，BIN&#x3D;256；如果划分区间，比如<code>0~15,16~31...</code>，那么BIN&#x3D;16，BIN在OpenCV文档中由<code>histSize</code>表示</p></li><li><p><strong>DIMS（维度）</strong>: 要计算的通道数，对于灰度图为1，普通彩色图为3</p></li><li><p><strong>RANGE（范围）</strong>: 要计算的像素值范围，一般为[0,256]，即所有强度值</p></li></ul><h3 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h3><p>使用 <code>cv2.calcHist()</code> 函数来计算图像的直方图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.calcHist(imgs, channels, mask, histSize, ranges)</span><br></pre></td></tr></table></figure><ul><li><p><code>imgs</code>: 输入的图像列表，通常是一个包含单通道或多通道图像的列表，通常输入<code>[img]</code></p></li><li><p><code>channels</code>：需要计算直方图的通道索引，灰度图像为<code>[0]</code>，彩色图像选择<code>[0/1/2]</code>|(BGR)</p></li><li><p><code>mask</code>: 掩膜，指定掩膜后只计算掩膜内的像素，如果没有输入<code>None</code></p><p>可以用阈值分割后的二值图也可以自己创建，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask = np.zeros(img.shape[:<span class="number">2</span>], np.uint8)</span><br><span class="line">mask[<span class="number">100</span>:<span class="number">300</span>, <span class="number">100</span>:<span class="number">300</span>] = <span class="number">255</span></span><br></pre></td></tr></table></figure></li><li><p><code>histSize</code>：直方图的BIN数量，灰度图像通常输入<code>[256]</code></p></li><li><p><code>ranges</code>: 像素值的范围，对于灰度图像，通常设置为<code>[0, 256]</code></p></li></ul><p>灰度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/Lena.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>]) <span class="comment"># 运行时间 0.0001872</span></span><br><span class="line">plt.plot(hist)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291122.png" alt="202509291122" style="zoom:67%;" /><p>彩色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/LenaRGB.bmp&quot;</span>, <span class="number">1</span>)</span><br><span class="line">colors = (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i, colors <span class="keyword">in</span> <span class="built_in">enumerate</span>(colors): <span class="comment"># 遍历序列返回索引和值</span></span><br><span class="line">    hist = cv2.calcHist([img],[i],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    plt.plot(hist, color = colors)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/20250929.webp" alt="20250929" style="zoom: 67%;" /><p>Numpy还提供了一个函数<code>np.histogram()</code>，在这里还要将将多维数组展平(<code>np.ravel()</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist,bins = np.histogram(img.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])  <span class="comment"># 运行时间0.0025162</span></span><br></pre></td></tr></table></figure><p>还有一种针对灰度图的更高效方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist = np.bincount(img.ravel(), minlength=<span class="number">256</span>)  <span class="comment"># 运行时间 0.0007413</span></span><br></pre></td></tr></table></figure><p><font color='Violetred'>但其实还是cv2的性能高</font></p><h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><p>刚刚直接用的plot将数据以曲线的形式绘制出来，但这并不是常见直方图的模样</p><p>Matplotlib 带有一个直方图绘图函数：<code>matplotlib.pyplot.hist()</code></p><p>可以直接输入图像，不需要先<code>cv2.calcHist()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/Lena.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291123.png" alt="202509291123" style="zoom:67%;" /><p>但对于彩色图样，选择普通绘图反而是更好的选择，因为这样可以很容易看出不同颜色的成分</p><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>直方图均衡化是一种增强图像对比度的方法，通过重新分配像素强度值，使直方图更加均匀，改善图像的全局亮度和对比度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq_img = cv2.equalizeHist(img)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/Lena.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">eq_img = cv2.equalizeHist(img)</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.imshow(img,<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.imshow(eq_img,<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.hist(eq_img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291145.webp" alt="202509291145" style="zoom: 67%;" /><h3 id="自适应均衡化"><a href="#自适应均衡化" class="headerlink" title="自适应均衡化"></a>自适应均衡化</h3><p>直方图均衡化是应用于整幅图片的，但是这可能导致局部细节丢失，自适应均衡化就是用来解决这一问题的，它在每一个小区域内(默认 8×8)进行直方图均衡化</p><p>当然，如果有噪声的话也会被放大，所以需要对对比度进行限制，所以这个算法全称叫<font color='Violetred'>对比度受限的自适应直方图均衡化CLAHE</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clahe = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>))</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291505~1.webp" alt="202509291505~1" style="zoom:67%;" /><p>可以看到不会有过曝区域</p><h3 id="直方图比较"><a href="#直方图比较" class="headerlink" title="直方图比较"></a>直方图比较</h3><p> <code>cv2.compareHist() </code>函数，用于比较两个直方图的相似度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">similarity = cv2.compareHist(hist1, hist2, method)</span><br></pre></td></tr></table></figure><ul><li><code>method</code>: 比较方法</li></ul><p>比较方法主要有四种：</p><table><thead><tr><th>方法</th><th>代码标识</th><th>范围</th><th>相似性判断</th><th>衡量目标</th></tr></thead><tbody><tr><td>相关性</td><td><code>cv2.HISTCMP_CORREL</code>|0</td><td>[-1,1]</td><td>越大越相似</td><td>直方图形状相似性</td></tr><tr><td>卡方</td><td><code>cv2.HISTCMP_CHISQR</code>|1</td><td>[0,+∞]</td><td>越小越相似</td><td>概率分布差异</td></tr><tr><td>相交</td><td><code>cv2.HISTCMP_INTERSECT</code>|2</td><td>[0,sum]</td><td>越大越相似</td><td>重叠部分</td></tr><tr><td>巴氏距离</td><td><code>cv2.HISTCMP_BHATTACHARYYA</code>|3</td><td>[0,1]</td><td>越小越相似</td><td>概率分布相似性</td></tr></tbody></table><blockquote><p>举例，直方图A &#x3D; <code>[1, 2, 3]</code>，直方图 B &#x3D; <code>[3, 2, 1]</code></p><p>Correlation: -0.999999999999998 (负相关)<br>Chi-Square: 0.8888887630568671<br>Intersection: 0.6666666865348816<br>Bhattacharyya: 0.298858482412642</p></blockquote><table><thead><tr><th>方法</th><th>常见场景</th></tr></thead><tbody><tr><td>相关性</td><td>检测线性相关性(亮度&#x2F;对比度变化)，找风格相似的图片</td></tr><tr><td>卡方</td><td>目标识别时发现差异</td></tr><tr><td>相交</td><td>直方图快速匹配</td></tr><tr><td>巴氏距离</td><td>目标跟踪，适合高精度相似性度量</td></tr></tbody></table><p>在进行比较之前，一般都要进行归一化</p><p>使用<code>cv2.normalize()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.normalize(src, dst=<span class="literal">None</span>, alpha=<span class="number">1</span>, beta=<span class="number">0</span>, norm_type)</span><br></pre></td></tr></table></figure><ul><li><p><code>src</code>：输入数组，可以是图像&#x2F;直方图</p></li><li><p><code>dst</code>：输出数组，如果写入None则覆盖输入</p></li><li><p><code>alpha</code>：L1，L2归一化需设为1，beta为无作用冗余参数</p><p><code>beta</code>：最大最小归一化时使用，归一化数值最大值</p></li><li><p><code>norm_type</code>：归一化方式</p></li></ul><p>归一化常见方式：</p><table><thead><tr><th>函数</th><th>目的</th><th>常见用途</th></tr></thead><tbody><tr><td><code>cv2.NORM_MINMAX</code></td><td>把数据线性拉伸到<code>[alpha, beta]</code>区间</td><td>图像对比度拉伸</td></tr><tr><td><code>cv2.NORM_L1</code>|2</td><td>所有值除以绝对值和</td><td>直方图归一化为概率分布</td></tr><tr><td><code>cv2.NORM_L2</code>(默认)|4</td><td>所有值除以平方和的平方根</td><td>把向量长度归一到 1</td></tr></tbody></table><p>匹配比较方法和归一化方式</p><table><thead><tr><th>方法</th><th>归一化方式</th><th>原因</th></tr></thead><tbody><tr><td>相关性</td><td>无需</td><td>相关性看趋势，线性缩放不影响结果</td></tr><tr><td>卡方</td><td>L1</td><td><font color='Violetred'>通常用于比较概率分布，需要归一化到概率分布</font></td></tr><tr><td>交集</td><td>不归一化&#x2F;L1</td><td>不归一化为绝对重叠数量；<br />归一化后为“重叠比例”含义</td></tr><tr><td>巴氏距离</td><td>L1</td><td><font color='Violetred'>定义基于概率分布，需要归一化到概率分布</font></td></tr></tbody></table><p>对于直方图均衡化后的图片，这四个方法其实都不太能看出是一张图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/Lena.bmp&quot;</span>, <span class="number">0</span>)</span><br><span class="line">eq_img = cv2.equalizeHist(img)</span><br><span class="line">hist_img = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">cv2.normalize(hist_img, hist_img, alpha=<span class="number">1</span>, beta=<span class="number">0</span>, norm_type=cv2.NORM_L1)</span><br><span class="line">hist_eq = cv2.calcHist([eq_img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">cv2.normalize(hist_eq, hist_eq, alpha=<span class="number">1</span>, beta=<span class="number">0</span>, norm_type=cv2.NORM_L1)</span><br><span class="line"><span class="comment"># 四种相似性计算</span></span><br><span class="line">methods = &#123;</span><br><span class="line">    <span class="string">&quot;Correlation&quot;</span>: cv2.HISTCMP_CORREL,</span><br><span class="line">    <span class="string">&quot;Chi-Square&quot;</span>: cv2.HISTCMP_CHISQR,</span><br><span class="line">    <span class="string">&quot;Intersection&quot;</span>: cv2.HISTCMP_INTERSECT,</span><br><span class="line">    <span class="string">&quot;Bhattacharyya&quot;</span>: cv2.HISTCMP_BHATTACHARYYA</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, method <span class="keyword">in</span> methods.items():</span><br><span class="line">    score = cv2.compareHist(hist_img, hist_eq, method)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;score&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># Correlation: 0.007809369904676664  均衡化后拉伸平铺，相关性基本消失</span></span><br><span class="line"><span class="comment"># Chi-Square: 40.33161269091677      不同BIN的差异很大</span></span><br><span class="line"><span class="comment"># Intersection: 0.5334510803222656   还有大约一半的直方图“重叠部分”</span></span><br><span class="line"><span class="comment"># Bhattacharyya: 0.5778464606235761  两个分布整体重叠度不高</span></span><br></pre></td></tr></table></figure><h2 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h2><p>模板匹配是一种在较大的图像中搜索和查找模板图像位置的方法</p><p>用<code>cv2.matchTemplate()</code>实现模板匹配，返回的是一副灰度图，最白的地方表示最大的匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.matchTemplate(img, templ, method)</span><br></pre></td></tr></table></figure><p><code>method</code>：匹配方法，有几种不同的计算方式</p><ul><li><p><code>cv2.TM_CCOEFF</code> &#x2F; <code>cv2.TM_CCOEFF_NORMED</code> (相关系数，常用，越大越像)</p></li><li><p><code>cv2.TM_CCORR</code> &#x2F; <code>cv2.TM_CCORR_NORMED</code> (相关匹配，越大越像，效果不好，用的少)</p></li><li><p><code>cv2.TM_SQDIFF</code> &#x2F; <code>cv2.TM_SQDIFF_NORMED</code> (平方差，数值越小越像)</p></li></ul><p>使用<code>cv2.minMaxLoc()</code>函数可以得到匹配值极值的坐标，以这个点为左上角角点，模板的宽和高画矩形就是匹配的位置了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)</span><br></pre></td></tr></table></figure><p>如果用的是平方差类方法<code>TM_SQDIFF</code>，数值越小越好，所以取<code>min_loc</code>，其他方法数值越大越好，所以取 <code>max_loc</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;imgs/Lena.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;imgs/face.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>] <span class="comment"># rows-&gt;h, cols-&gt;w</span></span><br><span class="line"><span class="comment"># 相关系数匹配方法：cv2.TM_CCOEFF</span></span><br><span class="line">res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line">left_top = max_loc  <span class="comment"># 左上角</span></span><br><span class="line">right_bottom = (left_top[<span class="number">0</span>] + w, left_top[<span class="number">1</span>] + h)  <span class="comment"># 右下角</span></span><br><span class="line">cv2.rectangle(img, left_top, right_bottom, <span class="number">255</span>, <span class="number">2</span>)  <span class="comment"># 画出矩形位置</span></span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.imshow(template, <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.imshow(res, <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.imshow(img, <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291525.webp" alt="202509291525" style="zoom:80%;" /><h3 id="多物体匹配"><a href="#多物体匹配" class="headerlink" title="多物体匹配"></a>多物体匹配</h3><p>在这个例子中，将使用著名游戏马里奥的截图，并在其中找到金币</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/mario.jpg&quot;</span>,<span class="number">1</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">template = cv2.imread(<span class="string">&quot;imgs/mario_coin.jpg&quot;</span>, <span class="number">0</span>)</span><br><span class="line">w, h = template.shape[::-<span class="number">1</span>]</span><br><span class="line">res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">threshold = <span class="number">0.8</span></span><br><span class="line">loc= np.where(res&gt;=threshold)</span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> <span class="built_in">zip</span>(*loc[::-<span class="number">1</span>]):</span><br><span class="line">    cv2.rectangle(img, pt, (pt[<span class="number">0</span>]+w,pt[<span class="number">1</span>]+h), (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509291538.webp" alt="202509291538" style="zoom: 80%;" /><h2 id="图像拼接"><a href="#图像拼接" class="headerlink" title="图像拼接"></a>图像拼接</h2><p>图像拼接的基本流程可以分为以下几个步骤：</p><ol><li><strong>图像读取</strong>：读取需要拼接的图像</li><li><strong>特征点检测</strong>：在每张图像中检测出关键点（特征点）</li><li><strong>特征点匹配</strong>：在不同图像之间匹配这些特征点</li><li><strong>计算变换矩阵</strong>：根据匹配的特征点计算图像之间的变换矩阵</li><li><strong>图像融合</strong>：将图像按照变换矩阵进行拼接，并进行融合处理以消除拼接痕迹</li></ol><p>特征点检测是图像拼接的关键步骤，OpenCV 提供了多种特征点检测算法，如SIFT、SURF、ORB 等，其中<font color='Violetred'>SIFT和SURF是浮点描述子，ORB是二进制描述子 </font></p><p>SIFT长期被认为鲁棒性最好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创造SIFT检测器</span></span><br><span class="line">sift = cv2.SIFT_create()</span><br><span class="line">kps1, des1 = sift.detectAndCompute(img1, <span class="literal">None</span>)</span><br><span class="line">kps2, des2 = sift.detectAndCompute(img2, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><code>detectAndCompute()</code> 函数会返回两个值：关键点(keypoints)和描述符(descriptors)，关键点是图像中的显著点，描述符是对这些关键点的描述，用于后续的匹配</p><p>OpenCV 提供了 <code>BFMatcher</code> 或 <code>FlannBasedMatcher</code> 来进行特征点匹配</p><table><thead><tr><th>匹配方法</th><th>描述</th><th>SIFT&#x2F;SURF</th><th>ORB&#x2F;BRIEF</th></tr></thead><tbody><tr><td>BFMatcher</td><td>暴力匹配，逐个对比计算距离</td><td>欧式距离(L2范数)</td><td>汉明距离(二进制取与)</td></tr><tr><td>FlannBasedMatcher</td><td>近似快速匹配，使用ANN(近似最相邻)搜索算法</td><td>KD-Tree(K维树)</td><td>LSH(局部敏感哈希)</td></tr></tbody></table><p>BFMatcher简单直接，但计算量大，速度慢；</p><p>FlannBasedMatcher匹配速度更快，更适合大规模特征点匹配，虽然结果近似最近邻，但是在实际应用中几乎不影响效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- BFMatcher ---</span></span><br><span class="line">bf = cv2.BFMatcher() <span class="comment"># L2范数</span></span><br><span class="line">matches_bf = bf.knnMatch(des1, des2, k=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># --- FLANN ---</span></span><br><span class="line">index_params = <span class="built_in">dict</span>(algorithm=<span class="number">1</span>, trees=<span class="number">5</span>)   <span class="comment"># KDTree</span></span><br><span class="line">search_params = <span class="built_in">dict</span>(checks=<span class="number">50</span>)</span><br><span class="line">flann = cv2.FlannBasedMatcher(index_params, search_params)</span><br><span class="line">matches_flann = flann.knnMatch(des1, des2, k=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>FLANN的创建需要输入参数</p><ul><li><p>SIFT&#x2F;SURF → <code>algorithm=1, trees=5</code> （KDTree）</p></li><li><p>ORB → <code>algorithm=6, table_number=6, key_size=12, multi_probe_level=1</code> （LSH）</p></li><li><p>checks&#x3D;50 → 表示搜索时在多少个叶节点里查找候选(常用 32~128 之间)</p></li></ul><p><code>knnMatch()</code> 函数会返回每个特征点的两个最佳匹配，通过比率测试(Lowe’s ratio test)来筛选出好的匹配点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">good_matches = []</span><br><span class="line"><span class="keyword">for</span> m, n <span class="keyword">in</span> matches_flann:</span><br><span class="line">    <span class="keyword">if</span> m.distance &lt; <span class="number">0.75</span> * n.distance:</span><br><span class="line">        good_matches.append(m)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(good_matches) &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;匹配点太少，无法拼接&quot;</span>)</span><br></pre></td></tr></table></figure><p>在得到好的匹配点后，可以使用这些点来计算图像之间的变换矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取匹配点的坐标</span></span><br><span class="line">src_pts = np.float32([kps1[m.queryIdx].pt <span class="keyword">for</span> m <span class="keyword">in</span> good_matches]).reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">dst_pts = np.float32([kps2[m.trainIdx].pt <span class="keyword">for</span> m <span class="keyword">in</span> good_matches]).reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 计算单应性矩阵</span></span><br><span class="line">H, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, <span class="number">5.0</span>)</span><br></pre></td></tr></table></figure><p>最后使用计算出的单应性矩阵将图像进行拼接，并进行融合处理以消除拼接痕迹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透视变换 + 融合</span></span><br><span class="line">h1, w1 = img1.shape[:<span class="number">2</span>]</span><br><span class="line">h2, w2 = img2.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 计算输出画布</span></span><br><span class="line">pts_img1 = np.float32([[<span class="number">0</span>,<span class="number">0</span>], [<span class="number">0</span>,h1], [w1,h1], [w1,<span class="number">0</span>]]).reshape(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># OpenCV要求数组是N×1×2的格式</span></span><br><span class="line"><span class="comment"># 用单应矩阵 H 把角点 投影到 img2 的坐标系里</span></span><br><span class="line">pts_img1_trans = cv2.perspectiveTransform(pts_img1, H)</span><br><span class="line"><span class="comment"># 把变换后的 img1 的四个角点和原始 img2 的四个角点拼在一起</span></span><br><span class="line">pts_all = np.concatenate((pts_img1_trans, np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,h2],[w2,h2],[w2,<span class="number">0</span>]]).reshape(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)), axis=<span class="number">0</span>)</span><br><span class="line">[xmin, ymin] = np.int32(pts_all.<span class="built_in">min</span>(axis=<span class="number">0</span>).ravel() - <span class="number">0.5</span>)</span><br><span class="line">[xmax, ymax] = np.int32(pts_all.<span class="built_in">max</span>(axis=<span class="number">0</span>).ravel() + <span class="number">0.5</span>)</span><br><span class="line"> <span class="comment"># 平移变换，确保坐标正值</span></span><br><span class="line">t = [-xmin, -ymin] <span class="comment"># 定义平移向量，因为xmin和ymin可能是负数</span></span><br><span class="line">H_trans = np.array([[<span class="number">1</span>,<span class="number">0</span>,t[<span class="number">0</span>]], [<span class="number">0</span>,<span class="number">1</span>,t[<span class="number">1</span>]], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]) <span class="comment"># 把所有点整体平移(tx, ty)</span></span><br><span class="line"><span class="comment"># warp</span></span><br><span class="line">result = cv2.warpPerspective(img1, H_trans.dot(H), (xmax-xmin, ymax-ymin))</span><br><span class="line">result[t[<span class="number">1</span>]:h2+t[<span class="number">1</span>], t[<span class="number">0</span>]:w2+t[<span class="number">0</span>]] = img2 <span class="comment"># 把 img2 直接贴到大画布的正确位置</span></span><br><span class="line"><span class="comment"># 因为整个画布已经被平移过，所以 img2 也要偏移</span></span><br></pre></td></tr></table></figure><p>拼接效果可能不是特别好</p><h2 id="简单滤镜"><a href="#简单滤镜" class="headerlink" title="简单滤镜"></a>简单滤镜</h2><p>主要滤镜效果：</p><table><thead><tr><th align="left"><strong>滤镜效果</strong></th><th align="left"><strong>实现方法</strong></th></tr></thead><tbody><tr><td align="left">灰度滤镜</td><td align="left"><code>cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</code></td></tr><tr><td align="left">模糊滤镜</td><td align="left"><code>cv2.GaussianBlur(image, (15, 15), 0)</code></td></tr><tr><td align="left">怀旧滤镜</td><td align="left">通过调整色彩通道的权重，模拟老照片效果</td></tr><tr><td align="left">浮雕滤镜</td><td align="left">使用卷积核 <code>[[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]</code> 进行卷积操作</td></tr><tr><td align="left">锐化滤镜</td><td align="left">使用卷积核 <code>[[0, -1, 0], [-1, 5, -1], [0, -1, 0]]</code> 进行卷积操作</td></tr><tr><td align="left">边缘检测滤镜</td><td align="left"><code>cv2.Canny(gray_image, 100, 200)</code></td></tr></tbody></table><h3 id="怀旧滤镜"><a href="#怀旧滤镜" class="headerlink" title="怀旧滤镜"></a>怀旧滤镜</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/LenaRGB.bmp&quot;</span>)</span><br><span class="line"><span class="comment"># 分离 BGR 通道</span></span><br><span class="line">b,g,r = cv2.split(img)</span><br><span class="line"><span class="comment"># 调整通道强度</span></span><br><span class="line">r = np.clip(r*<span class="number">0.393</span>+g*<span class="number">0.769</span>+b*<span class="number">0.189</span>,<span class="number">0</span>,<span class="number">255</span>).astype(np.uint8)</span><br><span class="line">g = np.clip(r*<span class="number">0.349</span>+g*<span class="number">0.686</span>+b*<span class="number">0.168</span>,<span class="number">0</span>,<span class="number">255</span>).astype(np.uint8)</span><br><span class="line">b = np.clip(r*<span class="number">0.272</span>+g*<span class="number">0.534</span>+b*<span class="number">0.131</span>,<span class="number">0</span>,<span class="number">255</span>).astype(np.uint8)</span><br><span class="line"><span class="comment"># 合并通道</span></span><br><span class="line">img = cv2.merge([b,g,r])</span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041051.webp" alt="202510041051" style="zoom:67%;" /><h3 id="浮雕滤镜"><a href="#浮雕滤镜" class="headerlink" title="浮雕滤镜"></a>浮雕滤镜</h3><p>浮雕滤镜通过计算图像中相邻像素的差值，生成一种类似于浮雕的效果，这种滤镜通常用于增强图像的边缘和纹理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/LenaRGB.bmp&quot;</span>)</span><br><span class="line"><span class="comment"># 转换为灰度图像</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 定义卷积核</span></span><br><span class="line">kernel = np.array([[-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                   [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                   [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="comment"># 应用卷积核</span></span><br><span class="line">emboss_img = cv2.filter2D(gray, -<span class="number">1</span>, kernel)</span><br><span class="line">plt.imshow(cv2.cvtColor(emboss_img, cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041056.webp" alt="202510041056" style="zoom: 67%;" /><h2 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h2><p>霍夫变换常用来在图像中提取直线和圆等几何形状</p><h3 id="霍夫直线变换"><a href="#霍夫直线变换" class="headerlink" title="霍夫直线变换"></a>霍夫直线变换</h3><p>直线的参数方程：$y&#x3D;kx+b$</p><p>但是在 $k\rightarrow \infty$ 时将无效，霍夫变换用极坐标的形式<br>$$<br>\rho &#x3D; x\cos \theta +y\sin \theta<br>$$<br>任何一条直线都能用一对$(\rho ,\theta)$唯一表示</p><p>用<code>cv2.HoughLines()</code>在二值图上实现霍夫变换，函数返回的是一组直线的$(\rho ,\theta)$数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines = cv2.HoughLines(edges, <span class="number">1</span>, np.pi / <span class="number">180</span>, threshold)</span><br></pre></td></tr></table></figure><ul><li>参数1：一般是边缘检测后的二值图</li><li>参数2：距离$\rho$的精度，值越大，考虑越多的线，一般使用1像素</li><li>参数3：角度$\theta $的精度，值越小，考虑越多的线，一般使用1度</li><li>参数4：累加数阈值，值越小，考虑越多的线</li></ul><p><strong>标准霍夫变换</strong>会检测到整条无穷延伸的直线，而实际中更想要<strong>线段</strong></p><p>OpenCV 提供 <code>cv2.HoughLinesP</code>(统计概率霍夫直线变换)，这是一种改进算法，输出线段的起止点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linesP = cv2.HoughLinesP(edges, <span class="number">1</span>, np.pi/<span class="number">180</span>, threshold, minLineLength=<span class="number">50</span>, maxLineGap=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>前面几个参数跟之前的一样，有两个可选参数，最短长度阈值以及同一直线两点间的最大距离</p><p>读取 → 转灰度 → Canny检测 → 霍夫变换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&quot;imgs/hough_test.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 绘制黑背景用于显示</span></span><br><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line">linesP = cv2.HoughLinesP(edges, <span class="number">1</span>, np.pi/<span class="number">180</span>, <span class="number">80</span>, minLineLength=<span class="number">50</span>, maxLineGap=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 遍历，linesP.shape = (N, 1, 4)</span></span><br><span class="line"><span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> linesP[:,<span class="number">0</span>]: <span class="comment"># 选出所有线段的第一个数组，压缩为(N,4) </span></span><br><span class="line">    cv2.line(drawing, (x1,y1), (x2,y2), (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">plt.imshow(drawing)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041328.png" alt="202510041328" style="zoom:67%;" /><h3 id="霍夫圆变换"><a href="#霍夫圆变换" class="headerlink" title="霍夫圆变换"></a>霍夫圆变换</h3><p>同理，霍夫变换也可以用于检测圆<br>$$<br>(x-a)^2+(y-b)^2 &#x3D; r^2<br>$$<br>参数空间变成$(a, b, r)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cv2.HoughCircles(</span><br><span class="line">    image,            <span class="comment"># 输入图像（必须是灰度图）</span></span><br><span class="line">    method,           <span class="comment"># 检测方法（通常用 cv2.HOUGH_GRADIENT）</span></span><br><span class="line">    dp,               <span class="comment"># 累加器分辨率的反比，1为等尺寸，2为图像的一半</span></span><br><span class="line">    minDist,          <span class="comment"># 检测到的圆之间的最小距离，通常为图像高度的若干份之一</span></span><br><span class="line">    param1=<span class="number">100</span>,       <span class="comment"># Canny 边缘检测的高阈值，低阈值自动为其一半</span></span><br><span class="line">    param2=<span class="number">30</span>,        <span class="comment"># 圆心累加器阈值（越小越容易检测到假圆）</span></span><br><span class="line">    minRadius=<span class="number">0</span>,      <span class="comment"># 圆的最小半径，0自动搜索，已知物体建议精确设定</span></span><br><span class="line">    maxRadius=<span class="number">0</span>       <span class="comment"># 圆的最大半径，同理</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;imgs/hough_test.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 绘制黑背景用于显示</span></span><br><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape <span class="comment"># 图像尺寸</span></span><br><span class="line">circles = cv2.HoughCircles(gray, cv2.HOUGH_GRADIENT, dp = <span class="number">1</span>, minDist= h/<span class="number">8</span>, param2=<span class="number">30</span>)</span><br><span class="line">circles = np.uint16(np.around(circles)) <span class="comment"># 检测到的圆心坐标和半径从浮点数转换成无符号整数</span></span><br><span class="line"><span class="keyword">for</span> (x, y, r) <span class="keyword">in</span> circles[<span class="number">0</span>, :]:</span><br><span class="line">    cv2.circle(drawing, (x, y), r, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">plt.imshow(drawing)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041338.png" alt="202510041338" style="zoom:67%;" /><h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><p>视频是由一系列连续的图像帧组成的，每一帧都是一幅静态图像，核心就是对这些图像帧进行处理</p><h3 id="视频读取"><a href="#视频读取" class="headerlink" title="视频读取"></a>视频读取</h3><p>要读取视频文件，首先需要创建一个 <code>cv2.VideoCapture</code> 对象，并指定视频文件的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="string">&quot;imgs/camera_vedio.mp4&quot;</span>)</span><br><span class="line"><span class="comment"># 检查视频是否成功打开</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: Could not open video.&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># ret: 标识符，表示是否成功读取</span></span><br><span class="line">    <span class="comment"># frame: 当前帧图像</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Video&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>除了读取视频文件，OpenCV 还可以直接从摄像头读取视频，只需要将 <code>cv2.VideoCapture</code> 的参数设置为摄像头的索引(通常为0)即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 检查摄像头是否成功打开</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: Could not open camera.&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="comment"># 读取视频帧</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># 如果读取到最后一帧，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 显示当前帧</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Camera&#x27;</span>, frame)</span><br><span class="line">    <span class="comment"># 按下esc 退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>电脑没有摄像头的话可以参考这篇内容：<a href="/posts/29316.html" title="虚拟摄像头构建">虚拟摄像头构建</a></p><p>之后就可以对视频画面进行一些实时操作了</p><h3 id="视频帧处理"><a href="#视频帧处理" class="headerlink" title="视频帧处理"></a>视频帧处理</h3><p>在读取视频帧后，可以对每一帧进行各种图像处理操作，并进行保存</p><p>在读取后需要利用<code>.get()</code>获取视频的属性(如宽度、高度、帧率等)，方便创建保存对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fps = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FPS)) <span class="comment"># 帧率</span></span><br><span class="line">width = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH)) <span class="comment"># 宽度</span></span><br><span class="line">height = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)) <span class="comment"># 高度</span></span><br></pre></td></tr></table></figure><p>视频如果分辨率和帧率过高输出可能会出现掉帧，根据性能量力而行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">input_path = <span class="string">&quot;imgs/tree.mp4&quot;</span></span><br><span class="line">output_path = <span class="string">&quot;tree.avi&quot;</span></span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(input_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: Could not open camera.&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="comment"># 获取视频的帧率和尺寸</span></span><br><span class="line">fps = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FPS))</span><br><span class="line"><span class="comment"># width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span></span><br><span class="line"><span class="comment"># height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span></span><br><span class="line"><span class="comment"># 创建 VideoWriter 对象，保存处理后的视频</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;XVID&#x27;</span>) <span class="comment"># 常见编码: &quot;XVID&quot;, &quot;MJPG&quot;, &quot;mp4v&quot;</span></span><br><span class="line">out = cv2.VideoWriter(output_path, fourcc, fps, (<span class="number">1080</span>, <span class="number">720</span>))</span><br><span class="line"><span class="comment"># out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    frame = cv2.resize(frame, (<span class="number">1080</span>,<span class="number">720</span>)) <span class="comment"># 改尺寸了要加上</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    blur = cv2.GaussianBlur(gray, (<span class="number">5</span>,<span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">    edges = cv2.Canny(blur, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line">    edges = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)</span><br><span class="line">    out.write(edges)</span><br><span class="line">    <span class="comment"># cv2.imshow(&#x27;Video&#x27;, edges)</span></span><br><span class="line">    <span class="comment"># if cv2.waitKey(25) &amp; 0xFF == 27:</span></span><br><span class="line">    <span class="comment">#     break</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;视频处理完毕&quot;</span>)</span><br></pre></td></tr></table></figure><p>摄像头实时处理读出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">output_path = <span class="string">&quot;res/camera_output.mp4&quot;</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: Could not open camera.&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="comment"># 获取摄像头参数</span></span><br><span class="line">fps = <span class="number">30.0</span>  <span class="comment"># 摄像头一般不一定能准确取到帧率，可以手动设定</span></span><br><span class="line">width = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">height = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line"><span class="comment"># 创建 VideoWriter</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;mp4v&#x27;</span>)</span><br><span class="line">out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按 ESC 退出录制...&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 图像处理：灰度化 + 边缘检测</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    edges = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line">    edges = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)</span><br><span class="line">    <span class="comment"># 写入文件</span></span><br><span class="line">    out.write(edges)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;Camera Processed&quot;</span>, edges)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;录制结束，视频保存为:&quot;</span>, output_path)</span><br></pre></td></tr></table></figure><h3 id="物体检测"><a href="#物体检测" class="headerlink" title="物体检测"></a>物体检测</h3><p>OpenCV提供了多种物体检测算法，如 Haar 特征分类器、HOG + SVM 等</p><h4 id="Haar特征分类器"><a href="#Haar特征分类器" class="headerlink" title="Haar特征分类器"></a>Haar特征分类器</h4><p>Haar 特征分类器是一种基于 Haar-like 特征的机器学习方法，用于检测图像中的目标</p><p>OpenCV 提供了预训练的 Haar 特征分类器，<code>cv2.CascadeClassifier</code>用于加载分类器，参数是分类器文件的路径</p><table><thead><tr><th>模型文件</th><th>检测目标</th><th>描述</th></tr></thead><tbody><tr><td><code>haarcascade_frontalface_default.xml</code></td><td>正面人脸</td><td>最常用</td></tr><tr><td><code>haarcascade_profileface.xml</code></td><td>侧面人脸</td><td></td></tr><tr><td><code>haarcascade_eye.xml</code></td><td>眼睛检测</td><td>需要配合人脸使用</td></tr><tr><td><code>haarcascade_smile.xml</code></td><td>微笑检测</td><td></td></tr></tbody></table><p>进行人脸检测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 加载 Haar 特征分类器</span></span><br><span class="line">face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + <span class="string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 将帧转换为灰度图像</span></span><br><span class="line">    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 检测人脸</span></span><br><span class="line">    faces = face_cascade.detectMultiScale(</span><br><span class="line">        gray_frame, </span><br><span class="line">        scaleFactor=<span class="number">1.1</span>, </span><br><span class="line">        minNeighbors=<span class="number">5</span>, </span><br><span class="line">        minSize=(<span class="number">30</span>, <span class="number">30</span>))</span><br><span class="line">    <span class="comment"># 在帧上绘制矩形框标记人脸</span></span><br><span class="line">    <span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">        cv2.rectangle(frame, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 显示带有人脸标记的帧</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Face Detection&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><code>detectMultiScale</code>会返回所有检测到的矩形框 <code>(x, y, w, h)</code></p><ul><li><p><code>scaleFactor</code>：表示图像尺寸的缩小比例，&gt;1缩小图像，<font color='Violetred'>常用1.1</font></p><p>计算方法：缩小比例 &#x3D; 1 - (1&#x2F;<code>scaleFactor</code>) </p><p><code>scaleFactor=1.1</code> 时，每次缩放后的新尺寸 &#x3D; 原尺寸×(1&#x2F;1.1) ≈ 原尺寸×0.909</p></li><li><p><code>minNeighbors</code>：表示在当前强度中心周围有多少个目标同时检测到才算有效，值越高越严格</p></li><li><p><code>minSize</code>：最小检测窗口，表示目标的最小尺寸</p></li></ul><p>Haar属于传统CV算法，速度快，适合实时，但检测精度不如深度学习模型，对光照、角度变化不鲁棒</p><h4 id="YOLOv5"><a href="#YOLOv5" class="headerlink" title="YOLOv5"></a>YOLOv5</h4><p>相比Haar，Yolov5可同时检测80+类别物体，输出带类别标签的边界框，对部分遮挡、光照变化、背景杂乱有较强鲁棒性，训练后的代码简洁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="comment"># torch 更新导致会出一些warming，眼不见为净</span></span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>, category=FutureWarning, message=<span class="string">&quot;.*torch.cuda.amp.autocast.*&quot;</span>)</span><br><span class="line"><span class="comment"># 加载YOLOv5模型(采用官方训练权重)</span></span><br><span class="line">model = torch.hub.load(<span class="string">&#x27;ultralytics/yolov5&#x27;</span>, <span class="string">&#x27;yolov5s&#x27;</span>)</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    results = model(frame)</span><br><span class="line">    <span class="comment">#  渲染结果（模型自带的画框函数）</span></span><br><span class="line">    annotated_frame = results.render()[<span class="number">0</span>]</span><br><span class="line">    cv2.imshow(<span class="string">&quot;YOLOv5 Real Time Detection&quot;</span>, annotated_frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="运动检测"><a href="#运动检测" class="headerlink" title="运动检测"></a>运动检测</h3><h4 id="帧差法"><a href="#帧差法" class="headerlink" title="帧差法"></a>帧差法</h4><p>通过计算帧之间的差异来检测运动物体，最直观</p><p>特点：简单，适合物体比较大、背景稳定的场景</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 读取第一帧</span></span><br><span class="line">ret, prev_frame = cap.read()</span><br><span class="line">prev_gray = cv2.cvtColor(prev_frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">prev_gray = cv2.GaussianBlur(prev_gray, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = cv2.GaussianBlur(gray, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 帧差</span></span><br><span class="line">    diff = cv2.absdiff(prev_gray, gray)</span><br><span class="line">    <span class="comment"># 对差异图像进行二值化处理</span></span><br><span class="line">    _, thresh = cv2.threshold(diff, <span class="number">25</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">    <span class="comment"># 膨胀操作，去除噪声</span></span><br><span class="line">    dilated = cv2.dilate(thresh, <span class="literal">None</span>, iterations=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 找轮廓</span></span><br><span class="line">    contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    <span class="comment"># 遍历轮廓进行挑选</span></span><br><span class="line">    <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:</span><br><span class="line">        <span class="keyword">if</span> cv2.contourArea(cnt) &lt; <span class="number">500</span>:  <span class="comment"># 忽略太小的移动</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">        cv2.rectangle(frame, (x, y), (x+w, y+h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;motion detection&quot;</span>, frame)</span><br><span class="line">    prev_gray = gray <span class="comment"># 更新前一帧</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:  <span class="comment"># 按 ESC 退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h4 id="背景减除法"><a href="#背景减除法" class="headerlink" title="背景减除法"></a>背景减除法</h4><p>背景减除法是一种更为精准和鲁棒的运动检测技术，通过学习视频的静态背景，然后将当前帧与背景模型进行比较，从而识别出前景（即运动的物体），它比帧差法稳定，对光照变化更鲁棒</p><p>其基本流程如下：</p><ol><li>背景建模：通过分析视频序列中的多帧图像，建立一个背景模型</li><li>前景检测：将当前帧与背景模型进行比较，找出与背景差异较大的区域，这些区域即为前景对象。</li><li>背景更新：随着时间的推移，背景可能会发生变化（如光照变化、背景物体的移动等），因此需要不断更新背景模型</li></ol><p>OpenCV 提供了多种背景减除算法，其中MOG和MOG2是最常用的两种方法</p><p>MOG2是MOG的改进版本，主要区别在于它能够自动选择高斯分布的数量，并且能够更好地适应背景的变化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgbg = cv2.createBackgroundSubtractorMOG2(history=<span class="number">500</span>, varThreshold=<span class="number">16</span>, detectShadows=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>history</code>：训练的帧数(默认500)，值大表示模型记忆更久，适合稳定场景；值小更灵敏，适合背景经常变化的环境</p></li><li><p><code>varThreshold</code>：像素和背景模型的阈值(默认 16)</p><p>值小 → 更容易检测出前景，但噪声也多；值大 → 只检测明显运动的物体</p></li><li><p><code>detectShadows</code>：是否检测阴影，默认True，如果只想要前景物体，可以关掉它</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgmask = fgbg.apply(frame)</span><br></pre></td></tr></table></figure><p>输入一帧图像，输出前景掩码(mask)，掩码是单通道图像：背景0，前景255，阴影127</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建背景减除器</span></span><br><span class="line">fgbg = cv2.createBackgroundSubtractorMOG2(history=<span class="number">500</span>, varThreshold=<span class="number">50</span>, detectShadows=<span class="literal">False</span>) <span class="comment"># 这里不要阴影</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 应用背景减除，获得前景掩码</span></span><br><span class="line">    fgmask = fgbg.apply(frame)</span><br><span class="line">    <span class="comment"># 对掩码进行形态学操作，以消除噪声</span></span><br><span class="line">    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">    fgmask = cv2.morphologyEx(fgmask, cv2.MORPH_OPEN, kernel)</span><br><span class="line">    <span class="comment"># 膨胀操作</span></span><br><span class="line">    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">7</span>, <span class="number">7</span>))</span><br><span class="line">    fgmask = cv2.dilate(fgmask, kernel)</span><br><span class="line">    <span class="comment"># 查找轮廓</span></span><br><span class="line">    contours, hierarchy = cv2.findContours(fgmask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    <span class="comment"># 遍历所有轮廓</span></span><br><span class="line">    <span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">        <span class="comment"># 忽略面积过小的轮廓，以减少误报</span></span><br><span class="line">        <span class="keyword">if</span> cv2.contourArea(contour) &lt; <span class="number">500</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 获取轮廓的边界框</span></span><br><span class="line">        (x, y, w, h) = cv2.boundingRect(contour)</span><br><span class="line">        <span class="comment"># 在原始帧上绘制边界框</span></span><br><span class="line">        cv2.rectangle(frame, (x, y), (x+w, y+h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 显示结果</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Original Frame&#x27;</span>, frame)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Foreground Mask&#x27;</span>, fgmask)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>: <span class="comment"># 按esc退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>卷积核大小不同是为了先用最小的代价去除噪声，再用足够的强度来恢复和增强目标</p><p>会发现在检测时一个人可能出现多个框，是因为这个算法并不会把人当作一个整体来看待</p><p>相比YOLO这只是一种比较简单的低级检测，只会发现哪里在动，不关心这是不是一个整体</p><h2 id="车道检测"><a href="#车道检测" class="headerlink" title="车道检测"></a>车道检测</h2><p>无人车上的相机拍摄的视频中，车道线的位置应该基本固定在某一个范围内</p><p>手动把这部分 ROI 区域抠出来，就会排除掉大部分干扰</p><p>利用霍夫变换检测直线，但 ROI 区域内的边缘直线信息还是很多。考虑到只有左右两条车道线，一条斜率为正，一条为负，可将所有的线分为两组，每组再通过均值或最小二乘法拟合的方式确定唯一一条线就可以完成检测</p><p>总体步骤如下：</p><ol><li>读取视频帧（逐帧处理）</li><li>灰度化 + 高斯滤波（降噪）</li><li>Canny边缘检测（提取边缘）</li><li>定义ROI（只保留车道区域）</li><li>霍夫直线变换（检测车道线）</li><li>线段拟合与绘制（平滑显示结果）</li></ol><h3 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义参数</span></span><br><span class="line">blur_ksize = <span class="number">5</span></span><br><span class="line">canny_low = <span class="number">50</span></span><br><span class="line">canny_high = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_img</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="comment"># 灰度化</span></span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    blur = cv2.GaussianBlur(gray, (blur_ksize,blur_ksize), <span class="number">0</span>)</span><br><span class="line">    edges = cv2.Canny(blur, canny_low, canny_high)</span><br><span class="line">    <span class="keyword">return</span> edges</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041350.png" alt="202510041350" style="zoom: 80%;" /><h3 id="ROI截取"><a href="#ROI截取" class="headerlink" title="ROI截取"></a>ROI截取</h3><p>创建一个梯形的 mask 掩膜，然后与边缘检测结果图混合运算</p><p>掩膜中白色的部分保留，黑色的部分舍弃</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">roi_mask</span>(<span class="params">img, vertices</span>):</span><br><span class="line">    <span class="comment"># 创建掩膜</span></span><br><span class="line">    mask = np.zeros_like(img)</span><br><span class="line">    cv2.fillPoly(mask, vertices, <span class="number">255</span>)</span><br><span class="line">    masked_image = cv2.bitwise_and(img, mask)</span><br><span class="line">    <span class="keyword">return</span> masked_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义ROI</span></span><br><span class="line">h, w = edges.shape[:<span class="number">2</span>]</span><br><span class="line">roi_vertices = np.array([[(<span class="number">0</span>,h),(<span class="number">460</span>, <span class="number">325</span>), (<span class="number">520</span>, <span class="number">325</span>),(w,h)]])</span><br><span class="line">roi = roi_mask(edges, roi_vertices)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510041408.png" alt="202510041408" style="zoom:80%;" /><h3 id="霍夫直线提取"><a href="#霍夫直线提取" class="headerlink" title="霍夫直线提取"></a>霍夫直线提取</h3><p>使用统计概率霍夫直线变换，因为后续还需要处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_lines</span>(<span class="params">img, lines, color=[<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>], thickness=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> lines[:,<span class="number">0</span>]:</span><br><span class="line">        cv2.line(img, (x1, y1), (x2, y2), color, thickness)</span><br><span class="line"><span class="comment"># 霍夫变换参数</span></span><br><span class="line">rho = <span class="number">1</span></span><br><span class="line">theta = np.pi / <span class="number">180</span></span><br><span class="line">threshold = <span class="number">15</span></span><br><span class="line">min_line_len = <span class="number">40</span></span><br><span class="line">max_line_gap = <span class="number">20</span></span><br><span class="line">lines = cv2.HoughLinesP(roi, rho, theta, threshold, minLineLength=min_line_len, maxLineGap=max_line_gap)</span><br><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line">draw_lines(drawing, lines)</span><br></pre></td></tr></table></figure><h3 id="车道计算"><a href="#车道计算" class="headerlink" title="车道计算"></a>车道计算</h3><p>前面通过霍夫变换得到了多条直线的起点和终点</p><p>目的是通过某种算法只得到左右两条车道线</p><ol><li><p>根据斜率正负划分某条线是左车道还是右车道<br>$$<br>k &#x3D; \frac{y_2-y_1}{x_2-x_1}<br>$$<br>左车道斜率小于0，右车道斜率大于0</p></li><li><p>迭代计算各直线斜率与斜率均值的差，排除掉差值过大的异常数据</p></li><li><p>最小二乘法拟合左右车道线</p><p>Python 中可以直接使用<code>np.polyfit()</code>进行最小二乘法拟合</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clean_lines</span>(<span class="params">lines, threshold</span>):</span><br><span class="line">    <span class="comment"># 迭代计算斜率均值，排除掉与差值差异较大的数据</span></span><br><span class="line">    slopes = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="comment"># 规范为一维 4 元素数组</span></span><br><span class="line">        arr = np.array(line).reshape(<span class="number">4</span>)</span><br><span class="line">        x1, y1, x2, y2 = arr</span><br><span class="line">        <span class="keyword">if</span> x2 == x1:</span><br><span class="line">            <span class="comment"># 垂直线略过（避免除零）</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        slope = (y2 - y1) / (x2 - x1)</span><br><span class="line">        slopes.append(slope)</span><br><span class="line">    slopes = np.array(slopes)</span><br><span class="line">    mean_slope = np.mean(slopes)</span><br><span class="line">    mask = np.<span class="built_in">abs</span>(slopes - mean_slope) &lt; threshold</span><br><span class="line">    <span class="comment"># 返回剔除异常值的lines</span></span><br><span class="line">    <span class="keyword">return</span> [line <span class="keyword">for</span> line, sign <span class="keyword">in</span> <span class="built_in">zip</span>(lines, mask) <span class="keyword">if</span> sign]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">least_squares_fit</span>(<span class="params">point_list, ymin, ymax</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> point_list <span class="keyword">or</span> <span class="built_in">len</span>(point_list) &lt; <span class="number">2</span>:   <span class="comment"># 没点或点数太少</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 最小二乘法拟合</span></span><br><span class="line">    x = [p[<span class="number">0</span>] <span class="keyword">for</span> p <span class="keyword">in</span> point_list]</span><br><span class="line">    y = [p[<span class="number">1</span>] <span class="keyword">for</span> p <span class="keyword">in</span> point_list]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># polyfit 第三个参数为拟合多项式的阶数，所以 1 代表线性</span></span><br><span class="line">    fit = np.polyfit(y, x, <span class="number">1</span>)</span><br><span class="line">    fit_fn = np.poly1d(fit)  <span class="comment"># 获取拟合的结果</span></span><br><span class="line">    xmin = <span class="built_in">int</span>(fit_fn(ymin))</span><br><span class="line">    xmax = <span class="built_in">int</span>(fit_fn(ymax))</span><br><span class="line">    <span class="keyword">return</span> [(xmin, ymin), (xmax, ymax)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_lanes</span>(<span class="params">img, lines, color=[<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>], thickness=<span class="number">8</span></span>):</span><br><span class="line">    h = img.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 划分左右车道</span></span><br><span class="line">    left_lines, right_lines = [], []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x2 == x1:  <span class="comment"># 避免垂直线</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            k = (y2 - y1) / (x2 - x1)</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                left_lines.append(line)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_lines.append(line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left_lines <span class="keyword">or</span> <span class="keyword">not</span> right_lines:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清理异常数据</span></span><br><span class="line">    left_lines = clean_lines(left_lines, <span class="number">0.1</span>)</span><br><span class="line">    right_lines = clean_lines(right_lines, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到左右车道线点的集合，拟合直线</span></span><br><span class="line">    left_points = []</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> left_lines:</span><br><span class="line">        x1, y1, x2, y2 = l.reshape(<span class="number">4</span>) <span class="comment"># 不会出现元组报错</span></span><br><span class="line">        left_points.append((x1, y1))</span><br><span class="line">        left_points.append((x2, y2))</span><br><span class="line"></span><br><span class="line">    right_points = []</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> right_lines:</span><br><span class="line">        x1, y1, x2, y2 = l.reshape(<span class="number">4</span>)</span><br><span class="line">        right_points.append((x1, y1))</span><br><span class="line">        right_points.append((x2, y2))</span><br><span class="line">    <span class="comment"># 这里写325是因为之前限制325</span></span><br><span class="line">    left_results = least_squares_fit(left_points, <span class="number">325</span>, h)</span><br><span class="line">    right_results = least_squares_fit(right_points, <span class="number">325</span>, h)</span><br><span class="line">    <span class="keyword">if</span> left_results <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> right_results <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 没法画，直接跳过</span></span><br><span class="line">    <span class="comment"># 注意这里点的顺序（左上 → 左下 → 右下 → 右上）</span></span><br><span class="line">    vtxs = np.array([[left_results[<span class="number">0</span>], left_results[<span class="number">1</span>], right_results[<span class="number">1</span>], right_results[<span class="number">0</span>]]])</span><br><span class="line">    <span class="comment"># 填充车道区域</span></span><br><span class="line">    cv2.fillPoly(img, vtxs, color)</span><br><span class="line">    <span class="comment"># 或者只画车道线</span></span><br><span class="line">    <span class="comment"># cv2.line(img, left_results[0], left_results[1], color, thickness)</span></span><br><span class="line">    <span class="comment"># cv2.line(img, right_results[0], right_results[1], color, thickness)</span></span><br></pre></td></tr></table></figure><h3 id="视频处理-1"><a href="#视频处理-1" class="headerlink" title="视频处理"></a>视频处理</h3><p>搞定图以后就是视频帧的提取和合成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理视频</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">&quot;Lane_Detection/cv2_yellow_lane.mp4&quot;</span>)</span><br><span class="line"><span class="comment"># 视频参数</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;mp4v&#x27;</span>)</span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">w = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">h = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">out = cv2.VideoWriter(<span class="string">&quot;Lane_Detection/output.mp4&quot;</span>, fourcc, fps, (w, h))</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 处理帧</span></span><br><span class="line">    result = process_img(frame)</span><br><span class="line">    <span class="comment"># 播放</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;Lane Detection&quot;</span>, result)</span><br><span class="line">    out.write(result)</span><br><span class="line">    <span class="comment"># 按 esc 退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>也可以利用Python 的视频编辑包<code>moviepy</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output = <span class="string">&#x27;Lane_Detection/output.mp4&#x27;</span></span><br><span class="line">clip = VideoFileClip(<span class="string">&quot;Lane_Detection/cv2_yellow_lane.mp4&quot;</span>)</span><br><span class="line">out_clip = clip.fl_image(process_img)</span><br><span class="line">out_clip.write_videofile(output, audio=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="全代码"><a href="#全代码" class="headerlink" title="全代码"></a>全代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> moviepy.editor <span class="keyword">import</span> VideoFileClip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数</span></span><br><span class="line">blur_ksize = <span class="number">5</span></span><br><span class="line">canny_low = <span class="number">50</span></span><br><span class="line">canny_high = <span class="number">150</span></span><br><span class="line"><span class="comment"># 霍夫变换参数</span></span><br><span class="line">rho = <span class="number">1</span></span><br><span class="line">theta = np.pi / <span class="number">180</span></span><br><span class="line">threshold = <span class="number">15</span></span><br><span class="line">min_line_len = <span class="number">40</span></span><br><span class="line">max_line_gap = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">roi_mask</span>(<span class="params">img, vertices</span>):</span><br><span class="line">    <span class="comment"># 创建掩膜</span></span><br><span class="line">    mask = np.zeros_like(img)</span><br><span class="line">    cv2.fillPoly(mask, vertices, <span class="number">255</span>)</span><br><span class="line">    masked_image = cv2.bitwise_and(img, mask)</span><br><span class="line">    <span class="keyword">return</span> masked_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_lines</span>(<span class="params">img, lines, color=[<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>], thickness=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> lines[:,<span class="number">0</span>]:</span><br><span class="line">        cv2.line(img, (x1, y1), (x2, y2), color, thickness)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_lines</span>(<span class="params">lines, threshold</span>):</span><br><span class="line">    <span class="comment"># 迭代计算斜率均值，排除掉与差值差异较大的数据</span></span><br><span class="line">    slopes = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="comment"># 规范为一维 4 元素数组</span></span><br><span class="line">        arr = np.array(line).reshape(<span class="number">4</span>)</span><br><span class="line">        x1, y1, x2, y2 = arr</span><br><span class="line">        <span class="keyword">if</span> x2 == x1:</span><br><span class="line">            <span class="comment"># 垂直线略过（避免除零）</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        slope = (y2 - y1) / (x2 - x1)</span><br><span class="line">        slopes.append(slope)</span><br><span class="line">    slopes = np.array(slopes)</span><br><span class="line">    mean_slope = np.mean(slopes)</span><br><span class="line">    mask = np.<span class="built_in">abs</span>(slopes - mean_slope) &lt; threshold</span><br><span class="line">    <span class="comment"># 返回剔除异常值的lines</span></span><br><span class="line">    <span class="keyword">return</span> [line <span class="keyword">for</span> line, sign <span class="keyword">in</span> <span class="built_in">zip</span>(lines, mask) <span class="keyword">if</span> sign]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">least_squares_fit</span>(<span class="params">point_list, ymin, ymax</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> point_list <span class="keyword">or</span> <span class="built_in">len</span>(point_list) &lt; <span class="number">2</span>:   <span class="comment"># 没点或点数太少</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 最小二乘法拟合</span></span><br><span class="line">    x = [p[<span class="number">0</span>] <span class="keyword">for</span> p <span class="keyword">in</span> point_list]</span><br><span class="line">    y = [p[<span class="number">1</span>] <span class="keyword">for</span> p <span class="keyword">in</span> point_list]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># polyfit 第三个参数为拟合多项式的阶数，所以 1 代表线性</span></span><br><span class="line">    fit = np.polyfit(y, x, <span class="number">1</span>)</span><br><span class="line">    fit_fn = np.poly1d(fit)  <span class="comment"># 获取拟合的结果</span></span><br><span class="line">    xmin = <span class="built_in">int</span>(fit_fn(ymin))</span><br><span class="line">    xmax = <span class="built_in">int</span>(fit_fn(ymax))</span><br><span class="line">    <span class="keyword">return</span> [(xmin, ymin), (xmax, ymax)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_lanes</span>(<span class="params">img, lines, color=[<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>], thickness=<span class="number">8</span></span>):</span><br><span class="line">    h = img.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 划分左右车道</span></span><br><span class="line">    left_lines, right_lines = [], []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x2 == x1:  <span class="comment"># 避免垂直线</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            k = (y2 - y1) / (x2 - x1)</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                left_lines.append(line)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_lines.append(line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left_lines <span class="keyword">or</span> <span class="keyword">not</span> right_lines:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清理异常数据</span></span><br><span class="line">    left_lines = clean_lines(left_lines, <span class="number">0.1</span>)</span><br><span class="line">    right_lines = clean_lines(right_lines, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到左右车道线点的集合，拟合直线</span></span><br><span class="line">    left_points = []</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> left_lines:</span><br><span class="line">        x1, y1, x2, y2 = l.reshape(<span class="number">4</span>) <span class="comment"># 不会出现元组报错</span></span><br><span class="line">        left_points.append((x1, y1))</span><br><span class="line">        left_points.append((x2, y2))</span><br><span class="line"></span><br><span class="line">    right_points = []</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> right_lines:</span><br><span class="line">        x1, y1, x2, y2 = l.reshape(<span class="number">4</span>)</span><br><span class="line">        right_points.append((x1, y1))</span><br><span class="line">        right_points.append((x2, y2))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里写325是因为之前限制325</span></span><br><span class="line">    left_results = least_squares_fit(left_points, <span class="number">325</span>, h)</span><br><span class="line">    right_results = least_squares_fit(right_points, <span class="number">325</span>, h)</span><br><span class="line">    <span class="keyword">if</span> left_results <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> right_results <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 没法画，直接跳过</span></span><br><span class="line">    <span class="comment"># 注意这里点的顺序（左上 → 左下 → 右下 → 右上）</span></span><br><span class="line">    vtxs = np.array([[left_results[<span class="number">0</span>], left_results[<span class="number">1</span>], right_results[<span class="number">1</span>], right_results[<span class="number">0</span>]]])</span><br><span class="line">    <span class="comment"># 填充车道区域</span></span><br><span class="line">    cv2.fillPoly(img, vtxs, color)</span><br><span class="line">    <span class="comment"># 或者只画车道线</span></span><br><span class="line">    <span class="comment"># cv2.line(img, left_results[0], left_results[1], color, thickness)</span></span><br><span class="line">    <span class="comment"># cv2.line(img, right_results[0], right_results[1], color, thickness)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_img</span>(<span class="params">img</span>):</span><br><span class="line">    h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 灰度化、滤波和Canny</span></span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    blur = cv2.GaussianBlur(gray, (blur_ksize,blur_ksize), <span class="number">0</span>)</span><br><span class="line">    edges = cv2.Canny(blur, canny_low, canny_high)</span><br><span class="line">    <span class="comment"># 提取ROI</span></span><br><span class="line">    roi_vertices = np.array([[(<span class="number">0</span>,h),(<span class="number">460</span>, <span class="number">325</span>), (<span class="number">520</span>, <span class="number">325</span>),(w,h)]])</span><br><span class="line">    roi = roi_mask(edges, roi_vertices)</span><br><span class="line">    <span class="comment"># 霍夫直线提取</span></span><br><span class="line">    lines = cv2.HoughLinesP(roi, rho, theta, threshold, minLineLength=min_line_len, maxLineGap=max_line_gap)</span><br><span class="line">    <span class="comment"># 车道拟合计算</span></span><br><span class="line">    drawing = np.zeros_like(img)</span><br><span class="line">    draw_lanes(drawing, lines)</span><br><span class="line">    <span class="comment"># 最终将结果合在原图上</span></span><br><span class="line">    result = cv2.addWeighted(img, <span class="number">0.9</span>, drawing, <span class="number">0.4</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 处理图片</span></span><br><span class="line">    <span class="comment"># img = cv2.imread(&quot;Lane_Detection/img1.jpg&quot;,1)</span></span><br><span class="line">    <span class="comment"># res = process_img(img)</span></span><br><span class="line">    <span class="comment"># cv2.imshow(&quot;Lane_Detection&quot;, res)</span></span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理视频</span></span><br><span class="line">    cap = cv2.VideoCapture(<span class="string">&quot;Lane_Detection/cv2_yellow_lane.mp4&quot;</span>)</span><br><span class="line">    <span class="comment"># 视频参数</span></span><br><span class="line">    fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;mp4v&#x27;</span>)</span><br><span class="line">    fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">    w = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">    h = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">    out = cv2.VideoWriter(<span class="string">&quot;Lane_Detection/output.mp4&quot;</span>, fourcc, fps, (w, h))</span><br><span class="line">    <span class="keyword">while</span> cap.isOpened():</span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 处理帧</span></span><br><span class="line">        result = process_img(frame)</span><br><span class="line">        <span class="comment"># 播放</span></span><br><span class="line">        cv2.imshow(<span class="string">&quot;Lane Detection&quot;</span>, result)</span><br><span class="line">        out.write(result)</span><br><span class="line">        <span class="comment"># 按 esc 退出</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    cap.release()</span><br><span class="line">    out.release()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        output = &#x27;Lane_Detection/output.mp4&#x27;</span></span><br><span class="line"><span class="string">        clip = VideoFileClip(&quot;Lane_Detection/cv2_yellow_lane.mp4&quot;)</span></span><br><span class="line"><span class="string">        out_clip = clip.fl_image(process_img)</span></span><br><span class="line"><span class="string">        out_clip.write_videofile(output, audio=False)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python信号处理</title>
      <link href="/posts/35959.html"/>
      <url>/posts/35959.html</url>
      
        <content type="html"><![CDATA[<p>Scipy 是基于 Numpy 的科学计算库，用于数学、科学、工程学等领域</p><p>包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算</p><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>正弦波表达：<br>$$<br>x(t) &#x3D; A_1\sin (2\pi f_1t+\phi_1)+A_2\sin (2\pi f_2t+\phi_2)<br>$$<br>添加高斯白噪声：noise_signal &#x3D; signal + noise, 其中noise$\sim N(0,\sigma^2) $</p><h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> fft</span><br></pre></td></tr></table></figure><p>傅里叶变换将时域信号变换到频域，分析不同频率分量</p><p>计算机处理的是离散采样信号，DFT 是傅里叶变换的离散形式</p><p>FFT是DFT的高效算法，将计算复杂度从$O(N^2)$降至$O(N\log N)$，极大提升计算速度</p><p>输出结果为复数数组，幅度：频率成分的强度(<code>np.abs(x)</code>)  相位：频率成分的偏移(<code>np.angle(X)</code>)</p><blockquote><p>numpy也有<code>fft</code>模块，两者的接口相同，但是只能用CPU，不支持并行或GPU，尽量用scipy库内的</p></blockquote><p>信号参数：采样率$f_s$  信号频率$f$  采样时间$T$  采样点数$N&#x3D;f_s\cdot T$</p><p>频率分辨率：$\Delta f&#x3D; f_s&#x2F;N$，当信号频率不是$\Delta f$的整数倍时，能量会“泄露”到相邻频段，详见频谱泄露</p><p><font color='Violetred'>奈奎斯特采样频率：采样频率至少是信号最高频率的两倍，才能无失真地重建原始信号</font></p><p>对于实数输入信号，频域结果具有<strong>共轭对称性</strong>：</p><ul><li>后一半频率是前一半的镜像(忽略 Nyquist 频率点)</li><li>实际分析时通常取前半部分(单侧频谱)</li></ul><p>可以只计算正频率部分，输出长度减半：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接保留正部分</span></span><br><span class="line">fft.rfft(sig)    </span><br><span class="line">fft.rfftfreq(n,d) </span><br><span class="line"><span class="comment"># 普通写法</span></span><br><span class="line">fft.fft(sig)[:N//<span class="number">2</span>]</span><br><span class="line">fft.fftfreq(n,d)[:N//<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 通过`fftshift`可以换成[-fs/2...fs/2]的对称频率谱</span></span><br></pre></td></tr></table></figure><p>$n$为信号长度，$d$为采样间隔，返回对应傅里叶变换的频率轴</p><p>默认的FFT函数只做了求和，所以计算出来的幅值会比实际大<code>N</code>倍</p><p>如果只取正频率部分，需要乘上<code>2/N</code>做归一化，归一化是为了保证数值物理意义正确</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnitude = <span class="number">2</span>/N * np.<span class="built_in">abs</span>(signal_fft)</span><br></pre></td></tr></table></figure><p><strong>一维傅里叶变换</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">f1, f2, fs, T= <span class="number">50</span>, <span class="number">200</span>, <span class="number">500</span>, <span class="number">1.0</span></span><br><span class="line">N = <span class="built_in">int</span>(fs*T) <span class="comment"># 采样点数</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, N, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal1 = <span class="number">0.7</span> * np.sin(<span class="number">2</span> * np.pi * f1 * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * f2 * t)</span><br><span class="line"><span class="comment"># 计算傅里叶变换</span></span><br><span class="line">signal_fft = fft.rfft(signal1)</span><br><span class="line"><span class="comment"># 获取频率轴</span></span><br><span class="line">freqs = fft.rfftfreq(N, <span class="number">1</span>/fs)</span><br><span class="line"><span class="comment"># 计算归一化幅度谱</span></span><br><span class="line">magnitude = <span class="number">2</span>/N * np.<span class="built_in">abs</span>(signal_fft)</span><br><span class="line">reconstructed_signal = fft.ifft(signal_fft)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t[:<span class="number">100</span>], signal1[:<span class="number">100</span>], <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Time Domain Signal&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Time [s]&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Time [s]&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Amplitude&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(freqs, magnitude, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Magnitude Spectrum&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Frequency [Hz]&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Amplitude&quot;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>二维傅里叶</strong>：</p><p>在图像处理分析中一般不选择归一化，因为主要目的是「看结构而不是看数值」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个二维信号(例如图像)</span></span><br><span class="line">image = np.random.random((<span class="number">256</span>, <span class="number">256</span>))  <span class="comment"># 256x256的随机图像</span></span><br><span class="line"><span class="comment"># 对二维信号进行傅里叶变换</span></span><br><span class="line">fft_image = fft.fft2(image)  <span class="comment"># 不用rfft2，无法同时双轴处理</span></span><br><span class="line"><span class="comment"># 移动频率成分，使得零频率部分位于中心</span></span><br><span class="line">fft_image_shifted = fft.fftshift(fft_image)</span><br><span class="line"><span class="comment"># 计算幅度谱(Magnitude Spectrum)</span></span><br><span class="line">magnitude_spectrum = np.<span class="built_in">abs</span>(fft_image_shifted) <span class="comment"># 未归一化</span></span><br><span class="line"><span class="comment"># 计算幅度谱的对数，便于显示</span></span><br><span class="line">log_magnitude_spectrum = np.log(magnitude_spectrum + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 可视化频谱</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">plt.imshow(log_magnitude_spectrum, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Magnitude Spectrum (Log Scale)&quot;</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>归一化场景分析：</p><table><thead><tr><th>场景</th><th>是否需要归一化</th><th>原因 &#x2F; 目标</th></tr></thead><tbody><tr><td>频谱图展示(图像&#x2F;信号)</td><td>不需要</td><td>只看频率分布，不关心绝对幅度<br />未归一化+log 更直观</td></tr><tr><td>信号幅值恢复</td><td>需要</td><td>FFT默认放大N倍，必须除以N才能得到真实幅度</td></tr><tr><td>功率&#x2F;能量分析</td><td>需要</td><td>保证时域能量与频域能量一致</td></tr><tr><td>滤波器设计&#x2F;频域运算</td><td>需要</td><td>滤波器幅值必须落在理论范围内，否则滤波结果能量失真</td></tr><tr><td>逆变换恢复图像&#x2F;信号</td><td>看情况</td><td>如果正向和逆向保持一致就不必管；如果只做正向归一化，需要注意逆变换对应的系数</td></tr></tbody></table><h3 id="滤波器设计"><a href="#滤波器设计" class="headerlink" title="滤波器设计"></a>滤波器设计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br></pre></td></tr></table></figure><p>以巴特沃斯滤波器的函数举例，各个滤波器之间的参数设置基本一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">butter(N, Wn, btype=<span class="string">&#x27;low&#x27;</span>, analog=<span class="literal">False</span>, output=<span class="string">&#x27;ba&#x27;</span>, fs=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li><code>N</code>：滤波器阶数，阶数越高，滤波越陡峭</li><li><code>Wn</code>：截止频率，是一个长度为2的序列，单个或区间上下限</li><li><code>btype</code>：滤波器类型，包括低通滤波器(low)、高通滤波器(high)、带通滤波器(band)、带阻滤波器(bandstop)，默认为low</li><li><code> analog</code>：默认返回一个数字滤波器，如果为True则返回一个模拟滤波器</li><li><code>output</code>：输出，默认<code>&#39;ba&#39;</code>，可选<code>zpk</code>和<code>sos</code></li><li><code>fs</code>：系统的采样频率，如果不提供会报错</li></ul><p>也可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">butter(N, Wn/fs, btype=<span class="string">&#x27;low&#x27;</span>, analog=<span class="literal">False</span>, output=<span class="string">&#x27;ba&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>IIR滤波器</strong>：</p><p>巴特沃斯滤波器：常见的滤波器，它的特点是保持平滑的频率响应，没有波动，适用于那些要求频率响应平稳的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fs = <span class="number">500</span>  <span class="comment"># 采样频率 500Hz</span></span><br><span class="line">lowcut = <span class="number">100.0</span>  <span class="comment"># 截止频率 100Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用巴特沃斯滤波器设计一个4阶低通滤波器</span></span><br><span class="line">b, a = signal.butter(<span class="number">4</span>, lowcut, btype=<span class="string">&#x27;low&#x27;</span>, fs=fs)</span><br><span class="line"><span class="comment"># 打印滤波器系数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;滤波器系数 b: <span class="subst">&#123;b&#125;</span>&quot;</span>) <span class="comment"># 滤波器的分子系数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;滤波器系数 a: <span class="subst">&#123;a&#125;</span>&quot;</span>) <span class="comment"># 滤波器的分母系数</span></span><br><span class="line"><span class="comment"># 计算频率响应</span></span><br><span class="line">w, h = signal.freqz(b, a, worN=<span class="number">2000</span>, fs=fs)</span><br><span class="line"><span class="comment"># 绘制滤波器频率响应</span></span><br><span class="line">plt.plot(w, <span class="built_in">abs</span>(h), <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;巴特沃斯低通滤波器频率响应&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;频率 [Hz]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;幅度&#x27;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>切比雪夫滤波器：能够提供更陡峭的频率响应，但它会引入波动(波纹)，可以用于需要锐利频率选择的场景</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rp = <span class="number">1</span>  <span class="comment"># 通带最大波纹(dB)</span></span><br><span class="line">lowcut = <span class="number">100.0</span>  <span class="comment"># 截止频率 100Hz</span></span><br><span class="line"><span class="comment"># 使用切比雪夫I型滤波器设计一个4阶低通滤波器</span></span><br><span class="line">b, a = signal.cheby1(<span class="number">4</span>, rp, lowcut, fs=fs)</span><br><span class="line"><span class="comment"># 计算频率响应</span></span><br><span class="line">w, h = signal.freqz(b, a, worN=<span class="number">2000</span>, fs=fs)</span><br><span class="line"><span class="comment"># 绘制滤波器频率响应</span></span><br><span class="line">plt.plot(w, <span class="built_in">abs</span>(h), <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;切比雪夫I型低通滤波器频率响应&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;频率 [Hz]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;幅度&#x27;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>二阶陷波和谐振滤波器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs, f0, Q = <span class="number">500</span>, <span class="number">100</span>, <span class="number">30</span> <span class="comment"># f0为陷波/谐振频率</span></span><br><span class="line">b_notch, a_notch = signal.iirnotch(f0, Q, fs=fs)   <span class="comment"># 直接传f0,需要品质因子</span></span><br><span class="line">b_peak, a_peak = signal.iirpeak(f0, Q, fs=fs)</span><br><span class="line"><span class="comment"># 计算频率响应</span></span><br><span class="line">w1, h1 = signal.freqz(b_notch, a_notch, worN=<span class="number">2000</span>, fs=fs)</span><br><span class="line">w2, h2 = signal.freqz(b_peak, a_peak, worN=<span class="number">2000</span>, fs=fs)</span><br><span class="line"><span class="comment"># 绘制滤波器频率响应</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(w1, <span class="built_in">abs</span>(h1), <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(w2, <span class="built_in">abs</span>(h2), <span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>FIR 滤波器</strong>：</p><p>可以通过选择不同的窗函数来实现低通、高通等滤波效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用窗函数法设计一个低通FIR滤波器</span></span><br><span class="line">numtaps = <span class="number">101</span>  <span class="comment"># 滤波器的长度(系数个数)</span></span><br><span class="line">b = signal.firwin(numtaps, lowcut, pass_zero=<span class="literal">True</span>, fs=fs)</span><br><span class="line"><span class="comment"># 计算频率响应</span></span><br><span class="line">w, h = signal.freqz(b, worN=<span class="number">2000</span>, fs=fs)</span><br><span class="line"><span class="comment"># 绘制滤波器频率响应</span></span><br><span class="line">plt.plot(w, <span class="built_in">abs</span>(h), <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;FIR低通滤波器频率响应&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;频率 [Hz]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;幅度&#x27;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="滤波操作"><a href="#滤波操作" class="headerlink" title="滤波操作"></a>滤波操作</h3><p>常见的两个函数：</p><ul><li><p><code>scipy.signal.lfilter</code>：使用递归公式对输入信号进行滤波</p></li><li><p><code>scipy.signal.filtfilt</code>：对信号进行零相位滤波，即滤波操作前后都进行一次</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filtered = signal.lfilter(b, a, noise_signal)</span><br><span class="line">filtered = signal.filtfilt(b, a, noise_signal)</span><br></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th><code>lfilter</code></th><th><code>filtfilt</code></th></tr></thead><tbody><tr><td>滤波方向</td><td>单向滤波(从前到后)</td><td>双向滤波(从前到后 + 从后到前)</td></tr><tr><td>相位延迟</td><td>引入相位延迟(有延迟)</td><td>无相位延迟(零相位)</td></tr><tr><td>输出信号</td><td>会有信号的末尾和开始部分的失真</td><td>保持原始信号的时域特性，不会有失真</td></tr><tr><td>计算性能</td><td>计算速度较快，适用于实时信号处理</td><td>需要更多计算，适用于离线处理，较慢</td></tr><tr><td>使用场景</td><td>实时滤波，延迟容忍的应用</td><td>高精度滤波，要求保持信号时域特性</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">生成信号(1 kHz + 2 Khz + 50 Hz + 噪声)，进行FFT分析，</span></span><br><span class="line"><span class="string">应用带阻(50 Hz)+ 巴特沃斯低通(1.5kHz)滤波，</span></span><br><span class="line"><span class="string">绘制并保存结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> scipy.signal <span class="keyword">as</span> signal</span><br><span class="line"><span class="keyword">import</span> scipy.fft <span class="keyword">as</span> fft</span><br><span class="line"></span><br><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">OUTPUT_DIR = <span class="string">&quot;res&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">TimeAndFFT_plot</span>(<span class="params">t_seg, sig, fs, title</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(sig)</span><br><span class="line">    seg_len = <span class="built_in">len</span>(t_seg)</span><br><span class="line">    freq = fft.rfftfreq(N, <span class="number">1</span>/fs)</span><br><span class="line">    magnitude = <span class="number">2</span>/N*np.<span class="built_in">abs</span>(fft.rfft(sig))</span><br><span class="line">    fig, (ax1,ax2) = plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    ax1.plot(t_seg, sig[:seg_len], <span class="string">&#x27;r--&#x27;</span>)</span><br><span class="line">    ax1.set_title(title+<span class="string">&quot; Time-domain&quot;</span>)</span><br><span class="line">    ax1.set_xlabel(<span class="string">&quot;Time (s)&quot;</span>)</span><br><span class="line">    ax1.set_ylabel(<span class="string">&quot;Amplitude&quot;</span>)</span><br><span class="line">    ax1.grid()</span><br><span class="line"></span><br><span class="line">    ax2.plot(freq, magnitude, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    ax2.set_title(title+<span class="string">&quot; FFT&quot;</span>)</span><br><span class="line">    ax2.set_xlabel(<span class="string">&quot;Frequency (Hz)&quot;</span>)</span><br><span class="line">    ax2.set_ylabel(<span class="string">&quot;Magnitude&quot;</span>)</span><br><span class="line">    ax2.set_xlim(<span class="number">0</span>,<span class="number">2200</span>)</span><br><span class="line">    ax2.grid()</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    savepath = Path(OUTPUT_DIR)/<span class="string">f&quot;<span class="subst">&#123;title&#125;</span>.png&quot;</span></span><br><span class="line">    plt.savefig(savepath, dpi=<span class="number">300</span>)</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># ==== 参数设置 ====</span></span><br><span class="line">    Path(OUTPUT_DIR).mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    fs = <span class="number">10000</span></span><br><span class="line">    duration = <span class="number">1</span></span><br><span class="line">    N = <span class="built_in">int</span>(fs*duration)</span><br><span class="line">    t = np.arange(N)/fs</span><br><span class="line">    <span class="comment"># ==== 信号组成 ====</span></span><br><span class="line">    f = <span class="number">1000</span></span><br><span class="line">    f_inter = <span class="number">50</span></span><br><span class="line">    amp1 = <span class="number">0.7</span></span><br><span class="line">    amp2 = <span class="number">0.6</span></span><br><span class="line">    amp_inter = <span class="number">0.5</span></span><br><span class="line">    rand_std = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==== 信号产生 ====</span></span><br><span class="line">    signal_clean = amp1*np.sin(<span class="number">2</span>*np.pi*f*t) + amp2*np.sin(<span class="number">2</span>*np.pi*<span class="number">2</span>*f*t)+amp_inter*np.sin(<span class="number">2</span>*np.pi*f_inter*t)</span><br><span class="line">    noise = <span class="number">0.2</span>*rng.normal(<span class="number">0</span>, rand_std, N)</span><br><span class="line">    signal_noise = signal_clean + noise</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于时域可视化的短时段（前0.01秒）</span></span><br><span class="line">    seg_len = <span class="built_in">int</span>(<span class="number">0.01</span>*fs)</span><br><span class="line">    t_seg = t[:seg_len]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==== 绘制时域图和频谱图 ====</span></span><br><span class="line">    TimeAndFFT_plot(t_seg, signal_clean, fs, <span class="string">&quot;original&quot;</span>)</span><br><span class="line">    TimeAndFFT_plot(t_seg, signal_noise, fs, <span class="string">&quot;noisy&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==== 滤波器设计 ====</span></span><br><span class="line">    lowcut = <span class="number">1500</span></span><br><span class="line">    b_lp, a_lp = signal.butter(<span class="number">4</span>, lowcut, btype=<span class="string">&#x27;low&#x27;</span>, fs=fs) <span class="comment"># 低通滤波器</span></span><br><span class="line">    f0, Q = <span class="number">50.0</span>, <span class="number">30</span></span><br><span class="line">    w0 = f0/(fs/<span class="number">2</span>)</span><br><span class="line">    b_notch, a_notch = signal.iirnotch(w0,Q)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==== 滤波操作 ====</span></span><br><span class="line">    sig_lp = signal.filtfilt(b_lp, a_lp, signal_noise)</span><br><span class="line">    sig_notch = signal.filtfilt(b_notch, a_notch, signal_noise)</span><br><span class="line">    sig_lp_notch = signal.filtfilt(b_notch, a_notch, sig_lp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==== 绘制时域图和频谱图 ====</span></span><br><span class="line">    TimeAndFFT_plot(t_seg, sig_lp, fs, <span class="string">&quot;lowpass&quot;</span>)</span><br><span class="line">    TimeAndFFT_plot(t_seg, sig_notch, fs, <span class="string">&quot;notch&quot;</span>)</span><br><span class="line">    TimeAndFFT_plot(t_seg, sig_lp_notch, fs, <span class="string">&quot;lowpass+notch&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>数学公式：<br>$$<br>y[n]&#x3D;(x*h)[n]&#x3D;\sum_{k&#x3D;-\infty}^\infty x[k]\cdot h[n-k]<br>$$<br>信号$x[n]$和滤波器$h[n]$的“滑动加权叠加”</p><p>移动平均滤波器(最简单的滤波器，等价于低通)：<br>$$<br>y[n]&#x3D;\frac{1}{M}\sum_{k&#x3D;0}^{M-1}x[n-k]<br>$$<br>本质上就是卷积核 $h[n] &#x3D; [1&#x2F;M, 1&#x2F;M, …, 1&#x2F;M]$</p><p>虽然numpy库内也有卷积函数，但是大部分情况下还是选用scipy库的卷积函数，对比如下：</p><table><thead><tr><th>特性</th><th><code>np.convolve</code></th><th><code>scipy.signal.convolve</code></th></tr></thead><tbody><tr><td>支持维度</td><td>仅限一维 (1D)</td><td>支持任意维度(1D&#x2F;2D&#x2F;3D)</td></tr><tr><td>计算速度</td><td>小型一维数据较快</td><td>大型或多维数据优化更好</td></tr><tr><td>功能扩展</td><td>基础功能</td><td>支持复数、FFT加速、边界处理等高级选项</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal.convolve(in1, in2, mode=<span class="string">&#x27;same&#x27;</span>, method=<span class="string">&#x27;auto&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>mode</code>(输出尺寸)：</p><ul><li><code>&#39;full&#39;</code>：完整线性卷积[默认]</li><li><code>&#39;same&#39;</code>：输出与<code>in1</code>同形，且在<code>full</code>结果中居中对齐</li><li><code>&#39;valid&#39;</code>：输出仅包含那些不依赖于零填充的元素(要求<code>in1</code>或<code>in2</code>至少一个在每个维度上必须至少与另一个一样大)</li></ul><p><code>method</code>(计算方法)：</p><ul><li><code>&#39;direct&#39;</code>：卷积直接由和来确定，即卷积的定义(适合 kernel 很短或只需少量输出点时)</li><li><code>&#39;fft&#39;</code>：通过 FFT 计算(内部调用<code>fftconvolve</code>)</li><li><code>&#39;auto&#39;</code>：根据对哪种方法更快进行的估计自动选择直接方法或傅里叶方法[默认]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = np.ones(M)/M <span class="comment"># M越大平滑效果越好</span></span><br><span class="line">smoothed = signal.convolve(signal1, h, <span class="string">&#x27;same&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="频谱泄露"><a href="#频谱泄露" class="headerlink" title="频谱泄露"></a>频谱泄露</h3><p>频谱泄漏是指在进行傅里叶变换时，由于信号截断或周期化造成的频谱畸变现象，是离散傅里叶变换DFT中一个非常常见的现象</p><p>简单来说就是原本应该集中在一个频率点上的能量，由于“泄漏”到了其他频率点上，导致频谱变得模糊不清</p><ul><li>理想频谱：单一频率的冲击函数</li><li>泄露后的频谱：主瓣拓宽 + 旁瓣拖尾</li></ul><p><strong>为什么会发生频谱泄漏？</strong></p><p><font color='Violetred'>DFT假设信号是周期性的</font>，且采样窗口是信号的精确周期</p><p>如果信号的频率刚好是采样频率分辨率的整数倍，那么周期延拓时首尾能够平滑拼接，频谱会集中在对应的频率点上</p><p>如果不是整数倍，则首尾无法拼接，周期性假设失效，等效于信号被突然截断，相当于乘了一个矩形窗，而在频域上，乘法相当于卷积</p><p>矩形窗的频谱是一个<code>sinc</code>函数，主瓣窄但旁瓣高，在频域里就会产生旁瓣扩展，能量扩散到多个频率点上，这就是频谱泄漏</p><p>本质：有限截断信号等效于矩形窗乘积 → 频域产生卷积 → 能量扩散</p><p>举个例子：</p><p>$f_s&#x3D;1000Hz,N&#x3D;1000\rightarrow \Delta f&#x3D;f_s&#x2F;N&#x3D;1Hz$</p><p>如果信号频率为50Hz，对齐FFT频点，那么频谱主要集中在50Hz处；</p><p>如果信号频率为50.5Hz，不在整数频点，那么频谱主瓣在50.5Hz处，但能量会扩散到周围很多频率点，看起来拖尾 </p><p><strong>解决方法</strong>：</p><ul><li>增加采样点数N：提高频率分辨率$\Delta f&#x3D; f_s&#x2F;N$，让频率更接近FFT栅格</li><li>加窗函数：用汉宁窗、汉明窗、布莱克曼窗等替代矩形窗，减少旁瓣泄漏，但<font color='Violetred'>会增宽主瓣</font></li><li><font color='Violetred'>零填充</font>：在进行FFT变换之前，在信号末尾添加若干个零，可以提高频谱显示的平滑度(可以提高频谱分辨率，但并不能消除频谱泄漏)</li></ul><p>实际应用要在“泄漏小”和“分辨率高”之间折中</p><p>当采样率不变的情况下，提高频率分辨率的方法就是增加采样时间</p><h4 id="窗函数"><a href="#窗函数" class="headerlink" title="窗函数"></a>窗函数</h4><p>窗函数通过在信号两端平滑过渡到零，减少边界不连续性，从而：</p><ol><li>抑制频谱泄露(降低旁瓣)</li><li>提高频率分辨率(窄化主瓣)</li></ol><p>常用评价指标：</p><ul><li>主瓣宽度：影响能否分辨紧邻的频率</li><li>旁瓣电平：决定泄漏到远处的能量大小(越低越好)</li></ul><table><thead><tr><th>窗函数</th><th>主瓣宽度</th><th>旁瓣峰值(dB)</th><th>常用场景</th></tr></thead><tbody><tr><td>矩形窗</td><td>最窄</td><td>-13</td><td>瞬时分析</td></tr><tr><td>Hann窗(汉宁窗)</td><td>中等</td><td>-31</td><td>通用场景</td></tr><tr><td>Hamming窗(海明窗)</td><td>稍窄</td><td>-41</td><td>音频处理</td></tr><tr><td>Blackman窗(布莱克曼窗)</td><td>宽</td><td>-58</td><td>高精度测量</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> windows</span><br><span class="line"></span><br><span class="line">N = <span class="number">1024</span>  <span class="comment"># 窗长度</span></span><br><span class="line"><span class="comment"># 生成窗函数</span></span><br><span class="line">hanning = windows.hann(N)        <span class="comment"># 汉宁窗</span></span><br><span class="line">hamming = windows.hamming(N)     <span class="comment"># 海明窗</span></span><br><span class="line">blackman = windows.blackman(N)   <span class="comment"># 布莱克曼窗</span></span><br><span class="line">rect = np.ones(N)                <span class="comment"># 矩形窗</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化窗函数</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(hanning, label=<span class="string">&#x27;Hann&#x27;</span>)</span><br><span class="line">plt.plot(hamming, label=<span class="string">&#x27;Hamming&#x27;</span>)</span><br><span class="line">plt.plot(blackman, label=<span class="string">&#x27;Blackman&#x27;</span>)</span><br><span class="line">plt.plot(rect, <span class="string">&#x27;--&#x27;</span>, label=<span class="string">&#x27;Rectangular&#x27;</span>)</span><br><span class="line">plt.legend(); plt.title(<span class="string">&#x27;常用窗函数&#x27;</span>); plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>一个50Hz正弦波，采样率1000，采样215点(周期不再整数倍，出现泄露)</p><p>对比不同窗函数的频谱，并采用零填充使得频谱平滑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> windows</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置中文字体支持</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>, <span class="string">&#x27;Microsoft YaHei&#x27;</span>, <span class="string">&#x27;KaiTi&#x27;</span>, <span class="string">&#x27;SimSun&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">palette = plt.get_cmap(<span class="string">&#x27;Set1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 参数设置 ====</span></span><br><span class="line">fs = <span class="number">1000</span>   <span class="comment"># 采样率 Hz</span></span><br><span class="line">f = <span class="number">50</span>      <span class="comment"># 信号频率 Hz</span></span><br><span class="line">N = <span class="number">215</span>     <span class="comment"># 采样点数(故意不匹配) 分辨率为1/T=4.65Hz</span></span><br><span class="line">fft_size = <span class="number">1024</span> <span class="comment"># 零填充，插值让曲线更平滑，建议 4~8 倍且为2的幂次</span></span><br><span class="line">t = np.arange(N) / fs</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 生成信号 ====</span></span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * f * t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 窗函数字典 ====</span></span><br><span class="line">windows_dict = &#123;</span><br><span class="line">    <span class="string">&quot;矩形窗&quot;</span>: np.ones(N),</span><br><span class="line">    <span class="string">&quot;汉宁窗&quot;</span>: windows.hann(N),</span><br><span class="line">    <span class="string">&quot;海明窗&quot;</span>: windows.hamming(N),</span><br><span class="line">    <span class="string">&quot;布莱克曼窗&quot;</span>: windows.blackman(N)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== FFT 计算函数 ====</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_fft</span>(<span class="params">sig, win, fs</span>):</span><br><span class="line">    sig_win = sig * win</span><br><span class="line">    <span class="comment"># 会自动在信号后面补零到fft_size点，再做 FFT，实现零填充</span></span><br><span class="line">    <span class="comment"># 使得输出曲线更平滑，但分辨率不变</span></span><br><span class="line">    fft_vals = np.fft.rfft(sig_win, fft_size)</span><br><span class="line">    freqs = np.fft.rfftfreq(fft_size, <span class="number">1</span>/fs)</span><br><span class="line">    <span class="comment"># 修正幅度：除以窗口均值，保证幅度不会因加窗衰减</span></span><br><span class="line">    magnitude = np.<span class="built_in">abs</span>(fft_vals) / (N * np.mean(win)) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> freqs, magnitude, sig_win</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 存储结果 ====</span></span><br><span class="line">results = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> name, win <span class="keyword">in</span> windows_dict.items():</span><br><span class="line">    freqs, mag, sig_win = compute_fft(signal, win, fs)</span><br><span class="line">    results[name] = &#123;<span class="string">&quot;freqs&quot;</span>: freqs, <span class="string">&quot;mag&quot;</span>: mag, <span class="string">&quot;sig&quot;</span>: sig_win&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 绘制时域信号 ====</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.title(<span class="string">&quot;不同窗函数的时域信号&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name, res <span class="keyword">in</span> results.items():</span><br><span class="line">    plt.plot(t[N//<span class="number">2</span>-<span class="number">50</span>:N//<span class="number">2</span>+<span class="number">50</span>], res[<span class="string">&quot;sig&quot;</span>][N//<span class="number">2</span>-<span class="number">50</span>:N//<span class="number">2</span>+<span class="number">50</span>], label=name)</span><br><span class="line">plt.xlabel(<span class="string">&quot;时间 (s)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;幅度&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 分图绘制频谱对比(对数 dB) ====</span></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># enumerate(..., 1) 给循环编号</span></span><br><span class="line"><span class="keyword">for</span> i, (name, res) <span class="keyword">in</span> <span class="built_in">enumerate</span>(results.items(), <span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 先归一化，让主瓣的最大值为1，再转到dB(20*log10(...))</span></span><br><span class="line">    mag_db = <span class="number">20</span> * np.log10(res[<span class="string">&quot;mag&quot;</span>] / np.<span class="built_in">max</span>(res[<span class="string">&quot;mag&quot;</span>]) + <span class="number">1e-12</span>)</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i)</span><br><span class="line">    plt.plot(res[<span class="string">&quot;freqs&quot;</span>], mag_db, color=palette(i))</span><br><span class="line">    plt.title(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 频谱 (dB)&quot;</span>)</span><br><span class="line">    plt.xlim(<span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line">    plt.ylim(-<span class="number">120</span>, <span class="number">5</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;频率 (Hz)&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;相对幅度 (dB)&quot;</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==== 绘制频域对比(对数 dB)====</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.title(<span class="string">&quot;不同窗函数的频谱泄漏对比&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name, res <span class="keyword">in</span> results.items():</span><br><span class="line">    mag_db = <span class="number">20</span> * np.log10(res[<span class="string">&quot;mag&quot;</span>] / np.<span class="built_in">max</span>(res[<span class="string">&quot;mag&quot;</span>]) + <span class="number">1e-12</span>)</span><br><span class="line">    plt.plot(res[<span class="string">&quot;freqs&quot;</span>], mag_db, label=name)</span><br><span class="line">plt.axvline(x=f, color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, alpha=<span class="number">0.5</span>, label=<span class="string">f&quot;理论频率 <span class="subst">&#123;f&#125;</span>Hz&quot;</span>)</span><br><span class="line">plt.xlim(<span class="number">20</span>, <span class="number">80</span>)</span><br><span class="line">plt.ylim(-<span class="number">80</span>, <span class="number">5</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;频率 (Hz)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;相对幅度 (dB)&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> wavfile</span><br></pre></td></tr></table></figure><p><code>.wav</code> 文件是 PCM 编码的无压缩音频格式</p><p>主要信息：</p><ul><li>采样率(Hz)：每秒采样次数(CD 音质是 44100 Hz)</li><li>位深：每个采样点的精度(16 位、32 位)</li><li>声道数：单声道 &#x2F; 双声道</li></ul><p>读入音频：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs, data = wavfile.read(<span class="string">&quot;audio.wav&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> data.ndim &gt; <span class="number">1</span>:</span><br><span class="line">    data = data[:,<span class="number">0</span>]  <span class="comment"># 单声道</span></span><br></pre></td></tr></table></figure><p>写出音频：</p><p>写 16-bit PCM(常见、兼容)，要先归一化并转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">int16_data</span>(<span class="params">data</span>):</span><br><span class="line">    data_normalized = data/ np.<span class="built_in">max</span>(np.<span class="built_in">abs</span>(data))</span><br><span class="line">    data_int16 = (data_normalized * <span class="number">32767</span>).astype(np.int16)</span><br><span class="line">    <span class="keyword">return</span> data_int16</span><br><span class="line">pcm16 = int16_data(data)</span><br><span class="line">wavfile.write(<span class="string">&#x27;sine_int16.wav&#x27;</span>, fs, pcm16)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光电探测器基础</title>
      <link href="/posts/22050.html"/>
      <url>/posts/22050.html</url>
      
        <content type="html"><![CDATA[<h2 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h2><p>需要满足两个假设：</p><ul><li>玻尔兹曼分布，每一个半导体区域都是非简并半导体；</li><li>完全电离，忽略温度对PN结的影响</li></ul><p>玻尔兹曼分布的解释：</p><table><thead><tr><th></th><th>玻尔兹曼分布</th><th>费米–狄拉克分布</th></tr></thead><tbody><tr><td>适用粒子</td><td>可区分粒子(经典)</td><td>费米子(电子等)</td></tr><tr><td>是否考虑泡利不相容</td><td>否</td><td>是</td></tr><tr><td>数学形式</td><td>$e^{-(E-E_F)&#x2F;kT}$</td><td>$1&#x2F;(e^{(E-E_F)&#x2F;kT}+1)$</td></tr><tr><td>高温极限</td><td>保持原形</td><td>退化为玻尔兹曼分布</td></tr><tr><td>典型应用</td><td>理想气体</td><td>金属导电电子、半导体电子</td></tr><tr><td>服从分布</td><td>非简并半导体</td><td>简并半导体</td></tr></tbody></table><p>电子和空穴都是费米子，理论上都应该遵守费米–狄拉克分布</p><p>但在半导体中，通常载流子浓度较低，导带(或价带)中几乎没有被填满的情况<br>$$<br>(E-E_F)\gg kT<br>$$<br>所以半导体的中分布绝大部分服从玻尔兹曼分布，并且使用玻尔兹曼分布更直观</p><p>在常温和弱掺杂条件下，通常使用玻尔兹曼近似来简化分析，但在强掺杂条件下(进入简并)需要回到费米狄拉克分布</p><h3 id="PN结的基本结构"><a href="#PN结的基本结构" class="headerlink" title="PN结的基本结构"></a>PN结的基本结构</h3><p><strong>P型半导体</strong>：主要载流子是空穴(通过掺入受主杂质，如硼)</p><p><strong>N型半导体</strong>：主要载流子是电子(通过掺入施主杂质，如磷)</p><p>PN结是由P型半导体和N型半导体紧密结合而形成的半导体结，分隔p区和n区的交界面为冶金结</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-09-14_20-20-59.webp" alt="Snipaste_2025-09-14_20-20-59" style="zoom:80%;" /><h3 id="耗尽层"><a href="#耗尽层" class="headerlink" title="耗尽层"></a>耗尽层</h3><p>在结区附近，由于电子和空穴相互扩散并复合，N区留下正电荷，P区留下负电荷，形成一个几乎没有自由载流子的“耗尽层”</p><p>假设均匀掺杂并且空间电荷区在边缘处快速截断</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-09-14_21-00-31.webp" alt="Snipaste_2025-09-14_21-00-31" style="zoom:67%;" /><p>在空间电荷区的电荷密度则可以表示为：<br>$$<br>\begin{aligned}&amp;\rho (x)&#x3D;-eN_A,\quad -x_p&lt;x&lt;0\<br>&amp;\rho (x)&#x3D;eN_D,\quad 0&lt;x&lt;x_n<br>\end{aligned}<br>$$<br>根据电荷守恒需要满足 $N_Ax_p &#x3D; N_Dx_n$ </p><p>结合泊松方程可以得到空间电荷区宽度：<br>$$<br>W&#x3D;x_{n}+x_{p}&#x3D;\sqrt{\frac{2 \varepsilon_{s}}{e} \frac{N_{A}+N_{D}}{N_{A} N_{D}} V_{b i}}<br>$$</p><p>在此基础上可以推算出结电容<br>$$<br>C_j &#x3D; \frac{\varepsilon_s A}{W}<br>$$</p><h3 id="内建电势"><a href="#内建电势" class="headerlink" title="内建电势"></a>内建电势</h3><p>假设PN结两端没有外加电场，那么整个半导体系统的费米能级应该处处相同，但是p区和n区内导带和价带的位置随着费米能级的变化而变化，所以空间电荷区内的导带和价带会发生弯曲</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-09-14_20-25-25.webp" alt="Snipaste_2025-09-14_20-25-25" style="zoom:80%;" /><p>n区的电子在进入p区的过程中会遇到一个势垒，阻碍电子继续扩散，<font color='Violetred'>扩散与漂移达到平衡后</font>留下的电势差称为内建电势差，记为$V_{bi}$<br>$$<br>V_{bi} &#x3D; |\phi_{Fp}|+|\phi_{Fn}|<br>$$<br>n区电子浓度可以表示为：<br>$$<br>n_0 &#x3D; N_c\exp[\frac{-(E_c-E_F)}{kT}] &#x3D; n_i\exp[\frac{E_F-E_{Fi}}{kT}]<br>$$<br>在完全电离的情况下平衡电子浓度(多数载流子浓度)几乎等于施主浓度 $n_0&#x3D;N_D$</p><p>解得<br>$$<br>E_F-E_{Fi}&#x3D; {kT}\ln \frac{N_D}{n_i}<br>$$<br>同理<br>$$<br>E_{Fi}-E_F&#x3D;{kT}\ln\frac{N_A}{n_i}<br>$$<br>$\Delta E &#x3D; eV$，所以PN的内建电势差大小为<br>$$<br>V_{bi}&#x3D;\frac{kT}{e}\ln(\frac{N_aN_d}{n_i^2})<br>$$</p><h3 id="外加电势"><a href="#外加电势" class="headerlink" title="外加电势"></a>外加电势</h3><p>在已有的内建电势基础上，如果在PN结两端增加一个电压值会导致不同的行为</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-09-14_21-16-21.webp" alt="Snipaste_2025-09-14_21-16-21" style="zoom: 67%;" /><p>如果将正极与n区连接(反偏)，那么外加电场与内建电场的方向相同，这导致扩散运动更加受限，因此PN结内几乎没有电荷的流动，耗尽层的厚度增大</p><p>如果将正极与p区连接(正偏)，那么外加电场与内建电场的方向相反，减弱了内建电场的阻碍作用，使得扩散运动加剧，因此有电荷流动的区域更多了，耗尽层的厚度减小</p><h3 id="电流"><a href="#电流" class="headerlink" title="电流"></a>电流</h3><table><thead><tr><th></th><th>漂移电流</th><th>扩散电流</th></tr></thead><tbody><tr><td>成因(驱动力)</td><td>外电场或内建电场</td><td>浓度梯度</td></tr><tr><td>物理本质</td><td>受力定向移动</td><td>随机运动的统计结果</td></tr><tr><td>方向</td><td>电子p→n</td><td>电子n→p</td></tr><tr><td>典型场景</td><td>反向偏压下的二极管电流</td><td>正向偏压下的二极管电流</td></tr><tr><td>与欧姆定律关系</td><td>遵循欧姆定律</td><td>不遵循欧姆定律</td></tr></tbody></table><p>漂移电流(与外加电场关系密切)：<br>$$<br>J_{drift}&#x3D;en\mu_nE+ep\mu_pE<br>$$<br>其中$\mu_n,\mu_p$为电子&#x2F;空穴的迁移率</p><p>扩散电流(与PN结属性相关)：(电子带负电正，负号抵消，空穴需要带负号)<br>$$<br>J_{diff}&#x3D;eD_n\frac{dn}{dx}-eD_p\frac{dp}{dx}<br>$$<br>其中$D_n,D_p$为电子&#x2F;空穴的扩散系数，$\frac{dn}{dx}&#x2F;\frac{dp}{dx}$代表浓度梯度，$D$常用爱因斯坦关系转换$D&#x2F;\mu &#x3D; kT$</p><p>推广到三维情况有</p><p>$$<br>J&#x3D;e n \mu_n \mathrm{E}+e p \mu_p \mathrm{E}+e D_n \nabla n-e D_p \nabla p<br>$$</p><blockquote><p>想象一个山坡上有两种小球：</p><ul><li>蓝色球代表电子，带负电</li><li>红色球代表空穴，带正电</li></ul><p>漂移：<br> 往右边吹一阵风(电场向右)，<br> 红球(正电)顺风滚下去，蓝球(负电)逆风滚上去<br> 但电流定义按正电走的方向——所以红、蓝都对电流“有贡献向右”</p><p>扩散：<br> 现在没风，只是左边的球多，右边的球少<br> 蓝红都往右扩散(粒子运动相同)，<br> 但红球带正电、蓝球带负电——一个推电流向右，一个推电流向左(负号的产生)</p></blockquote><p><strong>正向偏置下</strong>：外加的正向电压会削弱内建电场，这使得多数载流子的扩散变得更加容易，扩散电流急剧增加，并成为总电流的主要部分；漂移电流基本保持不变(因为它取决于少数载流子的数量)，<font color='Violetred'>PN结的电流主要是扩散电流</font></p><p><strong>反向偏置</strong>：外加的反向电压会增强内建电场，这极大地阻碍了多数载流子的扩散，使得扩散电流变得微不足道，电流主要由少数载流子在增强的电场下的漂移运动构成。<font color='Violetred'>PN结的电流主要是漂移电流</font>，但这个电流非常小，也被称为反向饱和电流$I_0$</p><h2 id="光电二极管"><a href="#光电二极管" class="headerlink" title="光电二极管"></a>光电二极管</h2><h3 id="光电二极管原理"><a href="#光电二极管原理" class="headerlink" title="光电二极管原理"></a>光电二极管原理</h3><p><font color='Violetred'>光电二极管是一种特殊设计的PN结，其核心功能是利用PN结的光电效应将光信号转换为电信号</font></p><p>为了有效地接收入射光线，光电二极管将其PN结的表面积设计得相对较大，电极则相对较小，此外，PN结的深度非常浅，通常小于1微米</p><p>当光电二极管暴露在光线下且光子能量 $h\nu&gt;E_g$ 时，PN结中的价带电子会被激发到导带，产生电子–空穴对</p><p>如果电子–空穴对出现在耗尽层或靠近耗尽层的区域，就会被内建电场(或外加反向偏置电场)迅速分离，电子拉向n区，空穴拉向p区，这些分离的载流子流向外电路，就形成了光电流$I_{ph}$</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202509142209.webp" alt="202509142209" style="zoom: 33%;" /><p>一般情况下，光电流与入射光强成正比：<br>$$<br>I_{ph} &#x3D; e\eta\frac{P_{opt}}{h\nu}<br>$$</p><ul><li><p>$\eta $: 量子效率(有效分离的电子–空穴对与吸收光子数之比)</p></li><li><p>$P_{opt}$: 入射光功率</p></li></ul><p>光电流的方向与<font color='Violetred'>二极管正向电流相反</font>，所以二极管方程修改为：<br>$$<br>I &#x3D; I_0(e^{qV&#x2F;kT}-1)-I_{ph}<br>$$<br>绝大多数情况下光电二极管工作在反向偏置状态下，这是因为反偏电压增大可以使耗尽区变宽，载流子能在耗尽区内被电场迅速抽取，减少复合、提高量子效率，此时光电流更大，响应更灵敏<br>$$<br>I_{out} &#x3D; I_{dark}+I_{ph}<br>$$<br>反偏电压大概在10~50V这个区间</p><p>缺点：反偏电压增大也会导致暗电流增大，噪声增多</p><h3 id="PIN光电二极管"><a href="#PIN光电二极管" class="headerlink" title="PIN光电二极管"></a>PIN光电二极管</h3><p>PIN光电二极管是一种结构较传统PN光电二极管有所改进的光电探测器</p><p>为了克服PN结的局限，PIN二极管在PN结之间增加了一个几乎未掺杂的本征区(I区)，电阻率高、载流子浓度低</p><p>相比普通的PN结，I层的存在大大加宽了耗尽区的宽度，从而显著降低了结电容，减小了RC时间常数</p><p>主要特性：</p><ul><li><strong>响应速度快</strong></li><li><strong>量子效率高&#x2F;响应度高</strong>：I层为入射光子提供了更大的吸收体积</li><li><strong>暗电流低</strong>：I层载流子浓度极低</li></ul><h3 id="光电流的放大"><a href="#光电流的放大" class="headerlink" title="光电流的放大"></a>光电流的放大</h3><p>在弱光场景(如激光测距、光通信)中，入射光功率只有几微瓦，对应光电流仅几微安，甚至达到 pA 级</p><p>若直接串联电阻测电压，需要非常大的电阻值，会导致：</p><ul><li><p>热噪声剧增</p></li><li><p>带宽严重下降</p></li><li><p>响应时间变慢</p></li></ul><p><font color='Violetred'>跨阻放大器TIA是光电探测器最常见的读出电路</font></p><p>TIA电路是一个反相放大器，光电二极管接在运放的<strong>反相输入端</strong></p><p>简单的反向放大器电路示意图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510082033.webp" alt="202510082033" style="zoom:67%;" /><p>基本结构：</p><ul><li>反馈电阻$R_f$</li><li>反馈电容$C_f$</li></ul><p>运放通过反馈电阻$R_f$维持该节点电压近似为0V(虚地)<br>$$<br>V_{out} &#x3D; -I_{pd}\cdot R_F<br>$$<br>输出电压取决于反馈电阻，在设计时需考虑两个因素：最大反向电流$I_{ph}$(max) 以及所需输出电压范围$V_{out}$(max) 和 $V_{out}$(min)</p><p>运放反相端的总电容&#x3D;节电容$C_j$+封装电容$C_{\text{pkg}}$+电缆电容$C_{\text{cable}}$+运放输入电容$C_{\text{amp,in}}$<br>$$<br>C_t&#x3D;C_j+C_{\mathrm{pkg}}+C_{\text {cable }}+C_{\text {amp,in }}<br>$$<br>反馈电阻与总电容构成一阶低通滤波器，其截止频率（反馈极点）为<br>$$<br>f_F&#x3D;\frac{1}{2\pi R_FC_t}<br>$$<br>反馈电容$C_f$用来补偿由于输入总电容$C_t$引起的相位滞后，防止运放高频不稳定</p><p>一般$C_f &#x3D; C_t&#x2F;k$，$k$取3-10，根据运放大小决定</p><ul><li>k 越大 → 带宽更高，但稳定裕度更小</li><li>k 越小 → 更稳定，但带宽下降</li></ul><h3 id="APD雪崩光电二极管"><a href="#APD雪崩光电二极管" class="headerlink" title="APD雪崩光电二极管"></a>APD雪崩光电二极管</h3><p>PIN光电二极管已经解决了传统PN光电二极管的问题(耗尽层窄、响应慢)，具备高速和高量子效率，但PIN没有内部增益，产生的光电流直接取决于光功率。在弱光检测(比如远距离光纤通信)中，信号电流可能非常微弱，需要额外的电子放大器，噪声就会成为限制</p><p>APD在PIN的基础上，通过一个巧妙的内部放大机制，能够在探测到微弱光信号时产生远大于PIN二极管的输出电流</p><p>典型的结构是 <strong>P⁺-π-P-N⁺</strong> 结构(有时也写作 <strong>P⁺-I-P-N⁺</strong>)，常用于长波长(如光通信中1.3μm和1.55μm)的 InGaAs APD</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/43074_2022_52_Fig1_HTML.webp" alt="43074_2022_52_Fig1_HTML" style="zoom: 33%;" /><ul><li>P+层：高掺杂的P型层，光从这一面入射</li><li>π层：低掺杂或本征的P型层，<font color='DarkViolet'>光子吸收区</font>，电场较低，防止提前击穿，但又足够强让载流子快速漂移</li><li>P层：中等掺杂的P型层，<font color='DarkViolet'>倍增区</font>，在高的反向偏压下，会形成一个非常强大的电场，当载流子进入此区时会被加速到足够高的能量，引发<font color='Violetred'>碰撞电离</font></li><li>N+层：高掺杂的N型衬底层，提供良好的欧姆接触和机械支撑</li></ul><p>雪崩效应的核心是碰撞电离：</p><ol><li>当一个能量足够的光子入射到APD并被<strong>π吸收区</strong>吸收时，会产生一个电子-空穴对；</li><li>在吸收区的中等电场作用下，电子和空穴被迅速分离开，电子向N⁺区移动，而空穴向P⁺区移动；</li><li>电子向N⁺区漂移的过程中，会进入电场强度极高的P倍增区(在某些设计中，也可能是空穴进入倍增区)，电子被极大地加速，获得了非常高的动能</li><li>高速电子与晶格原子碰撞后将价带电子撞击出来，产生新的电子-空穴对。新产生的立刻被强电场加速，继续撞击产生二次电离，发生连锁反应，因此称为<strong>雪崩倍增效应</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">光子 → 产生电子-空穴对 → 高场加速 → 撞击电离 → 级联放大</span><br></pre></td></tr></table></figure><p>结果是光生电流被指数级放大，这个倍增过程可以用一个倍增因子$M$来表征，$M&#x3D;I_M&#x2F;I_0$</p><p>理论上：<br>$$<br>M(V)&#x3D;\frac{1}{1-(V&#x2F;V_{br})^n}<br>$$<br>$V_{br}$为击穿电压(大概在100-200V区间)，$n$为经验系数(2~6，取决于材料与结构)，当$V\rightarrow V_{br}$时$M$会上升到无穷大，完全击穿</p><p>增益带来的同时还有噪声(乘法噪声)：<br>$$<br>F(M)&#x3D;k\cdot M+(1-k)(2-\frac{1}{M})<br>$$<br>$k$为电子与空穴的电离系数比(硅大概0.1，InGaAs大概0.2-0.5)</p><p>总噪声电流：<br>$$<br>I_{noise}&#x3D;\sqrt{2q(I_{dark}+I_{ph})M^{2}F(M)\Delta f+4kT\Delta f&#x2F;R_{L}}<br>$$<br>扫描不同偏压下的表现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">M</span>(<span class="params">V</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> - (V / V_br) ** n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">M, k</span>):</span><br><span class="line">    <span class="keyword">return</span> k * M + (<span class="number">1</span> - k) * (<span class="number">2</span> - <span class="number">1</span> / M)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">total_noise</span>(<span class="params">I_dark, I_ph, M, F, Delta_f, RL</span>):</span><br><span class="line">    term1 = <span class="number">2</span> * q * (I_dark+I_ph) * (M ** <span class="number">2</span>) * F * Delta_f</span><br><span class="line">    term2 = <span class="number">4</span> * k_B * T * Delta_f / RL</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(term1 + term2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常数</span></span><br><span class="line">q = <span class="number">1.6e-19</span>        <span class="comment"># 电荷 (C)</span></span><br><span class="line">k_B = <span class="number">1.38e-23</span>     <span class="comment"># Boltzmann 常数 (J/K)</span></span><br><span class="line">T = <span class="number">300</span>            <span class="comment"># 温度 (K)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 探测器参数</span></span><br><span class="line">R_lambda = <span class="number">0.6</span>     <span class="comment"># A/W (PIN 响应度)</span></span><br><span class="line">V_br = <span class="number">150</span>         <span class="comment"># 击穿电压 (V)</span></span><br><span class="line">n = <span class="number">3</span>              <span class="comment"># 指数因子</span></span><br><span class="line">k = <span class="number">0.3</span>            <span class="comment"># 电离系数比</span></span><br><span class="line">I_dark = <span class="number">1e-9</span>      <span class="comment"># 暗电流 (A)</span></span><br><span class="line">RL = <span class="number">1e3</span>           <span class="comment"># 负载电阻</span></span><br><span class="line">Delta_f = <span class="number">10e6</span>     <span class="comment"># 带宽 (Hz)</span></span><br><span class="line">P_opt = <span class="number">10e-6</span>      <span class="comment"># 光功率 (W)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描电压</span></span><br><span class="line">V = np.linspace(<span class="number">100</span>, <span class="number">149</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment"># 各项计算</span></span><br><span class="line">M_values = M(V)</span><br><span class="line">F_values = F(M_values, k)</span><br><span class="line">I_ph = R_lambda * P_opt</span><br><span class="line"></span><br><span class="line">I_noise = total_noise(I_dark, I_ph, M_values, F_values, Delta_f, RL)</span><br><span class="line">I_signal = I_ph*M_values</span><br><span class="line">SNR = I_signal/I_noise</span><br><span class="line"><span class="comment"># 标注极值点</span></span><br><span class="line">max_index = np.argmax(SNR)  <span class="comment"># 找到SNR最大值的索引</span></span><br><span class="line">max_V = V[max_index]        <span class="comment"># 对应的电压</span></span><br><span class="line">max_SNR_dB = <span class="number">20</span> * np.log10(SNR[max_index])  <span class="comment"># 电流比，对数用20</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(V, M_values)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Multiplication Gain M&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot(V, F_values)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Excess Noise Factor&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">plt.plot(V, <span class="number">20</span>*np.log10(SNR))</span><br><span class="line">plt.scatter(max_V, max_SNR_dB, color=<span class="string">&#x27;red&#x27;</span>, zorder=<span class="number">5</span>)  <span class="comment"># 标记极值点</span></span><br><span class="line">plt.annotate(<span class="string">f&#x27;Max: <span class="subst">&#123;max_SNR_dB:<span class="number">.2</span>f&#125;</span> dB\nat <span class="subst">&#123;max_V:<span class="number">.1</span>f&#125;</span> V&#x27;</span>,</span><br><span class="line">             xy=(max_V, max_SNR_dB),</span><br><span class="line">             xytext=(max_V, max_SNR_dB-<span class="number">2</span>),</span><br><span class="line">             fontsize=<span class="number">10</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Bias Voltage (V)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;SNR (dB)&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510071326~1.webp" alt="202510071326~1" style="zoom: 50%;" /><p>可以看到$M$随$V$增加上升，在接近击穿电压时指数式增长，$F$的趋势和$M$差不多，SNR先上升(信号增强主导)后下降(噪声主导)</p><p>$k$减小则$F(M)$的上升趋势变慢，使得SNR的极值向右移动，$M$不受$k$影响，以下为$k&#x3D;0.1$</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510071348.webp" alt="202510071348" style="zoom:50%;" /><p>同理，$n$增大$M$上升趋势变慢，导致$F(M)$上升趋势也降低，SNR的极值向右移动</p><p>通常把$M$设在5–20，超过这个区间，$F(M)$与暗电流增长常常抵消进一步放大带来的收益</p><h3 id="对比PIN和APD"><a href="#对比PIN和APD" class="headerlink" title="对比PIN和APD"></a>对比PIN和APD</h3><table><thead><tr><th>特性</th><th>PIN 光电二极管</th><th>APD 雪崩光电二极管</th></tr></thead><tbody><tr><td>内部增益</td><td>无</td><td>有(10~1000倍)</td></tr><tr><td>工作偏压</td><td>低(&lt;5V)</td><td>高(几十~几百伏)</td></tr><tr><td>灵敏度</td><td>中等</td><td>高</td></tr><tr><td>响应速度</td><td>高速</td><td>稍低于PIN(雪崩倍增需时间)</td></tr><tr><td>噪声</td><td>低</td><td>高(乘法噪声)</td></tr><tr><td>应用</td><td>一般光检测、光通信、高速通信</td><td>长距离光纤通信，高灵敏度探测，激光雷达</td></tr></tbody></table><p>对于PIN<br>$$<br>SNR_{PIN} &#x3D; \frac{R\cdot P}{\sqrt{2q(R\cdot P+I_d)\Delta f+\frac{4k_BT\Delta f}{R_L}}}<br>$$<br>但对于APD，噪声与信号电流都放大了<br>$$<br>SNR_{APD}&#x3D;\frac{M\cdot R\cdot P}{\sqrt{2q(R\cdot P+I_d)M^2F(M)\Delta f+\frac{4k_BT\Delta f}{R_L}}}<br>$$<br>在低光条件下，$P$非常小，导致光电流也非常微弱</p><table><thead><tr><th>条件</th><th>主导噪声</th><th>谁更优？</th><th>原因</th></tr></thead><tbody><tr><td>低光功率</td><td>热噪声</td><td>APD</td><td>内部增益$M$将信号抬升至热噪声基底之上</td></tr><tr><td>高光功率</td><td>散粒噪声</td><td>PIN</td><td>不再需要增益，APD的过剩噪声$F(M)$劣化了SNR</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 物理常数 ---</span></span><br><span class="line">q = <span class="number">1.6e-19</span>        <span class="comment"># 元电荷 (C)</span></span><br><span class="line">k_B = <span class="number">1.38e-23</span>     <span class="comment"># 玻尔兹曼常数 (J/K)</span></span><br><span class="line">h = <span class="number">6.626e-34</span>      <span class="comment"># 普朗克常数 (J·s)</span></span><br><span class="line">c = <span class="number">3e8</span>            <span class="comment"># 光速 (m/s)</span></span><br><span class="line">T = <span class="number">300</span>            <span class="comment"># 温度 (K)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 系统参数 ---</span></span><br><span class="line">BW = <span class="number">1e6</span>           <span class="comment"># 带宽 (Hz)</span></span><br><span class="line">R_L = <span class="number">50</span>           <span class="comment"># 负载电阻 (Ω)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 探测器参数 ---</span></span><br><span class="line">wavelength = <span class="number">850e-9</span>   <span class="comment"># 入射波长 (m)</span></span><br><span class="line">eta = <span class="number">0.8</span>             <span class="comment"># 量子效率</span></span><br><span class="line">Id_pin = <span class="number">5e-12</span>        <span class="comment"># PIN 暗电流 (A)</span></span><br><span class="line">M = <span class="number">15</span>                <span class="comment"># APD 倍增因子</span></span><br><span class="line">Id_apd = <span class="number">1e-9</span>         <span class="comment"># APD 暗电流 (A)</span></span><br><span class="line">k = <span class="number">0.1</span>               <span class="comment"># APD电离系数比</span></span><br><span class="line">F = k*M+(<span class="number">1</span>-k)*(<span class="number">2</span>-<span class="number">1</span>/M) <span class="comment"># APD 噪声因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 响应度计算 ---</span></span><br><span class="line">R = (eta * q * wavelength) / (h * c)   <span class="comment"># 响应度 (A/W)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 输入光功率范围 ---</span></span><br><span class="line">P_in = np.logspace(-<span class="number">6</span>, -<span class="number">2</span>, <span class="number">200</span>)   <span class="comment"># 1uW → 10 mW</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 热噪声 ---</span></span><br><span class="line">I_noise_thermal = (<span class="number">4</span> * k_B * T * BW) / R_L</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- PIN SNR ---</span></span><br><span class="line">I_sig_pin = R * P_in</span><br><span class="line">I_noise_pin = np.sqrt(<span class="number">2</span> * q * (R * P_in + Id_pin) * BW + I_noise_thermal)</span><br><span class="line">snr_pin = I_sig_pin / I_noise_pin</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- APD SNR ---</span></span><br><span class="line">I_sig_apd = M * R * P_in</span><br><span class="line">noise_var_apd =<span class="number">2</span> * q * (R * P_in + Id_apd) * (M**<span class="number">2</span>) * F * BW + I_noise_thermal</span><br><span class="line">I_noise_apd = np.sqrt(noise_var_apd)</span><br><span class="line">snr_apd = I_sig_apd / I_noise_apd</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 绘图 ---</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;seaborn-v0_8-whitegrid&#x27;</span>)</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># X 轴单位：µW</span></span><br><span class="line">ax.plot(P_in * <span class="number">1e6</span>, <span class="number">20</span> * np.log10(snr_pin),</span><br><span class="line">        label=<span class="string">&#x27;PIN&#x27;</span>, color=<span class="string">&#x27;dodgerblue&#x27;</span>, linewidth=<span class="number">2.5</span>)</span><br><span class="line">ax.plot(P_in * <span class="number">1e6</span>, <span class="number">20</span> * np.log10(snr_apd),</span><br><span class="line">        label=<span class="string">f&#x27;APD(M=<span class="subst">&#123;M&#125;</span>, F=<span class="subst">&#123;F:<span class="number">.1</span>f&#125;</span>)&#x27;</span>,</span><br><span class="line">        color=<span class="string">&#x27;crimson&#x27;</span>, linewidth=<span class="number">2.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;PIN vs. APD SNR Comparison&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Input Optical Power (µW)&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;SNR [dB]&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">ax.legend(fontsize=<span class="number">11</span>)</span><br><span class="line">ax.grid(<span class="literal">True</span>, which=<span class="string">&quot;both&quot;</span>, ls=<span class="string">&quot;--&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 寻找交叉点并标记 ---</span></span><br><span class="line">idx = np.argwhere(np.diff(np.sign(snr_pin - snr_apd))).flatten()</span><br><span class="line"><span class="keyword">if</span> idx.size &gt; <span class="number">0</span>:</span><br><span class="line">    crossover_power_uW = P_in[idx[<span class="number">0</span>]] * <span class="number">1e6</span></span><br><span class="line">    crossover_snr_db = <span class="number">20</span> * np.log10(snr_pin[idx[<span class="number">0</span>]])</span><br><span class="line">    ax.plot(crossover_power_uW, crossover_snr_db, <span class="string">&#x27;o&#x27;</span>,</span><br><span class="line">            color=<span class="string">&#x27;darkviolet&#x27;</span>, markersize=<span class="number">8</span>)</span><br><span class="line">    ax.annotate(<span class="string">f&#x27;Crossover Point\n~<span class="subst">&#123;crossover_power_uW:<span class="number">.2</span>f&#125;</span> µW&#x27;</span>,</span><br><span class="line">                xy=(crossover_power_uW, crossover_snr_db),</span><br><span class="line">                xytext=(crossover_power_uW, crossover_snr_db - <span class="number">15</span>),</span><br><span class="line">                arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, shrink=<span class="number">0.05</span>,</span><br><span class="line">                                width=<span class="number">1</span>, headwidth=<span class="number">8</span>),</span><br><span class="line">                ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;top&#x27;</span>, fontsize=<span class="number">11</span>,</span><br><span class="line">                bbox=<span class="built_in">dict</span>(boxstyle=<span class="string">&#x27;round,pad=0.3&#x27;</span>,</span><br><span class="line">                          fc=<span class="string">&#x27;yellow&#x27;</span>, alpha=<span class="number">0.6</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510131040.webp" alt="202510131040" style="zoom:50%;" /><p>符合预期</p><h2 id="CCD与CMOS"><a href="#CCD与CMOS" class="headerlink" title="CCD与CMOS"></a>CCD与CMOS</h2><h3 id="CCD"><a href="#CCD" class="headerlink" title="CCD"></a>CCD</h3><p>CCD全称是Charge Coupled Device(电荷耦合器件)，是一种将光信号转换为电信号的半导体成像器件</p><p>器件结构主要有：</p><ul><li>像素：每像素有一个感光区和一个潜在电势阱(由栅极电压形成)</li><li>栅极：通常每像素用2或3个栅极做时钟控制，通过交替电压把电荷转移</li><li>垂直移位通道：把整列像素的电荷逐行推到最底下一行的水平传输寄存器</li><li>横向寄存器：把底行的电荷逐像素推到输出结构</li><li>输出放大器：把单个像素电荷转换成电压，再经模数转换器(ADC)变为数字值</li></ul><p>工作可以分为四个主要过程：</p><ol><li><p>光吸收与电子生成：光照射到CCD表面后，光敏区内的硅吸收光子，产生电子–空穴对，电子收集到像素的势阱</p></li><li><p>电荷积累(积分)：在曝光时间内，像素积累电荷，直到读取或达到饱和；曝光结束后，每个像素中储存的电荷量代表了该像素的亮度</p></li><li><p><font color='Violetred'>电荷转移(耦合)</font>：施加时钟脉冲到栅极，按顺序把每列电荷推到横向寄存器，再逐像素推向输出放大器</p><p>逐像素移送保证了<font color='Orange'>极高的一致性和低噪声，但代价是读出速度受限</font></p></li><li><p>信号读出与放大：每个像素在输出端把电荷转换为电压，经过放大器与 ADC 得到数字值，最终形成图像数据</p></li></ol><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510051737.webp" alt="202510051737" style="zoom: 20%;" /><p>根据<strong>电荷传输方式</strong>的不同，CCD可分为几种：</p><ul><li><p>全帧转移(Full-Frame CCD)：整个阵列都是光敏区，需要机械快门控制曝光</p><p>转移期间如果没有机械快门来阻挡入射光，会继续产生电子，导致拖影，损坏图像</p><p>优点：感光效率高，噪声最低，结构简单；</p><p>缺点：读出速度较慢，不能用于视频或快速拍摄</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/6389311791916204761318908.webp" alt="6389311791916204761318908" style="zoom: 67%;" /></li><li><p>帧转移(Frame-Transfer CCD)：传感器分为两个相等的部分：有源成像阵列和遮光存储阵列，曝光后整帧电荷被快速转移到存储区</p><p>在读取存储区域时，光敏区可以立即开始集成下一帧，从而实现比全帧CCD更高的帧速率</p><p>优点：无需机械快门，避免拖影，曝光和读出实现并行；</p><p>缺点：存储区占据芯片面积，感光面积减少，成本与功耗高</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/6389311795906633476230955.webp" alt="6389311795906633476230955" style="zoom:67%;" /></li><li><p>行转移(Interline CCD)：每列像素旁有独立存储区，曝光结束后，电子迅速转移到相邻的存储区。存储区被遮光，因此可在下一次曝光时同时读出上一帧</p><p>这种方式可以实现<font color='Violetred'>电子快门</font>，无需机械部件</p><p>优点：快速曝光控制，无拖影，读出速度快，支持视频帧率；</p><p>缺点：光敏区被存储区挤占，填充因子降低(感光面积减少)，需要微透镜引导光线集中到感光区</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/6389311799526847239503801.webp" alt="6389311799526847239503801" style="zoom:67%;" /></li></ul><p>微透镜的作用：当光线射入时，微透镜会把原本可能落在“非感光区”的光线重新聚焦到有效感光部分，有效光捕获率可以从 30–40% 提升到接近 90%</p><p>制作方式包括光刻+热重流，让光刻胶在加热下自然形成半球形，现代技术中也会用离子束刻蚀或纳米压印方法形成更精确的形状；<font color='Violetred'>透镜材质需具备高透光率、低吸收率，并能耐高温工艺</font></p><p>可以分为<strong>线阵CCD</strong>和<strong>面阵CCD</strong></p><ul><li><p>线状CCD一般只有一排或几排像素，用于颜色分离，不能一次获取整个画面，而是通过移动被拍对象(或移动CCD本身)逐行扫描图像，分辨率高但需要机械扫描系统</p></li><li><p>面状CCD拥有二维像素阵列，可以一次性采集整幅图像，无需移动。快门打开时，整个二维像素阵列同时曝光，然后电荷被逐行读出，一次曝光即可获取完整图像，但读出速度相对较慢(现代CMOS已改善)</p></li></ul><p>在光谱CCD中，想要的是光的能量分布，也就是不同波长的强度，就意味着它需要一个维度记录波长</p><p>在典型的光谱仪中，光线从<font color='Violetred'>狭缝(slit)</font>进入，经过光栅或棱镜被色散开，按照波长展开成一条光谱</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/2c5def29-8af9-466d-84c0-95ccea2159bd.webp" alt="2c5def29-8af9-466d-84c0-95ccea2159bd" style="zoom: 33%;" /><p>CCD上看到的不是整幅图像，而是一条光谱带，横轴是波长，纵轴(对应狭缝高度)几乎是恒定的，只包含那个点的少量空间信息</p><h3 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h3><p>与CCD一样，目标都是把光子变成电子信号</p><p>工作原理：</p><ol><li><p>光电转换：光线经顶部微透镜和滤色片聚焦到光电二极管(与CCD类似)，每个像素的光敏区吸收光子</p></li><li><p>电荷积累：电子在电荷阱中累积一段曝光时间</p></li><li><p><font color='Violetred'>信号读出</font>：<font color='DarkViolet'>与CCD最大的不同</font>，每个像素不仅有光敏区，还有读出电路，先读出再转移</p><p>像素电路通常由3～5个晶体管组成，称为3T&#x2F;4T像素结构</p><p>电荷被转化为电压信号，由像素内部的放大晶体管放大</p><p>行列扫描电路按顺序选则每行像素，逐列读出，<font color='Violetred'>每个像素信号都在片上完成放大与数字化</font></p></li><li><p>信号处理：芯片上可以直接集成图像信号处理(ISP)模块，执行曝光控制、去噪、白平衡、Gamma校正等操作</p></li></ol><p>常见像素电路的结构有两种：</p><ul><li><p><strong>3T像素</strong>：复位晶体管、放大晶体管、选择晶体管</p><p>结构简单，但噪声较大，灵敏度略低</p></li><li><p><strong>4T像素</strong>：在3T基础上增加一个转移门，可将电荷从光电二极管转移到独立的浮动扩散区，这让其能实现电子快门，并且支持低噪声读取(CDS)</p><p>现代高端 CMOS 图像传感器几乎都采用4T架构</p></li></ul><p><strong>正照式CMOS(FSI)</strong></p><p>早期结构，如刚刚所述，光线要穿过：微透镜；彩色滤光片；经过金属布线层(信号与供电线路)；抵达光电二极管</p><p>问题在于<font color='Violetred'>金属布线遮光严重</font></p><hr><p><strong>背照式CMOS(BSI)</strong></p><ol><li>先在硅片正面完成所有电路制造(包括晶体管、金属布线等)；</li><li>将晶圆与支撑基片粘合(防止在加工时破裂)；</li><li>从背面化学机械抛光(CMP)或刻蚀，薄化硅基底，厚度降至几微米；</li><li>在背面重新沉积抗反射层、微透镜和彩色滤光片</li></ol><p>光线从背面直接照入硅基底，先抵达光电二极管，再往下是电路层</p><p>光线不再被金属层遮挡，使得光子利用率提升50%以上</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510052103.webp" alt="202510052103" style="zoom: 50%;" /><hr><p><strong>堆栈式CMOS(Stacked)</strong></p><p>堆叠式传感器将图像传感器和信号处理电路分离成两层晶圆</p><ul><li><p>上层：像素阵列——负责感光；</p></li><li><p>下层：逻辑电路——负责信号放大、模数转换、缓存等；</p></li></ul><p>两层通过TSV(Through-Silicon Via, 硅通孔)实现垂直连接</p><p>使用堆栈式技术，人们研究出了一种新的拜耳排列RGBW</p><p>其中，RGB对应常见的红绿蓝，W对应白，对亮度感光，这样传感器的低光感光能力就大大提升</p><hr><p>制造 BSI 和 Stacked 传感器的工艺非常苛刻：</p><ul><li>硅片要薄到几微米，任何应力不均都会导致晶圆翘曲或裂纹；</li><li>TSV 互连要求纳米级精度，否则信号延迟和噪声都会显著上升；</li><li>微透镜、滤光片、背照层的排列需与光路完全匹配，否则边缘像素会产生角度光偏差</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>对比项</th><th>CCD</th><th>CMOS</th></tr></thead><tbody><tr><td>读出方式</td><td>电荷逐级转移(串行)</td><td>各像素独立读出(并行)</td></tr><tr><td>放大位置</td><td>芯片边缘的单一放大器</td><td>每个像素内置放大器</td></tr><tr><td>功耗</td><td>高</td><td>低</td></tr><tr><td>速度</td><td>慢</td><td>快</td></tr><tr><td>噪声</td><td>读出噪声低且均一</td><td>早期略高且有FPN<br />现代sCMOS降到接近CCD水平</td></tr><tr><td>成本</td><td>专用工艺，通常成本较高</td><td>易量产，成本低且易集成</td></tr><tr><td>集成度</td><td>仅感光部分，片上功能少</td><td>可集成ADC、ISP、控制电路与片上处理</td></tr><tr><td>主要噪声来源</td><td>光子噪声、暗电流</td><td>读出噪声、光子噪声<br />暗电流、FPN(固定模式噪声)</td></tr><tr><td>优点</td><td>极高的图像质量和线性响应<br />低读噪与高均一性<br />适合科学级成像<br />长曝光&#x2F;低光表现优秀</td><td>高速、低延时、低成本<br />片上集成功能多<br />可电子快门、高速连拍<br />更适合移动设备</td></tr><tr><td>缺点</td><td>串行读出限制速度<br />工艺与成本要求高<br />电源与驱动时序要求严格</td><td>电路复杂，带来FPN&#x2F;一致性挑战<br />噪声影响大</td></tr></tbody></table><h2 id="图像传感器噪声模型"><a href="#图像传感器噪声模型" class="headerlink" title="图像传感器噪声模型"></a>图像传感器噪声模型</h2><p>图像传感器的总噪声主要由四个部分构成：光子噪声、暗电流噪声、读出噪声和固定模式噪声</p><p>把所有独立噪声看成方差相加<br>$$<br>\sigma_{\text{tot}}^2 &#x3D; \sigma_{\text{shot}}^2 + \sigma_{\text{dark}}^2 + \sigma_{\text{read}}^2 +  \sigma_{\text{FPN}}^2<br>$$</p><h3 id="光子-散粒-噪声"><a href="#光子-散粒-噪声" class="headerlink" title="光子(散粒)噪声"></a>光子(散粒)噪声</h3><p>光是量子化的，即使光强恒定，单位时间内入射光子的数量也有统计波动，遵循泊松分布</p><p>在一个采样时间$\Delta t$内，平均光功率为$P$与平均光子流的关系为$N &#x3D; P\lambda&#x2F;hc$，采样时间内平均到达的光子数$N_p&#x3D;\lambda _N &#x3D; N\cdot \Delta t$</p><p>$n$表示在一次具体采样中，真正到达探测器的光子个数，则泊松分布表示为<br>$$<br>P(n) &#x3D; \frac{(\lambda_N)^n e^{-\lambda_N}}{n!}<br>$$<br>泊松分布的一个关键特性是方差等于均值，则光子数的标准差为<br>$$<br>\sigma_{\text{shot}}^2&#x3D;N_p<br>$$<br>信噪比SNR为<br>$$<br>SNR_{ph} &#x3D; \frac{N_p}{\sqrt{N_p}} &#x3D; \sqrt{N_p}<br>$$<br>光子噪声是信号相关噪声：信号越强，绝对噪声增大，但信噪比反而越好</p><p>光子噪声无法通过电路消除，只能通过<font color='DarkViolet'>增加光通量或曝光时间提升SNR</font>，这也是长时间曝光或多张照片堆栈可以得到更纯净图像的根本原因</p><h3 id="暗电流"><a href="#暗电流" class="headerlink" title="暗电流"></a>暗电流</h3><p>当没有光照时，热激发会在光电二极管中产生电子，<font color='DarkViolet'>暗电流随温度强烈变化</font>，近似指数规律：<br>$$<br>I_{d} \propto T^3 e^{-\frac{E_g}{kT}}<br>$$<br>温度每升高6-10°C，暗电流大约翻一倍</p><p>暗电流产生的电子数同样遵循泊松分布，因此也属于散粒噪声($I_d$的单位为$e⁻&#x2F;s$)<br>$$<br>\sigma_{dark}^2 &#x3D; N_d &#x3D; I_d\cdot t<br>$$</p><blockquote><p>为什么在这里分开来讲光子噪声和暗电流噪声，因为在光电二极管理论分析中通常只关心电流端噪声，所以直接把两者合并成一个“散粒噪声项”，但在图像传感器分析中更关注成像效果、温度特性和后处理，所以才会人为拆开讲解</p></blockquote><p>在完全黑场(遮光)下拍摄时，图像并不全黑，会出现整体偏亮或不均匀的“背景发光”</p><p>可通过<font color='DarkViolet'>冷却或像素级暗场校正减弱</font></p><h3 id="读出噪声"><a href="#读出噪声" class="headerlink" title="读出噪声"></a>读出噪声</h3><p>读出噪声泛指从像素电荷转换为数字信号过程中引入的所有电子学噪声，是一个<font color='DarkViolet'>与信号强度无关的固定附加噪声</font>，可以看作是传感器的底噪</p><p>主要包含以下几种噪声机制：</p><ol><li>热噪声(Thermal noise)：电阻产生的随机电压，在带宽内功率均匀分布</li><li>1&#x2F;f噪声：低频漂移噪声，其功率谱密度与频率成反比，在低频时非常显著</li><li>kTC(复位)噪声：对像素电容进行复位操作时引入的电荷不确定性，通常用相关双采样去除</li></ol><p>$$<br>\sigma_{read}^2 &#x3D; \sigma_{thermal}^2  +\sigma^2_{1&#x2F;f} + \sigma_{kTC}^2 + \sigma_{ADC}^2<br>$$<br>其中每一项都近似高斯分布(Gaussian)，因此读出噪声总体服从正态分布</p><p><font color='Violetred'>在极弱光、短曝光或高增益(ISO)的情况下最为显著</font></p><p>在图像的极暗区域或阴影部分表现为随机的、细密的“盐粒状”噪点</p><p>降噪手段包括：</p><ul><li>相关双采样CDS(在像素复位后和曝光后各读一次，两次相减，去除kTC噪声)</li><li>避免过高的数字增益(ISO)</li><li><font color='DarkViolet'>多帧平均</font></li></ul><h3 id="固定模式噪声FPN"><a href="#固定模式噪声FPN" class="headerlink" title="固定模式噪声FPN"></a>固定模式噪声FPN</h3><p>FPN 不是随机噪声，而是由制造工艺的微小差异导致的空间不均匀性，不同像素的响应特性(如暗电流、增益)存在固定的微小差异，在暗场或均匀照明下仍存在</p><p>分为两类：</p><ul><li>偏置型DSNU：即使在零照度下，不同像素的输出(偏置)也不同</li><li>增益型PRNU：不同像素对光的响应灵敏度(增益)不同</li></ul><p>对于第 $i$ 个像素信号输出表示为：<br>$$<br>S_i&#x3D;g_i\cdot N_p+o_i<br>$$<br>其中$g_i$为像素的增益，$o_i$为像素偏置，整个图像的FPN方差可表示为：</p><p>$$<br>\sigma_{F P N}^{2}&#x3D;\sigma_{g}^{2} N_{p}^{2}+\sigma_{o}^{2}<br>$$<br><font color='Violetred'>偏置误差主导暗场噪声，而增益误差主导亮场噪声</font></p><p>由于其固定特性，在多张照片的相同位置会重复出现，表现为条纹、带状噪声</p><p>校正方式：</p><ul><li><font color='DarkViolet'>暗场帧减法</font>：有效校正Offset FPN</li><li><font color='DarkViolet'>平场校正</font>：通过拍摄均匀光源(平场)来测量并校正Gain FPN</li></ul><p>现代传感器通常具有<strong>片上校正电路</strong>，在输出前就抑制 FPN</p><h3 id="总噪声"><a href="#总噪声" class="headerlink" title="总噪声"></a>总噪声</h3><p>$$<br>\sigma_{total}^2 &#x3D; \sigma_{ph}^2 + \sigma_{dark}^2 + \sigma_{read}^2 + \sigma_{FPN}^2\<br>\text{SNR} &#x3D; \frac{N_p}{\sqrt{\sigma_{total}^2}}<br>$$</p><table><thead><tr><th>噪声类型</th><th>统计本质</th><th>主导条件</th><th>图像表现</th><th>改善策略</th></tr></thead><tbody><tr><td>光子噪声</td><td>泊松</td><td>光照充足，信号强</td><td>颗粒感，随亮度线性变强</td><td>增加总进光量(长曝光、大光圈)</td></tr><tr><td>暗电流</td><td>泊松</td><td>长曝光&#x2F;高温&#x2F;弱光</td><td>暗区随机噪点、热像素</td><td>传感器降温，缩短曝光，暗帧校正</td></tr><tr><td>读出噪声</td><td>近高斯</td><td>低照度&#x2F;短曝光&#x2F;高速读出</td><td>暗场“雪花底噪”，每帧不同</td><td>多次采样平均</td></tr><tr><td>固定模式噪声</td><td>非随机(空间固定)</td><td>所有情况都存在</td><td>固定条纹，帧间长得一样</td><td>硬件片上校正、拍平场&#x2F;暗场校准</td></tr></tbody></table><p><strong>代码语言</strong></p><ul><li><p>光子噪声：给光场施加泊松分布；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N_ph = np.random.poisson(idea_photons)</span><br></pre></td></tr></table></figure></li><li><p>暗电流噪声：给暗电流电子数施加泊松分布；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N_dark = np.random.poisson(dark_electrons)</span><br></pre></td></tr></table></figure></li><li><p>读出噪声：创建一个高斯分布矩阵，加性高斯白噪声</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N_read = np.random.normal(<span class="number">0</span>, read_noise_std, (rows, cols))</span><br></pre></td></tr></table></figure></li><li><p>固定模式噪声：光场叠加增益误差矩阵，读出噪声不叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gain_map = np.random.normal(<span class="number">1.0</span>, prnu_std, (rows, cols))</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_signal = gain_map*(N_ph + N_dark) + N_read</span><br></pre></td></tr></table></figure><p><code>N_ph + N_dark</code>: 光电子和暗电子在像素的势阱中被共同收集</p><p><code>gain_map * (...)</code>: 收集到的总电荷经过每个像素独特的增益放大</p><p><code>... + N_read</code>: 在所有信号被读出放大器处理时，最终叠加上读出噪声</p><h3 id="交互代码"><a href="#交互代码" class="headerlink" title="交互代码"></a>交互代码</h3><p><strong>参数设计</strong>：</p><ul><li>光子流量数 ≈ 10 ~ 10000 e⁻&#x2F;s&#x2F;piexl</li><li>曝光时间 ≈ 0.01 ~ 1s</li><li>暗电流率 ≈ 1 ~ 30 e⁻&#x2F;s&#x2F;piexl</li><li>读出噪声 ≈ 1 ~ 30 e⁻</li><li>FPN(PRNU) ≈ 0.01 ~ 0.05(1% ~ 5%)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> ipywidgets <span class="keyword">import</span> interact, FloatSlider, IntSlider, Layout</span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># --- 模拟函数 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simulate_cmos</span>(<span class="params"></span></span><br><span class="line"><span class="params">    photon_flux_rate,      <span class="comment"># 光子通量率</span></span></span><br><span class="line"><span class="params">    exposure_time,         <span class="comment"># 曝光时间 (s)</span></span></span><br><span class="line"><span class="params">    dark_current_rate,     <span class="comment"># 平均暗电流率</span></span></span><br><span class="line"><span class="params">    prnu_std,              <span class="comment"># 乘性增益标准差 (0.01 for 1%)</span></span></span><br><span class="line"><span class="params">    dsnu_std,              <span class="comment"># 暗电流的非均匀性</span></span></span><br><span class="line"><span class="params">    read_noise_std         <span class="comment"># 读出噪声标准差</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模拟CMOS传感器成像过程，并更精确地建模各种噪声源。</span></span><br><span class="line"><span class="string">    单位说明:</span></span><br><span class="line"><span class="string">    - 光子/暗电流相关的都是速率 (e-/pixel/s)</span></span><br><span class="line"><span class="string">    - 噪声都以电子数 (e-) 为单位</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># --- 参数设置 ---</span></span><br><span class="line">    rows, cols = <span class="number">128</span>, <span class="number">128</span></span><br><span class="line">    <span class="comment"># 模拟高斯光斑的光子通量率图</span></span><br><span class="line">    x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, cols)</span><br><span class="line">    y = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, rows)</span><br><span class="line">    X, Y = np.meshgrid(x, y)</span><br><span class="line">    photon_flux_map = photon_flux_rate * np.exp(-<span class="number">4</span> * (X**<span class="number">2</span> + Y**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 理想信号(平均光电子数)，无任何噪声</span></span><br><span class="line">    idea_photons = photon_flux_map * exposure_time</span><br><span class="line">    <span class="comment"># 暗电子数</span></span><br><span class="line">    dark_current_map = np.random.normal(dark_current_rate, dsnu_std, (rows, cols))</span><br><span class="line">    dark_current_map[dark_current_map &lt; <span class="number">0</span>] = <span class="number">0</span> <span class="comment"># 暗电流不能为负</span></span><br><span class="line">    dark_electrons = dark_current_map * exposure_time</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 生成噪声 ---</span></span><br><span class="line">    <span class="comment"># 光子散粒噪声</span></span><br><span class="line">    N_ph = np.random.poisson(idea_photons)</span><br><span class="line">    <span class="comment"># 暗电流散粒噪声</span></span><br><span class="line">    N_dark = np.random.poisson(dark_electrons)</span><br><span class="line">    <span class="comment"># 读出噪声</span></span><br><span class="line">    N_read = np.random.normal(<span class="number">0</span>, read_noise_std, (rows, cols))</span><br><span class="line">    <span class="comment"># 固定模式增益误差</span></span><br><span class="line">    gain_map = np.random.normal(<span class="number">1.0</span>, prnu_std, (rows, cols))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 输出信号 ---</span></span><br><span class="line">    final_signal = gain_map*(N_ph + N_dark) + N_read</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 结果展示 ---</span></span><br><span class="line">    fig, axs = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">12</span>, <span class="number">5</span>))</span><br><span class="line">    <span class="comment"># 理想图像现在是纯粹的光子信号</span></span><br><span class="line">    im1 = axs[<span class="number">0</span>].imshow(idea_photons, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    axs[<span class="number">0</span>].set_title(<span class="string">&quot;Ideal Image (Photon Signal Only)&quot;</span>)</span><br><span class="line">    fig.colorbar(im1, ax=axs[<span class="number">0</span>], shrink=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">    im2 = axs[<span class="number">1</span>].imshow(final_signal, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    axs[<span class="number">1</span>].set_title(<span class="string">&quot;Image with All Noise Sources&quot;</span>)</span><br><span class="line">    fig.colorbar(im2, ax=axs[<span class="number">1</span>], shrink=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ax <span class="keyword">in</span> axs:</span><br><span class="line">        ax.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- SNR 计算 ---</span></span><br><span class="line">    signal_mean = np.mean(idea_photons)</span><br><span class="line">    noise_std = np.std(final_signal - idea_photons)</span><br><span class="line">    SNR = <span class="number">20</span> * np.log10(signal_mean / noise_std)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;平均信噪比 ≈ <span class="subst">&#123;SNR:<span class="number">.2</span>f&#125;</span> dB&quot;</span>)</span><br><span class="line"></span><br><span class="line">style = &#123;<span class="string">&#x27;description_width&#x27;</span>: <span class="string">&#x27;initial&#x27;</span>&#125;</span><br><span class="line">layout = Layout(width=<span class="string">&#x27;80%&#x27;</span>)</span><br><span class="line"><span class="comment"># --- 交互界面 ---</span></span><br><span class="line">interact(</span><br><span class="line">    simulate_cmos,</span><br><span class="line">    photon_flux_rate=IntSlider(value=<span class="number">10000</span>, <span class="built_in">min</span>=<span class="number">100</span>, <span class="built_in">max</span>=<span class="number">20000</span>, step=<span class="number">100</span>, description=<span class="string">&#x27;光子通量率 (ph/s)&#x27;</span>, style=style, layout=layout),</span><br><span class="line">    exposure_time=FloatSlider(value=<span class="number">0.1</span>, <span class="built_in">min</span>=<span class="number">0.001</span>, <span class="built_in">max</span>=<span class="number">1.0</span>, step=<span class="number">0.005</span>, description=<span class="string">&#x27;曝光时间 (s)&#x27;</span>, style=style, layout=layout),</span><br><span class="line">    dark_current_rate=FloatSlider(value=<span class="number">1</span>, <span class="built_in">min</span>=<span class="number">0.1</span>, <span class="built_in">max</span>=<span class="number">30</span>, step=<span class="number">0.1</span>, description=<span class="string">&#x27;暗电流率 (e-/s)&#x27;</span>, style=style, layout=layout),</span><br><span class="line">    prnu_std=FloatSlider(value=<span class="number">0.01</span>, <span class="built_in">min</span>=<span class="number">0.0</span>, <span class="built_in">max</span>=<span class="number">0.05</span>, step=<span class="number">0.001</span>, description=<span class="string">&#x27;PRNU 标准差&#x27;</span>, style=style, layout=layout, readout_format=<span class="string">&#x27;.3f&#x27;</span>),</span><br><span class="line">    dsnu_std=FloatSlider(value=<span class="number">0.5</span>, <span class="built_in">min</span>=<span class="number">0.0</span>, <span class="built_in">max</span>=<span class="number">10</span>, step=<span class="number">0.1</span>, description=<span class="string">&#x27;DSNU 标准差 (e-/s)&#x27;</span>, style=style, layout=layout),</span><br><span class="line">    read_noise_std=FloatSlider(value=<span class="number">2</span>, <span class="built_in">min</span>=<span class="number">1</span>, <span class="built_in">max</span>=<span class="number">30</span>, step=<span class="number">1</span>, description=<span class="string">&#x27;读出噪声 (e-)&#x27;</span>, style=style, layout=layout)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="光电二极管的性能指标"><a href="#光电二极管的性能指标" class="headerlink" title="光电二极管的性能指标"></a>光电二极管的性能指标</h2><h3 id="光电转换特性"><a href="#光电转换特性" class="headerlink" title="光电转换特性"></a>光电转换特性</h3><p><font color='Violetred'>响应度$R$</font>：在特定波长的入射光照射下，光电二极管产生的光电流与入射光功率之比，单位A&#x2F;W<br>$$<br>R &#x3D; \frac{I_{ph}}{P} [A&#x2F;W]<br>$$<br>衡量光电二极管对光敏感的核心指标，表示光电转换的宏观效率，随波长变化，通常会有一个峰值响应波长<br>$$<br>R(\lambda) &#x3D; \eta \frac{e}{h\nu}&#x3D;\eta\frac{e\lambda}{hc}<br>$$<br>可以看出响应度随波长线性增大，但这并不是没有限制的，随着波长增大，当超过材料带隙后($\lambda &gt; \lambda_c$(截止波长))，响应度急剧下降，但边缘并不陡峭，存在带尾态(Urbach tail)</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510072155.webp" alt="202510072155" style="zoom: 50%;" />$$\lambda _c = \frac{hc}{E_g}$$因为$E_g$的单位为eV，所以计算截止波长可以直接$1240/Eg$<table><thead><tr><th>材料</th><th>带隙Eg(eV)</th><th>截止波长(nm)</th><th>常见用途</th></tr></thead><tbody><tr><td>Si</td><td>1.12</td><td>1100</td><td>可见光~近红外</td></tr><tr><td>Ge</td><td>0.67</td><td>1850</td><td>红外探测</td></tr><tr><td>InGaAs</td><td>0.75 (可调)</td><td>1650</td><td>光通信、近红外成像</td></tr><tr><td>HgCdTe</td><td>0.1~0.3 (可调)</td><td>4000~12000</td><td>中远红外探测、热成像</td></tr></tbody></table><p>温度升高 → 带隙变窄 → 截止波长$\lambda_c$“红移”</p><p><font color='Violetred'>量子效率$\eta$</font>：产生的光电子-空穴对数量与入射的光子数量之比，无单位</p><p>表示光电转换的微观效率，越高表明器件内部的光电转换机制越有效，取决于波长和材料，典型硅光电二极管的$\eta \sim 70%- 90%$</p><p><strong>是最典型的计算指标</strong>，可以从响应度$R$和波长计算得出<br>$$<br>\eta &#x3D; \frac{R\cdot h c}{e\lambda}\approx \frac{1240\cdot R}{\lambda(nm)} \times 100%<br>$$<br><strong>1240的推导</strong>：</p><p>$h$：普朗克常数 ($6.62607015 × 10^{-34} J\cdot s$)  </p><p>$e$：元电荷 ($1.6\times 10^{-19}C$)</p><p>$\lambda$：<font color='Violetred'>以nm为单位</font>，所以上下项均$\times 10^9$<br>$$<br>\frac{hc}{e} \times 10^9&#x3D; \frac{6.62607015\cdot10^{-34}\times 3\cdot10^{8}}{1.6\cdot10^{-19}}\times 10^9 \approx 1240<br>$$</p><p><font color='Violetred'>光谱响应范围</font>：光电二极管能够有效探测的光波长范围，决定了该二极管适用于哪个波段的应用</p><h3 id="噪声特性"><a href="#噪声特性" class="headerlink" title="噪声特性"></a>噪声特性</h3><p><font color='Violetred'>暗电流$I_d$</font>：在无光照时，给光电二极管施加反向偏压时流过的电流，主要由热激发或缺陷引起</p><p>是光电二极管主要的内部噪声源，暗电流越小，探测微弱信号的能力越强</p><p>对温度非常敏感，温度每升高6-10°C，暗电流大约增加一倍</p><p>暗电流噪声<font color='DarkViolet'>在低温下可忽略</font>，但在红外探测器中不可忽视</p><p><strong>噪声电流的来源</strong>：</p><p>主要考虑散粒噪声和热噪声，<font color='Violetred'>噪声与测量带宽的平方根成正比</font></p><p><font color='DarkViolet'><strong>散粒噪声</strong></font>(Shot Noise)：源于载流子通过PN结的随机性，是一种基本的量子噪声，它与流经二极管的总电流有关<br>$$<br>i^2_{shot} &#x3D; 2q(I_{ph}+I_{dark})\Delta f<br>$$<br><strong><font color='DarkViolet'>热噪声</font></strong>(Thermal noise)：由探测器本身和等效到输入端电阻$R_L$中电荷载流子的热运动引起<br>$$<br>i_{th}^2 &#x3D; \frac{4kT}{R_L}\Delta f<br>$$<br>如果用的是反馈电阻，记得这里改为$R_f$</p><p>总噪声电流(均方根值)<br>$$<br>I_{noise} &#x3D; \sqrt{i_{shot}^2 +i_{th}^2 }&#x3D;\sqrt{2q(I_{ph}+I_d)\Delta f+\frac{4kT}{R_{L}}\Delta f}<br>$$</p><p>在极低光功率下，$I_{ph}$很小，噪声主要由热噪声决定</p><p>随着光功率和光电流$I_{ph}$的增大，散粒噪声逐渐成为主导因素</p><p><font color='Orange'>光电流的数量级在某个界限前噪声主要由热噪声决定；当超过界限后，散粒噪声占据主导地位</font></p><p>参数：$R_L&#x3D;1k\Omega,T&#x3D;300K,I_{dark}&#x3D;1nA,\Delta f&#x3D;1MHz$</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510051503.webp" alt="202510051503" style="zoom:67%;" /><p>这里大概是$10^{-5}$量级，真实$R_L$往往等效成很大的$R_f$(kΩ→MΩ量级)，分界电流会更低，这也是为何弱光系统通常只考虑散粒噪声</p><p><font color='Violetred'>噪声等效功率$NEP$</font>：单位带宽下，当输出信号的信噪比SNR为1时，所需入射到探测器上的光功率，是衡量探测器灵敏度的核心指标<br>$$<br>NEP &#x3D;\frac{I_{noise}&#x2F;\sqrt {\Delta f}}{R}[W&#x2F;\sqrt{Hz}]<br>$$<br>$NEP$值越小，说明探测器探测微弱光信号的能力越强，性能越好</p><p><font color='Violetred'>探测率$D^<em>$</font>：消除探测器面积对$NEP$的影响，便于比较不同尺寸探测器的性能而引入的归一化指标<br>$$<br>D^</em> &#x3D; \frac{\sqrt{A}}{NEP}[cm\cdot \sqrt {Hz}&#x2F;W]<br>$$<br>$A$是探测器的有效感光面积，$D^*$越大，探测弱信号的能力越强</p><h3 id="响应速度特性"><a href="#响应速度特性" class="headerlink" title="响应速度特性"></a>响应速度特性</h3><p>响应速度决定了探测器能多快地响应光信号的变化，是高速应用(如光通信、激光雷达)的关键参数</p><p>光电二极管可简化为一个理想电流源，并联一个结电容$C_j$和一个并联电阻$R_{sh}$</p><p><font color='Violetred'>结电容$C_j$</font>：光电二极管PN结的电容，与负载电阻$R_L$构成了RC电路，决定了响应速度的物理极限，结电容越小，响应速度越快。施加反向偏压可以增加PN结耗尽区的宽度，从而有效降低结电容，提高响应速度</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/DET_DWG_3_780.jpg" style="zoom: 67%;" /><p>简单$R_L$读出在带宽与灵敏度间强牵制</p><p>在实际电路中，工程上多用跨阻放大器TIA读出，等效电阻大小为$R_f$(反馈电阻)，且输出为电压方便后级处理，并且$R_f$一般会同时并联一个$C_f$用于补偿</p><p>在频域中，系统相当于一个一阶低通滤波器<br>$$<br>H(f)&#x3D;\frac{1}{\sqrt{1+(2\pi fR_fC_t)^2}}<br>$$<br><font color='Violetred'>带宽(BW)$\Delta f$</font>：指探测器的响应度下降到其最大值的$\sqrt 2$(约70.7%，即<font color='Violetred'>-3dB</font>)时的调制频率</p><blockquote><p>光电二极管的RC截止频率可近似代表带宽，但真实带宽还受漂移时间等因素限制，物理带宽比截止频率低</p></blockquote><p>$$<br>\Delta f&#x3D;\frac{1}{2\pi R_{f}C_{t}}<br>$$<br>小电容+小反馈电阻 → 更高带宽，带宽越大，探测器能够处理的信号频率就越高</p><p><font color='Violetred'>响应时间$\tau_r $</font>：常指上升时间，即输出信号从光脉冲输入后幅度的10%上升到90%所需的时间，直观地描述了器件对光强变化的反应速度</p><p>带宽和上升时间之间有一个近似的换算关系，<font color='Orange'>如果手册只给了其中一个，另一个可以通过计算估算</font><br>$$<br>\tau_r \approx \frac{0.35}{\Delta f} \qquad \Delta f\approx \frac{0.35}{\tau_r}<br>$$</p><h3 id="信噪比SNR"><a href="#信噪比SNR" class="headerlink" title="信噪比SNR"></a>信噪比SNR</h3><p>信噪比是衡量输出信号质量的最终指标，它综合了信号强度和总噪声<br>$$<br>SNR &#x3D; \frac{I_{ph}}{I_{noise}}<br>$$<br><strong>弱光区域</strong>($RP_{opt}\ll I_{dark}$)，光电流远小于暗电流，SNR与入射光功率成正比<br>$$<br>{SNR}\approx\frac{RP}{\sqrt{2qI_{dark}\Delta f}}\propto P<br>$$<br><strong>强光区域</strong>($RP_{opt}\gg I_{dark}$)，光电流远大于暗电流，成为总电流和散粒噪声的主要来源，SNR与入射光功率的平方根成正比<br>$$<br>{SNR}\approx\frac{RP}{\sqrt{2qRP\Delta f}}&#x3D;\sqrt{\frac{RP}{2q\Delta f}}\propto \sqrt P<br>$$<br>与前一部分中讨论的光子噪声的SNR特性完全一致，因为光子噪声就是光电流散粒噪声的根本来源</p><p>转为对数形式时，因为一般计算时用的都是幅度比，所以<br>$$<br>\mathrm{dB} &#x3D; 20\log_{10}SNR<br>$$</p><h3 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h3><table><thead><tr><th>性能指标</th><th>单位</th><th>值越..越好</th><th>简单描述</th></tr></thead><tbody><tr><td>响应度</td><td>$A&#x2F;W$</td><td>↑</td><td>光电转换的宏观效率</td></tr><tr><td>量子效率</td><td>无</td><td>↑</td><td>光电转换的微观效率</td></tr><tr><td>暗电流</td><td>$A$</td><td>↓</td><td>无光时的噪声</td></tr><tr><td>带宽</td><td>$Hz$</td><td>↑</td><td>能处理的信号最高频率范围</td></tr><tr><td>噪声等效功率</td><td>$W&#x2F;\sqrt{Hz}$</td><td>↓</td><td>能探测到信号的最小光功率</td></tr><tr><td>比探测率</td><td>$cm\cdot \sqrt {Hz}&#x2F;W$</td><td>↑</td><td>标准化的探测能力</td></tr></tbody></table><table><thead><tr><th align="center">材料</th><th>光谱范围</th><th>暗电流</th><th>速度</th><th>成本</th><th>特点与适用场景</th></tr></thead><tbody><tr><td align="center">硅</td><td>可见到近红外(350~1100nm)</td><td>低(pA)</td><td>高速(小面积ps，常规ns)</td><td>低</td><td>成熟工艺，线性好，通用型</td></tr><tr><td align="center">黑硅</td><td>可见到近红外(400~1200+nm)</td><td>低到中等(pA-nA)</td><td>中高速(ns)</td><td>中等</td><td>具有更高的量子效率，适用于低光照</td></tr><tr><td align="center">锗Ge</td><td>近红外(800~1800nm)</td><td>高(~2–200 mA&#x2F;cm²)</td><td>低速(ns-$\mu s$)</td><td>低</td><td>光纤通信，需低温操作</td></tr><tr><td align="center">砷化铟镓InGaAs</td><td>近红外(900~1700nm)</td><td>低(pA-nA)</td><td>高速(ps)</td><td>中等</td><td>光纤通信主力，LIDAR</td></tr><tr><td align="center">扩展型砷化铟镓 InGaAs</td><td>近红外(1000~2600 nm)</td><td>高($\mu A$)</td><td>高速</td><td>高</td><td>光谱分析，需要热电制冷</td></tr><tr><td align="center">砷化锑化铟InAsSb</td><td>近红外至中红外</td><td>高($\mu A$-mA)</td><td>中低速</td><td>高</td><td>高温工作能力，适合 MWIR应用(气体探测、光谱、热成像等)</td></tr><tr><td align="center">碲化镉汞MCT(HgCdTe)</td><td>近红外至中&#x2F;远红外</td><td>高(温度依赖强)</td><td>中等到低速</td><td>非常高</td><td>最顶级的红外探测，通常需要制冷与复杂封装&#x2F;校准</td></tr></tbody></table><p><strong>为什么红外通信与LiDAR常用InGaAs?</strong></p><p>通信领域：1310nm与1550nm是光纤损耗最低的窗口</p><p>LiDAR领域：1550nm常被采用，因为人眼安全，同时能在雾、尘、烟环境中穿透力更好</p><p>硅的截止频率在~1100nm，无法满足需求</p><p><font color='DarkViolet'>InGaAs(InₓGa₁₋ₓAs)</font>是一种可调带隙半导体，靠调整In&#x2F;Ga比例，可以调节吸收边从约900nm到 2600nm，非常灵活；</p><p>通常用于探测器的InGaAs带隙约为0.75 eV，使得它对波长范围900nm到1700nm的光具有高吸收效率，完美覆盖了光纤通信中最重要、损耗最低的几个波段</p><p>在1550nm仍有0.9A&#x2F;W左右响应，且暗电流相对较小(肯定还是比硅大的)，室温下可工作，系统成本低</p><h3 id="性能计算"><a href="#性能计算" class="headerlink" title="性能计算"></a>性能计算</h3><p>常见手册参数包括：受光面积、响应度(典型值)、光谱响应范围、暗电流(最大值)、结电容</p><p>以滨松光子的S2386-5K硅光电二极管为例</p><p>参数表如下：</p><table><thead><tr><th>参数名称</th><th>数据</th></tr></thead><tbody><tr><td>受光面</td><td>$2.4 \times  2.4 mm$</td></tr><tr><td>光谱响应范围</td><td>$320\sim 1100nm$</td></tr><tr><td>最大灵敏度波长</td><td>$960 nm$</td></tr><tr><td>响应度(典型值)</td><td>$0.6A&#x2F;W$</td></tr><tr><td>暗电流(最大值)</td><td>$5pA$</td></tr><tr><td>上升时间(典型值)</td><td>$1.8 \mu s$</td></tr><tr><td>结电容(典型值)</td><td>$730pF$</td></tr></tbody></table><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/kspdb0110eb.webp" alt="kspdb0110eb" style="zoom:80%;" /><p>有效接收面$A &#x3D; 2.4^2 &#x3D; 5.76mm^2&#x3D;0.0576cm^2$</p><p>量子效率：(960nm处)<br>$$<br>\eta &#x3D; \frac{1240R}{\lambda}&#x3D;1240\times 0.6&#x2F;960 &#x3D; 77.5%<br>$$</p><p>利用Logistic模拟响应度随波长变化，类似，峰值略有差异，基本模拟</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510072133.webp" alt="202510072133" style="zoom: 67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> ipywidgets <span class="keyword">import</span> interact, FloatLogSlider, FloatSlider</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 物理常数 ---</span></span><br><span class="line">h = <span class="number">6.626e-34</span>  <span class="comment"># 普朗克常数 (J·s)</span></span><br><span class="line">c = <span class="number">3.0e8</span>      <span class="comment"># 光速 (m/s)</span></span><br><span class="line">q = <span class="number">1.6e-19</span>    <span class="comment"># 基本电荷 (C)</span></span><br><span class="line">k = <span class="number">1.38e-23</span>   <span class="comment"># 玻尔兹曼常数 (J/K)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">photodiode_analysis</span>(<span class="params"></span></span><br><span class="line"><span class="params">    A_mm2=<span class="number">5.76</span>, lambda_peak_nm=<span class="number">960</span>, R_peak=<span class="number">0.6</span>,</span></span><br><span class="line"><span class="params">    P_uW=<span class="number">10</span>, lambda_nm=<span class="number">960</span>,</span></span><br><span class="line"><span class="params">    Rf=<span class="number">1e4</span>, Cj0_pF=<span class="number">730</span>, Vb=<span class="number">10</span>,</span></span><br><span class="line"><span class="params">    Id_pA=<span class="number">5</span>, T=<span class="number">298</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    一个比较真实的光电二极管性能分析模型</span></span><br><span class="line"><span class="string">    1. 响应度(R)不再是固定输入，而是基于峰值波长和峰值响应度计算得出。</span></span><br><span class="line"><span class="string">    2. 结电容(Cj)会根据反向偏压动态变化</span></span><br><span class="line"><span class="string">    3. 模拟TIA放大器读出，采用Rf</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># --- 模型参数 ---</span></span><br><span class="line">    lambda_min_nm = <span class="number">320</span>      <span class="comment"># 模型中响应度开始不为0的波长 (nm)</span></span><br><span class="line">    lambda_cutoff_nm = <span class="number">1100</span>  <span class="comment"># 硅的截止波长 (nm)</span></span><br><span class="line">    Vbi = <span class="number">0.7</span>                <span class="comment"># 硅的内建电势 (V)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 单位换算 ---</span></span><br><span class="line">    A = A_mm2 * <span class="number">1e-6</span>     <span class="comment"># mm² → m²</span></span><br><span class="line">    P = P_uW * <span class="number">1e-6</span>      <span class="comment"># µW → W</span></span><br><span class="line">    Id = Id_pA * <span class="number">1e-12</span>   <span class="comment"># pA → A</span></span><br><span class="line">    Cj0 = Cj0_pF * <span class="number">1e-12</span> <span class="comment"># pF → F</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 响应度(R)计算 ---</span></span><br><span class="line">    <span class="comment"># 控制曲线陡峭度的参数（越大越尖锐）</span></span><br><span class="line">    k0 = <span class="number">5</span></span><br><span class="line">    <span class="comment"># 左右两边的陡峭度系数</span></span><br><span class="line">    k1 = k0 / (lambda_peak_nm - lambda_min_nm)</span><br><span class="line">    k2 = k0 / (lambda_cutoff_nm - lambda_peak_nm)</span><br><span class="line">    <span class="comment"># 计算上升与下降的logistic因子</span></span><br><span class="line">    L1 = <span class="number">1</span> / (<span class="number">1</span> + <span class="number">5</span>*np.exp(-k1 * (lambda_nm - lambda_min_nm)))</span><br><span class="line">    L2 = <span class="number">1</span> / (<span class="number">1</span> + <span class="number">5</span>*np.exp(k2 * (lambda_nm - lambda_cutoff_nm)))</span><br><span class="line">    R = R_peak * L1 * L2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 属性计算 ---</span></span><br><span class="line">    Cj = Cj0 / np.sqrt(<span class="number">1</span> + Vb / Vbi)    <span class="comment"># 结电容</span></span><br><span class="line">    Iph = R * P                         <span class="comment"># 光电流 (A)</span></span><br><span class="line">    eta = (R * h * c) / (q * (lambda_nm * <span class="number">1e-9</span>)) <span class="comment"># 量子效率</span></span><br><span class="line">    <span class="comment"># 时间常数和带宽</span></span><br><span class="line">    BW = <span class="number">1</span> / (<span class="number">2</span> * np.pi * Rf * Cj)</span><br><span class="line">    tau_r = <span class="number">0.35</span> / BW</span><br><span class="line">    BW_str = <span class="string">f&quot;<span class="subst">&#123;BW/<span class="number">1e6</span>:<span class="number">.2</span>f&#125;</span> MHz&quot;</span> <span class="keyword">if</span> BW &gt;= <span class="number">1e6</span> <span class="keyword">else</span> <span class="string">f&quot;<span class="subst">&#123;BW/<span class="number">1e3</span>:<span class="number">.2</span>f&#125;</span> kHz&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 噪声计算 ---</span></span><br><span class="line">    <span class="comment"># 散粒噪声: 包含光电流和暗电流</span></span><br><span class="line">    ishot = np.sqrt(<span class="number">2</span> * q * (Iph + Id) * BW)</span><br><span class="line">    <span class="comment"># 热噪声: 由负载电阻产生</span></span><br><span class="line">    itherm = np.sqrt(<span class="number">4</span> * k * T / Rf * BW)</span><br><span class="line">    <span class="comment"># 总噪声</span></span><br><span class="line">    Inoise = np.sqrt(ishot**<span class="number">2</span> + itherm**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 探测性能</span></span><br><span class="line">    NEP = Inoise / (R * np.sqrt(BW)) <span class="comment"># 噪声等效功率 (W/√Hz)</span></span><br><span class="line">    D_star = np.sqrt(A * <span class="number">1e4</span>) / NEP  <span class="comment"># 探测率 (cm·√Hz/W)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 信噪比</span></span><br><span class="line">    SNR = Iph / Inoise</span><br><span class="line">    SNR_dB = <span class="number">20</span> * np.log10(SNR)</span><br><span class="line">    <span class="comment"># --- 输出 ---</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">40</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;      光电二极管性能分析&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">40</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 输入与环境参数 ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;工作波长 λ = <span class="subst">&#123;lambda_nm:<span class="number">.0</span>f&#125;</span> nm&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;光功率 P_in = <span class="subst">&#123;P_uW:<span class="number">.2</span>f&#125;</span> µW&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;反馈电阻 R_f = <span class="subst">&#123;Rf/<span class="number">1e3</span>:<span class="number">.2</span>f&#125;</span> kΩ&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;反向偏压 V_b = <span class="subst">&#123;Vb:<span class="number">.2</span>f&#125;</span> V&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;温度 T = <span class="subst">&#123;T:<span class="number">.1</span>f&#125;</span> K&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 器件核心参数 (计算值) ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;光谱响应度 R = <span class="subst">&#123;R:<span class="number">.3</span>f&#125;</span> A/W (@ <span class="subst">&#123;lambda_nm:<span class="number">.0</span>f&#125;</span> nm)&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;量子效率 η = <span class="subst">&#123;eta*<span class="number">100</span>:<span class="number">.1</span>f&#125;</span>%&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;结电容 Cj = <span class="subst">&#123;Cj*<span class="number">1e12</span>:<span class="number">.2</span>f&#125;</span> pF (@ <span class="subst">&#123;Vb:<span class="number">.1</span>f&#125;</span> V)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 性能指标 ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;光电流 I_ph = <span class="subst">&#123;Iph*<span class="number">1e9</span>:<span class="number">.3</span>f&#125;</span> nA&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;带宽 BW = <span class="subst">&#123;BW_str&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;上升时间 (10%-90%) τ_r = <span class="subst">&#123;tau_r*<span class="number">1e9</span>:<span class="number">.2</span>f&#125;</span> ns&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 噪声与探测性能 (@ 计算带宽) ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;散粒噪声 I_shot = <span class="subst">&#123;ishot*<span class="number">1e12</span>:<span class="number">.3</span>f&#125;</span> pA&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;热噪声 I_therm = <span class="subst">&#123;itherm*<span class="number">1e12</span>:<span class="number">.3</span>f&#125;</span> pA&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;总电流噪声 I_noise = <span class="subst">&#123;Inoise*<span class="number">1e12</span>:<span class="number">.3</span>f&#125;</span> pA&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;信噪比 SNR = <span class="subst">&#123;SNR:<span class="number">.2</span>f&#125;</span> (<span class="subst">&#123;SNR_dB:<span class="number">.2</span>f&#125;</span> dB)&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;噪声等效功率 NEP = <span class="subst">&#123;NEP:<span class="number">.2</span>e&#125;</span> W/√Hz&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;探测率 D* = <span class="subst">&#123;D_star:<span class="number">.2</span>e&#125;</span> cm·√Hz/W&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 交互控件定义 (使用更常见的参数范围) ---</span></span><br><span class="line">interact(</span><br><span class="line">    photodiode_analysis,</span><br><span class="line">    A_mm2=FloatSlider(value=<span class="number">5.76</span>, <span class="built_in">min</span>=<span class="number">1</span>, <span class="built_in">max</span>=<span class="number">6</span>, step=<span class="number">0.1</span>, description=<span class="string">&#x27;受光面积 (mm²)&#x27;</span>),</span><br><span class="line">    lambda_peak_nm=FloatSlider(value=<span class="number">960</span>, <span class="built_in">min</span>=<span class="number">700</span>, <span class="built_in">max</span>=<span class="number">1000</span>, step=<span class="number">10</span>, description=<span class="string">&#x27;峰值波长 (nm)&#x27;</span>),</span><br><span class="line">    R_peak=FloatSlider(value=<span class="number">0.6</span>, <span class="built_in">min</span>=<span class="number">0.36</span>, <span class="built_in">max</span>=<span class="number">0.7</span>, step=<span class="number">0.01</span>, description=<span class="string">&#x27;峰值响应度 (A/W)&#x27;</span>),</span><br><span class="line">    P_uW = FloatLogSlider(value=<span class="number">10</span>, base=<span class="number">10</span>, <span class="built_in">min</span>=-<span class="number">2</span>, <span class="built_in">max</span>=<span class="number">3</span>, step=<span class="number">0.1</span>, description=<span class="string">&#x27;光照功率 (µW)&#x27;</span>), <span class="comment"># 0.01uW to 1mW</span></span><br><span class="line">    lambda_nm=FloatSlider(value=<span class="number">960</span>, <span class="built_in">min</span>=<span class="number">350</span>, <span class="built_in">max</span>=<span class="number">1100</span>, step=<span class="number">5</span>, description=<span class="string">&#x27;工作波长 (nm)&#x27;</span>),</span><br><span class="line">    Rf=FloatLogSlider(value=<span class="number">1e4</span>, base=<span class="number">10</span>, <span class="built_in">min</span>=<span class="number">3</span>, <span class="built_in">max</span>=<span class="number">6</span>, step=<span class="number">0.1</span>, description=<span class="string">&#x27;反馈电阻 (Ω)&#x27;</span>), <span class="comment"># 1k to 1M</span></span><br><span class="line">    Cj0_pF=FloatSlider(value=<span class="number">730</span>, <span class="built_in">min</span>=<span class="number">50</span>, <span class="built_in">max</span>=<span class="number">1000</span>, step=<span class="number">5</span>, description=<span class="string">&#x27;零偏压结电容 (pF)&#x27;</span>),</span><br><span class="line">    Vb=FloatSlider(value=<span class="number">5.0</span>, <span class="built_in">min</span>=<span class="number">0</span>, <span class="built_in">max</span>=<span class="number">20</span>, step=<span class="number">0.5</span>, description=<span class="string">&#x27;反向偏压 (V)&#x27;</span>),</span><br><span class="line">    Id_pA=FloatLogSlider(value=<span class="number">5</span>, base=<span class="number">10</span>, <span class="built_in">min</span>=<span class="number">0</span>, <span class="built_in">max</span>=<span class="number">4</span>, step=<span class="number">0.1</span>, description=<span class="string">&#x27;暗电流 (pA)&#x27;</span>), <span class="comment"># 1pA to 10nA</span></span><br><span class="line">    T=FloatSlider(value=<span class="number">298</span>, <span class="built_in">min</span>=<span class="number">77</span>, <span class="built_in">max</span>=<span class="number">350</span>, step=<span class="number">1</span>, description=<span class="string">&#x27;温度 (K)&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="硅vs石墨烯"><a href="#硅vs石墨烯" class="headerlink" title="硅vs石墨烯"></a>硅vs石墨烯</h3><table><thead><tr><th>特性</th><th>硅 (Silicon)</th><th>石墨烯 (Graphene)</th></tr></thead><tbody><tr><td>响应速度</td><td>ns~ps</td><td>ps~fs</td></tr><tr><td>波长范围</td><td>350nm~1100nm(可见-近红外)</td><td>极宽(UV–可见–IR–THz)(紫外-中红外)</td></tr><tr><td>量子效率</td><td>高(可达80–95%)</td><td>单层低(~2–3%)，需要光学谐振腔&#x2F;波导耦合</td></tr><tr><td>暗电流</td><td>极低(pA–nA)</td><td>较高(μA–mA)，噪声大</td></tr><tr><td>工艺成熟度</td><td>极其成熟，成本低</td><td>工艺尚不成熟，一致性差</td></tr><tr><td>主要应用</td><td>消费电子、太阳能电池、传统光通信</td><td>高速光通信、宽带光谱探测、前沿科学研究</td></tr></tbody></table><h2 id="Time-of-Flight-ToF"><a href="#Time-of-Flight-ToF" class="headerlink" title="Time-of-Flight(ToF)"></a>Time-of-Flight(ToF)</h2><h3 id="系统原理"><a href="#系统原理" class="headerlink" title="系统原理"></a>系统原理</h3><p>TOF(飞行时间)是一种通过计算光在介质中传播一定距离所需时间来测量距离的技术</p><p>基本原理：发射光脉冲 → 光传播 → 反射 → 探测延时 → 计算间距<br>$$<br>d &#x3D; \frac{c\cdot \Delta t}{2}<br>$$<br><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510081302.webp" alt="202510081302" style="zoom:50%;" /></p><p>常用激光，也就是光速，如果用声波就是声速$v&#x3D;343m&#x2F;s(20^\circ  C)$</p><p>动画模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib widget</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.animation <span class="keyword">import</span> FuncAnimation, PillowWriter</span><br><span class="line"><span class="comment"># 参数设置</span></span><br><span class="line">c = <span class="number">3e8</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line">delta_t = <span class="number">2</span>*d/c</span><br><span class="line">frames = <span class="number">200</span></span><br><span class="line">sensor_x = <span class="number">0</span></span><br><span class="line">target_x = d</span><br><span class="line">x_positions = np.linspace(sensor_x, target_x, frames//<span class="number">2</span>)</span><br><span class="line">x_positions = np.concatenate([x_positions, x_positions[::-<span class="number">1</span>]]) <span class="comment"># 往返运动</span></span><br><span class="line"><span class="comment"># 绘图设置</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">ax.set_xlim(-<span class="number">1</span>, d + <span class="number">1</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Distance (m)&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;ToF animation diagram&quot;</span>)</span><br><span class="line"><span class="comment"># 绘制传感器和目标</span></span><br><span class="line">sensor_dot, = ax.plot(sensor_x, <span class="number">0</span>, <span class="string">&#x27;bo&#x27;</span>, markersize=<span class="number">10</span>, label=<span class="string">&quot;sensor&quot;</span>)</span><br><span class="line">target_dot, = ax.plot(target_x, <span class="number">0</span>, <span class="string">&#x27;ro&#x27;</span>, markersize=<span class="number">10</span>, label=<span class="string">&quot;target&quot;</span>)</span><br><span class="line">light_dot, = ax.plot([], [], <span class="string">&#x27;yo&#x27;</span>, markersize=<span class="number">8</span>, label=<span class="string">&quot;light&quot;</span>)</span><br><span class="line">text_time = ax.text(<span class="number">0.5</span>, <span class="number">0.3</span>, <span class="string">&#x27;&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">text_distance = ax.text(<span class="number">0.5</span>, -<span class="number">0.3</span>, <span class="string">&#x27;&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    light_dot.set_data([], [])</span><br><span class="line">    text_time.set_text(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    text_distance.set_text(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> light_dot, text_time, text_distance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">frame</span>):</span><br><span class="line">    x = x_positions[frame]</span><br><span class="line">    light_dot.set_data(x, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟时间与测距计算</span></span><br><span class="line">    fraction = frame / (frames - <span class="number">1</span>)</span><br><span class="line">    t = fraction * delta_t</span><br><span class="line">    d_measured = c * t / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    text_time.set_text(<span class="string">f&quot;time: <span class="subst">&#123;t*<span class="number">1e9</span>:<span class="number">.2</span>f&#125;</span> ns&quot;</span>)</span><br><span class="line">    text_distance.set_text(<span class="string">f&quot;d_measured: <span class="subst">&#123;d_measured:<span class="number">.2</span>f&#125;</span> m&quot;</span>)</span><br><span class="line">    <span class="comment"># 延迟一帧停止：只在最后一帧之后停止</span></span><br><span class="line">    <span class="keyword">if</span> frame == frames-<span class="number">1</span>:</span><br><span class="line">        ani.event_source.stop()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;动画播放完成。&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> light_dot, text_time, text_distance</span><br><span class="line"></span><br><span class="line">ani = FuncAnimation(fig, update, frames=frames, init_func=init, interval=<span class="number">30</span>, blit=<span class="literal">True</span>)</span><br><span class="line">save_gif = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> save_gif:</span><br><span class="line">    writer = PillowWriter(fps=<span class="number">30</span>)</span><br><span class="line">    ani.save(<span class="string">&quot;tof_animation.gif&quot;</span>, writer=writer)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;已保存为 tof_animation.gif&quot;</span>)</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-10-08_16-44-11.webp" alt="Snipaste_2025-10-08_16-44-11" style="zoom: 67%;" /><h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p>一个典型的TOF系统由以下几个部分组成：</p><ul><li><p>发射端Tx：包括激光光源(主要是VCSEL，垂直腔面发射激光器)，激光驱动电路ASIC以及用于光束控制的光学组件(准直镜头，衍射光学元件DOE以及滤光片)</p></li><li><p>接收端Rx：包括镜头和滤光片，根据系统设计使用不同的传感器，以及ISP(图像信号处理器，完成信号放大、时间测距、3D深度图生成等计算)</p><p>传感器类型主要有这3种：</p><ul><li>CIS(CMOS Image Sensor)：常见于连续调制TOF系统，成像分辨率高</li><li><font color='Violetred'>SPAD(Single Photon Avalanche Diode)：单光子雪崩二极管</font>，灵敏度极高，<strong>用于脉冲式TOF系统</strong></li><li>SiPM(Silicon Photomultiplier)：硅光电倍增器，也能检测极弱光信号</li></ul></li><li><p>电源管理：TOF系统对电源的要求非常苛刻，<font color='DarkViolet'>VCSEL需要非常精确、快速响应的电流控制，以保证激光脉冲的一致性</font>，SPAD等器件通常需要高电压偏置才能工作在雪崩模式下，因此需要高精度、低噪声的电源管理模块</p></li><li><p>软件层：包括固件(运行在TOF芯片上的低层控制程序)、SDK(为上层应用提供接口函数)、操作系统(OS)与应用层</p></li></ul><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/1702878368563924.webp" alt="1702878368563924" style="zoom:50%;" /><p>脉冲信号模拟：发射端Tx脉冲有展宽，接收端Rx脉冲有幅度衰减</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">c = <span class="number">3e8</span>  <span class="comment"># 光速 (m/s)</span></span><br><span class="line">d = <span class="number">1.0</span>  <span class="comment"># 测距目标距离 (m)</span></span><br><span class="line">delta_t = <span class="number">2</span> * d / c  <span class="comment"># 光往返时间 (s)</span></span><br><span class="line"></span><br><span class="line">t_min = -<span class="number">2e-9</span>    <span class="comment"># 提前一点时间，方便看发射脉冲</span></span><br><span class="line">t_max = <span class="number">10e-9</span>    <span class="comment"># 足够长的窗口以容纳回波</span></span><br><span class="line">dt = <span class="number">10e-12</span>       <span class="comment"># 时间分辨率 10ps</span></span><br><span class="line">t = np.arange(t_min, t_max, dt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发射脉冲</span></span><br><span class="line">pluse_sigma = <span class="number">0.5e-9</span> <span class="comment"># 发射脉冲的时间宽度 (标准差 0.5 ns)</span></span><br><span class="line">pluse_amp = <span class="number">1.0</span></span><br><span class="line">pluse_tx = pluse_amp * np.exp(-t**<span class="number">2</span>/(<span class="number">2</span>*pluse_sigma**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收脉冲：延迟 delta_t，振幅衰减</span></span><br><span class="line">pluse_rx = <span class="number">0.4</span>* pluse_amp * np.exp(-(t-delta_t)**<span class="number">2</span>/(<span class="number">2</span>*pluse_sigma**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制模拟信号图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">plt.plot(t * <span class="number">1e9</span>, pluse_tx, label=<span class="string">&#x27;Tx pulse&#x27;</span>)</span><br><span class="line">plt.plot(t * <span class="number">1e9</span>, pluse_rx, label=<span class="string">&#x27;Rx pulse&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time(ns)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amp(a.u.)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">f&#x27;Ideal ToF Pulse(d=<span class="subst">&#123;d&#125;</span>m)&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-10-08_14-57-08.webp" alt="Snipaste_2025-10-08_14-57-08" style="zoom:67%;" /><h3 id="系统分类"><a href="#系统分类" class="headerlink" title="系统分类"></a>系统分类</h3><p>ToF根据调制方法的不同，可以分为两种：脉冲式和连续波调制式</p><p><strong>脉冲式</strong>：也称为直接TOF(dToF)，通过TDC(时间数字转化器)直接测量发射接收时间差$\Delta t$</p><table><thead><tr><th>分辨率</th><th>可测精度</th><th>对应距离精度</th></tr></thead><tbody><tr><td>1ns</td><td>30cm</td><td>较粗测距(普通 ToF)</td></tr><tr><td>100ps</td><td>3cm</td><td>高精度测距(中档 LiDAR)</td></tr><tr><td>10ps</td><td>3mm</td><td>精密测距(SPAD 系统)</td></tr><tr><td>1ps</td><td>0.3mm</td><td>实验室级精度</td></tr></tbody></table><p><strong>连续波调制</strong>：也称为间接TOF(iToF)，通过检测相位差来计算时间差</p><table><thead><tr><th>特性</th><th>脉冲式dTOF</th><th>连续波调制iTOF</th></tr></thead><tbody><tr><td>测距原理</td><td>测量飞行时间($\Delta t$)</td><td>测量相位差($\Delta \phi$)</td></tr><tr><td>发射信号</td><td>短脉冲</td><td>连续调制波</td></tr><tr><td>精度</td><td>高(ps级)</td><td>中(相位精度决定)</td></tr><tr><td>成本与功耗</td><td>高</td><td>低</td></tr><tr><td>典型应用</td><td>激光雷达、工业测距</td><td>手机3D相机、消费电子</td></tr><tr><td>误差来源</td><td>TDC分辨率<br />激光脉冲抖动<br />探测器时间抖动<br />多路径反射<br />温度漂移影响时钟</td><td>相位模糊(超过2π)<br />环境光影响<br />多路径反射</td></tr></tbody></table><p>想测1ns，就得把抖动压到100ps级别</p><h4 id="脉冲式dToF"><a href="#脉冲式dToF" class="headerlink" title="脉冲式dToF"></a>脉冲式dToF</h4><p>脉冲式直接测量光的往返时间，照射光源一般采用方波脉冲<br>$$<br>d &#x3D; \frac{c\cdot \Delta t}{2}<br>$$<br>$\Delta t$ 的测量方法有两种：</p><p><font color='DarkViolet'>快门积分法</font>：</p><p>激光器发出一个有限宽度的脉冲(持续时间$t_p$)，到达接收端探测器时，并不是瞬间一个点，而是一个有宽度的电流脉冲，通过早窗($S_0$)和晚窗($S_1$)的大小，就可以求得传播时间</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510081355.webp" alt="202510081355" style="zoom: 33%;" />$$d =  \frac{c}{2}\times t_p\times \frac{S_1}{S_0+S_1}$$最小的可测距离：$S_0$收集了全电荷，$S_1$没有收到，则$d=0$<p>最大的可测距离：$S1$收集全电荷，$S_0$没有收到，则$d&#x3D;0.5c\times t_p$，最大可测量距离是通过光脉冲宽度来确定的</p><p>优点：</p><ul><li>不需要亚纳秒级的TDC(硬件复杂度低)</li><li>积分能把噪声平均掉，对背景光有一定抑制</li><li>算法简单，适合CMOS图像传感器阵列(ToF相机常用)</li></ul><p>缺点：</p><ul><li>精度受限于脉冲宽度</li><li>多径回波时积分比值可能失真</li><li>本质是模拟插值，不是直接测时间</li></ul><p>在慢门后一般需要间隔一小段时间再进行下一次脉冲，这是为了避免前一次雪崩后的残余电荷可能导致虚假触发</p><p><font color='Darkviolet'>直方图法</font></p><p>关键组件：单光子雪崩二极管(SPAD)，一个光子 → 一次大电流脉冲</p><p>每次探测到一个光子，TDC记录其到达时间戳，经过多次脉冲发射，把光子到达时间累积成直方图，回波脉冲形成一个峰值，峰值位置就是$\Delta t$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">10000</span>  <span class="comment"># 重复测量次数</span></span><br><span class="line">true_delay = <span class="number">6.67e-9</span></span><br><span class="line">time_jitter = <span class="number">2e-10</span>  <span class="comment"># 探测器时间抖动</span></span><br><span class="line">arrival_times = rng.normal(true_delay, time_jitter, N)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间分辨率 10 ps</span></span><br><span class="line">bin_width = <span class="number">10e-12</span></span><br><span class="line"><span class="comment"># 定义时间范围，比如以 ±3σ 覆盖所有数据</span></span><br><span class="line">t_min = true_delay - <span class="number">3</span> * time_jitter</span><br><span class="line">t_max = true_delay + <span class="number">3</span> * time_jitter</span><br><span class="line">bins = np.arange(t_min, t_max + bin_width, bin_width)</span><br><span class="line"><span class="comment"># 绘制直方图并获取数据</span></span><br><span class="line">counts, bin_edges, _ = plt.hist(arrival_times * <span class="number">1e9</span>, bins=bins * <span class="number">1e9</span>, color=<span class="string">&#x27;lightblue&#x27;</span>)</span><br><span class="line">max_index = np.argmax(counts)</span><br><span class="line">peak_time = <span class="number">0.5</span>* (bin_edges[max_index] + bin_edges[max_index+<span class="number">1</span>])</span><br><span class="line">peak_count = counts[max_index]</span><br><span class="line"><span class="comment"># 标注峰值</span></span><br><span class="line">plt.scatter(peak_time, peak_count, color=<span class="string">&#x27;red&#x27;</span>, s=<span class="number">2</span>, label=<span class="string">&#x27;Peak&#x27;</span>)</span><br><span class="line">plt.text(peak_time, peak_count, <span class="string">f&#x27;<span class="subst">&#123;peak_time:<span class="number">.3</span>f&#125;</span> ns&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, ha=<span class="string">&#x27;left&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Arrival Time (ns)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Counts&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;SPAD Photon Arrival Histogram(10 ps resolution)&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-10-08_17-05-11.webp" alt="Snipaste_2025-10-08_17-05-11" style="zoom: 67%;" /><p>优点：</p><ul><li>精度高，时间分辨率取决于TDC bin宽度</li><li>对长距离测量更有优势</li><li>能分辨多径：直方图可能出现多个峰，对应多次反射</li></ul><p>缺点：</p><ul><li>硬件复杂，需要高速TDC(ps分辨率)</li><li>数据量大，需要累积统计才能形成稳定直方图</li><li>功耗较高，不太适合大规模阵列实时成像</li></ul><p>常用于高性能激光雷达(SPAD阵列 + TDC)、科研用激光测距</p><h4 id="连续波调制式iToF"><a href="#连续波调制式iToF" class="headerlink" title="连续波调制式iToF"></a>连续波调制式iToF</h4><p>实际应用中，通常采用的是正弦波调制<br>$$<br>I(t)&#x3D;I_0(1+\sin (2\pi ft))<br>$$<br>目标反射回来后，接收的信号会有一个相位延迟$\Delta \phi$</p><p>通过测相位差，可以推算距离<br>$$<br>d&#x3D; \frac{c\cdot \Delta \phi}{4\pi f}<br>$$<br><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-10-08_14-10-08.webp" alt="Snipaste_2025-10-08_14-10-08" style="zoom:50%;" /></p><p>不用皮秒级计时，只要能检测相位差</p><p>$\Delta \phi$的测量方法：(类似四步相移法)</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/202510081919.webp" alt="202510081919" style="zoom: 33%;" /><ol><li><p>假设发射的正弦信号$s(t)$振幅是$a$，调制频率是$f$<br>$$<br>s(t)&#x3D; a(1+\sin(2\pi f t))<br>$$</p></li><li><p>经过时延$\Delta t$后接收到的信号为$r(t)$，衰减后的振幅为$A$，强度偏移(由环境光引起)为$B$<br>$$<br>r(t) &#x3D; A \cdot (1 + \sin(2\pi f(t - \Delta t))) + B &#x3D; A \cdot (1 + \sin(2\pi ft - \Delta \varphi)) + B<br>$$<br>信号在时间上延迟相当于在波形上向后平移一个相位角</p></li><li><p>四个采样时间间隔相等，均为$T&#x2F;4$<br>$$<br>t_0&#x3D;0,t_1&#x3D; \frac{1}{4}T,t_2&#x3D;\frac{1}{2}T,t_3&#x3D;\frac{3}{4}T<br>$$<br>在一个周期内分四次采样，相位间隔分别是 0°, 90°, 180°, 270°</p></li><li><p>根据上述采样时间可以列出四个方程组<br>$$<br>r_i &#x3D; A\cdot \sin (2\pi ft_i-\Delta \phi)+(A+B)<br>$$<br>采样得到的$r_0,r_1,r_2,r_3$四个值，是相机像素实际测量到的光强</p></li><li><p>代入4个$t$发现<br>$$<br>r_2 - r_0 &#x3D; 2A \sin \Delta \varphi \ r_1 - r_3 &#x3D; 2A \cos \Delta \varphi<br>$$<br>则可知<br>$$<br>\Delta \phi &#x3D; 2\pi f\Delta t &#x3D; \mathrm{atan2}(r_2-r_0,r_1-r_3)<br>$$<br>用四个采样的光强，算出反射波与发射波之间的相位差</p><p>atan2是双参数反正切函数，用于求出角度且自动考虑象限</p></li><li><p>为了提高精度，需要估计信号的幅值A(调制分量)和偏置B(背景光)</p><p>平方并相加：<br>$$<br>(r_0 - r_2)^2 + (r_1 - r_3)^2 &#x3D; 4A^2(\sin^2 \Delta \varphi + \cos^2 \Delta \varphi)<br>$$<br>则可知<br>$$<br>A &#x3D; \frac{1}{2}\sqrt{(r_0 - r_2)^2 + (r_1 - r_3)^2}<br>$$<br>因为正弦函数在0°,90°,180°,270° 四点的平均值是0，则可知<br>$$<br>\<br>B &#x3D; \frac{1}{4}(r_0 + r_1 + r_2 + r_3) - A<br>$$</p></li><li><p>测距不确定度(误差$\sigma _d$)<br>$$<br>\sigma_d &#x3D; \frac{c}{4\sqrt{2\pi f}} \cdot \frac{\sqrt{A+B}}{c_d \cdot A}<br>$$<br>$c_d$是一个与相机系统有关的常数，用来把光强单位转成等效信号幅度单位</p><p>可知：</p><ul><li><p>调制频率越高(f ↑) → 距离误差越小<br>$$<br>\Delta d&#x3D; \frac{c}{4\pi f}<br>$$</p></li><li><p>反射信号越强(A ↑) → 距离误差越小</p></li><li><p>背景光越强(B ↑) → 距离误差越大</p></li></ul></li></ol><p>优点：</p><ul><li>更容易在 CMOS 图像传感器上实现，每个像素都能测深度</li><li>成本低，适合手机、近距3D成像</li><li>同时能做大规模二维阵列成像</li></ul><p>缺点：</p><ul><li><p>距离会模糊(周期性重复)，因为相位只在2π之间，对应最大无歧义距离<br>$$<br>d_{max} &#x3D; \frac{c}{2f}<br>$$</p></li><li><p>环境光干扰大，容易降低信噪比</p></li><li><p>调制频率限制精度</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 🥼半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="/posts/60233.html"/>
      <url>/posts/60233.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Python3的六个标准数据类型中：</p><ul><li>不可变数据：Number(数字)、String(字符串)、Tuple(元组)</li><li>可变数据：List(列表)、Dictionary(字典)、Set(集合)</li></ul><p>不可变指的是创建后内存内容不能再被修改，只能创建新的对象来修改</p><h3 id="数字Number"><a href="#数字Number" class="headerlink" title="数字Number"></a>数字Number</h3><p>Python 支持三种不同的数值类型：</p><ul><li>整型(int)，Python3整型是没有限制大小的，可以当作 Long 类型使用，布尔(bool)是整型的子类型</li><li>浮点型(float)</li><li>复数(complex)，可以用<code>a+bj</code>,或者<code>complex(a,b)</code>表示，复数的实部a和虚部b都是浮点型</li></ul><p>数据类型的转换只需要将数据类型作为函数名即可</p><p>在混合计算时会把整型转换成为浮点数，<code>+</code>,<code>-</code>,<code>*</code>和<code>/</code>和其它语言里一样</p><p>数值的除法包含两个运算符：<code>/</code>返回一个浮点数，<code>//</code>返回一个整数(但不一定是int，和分子分母的数据类型有关)</p><p>数学常量：<code>pi</code> and <code>e</code> </p><h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><p>用单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来，同时使用反斜杠<code>\</code>转义特殊字符，<font color='Violetred'>注意字符串不可变</font></p><p>字符串的切片：变量[头下标:尾下标]，索引值以0为开始值，-1为从末尾的开始位置</p><p>可以用<code>+</code>运算符连接在一起，用<code>*</code>运算符重复</p><p><strong>格式化</strong>推荐用<code>f-string</code>(python3.6之后)</p><p>以<strong>f</strong>开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去</p><p>用这种方式就不用再去判断使用<code>%s</code>还是<code>%d</code></p><h3 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h3><p>列表是Python中使用最频繁的数据类型，写在方括号<code>[]</code>之间，元素用逗号隔开</p><p>和字符串一样有索引和切片，不同的是<font color='Violetred'>列表中的元素是可以改变的</font></p><p>常用方法：(部分和c++类似)</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>len(list)</code></td><td>列表元素个数</td></tr><tr><td><code>list.count(obj)</code></td><td>统计某个元素在列表中出现的次数</td></tr><tr><td><code>list.index(obj)</code></td><td>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td><code>list.append(obj)</code></td><td>在列表末尾添加新的对象</td></tr><tr><td><code>list.insert(index, obj)</code></td><td>将对象插入列表</td></tr><tr><td><code>list.extend(seq)</code></td><td>在列表末尾一次性追加另一个序列中的多个值</td></tr><tr><td><code>list.pop([index=-1])</code></td><td>移除列表中的一个元素(默认最后一个)，并且返回该元素的值</td></tr><tr><td><code>list.remove(obj)</code></td><td>移除列表中某个值的第一个匹配项</td></tr><tr><td><code>list.sort(reverse=False)</code></td><td>对原列表进行排序</td></tr><tr><td><code>list.reverse()</code></td><td>反向列表中元素</td></tr></tbody></table><p>输出小技巧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 直接打印（默认输出）</span></span><br><span class="line"><span class="built_in">print</span>(matrix)</span><br><span class="line"><span class="comment"># 美化输出（去除逗号和方括号）</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> row))</span><br></pre></td></tr></table></figure><h3 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h3><p>与列表类似，不同之处在于元组的元素不能修改，写在小括号<code>()</code>里，元素之间用逗号隔开</p><p>和列表一样有索引和切片，<font color='Violetred'>不同之处在于元组的元素不能修改，且数据类型可以不同</font></p><p>元组中的元素值不允许删除，但可以使用<code>del</code>语句来删除整个元组</p><p>常用方法：(方法极少)</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>len(tuple)</code></td><td>计算元组元素个数</td></tr><tr><td><code>max(tuple)</code>&#x2F;<code>min(tuple)</code></td><td>返回元组中元素最大&#x2F;最小值</td></tr></tbody></table><h3 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h3><p>集合(Set)是一个无序、可变、不重复的元素集合，使用大括号<code>&#123;&#125;</code>表示，元素之间用逗号分隔</p><blockquote><p>3.7+中含存储顺序，但逻辑仍无序</p></blockquote><p>可以进行交集、并集、差集等常见的集合操作(<code>&amp;</code>,<code>|</code>,<code>-</code>)</p><p><font color='Violetred'>创建一个空集合必须用<code>set()</code>而不是<code>&#123; &#125;</code></font>，因为<code>&#123; &#125;</code>是用来创建一个空字典</p><p>常用方法：(类比c++ set)</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>set.add(x)</code></td><td>为集合添加元素</td></tr><tr><td><code>set.remove(x)</code></td><td>从集合移除元素</td></tr><tr><td><code>set.pop()</code></td><td>随机移除元素</td></tr><tr><td><code>set.clear()</code></td><td>移除集合中的所有元素</td></tr><tr><td><code>len(set)</code></td><td>计算集合元素个数</td></tr></tbody></table><p>适合用于去重、快速查找、集合关系运算</p><h3 id="字典Dictionary"><a href="#字典Dictionary" class="headerlink" title="字典Dictionary"></a>字典Dictionary</h3><p>字典是一种映射类型，用<code>&#123; &#125;</code>标识，是一个<font color='Violetred'>无序的键(key):值(value)的集合</font></p><blockquote><p>3.7+默认保持插入顺序</p></blockquote><p>键(key)必须使用不可变类型，且<font color='Violetred'>在同一个字典中，键(key)必须是唯一的</font></p><p>常用方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>dict.keys()</code></td><td>返回键的视图对象</td></tr><tr><td><code>dict.values()</code></td><td>返回值的视图对象</td></tr><tr><td><code>dict.items()</code></td><td>以列表返回视图对象</td></tr><tr><td><code>dict.update(dict2)</code></td><td>把字典dict2的键&#x2F;值对更新到dict里</td></tr><tr><td><code>dict.pop(key)</code></td><td>删除字典key所对应的值，返回被删除的值</td></tr><tr><td><code>dict.get(key, default=None)</code></td><td>返回指定键的值，如果不存在返回default设置的值</td></tr></tbody></table><h3 id="四大容器对比"><a href="#四大容器对比" class="headerlink" title="四大容器对比"></a>四大容器对比</h3><table><thead><tr><th>特性</th><th>列表 list</th><th>元组 tuple</th><th>集合 set</th><th>字典 dict</th></tr></thead><tbody><tr><td>定义方式</td><td><code>[]</code> 或 <code>list()</code></td><td><code>()</code> 或 <code>tuple()</code></td><td><code>&#123;&#125;</code> 或 <code>set()</code></td><td><code>&#123;key: value&#125;</code> 或 <code>dict()</code></td></tr><tr><td>是否有序</td><td>有序</td><td>有序</td><td>无序</td><td>有序</td></tr><tr><td>是否可变</td><td>可变</td><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td>元素是否可重复</td><td>允许重复</td><td>允许重复</td><td>自动去重</td><td>键(key)唯一，值(value)可重复</td></tr><tr><td>索引访问</td><td>支持</td><td>支持</td><td>不支持</td><td>通过 key 访问 value</td></tr><tr><td>适用场景</td><td>存放有序数据，可修改</td><td>固定数据，保护不被修改</td><td>去重、集合运算、快速查找</td><td>存放键值对，快速查找映射关系</td></tr></tbody></table><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br></pre></td></tr></table></figure><p>pathlib是对os的一个改进库，建议从os慢慢转变为pathlib</p><p>在MacOS和Linux系统下，路径默认使用的都是<code>正斜杠/</code>，在Windows系统下，正反斜杠都可以表示路径分隔符，默认的是<code>反斜杠\</code>，由于反斜杠本身属于转义符，这可能会导致使用反斜杠表示的路径在编码时无法被正确识别。最好就是全部用正斜杆<code>/</code>，避免出问题</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><table><thead><tr><th>功能</th><th><code>os</code>&#x2F;<code>os.path</code> 写法</th><th><code>pathlib</code> 写法</th></tr></thead><tbody><tr><td>获取当前工作目录</td><td><code>os.getcwd()</code></td><td><code>Path.cwd()</code></td></tr><tr><td>递归创建单层目录</td><td><code>os.makedirs(path, exist_ok=True)</code></td><td><code>Path(path).mkdir(parents=True, exist_ok=True)</code></td></tr><tr><td>删除空目录</td><td><code>os.rmdir(path)</code></td><td><code>Path(path).rmdir()</code></td></tr></tbody></table><p><code>os.removedirs(path)</code>：递归删除空目录，从最深层的子目录开始删除，直到遇到一个非空目录或者抛出错误为止；</p><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><table><thead><tr><th>功能</th><th><code>os</code> &#x2F; <code>os.path</code> 写法</th><th><code>pathlib</code> 写法</th></tr></thead><tbody><tr><td>拼接路径</td><td><code>os.path.join(path1,path2)</code></td><td><code>Path(path1) / path2</code></td></tr><tr><td>文件名(不含扩展名)</td><td>(很麻烦)</td><td><code>Path(path).stem</code></td></tr><tr><td>文件名(含扩展名)</td><td><code>os.path.basename(path)</code></td><td><code>Path(path).name</code></td></tr><tr><td>取扩展名</td><td><code>os.path.splitext(path)[1]</code></td><td><code>Path(path).suffix</code></td></tr><tr><td>取目录名</td><td><code>os.path.dirname(path)</code></td><td><code>Path(path).parent</code></td></tr><tr><td>检查是否存在</td><td><code>os.path.exists(path)</code></td><td><code>Path(path).exists()</code></td></tr><tr><td>删除文件</td><td><code>os.remove(path)</code></td><td><code>Path(path).unlink()</code></td></tr></tbody></table><h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a><font color='Violetred'>遍历目录</font></h3><p><code>os.listdir</code>列出某个目录下的文件和文件夹名(不递归)，只返回名字(不带路径)，需要<code>os.path.join</code>拼接绝对&#x2F;相对路径</p><p><code>Path.iterdir()</code>结合了<code>os.listdir</code> + <code>os.path.join</code> </p><p>计算文件夹下所有csv文件的平均值：(两种写法的区别只在循环开始部分)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_average</span>(<span class="params">folder</span>):</span><br><span class="line">    xs = <span class="literal">None</span>        <span class="comment"># 存放 x 轴</span></span><br><span class="line">    ys_list = []     <span class="comment"># 存放所有文件的第二列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(folder):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.endswith(<span class="string">&quot;.csv&quot;</span>):</span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment"># 只处理 CSV 文件</span></span><br><span class="line">        path = os.path.join(folder, name)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    for path in Path(folder).iterdir():</span></span><br><span class="line"><span class="string">    if path.suffix != &quot;.csv&quot;:   # 扩展名检查</span></span><br><span class="line"><span class="string">        continue</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 读入两列数据</span></span><br><span class="line">            data = np.loadtxt(path, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            x = data[:, <span class="number">0</span>]</span><br><span class="line">            y = data[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> xs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                xs = x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 检查 x 轴是否一致</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> np.allclose(xs, x):</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">f&quot;x轴不一致: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            ys_list.append(y)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Loaded <span class="subst">&#123;path&#125;</span>, <span class="subst">&#123;<span class="built_in">len</span>(y)&#125;</span> points&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Skip <span class="subst">&#123;path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ys_list:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;没有找到有效的 CSV 文件&quot;</span>)</span><br><span class="line"><span class="comment"># 转为numpy</span></span><br><span class="line">    ys = np.array(ys_list)</span><br><span class="line">    ys_avg = np.average(ys, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xs, ys_avg</span><br></pre></td></tr></table></figure><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>递归式的遍历，遍历指定目录及其子目录中的所有文件和目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.walk(top, topdown=<span class="literal">True</span>, onerror=<span class="literal">None</span>, followlinks=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_average_walk</span>(<span class="params">folder</span>):</span><br><span class="line">    xs = <span class="literal">None</span></span><br><span class="line">    ys_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> dirpath, _, filenames <span class="keyword">in</span> os.walk(folder):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> filenames:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.endswith(<span class="string">&quot;.csv&quot;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path = os.path.join(dirpath, name) <span class="comment"># 重新拼接文件路径</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    folder = Path(folder) # 需要转一下，不然用不了rglob</span></span><br><span class="line"><span class="string">    for path in folder.rglob(&quot;*.csv&quot;): </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = np.loadtxt(path, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                x = data[:, <span class="number">0</span>]</span><br><span class="line">                y = data[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> xs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    xs = x</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> np.allclose(xs, x):</span><br><span class="line">                        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;x轴不一致: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                ys_list.append(y)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Loaded <span class="subst">&#123;path&#125;</span>, <span class="subst">&#123;<span class="built_in">len</span>(y)&#125;</span> points&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Skip <span class="subst">&#123;path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ys_list:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;没有找到有效的 CSV 文件&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ys = np.array(ys_list)</span><br><span class="line">    ys_avg = np.average(ys, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xs, ys_avg</span><br></pre></td></tr></table></figure><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h3 id="创建和生成"><a href="#创建和生成" class="headerlink" title="创建和生成"></a>创建和生成</h3><h4 id="array函数"><a href="#array函数" class="headerlink" title="array函数"></a>array函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>object</code></td><td align="left">数组或嵌套的数列<code>list</code></td></tr><tr><td align="left"><code>dtype</code></td><td align="left">数组元素的数据类型，可选，一般不用自己指定</td></tr><tr><td align="left"><code>copy</code></td><td align="left">对象是否需要复制，可选</td></tr><tr><td align="left"><code>order</code></td><td align="left">创建数组的样式，C为行方向，F为列方向，A为任意方向(默认)</td></tr><tr><td align="left"><code>ndmin</code></td><td align="left">指定生成数组的最小维度</td></tr></tbody></table><p>传入复数数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>+<span class="number">2j</span>,<span class="number">2</span>+<span class="number">3j</span>],[<span class="number">3</span>+<span class="number">4j</span>,<span class="number">4</span>+<span class="number">5j</span>]], dtype= np.complex64)</span><br></pre></td></tr></table></figure><h4 id="arange函数"><a href="#arange函数" class="headerlink" title="arange函数"></a>arange函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(start, stop, step, dtype)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">起始值，默认为<code>0</code></td></tr><tr><td align="left"><code>stop</code></td><td align="left">终止值(不包含)</td></tr><tr><td align="left"><code>step</code></td><td align="left">步长，默认为<code>1</code></td></tr></tbody></table><h4 id="linspace函数"><a href="#linspace函数" class="headerlink" title="linspace函数"></a>linspace函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">序列的起始值</td></tr><tr><td align="left"><code>stop</code></td><td align="left">序列的终止值，如果<code>endpoint</code>为<code>True</code>，该值包含于数列中</td></tr><tr><td align="left"><code>num</code></td><td align="left">要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td align="left"><code>endpoint</code></td><td align="left">该值为<code>True</code>时，数列中包含<code>stop</code>值，默认<code>True</code></td></tr><tr><td align="left"><code>retstep</code></td><td align="left">该值为<code>True</code>时，生成的数组中会显示间距，反之不显示</td></tr></tbody></table><h4 id="logspace函数"><a href="#logspace函数" class="headerlink" title="logspace函数"></a>logspace函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">起始值：<code>base ** start</code></td></tr><tr><td align="left"><code>stop</code></td><td align="left">终止值：<code>base ** stop</code>，如果<code>endpoint</code>为<code>True</code>，该值包含于数列中</td></tr><tr><td align="left"><code>num</code></td><td align="left">要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td align="left"><code>endpoint</code></td><td align="left">该值为<code>True</code> 时，数列中中包含<code>stop</code>值，默认是True</td></tr><tr><td align="left"><code>base</code></td><td align="left">对数<code>log</code>的底数</td></tr></tbody></table><h4 id="ones-zeros函数"><a href="#ones-zeros函数" class="headerlink" title="ones&#x2F;zeros函数"></a>ones&#x2F;zeros函数</h4><p>创建出来的 array 默认是 float 类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.ones(shape, dtype = <span class="literal">None</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.zeros(shape, dtype = <span class="literal">None</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>shape</code></td><td align="left">数组形状</td></tr><tr><td align="left"><code>order</code></td><td align="left">‘C’行数组，或者’F’用于 FORTRAN 的列数组</td></tr></tbody></table><h4 id="random函数"><a href="#random函数" class="headerlink" title="random函数"></a>random函数</h4><p>最重要的API，经常用于随机生成训练或测试数据，神经网路初始化等</p><p>推荐使用新的方式生成，rng 是个 Generator，可用于生成各种分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)  <span class="comment"># Generator(PCG64) at 0x27C7981F900</span></span><br></pre></td></tr></table></figure><p>rng的size都有<code>()</code>，np.random的不是</p><table><thead><tr><th></th><th><code>np.random</code></th><th><code>rng</code></th></tr></thead><tbody><tr><td>0-1 连续均匀分布</td><td><code>np.random.rand(3,4)</code><br /><code>np.random.random((3,4))</code></td><td><code>rng.random((3,4))</code></td></tr><tr><td>指定上下界连续均匀分布</td><td><code>np.random.uniform(-1,1,(2,3))</code></td><td><code>rng.uniform(-1,1,(2,3))</code></td></tr><tr><td>指定上下界随机整数</td><td><code>np.random.randint(0,10,(2,3))</code></td><td><code>rng.integers(0,10,(2,3))</code></td></tr><tr><td>标准正态分布(0,1)</td><td><code>np.random.randn(2,4)</code></td><td><code>rng.standard_normal((2,4))</code></td></tr><tr><td>正态分布</td><td><code>np.random.normal(0,1,(3,5))</code></td><td><code>rng.normal(0,1,(3,5))</code></td></tr></tbody></table><p>常用用的就是2个分布：均匀分布和正态(高斯)分布</p><h3 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h3><p>一维数组的秩为1，二维数组的秩为2</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>arr.ndim</code></td><td align="left">数组的秩(rank)，即数组的维度数量或轴的数量</td></tr><tr><td align="left"><code>arr.shape</code></td><td align="left">数组的维度，表示数组在每个轴上的大小</td></tr><tr><td align="left"><code>arr.size</code></td><td align="left">数组中元素的总个数，等于 <code>np.shape</code> 中各个轴上大小的乘积</td></tr><tr><td align="left"><code>arr.dtype</code></td><td align="left">数组中元素的数据类型</td></tr><tr><td align="left"><code>arr.itemsize</code></td><td align="left">数组中每个元素的大小，以字节为单位</td></tr><tr><td align="left"><code>arr.real</code></td><td align="left">数组中每个元素的实部(如果元素类型为复数)</td></tr><tr><td align="left"><code>arr.imag</code></td><td align="left">数组中每个元素的虚部(如果元素类型为复数)</td></tr></tbody></table><h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><p><strong>最值</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="built_in">max</span>(axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>) <span class="comment"># min同理</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>axis</code></td><td>0为列，1为行，默认为全部</td></tr><tr><td><code>keepdims</code></td><td>是否保持原有维度，默认<code>False</code></td></tr></tbody></table><p>这个需要特别注意下，很多深度学习模型中都需要保持原有的维度进行后续计算</p><p><font color='Violetred'>在统计函数这块<code>axis</code>,<code>keepdims</code>用法都是一样的</font></p><p>另一种写法(少用)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.amax(arr)</span><br><span class="line">np.amin(arr)</span><br></pre></td></tr></table></figure><p><strong>分位数</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.median(arr) <span class="comment"># 中位数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.quantile(arr, q, axis) </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># 75% 的分位数，就是 a 里排序之后的中位数</span></span><br><span class="line"><span class="built_in">print</span> (np.percentile(a, <span class="number">75</span>))</span><br><span class="line"><span class="comment"># 6.25 75%*(6-1)=3.75 锁定索引3和4两个数 4+0.75*(7-4)=6.25</span></span><br></pre></td></tr></table></figure><p><strong>平均求和标准差</strong></p><p>使用最多的是「平均值」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.average(arr) <span class="comment"># 平均值</span></span><br><span class="line">np.<span class="built_in">sum</span>(arr)     <span class="comment"># 和</span></span><br><span class="line">np.std(arr)     <span class="comment"># 标准差</span></span><br><span class="line">np.var(arr)     <span class="comment"># 方差</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.cumsum(arr)  <span class="comment"># 累加</span></span><br><span class="line">np.cumprod(arr) <span class="comment"># 累乘</span></span><br></pre></td></tr></table></figure><p><strong>元素出现次数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.bincount(arr)</span><br></pre></td></tr></table></figure><p>返回不同元素出现的次数</p><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p>这小节里面的API使用非常高频，尤其是扩展1维度的 <code>expand_dims</code> 和去除1维度的 <code>squeeze</code>，在很多神经网络架构常见</p><h4 id="修改数组形状"><a href="#修改数组形状" class="headerlink" title="修改数组形状"></a>修改数组形状</h4><p>reshape会生成一个新的array，但resize不会</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>reshape()</code></td><td align="left">原数组形状不变</td></tr><tr><td align="left"><code>resize()</code></td><td align="left">会改变原数组形状</td></tr><tr><td align="left"><code>ravel()</code></td><td align="left">将多维数组展平</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line">arr1 = arr.reshape(<span class="number">4</span>,-<span class="number">1</span>)  <span class="comment"># 可以用-1让编译器自动计算，resize不行</span></span><br></pre></td></tr></table></figure><p><font color='Violetred'>reshape元素数量必须与原array一致</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arr1.resize(3,2)       # 报错，数组内元素数量多</span></span><br><span class="line">arr1copy = np.copy(arr1) <span class="comment"># 可以copy再resize来截断</span></span><br><span class="line">arr1copy.resize(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">arr1.shape  <span class="comment"># arr1的数组shape不变 (4,3)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 refcheck 设为 False ，可以让resize超出部分设为0</span></span><br><span class="line"><span class="comment"># 注意，这种方法不能对切片出来的数据使用，会提示报错</span></span><br><span class="line">arr2 = np.copy(arr1)</span><br><span class="line">arr2.resize(<span class="number">4</span>,<span class="number">4</span>,refcheck=<span class="literal">False</span>) <span class="comment"># 多的部分全部为0</span></span><br></pre></td></tr></table></figure><h4 id="修改数组维度"><a href="#修改数组维度" class="headerlink" title="修改数组维度"></a>修改数组维度</h4><p><font color='Violetred'>注意：无论是扩展还是缩减，无论是扩展还是缩减，多或少的 shape 都是 1</font></p><p>扩充维度不能跳跃</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">arr = rng.integers(<span class="number">1</span>,<span class="number">100</span>,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">expanded = np.expand_dims(arr, axis=(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment"># expanded.shape → (3,1,4,1,1)</span></span><br><span class="line"><span class="comment"># axis 先在1插入，变成(3,1,4) 再在axis=3插入，变成(3,1,4,1) 最后再插</span></span><br><span class="line"><span class="comment"># expanded = np.expand_dims(arr, axis=(1, 3, 8)) # 报错</span></span><br></pre></td></tr></table></figure><p><code>squeeze</code>时如果指定维度，则该维度<code>shape</code>必须是 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.squeeze(expanded, axis=0) # 报错</span></span><br><span class="line">np.squeeze(expanded, axis=<span class="number">1</span>) <span class="comment"># (3,4,1,1)</span></span><br><span class="line"><span class="comment"># 去除所有维度为 1 的</span></span><br><span class="line">np.squeeze(expanded) <span class="comment"># (3,4)</span></span><br></pre></td></tr></table></figure><h4 id="反序"><a href="#反序" class="headerlink" title="反序"></a>反序</h4><p>如果对一个字符串或数组进行反序，一般会利用<code>reversed</code>，或者利用<code>list</code>的索引，这就是numpy中array的反序方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br><span class="line"><span class="comment"># [[ 9 77 65 44]</span></span><br><span class="line"><span class="comment">#  [43 86  9 70]</span></span><br><span class="line"><span class="comment">#  [20 10 53 97]]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[::-<span class="number">1</span>] <span class="comment"># 默认行反序</span></span><br><span class="line"><span class="comment"># [[20 10 53 97]</span></span><br><span class="line"><span class="comment">#  [43 86  9 70]</span></span><br><span class="line"><span class="comment">#  [ 9 77 65 44]]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按行反转(上下翻转)</span></span><br><span class="line">arr[::-<span class="number">1</span>, :]</span><br><span class="line"><span class="comment"># [[20 10 53 97]</span></span><br><span class="line"><span class="comment">#  [43 86  9 70]</span></span><br><span class="line"><span class="comment">#  [ 9 77 65 44]]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按列反转(左右翻转)</span></span><br><span class="line">arr[:, ::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># [[44 65 77  9]</span></span><br><span class="line"><span class="comment">#  [70  9 86 43]</span></span><br><span class="line"><span class="comment">#  [97 53 10 20]]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时行列反转</span></span><br><span class="line">arr[::-<span class="number">1</span>, ::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># [[97 53 10 20]</span></span><br><span class="line"><span class="comment">#  [70  9 86 43]</span></span><br><span class="line"><span class="comment">#  [44 65 77  9]]</span></span><br></pre></td></tr></table></figure><h4 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h4><p>通俗理解就是把数组放倒，shape反转，行变成列，列成为行</p><p>建议二维矩阵用 <code>arr.T</code>(会快很多)，超过二维的张量可以用 <code>np.transpose</code>，会更加灵活些</p><p><font color='Violetred'>注意：一维数组转置还是自己，不会反转</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr.T</span><br><span class="line"><span class="comment"># [[ 9 43 20]</span></span><br><span class="line"><span class="comment">#  [77 86 10]</span></span><br><span class="line"><span class="comment">#  [65  9 53]</span></span><br><span class="line"><span class="comment">#  [44 70 97]]</span></span><br><span class="line">arr.reshape(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>).T.shape <span class="comment"># 输出 (4,3,1,1)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.transpose可以指定 axes，不指定时和T一样</span></span><br><span class="line">np.transpose(arr.reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>), axes=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)).shape</span><br><span class="line"><span class="comment"># 输出 (1,3,1,4)</span></span><br></pre></td></tr></table></figure><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>本小节严格来说只有两个API：<code>np.concatenate</code> 和 <code>np.stack</code></p><p>前者是拼接，后者是堆叠(会增加一个维度)，都可以指定维度</p><p><font color='Violetred'><code>vstack</code>和<code>hstack</code>虽然看起来是<code>stack</code>，但他俩本质还是<code>concatenate</code></font> </p><p><code>vstack</code>等价于 axis&#x3D;0，<code>hstack</code>等价于axis&#x3D;1，建议只用<code>concatenate</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">arr1 = rng.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">arr2 = rng.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">np.concatenate(arr1, arr2)  <span class="comment"># 默认沿axis=0(列)连接</span></span><br><span class="line">np.concatenate((arr1, arr2), axis=<span class="number">1</span>)  <span class="comment"># 沿行连接</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆叠，默认根据 axis=0 进行</span></span><br><span class="line">np.stack((arr1, arr2))  <span class="comment"># 增加维度，shape(2,2,3)</span></span><br><span class="line"><span class="comment"># [[[0.77395605 0.43887844 0.85859792]</span></span><br><span class="line"><span class="comment">#  [0.69736803 0.09417735 0.97562235]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[0.7611397  0.78606431 0.12811363]</span></span><br><span class="line"><span class="comment">#  [0.45038594 0.37079802 0.92676499]]]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆叠，根据 axis=2</span></span><br><span class="line">np.stack((arr1, arr2), axis=<span class="number">2</span>) <span class="comment"># shape为(2,3,2)</span></span><br><span class="line"><span class="comment"># [[[0.77395605 0.7611397 ]</span></span><br><span class="line"><span class="comment">#  [0.43887844 0.78606431]</span></span><br><span class="line"><span class="comment">#  [0.85859792 0.12811363]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[0.69736803 0.45038594]</span></span><br><span class="line"><span class="comment">#  [0.09417735 0.37079802]</span></span><br><span class="line"><span class="comment">#  [0.97562235 0.92676499]]]</span></span><br></pre></td></tr></table></figure><h3 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h3><p>切片和索引是通过对已有 array 进行操作而得到想要的「部分」元素的行为过程</p><p>把处理按维度分开，不处理的维度统一用<code>:</code>替代，也有用<code>...</code>表示的，但是<code>:</code>更多</p><p><font color='Violetred'>索引支持负数，即从后往前索引</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[:<span class="number">3</span>, <span class="number">1</span>:<span class="number">3</span>]       <span class="comment"># 0-3行，1-3列</span></span><br><span class="line">arr[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">0</span>:<span class="number">3</span>:<span class="number">2</span>]  <span class="comment"># 也可以start:stop:step来多选</span></span><br></pre></td></tr></table></figure><h3 id="筛选和过滤"><a href="#筛选和过滤" class="headerlink" title="筛选和过滤"></a>筛选和过滤</h3><p>主要包括以下内容：</p><ul><li>条件筛选</li><li>提取(按条件)</li><li>抽样(按分布)</li><li>最大最小 index(特殊值)</li></ul><p>这几个内容都很重要，使用的也非常高频，条件筛选经常用于 <code>Mask</code> 或异常值处理，提取则常用于结果过滤，抽样常用在数据生成(比如负样本抽样)，最大最小 <code>index</code> 则常见于机器学习模型预测结果判定中(根据最大概率所在的 index 决定结果属于哪一类)</p><h4 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h4><p>核心 API 是 <code>np.where</code>，返回输入数组中满足给定条件的元素的索引(元组)</p><p>需要注意的是：<code>where</code>分别返回各维度的<code>index</code>，赋值的是「不满足」条件的，类似三元表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.where(arr&gt;<span class="number">50</span>, arr, -<span class="number">1</span>)  <span class="comment"># 将&lt;=50的赋值为-1</span></span><br><span class="line"><span class="comment"># arr&gt;50 ? arr : -1</span></span><br></pre></td></tr></table></figure><h4 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h4><p><code>np.extract() </code>函数根据某个条件从数组中抽取元素，返回满条件的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.extract(condition, arr)</span><br></pre></td></tr></table></figure><p>提取和唯一值返回的都是一维向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.unique(arr) <span class="comment"># 提取唯一值，也是一种提取</span></span><br></pre></td></tr></table></figure><h4 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.choice(a, size=<span class="literal">None</span>, replace=<span class="literal">True</span>, p=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>a</code></td><td>如果是整数表示从<code>np.arange(a)</code> 里抽取元素<br />如果是一维数组直接从数组里抽取</td></tr><tr><td><code>size</code></td><td>抽取结果的形状(默认是返回一个数)，也可以是元组</td></tr><tr><td><code>replace</code></td><td><code>True</code>(默认)有放回抽样，元素可重复<br /><code>False</code>则不放回，元素不重复</td></tr><tr><td><code>p</code></td><td>每个元素被选中的概率，和必须为1，默认均匀分布</td></tr></tbody></table><p>如果<code>replace=False</code>，那么 <code>size</code> 不能大于元素总数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.choice(<span class="number">1000</span>,<span class="number">50</span>,replace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="最值索引"><a href="#最值索引" class="headerlink" title="最值索引"></a>最值索引</h4><p>主要是<code>np.argmax/argmin</code>这两个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.argmax(arr, axis=<span class="literal">None</span>)</span><br><span class="line">np.argmin(arr, axis=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><code>None</code>(默认)把数组展平成一维，再找最大&#x2F;最小值的位置，<code>axis=0</code>沿列方向，<code>axis=1</code>沿行方向</p><p><code>np.argsort()</code> 函数返回的是数组值从小到大的索引值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.argsort(arr, axis=-<span class="number">1</span>,kind=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><code>axis</code>默认-1，即最后一个轴，如果设置为None则会先展平为一维再排序</p><p><code>kind</code>是排序算法，可选</p><table><thead><tr><th align="left">种类</th><th align="left">速度</th><th align="left">最坏情况</th><th align="left">工作空间</th><th align="left">稳定性</th></tr></thead><tbody><tr><td align="left"><code>&#39;quicksort&#39;</code>(快速排序)(默认)</td><td align="left">1</td><td align="left"><code>O(n^2)</code></td><td align="left">0</td><td align="left">否</td></tr><tr><td align="left"><code>&#39;mergesort&#39;</code>(归并排序)</td><td align="left">2</td><td align="left"><code>O(n*log(n))</code></td><td align="left">~n&#x2F;2</td><td align="left"><font color='Violetred'>是</font></td></tr><tr><td align="left"><code>&#39;heapsort&#39;</code>(堆排序)</td><td align="left">3</td><td align="left"><code>O(n*log(n))</code></td><td align="left">0</td><td align="left">否</td></tr></tbody></table><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><h4 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h4><p>所有的算术函数均可直接运用于array，<code>+-*/</code>四则运算，<code>**</code>平方以及开方</p><table><thead><tr><th>功能</th><th>numpy模块</th></tr></thead><tbody><tr><td>绝对值</td><td><code>np.abs(x)</code> &#x2F; <code>np.fabs(x)</code></td></tr><tr><td>四舍五入</td><td><code>np.round(x, n)</code></td></tr><tr><td>取整</td><td><code>np.ceil(x)</code>(向上)&#x2F;<code>np.floor(x)</code>(向下)</td></tr><tr><td>对数</td><td><code>np.log(x)</code> <code>np.log10(x)</code> <code>np.log2(x)</code></td></tr><tr><td>取余</td><td><code>np.mod(x, y)</code> <code>y</code>可以是数组，不同被除数</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.minimum(arr, num) <span class="comment"># 超过num的都置为num</span></span><br><span class="line">np.maximum(arr, num) <span class="comment"># 小于num的都置于num</span></span><br></pre></td></tr></table></figure><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>广播(Broadcast)是numpy对不同形状(shape)的数组进行数值计算的方式</p><p>当运算中的2个数组的形状不同时，将自动触发广播机制</p><p>广播规则：</p><ul><li>如果两个数组的维度不相同，那么小维度数组的形状将会在最左边补1</li><li>如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为1的维度拓展以匹配另外一个数组形状</li><li>如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度等于1，那么会引发异常</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])   <span class="comment"># shape (1,3) → shape(2,3)</span></span><br><span class="line">b = np.array([[<span class="number">10</span>], [<span class="number">20</span>]])  <span class="comment"># shape (2,1) → shape(2,3)</span></span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="comment"># [[11 12 13]</span></span><br><span class="line"><span class="comment">#  [21 22 23]]</span></span><br></pre></td></tr></table></figure><p>不能广播的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])     <span class="comment"># shape (3,)</span></span><br><span class="line">b = np.array([<span class="number">1</span>, <span class="number">2</span>])        <span class="comment"># shape (2,)</span></span><br><span class="line"><span class="built_in">print</span>(a + b)   <span class="comment"># 报错，因为维度匹配了但既不相等也不为1 → 无法广播</span></span><br></pre></td></tr></table></figure><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p><code>dot</code> 和 <code>matmul</code> 在高维度时表现不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.dot(a, b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.matmul(a, b)   <span class="comment"># 等价于 a @ b</span></span><br><span class="line"><span class="comment"># 写矩阵运算时推荐用 `@`，代码更直观</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>情况</th><th><code>np.dot</code></th><th><code>np.matmul</code>(或 <code>@</code>)</th></tr></thead><tbody><tr><td>1D·1D</td><td>向量内积(标量)</td><td>向量内积(标量)</td></tr><tr><td>2D·2D</td><td>矩阵乘法</td><td>矩阵乘法</td></tr><tr><td>2D·1D</td><td>矩阵 × 向量 → 1D</td><td>矩阵 × 向量 → 1D</td></tr><tr><td>1D·2D</td><td>向量 × 矩阵 → 1D</td><td>向量 × 矩阵 → 1D</td></tr><tr><td>高维数组</td><td>只在最后两维做点积</td><td>支持批量矩阵乘法</td></tr></tbody></table><p>Hadamard乘积(逐元素相乘)：直接使用<code>*</code></p><p>常用线性代数方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>np.linalg.det(arr)</code></td><td>计算行列式</td></tr><tr><td><code>np.linalg.inv(arr)</code></td><td>求逆矩阵(前提行列式&gt;0)</td></tr><tr><td><code>np.linalg.eig(arr)</code></td><td>求特征值和特征向量</td></tr><tr><td><code>np.linalg.solve(A,b)</code></td><td>求方程Ax&#x3D;b</td></tr></tbody></table><h3 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h3><table><thead><tr><th>加载常用数据格式</th><th>保存数据</th></tr></thead><tbody><tr><td><code>np.loadtxt()</code></td><td><code>np.savetxt()</code></td></tr><tr><td><code>np.fromstring()</code></td><td><code>np.save()</code>, <code>np.savez()</code>, <code>np.savez_compressed()</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.loadtxt(fname, dtype=<span class="literal">None</span>, delimiter=<span class="string">&quot;,&quot;</span>, comments=<span class="string">&quot;#&quot;</span>, skiprows=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>fname</code></td><td align="left">文件的路径</td></tr><tr><td align="left"><code>delimiter</code></td><td align="left">指定数据在文件中的分隔符，在CSV文件中通常是逗号</td></tr><tr><td align="left"><code>skiprows</code></td><td align="left">指示 <code>loadtxt</code> 函数跳过文件前n行</td></tr><tr><td align="left"><code>comment</code></td><td align="left">如果行的开头为<code>&quot;#&quot;</code>则跳过</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.fromstring(s, dtype, count=-<span class="number">1</span>, sep=<span class="string">&#x27;,&#x27;</span>)  <span class="comment"># 把字符串转换成一维数组</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>s</code></td><td align="left">输入的字符串</td></tr><tr><td align="left"><code>delimiter</code></td><td align="left">指定数据在文件中的分隔符，在CSV文件中通常是逗号</td></tr><tr><td align="left"><code>count</code></td><td align="left">需要读取的元素数量，默认为-1，表示读取字符串中的所有元素</td></tr><tr><td align="left"><code>sep</code></td><td align="left">字符串中元素之间的分隔符，在CSV文件中通常是逗号</td></tr></tbody></table><h3 id="保存为文件"><a href="#保存为文件" class="headerlink" title="保存为文件"></a>保存为文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savetxt(fname, arr, fmt=<span class="string">&#x27;%s&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, newline=<span class="string">&#x27;\n&#x27;</span>, header=<span class="string">&#x27;&#x27;</span>, footer=<span class="string">&#x27;&#x27;</span>, comments=<span class="string">&#x27;# &#x27;</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>fname</code></td><td align="left">文件的路径</td></tr><tr><td align="left"><code>arr</code></td><td align="left">要存储的阵列数据</td></tr><tr><td align="left"><code>fmt</code></td><td align="left">要存储的数据格式，默认<code>%.18e</code>(科学记数法)</td></tr><tr><td align="left"><code>delimiter</code></td><td align="left">加载分隔符，默认是空格</td></tr><tr><td align="left"><code>newline</code></td><td align="left">行分隔符，默认换行符</td></tr><tr><td align="left"><code>header</code></td><td align="left">开头字符串(存储为csv文件时可以生成标题)</td></tr><tr><td align="left"><code>footer</code></td><td align="left">结尾字符串</td></tr><tr><td align="left"><code>comments</code></td><td align="left">文中的注释</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">row_string = <span class="string">&quot;20131, 10, 67, 20132, 11, 88, 20133, 12, 98, 20134, 8, 100, 20135, 9, 75, 20136, 12, 78&quot;</span></span><br><span class="line">data = np.fromstring(row_string, sep=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">data = data.reshape(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 保存数据</span></span><br><span class="line">np.savetxt(<span class="string">&quot;save_data.csv&quot;</span>, data, delimiter=<span class="string">&quot;,&quot;</span>, fmt=<span class="string">&#x27;%s&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>np.save()</code>保存一个array → <code>.npy</code></p><p><code>np.savez()</code>保存多个array(同<code>np.savez_compressed()</code>) → <code>.npz</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savez(file，kwd1=arr1, kwd2=arr2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">train_data = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">test_data = np.array([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line">np.savez(<span class="string">&quot;save_data_02.npz&quot;</span>, train=train_data, test=test_data)</span><br><span class="line"><span class="comment"># np.savez_compressed(&quot;save_data.npz&quot;, train=train_data, test=test_data)</span></span><br><span class="line">npz_data = np.load(<span class="string">&quot;save_data_02.npz&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train:&quot;</span>, npz_data[<span class="string">&quot;train&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test:&quot;</span>, npz_data[<span class="string">&quot;test&quot;</span>])</span><br></pre></td></tr></table></figure><h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>其用法和matlab极其相似</p><p>一个完整的matplotlib图像通常会包括以下四个部分：</p><ul><li><code>Figure</code>：用来容纳所有绘图元素，可以包含多个<code>Axes</code>，可以设置画布大小、分辨率等</li><li><code>Axes</code>：实际绘制数据的区域，一个<code>Figure</code>可以包含多个<code>Axes</code>，包含坐标轴、标题、标签等</li><li><code>Axis</code>：Axes的下属层级，用于处理坐标轴、刻度、标签范围</li><li><code>Artist</code>：图表中的元素：线条、点、文字、图例等</li></ul><p>matplotlib提供了两种最常用的绘图接口：</p><ol><li><p><font color='Violetred'>显式创建figure和axes</font>，直接操作Figure和Axes对象，更灵活可控，也被称为OO模式</p></li><li><p>依赖pyplot自动创建figure和axes，写法和matlab完全一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.plot()</span><br><span class="line">plt.title()</span><br><span class="line">plt.xlabel()</span><br><span class="line">plt.ylabel()</span><br><span class="line">plt.legend([])</span><br><span class="line">plt.suptitle() <span class="comment"># 加大标题</span></span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th>常见属性</th><th>设置</th></tr></thead><tbody><tr><td>颜色<code>color</code></td><td>r g b c m y k w</td></tr><tr><td>线型<code>linestyle</code></td><td><code>&#39;-&#39;</code>, <code>&#39;--&#39;</code>, <code>&#39;-.&#39;</code>, <code>&#39;&#39;</code>(只画点)</td></tr><tr><td>线宽<code>linewidth</code></td><td>一般2</td></tr><tr><td>标记<code>marker</code></td><td><code>&#39;o&#39;</code>, <code>&#39;s&#39;</code>, <code>&#39;D&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;x&#39;</code></td></tr><tr><td>透明度<code>alpha</code></td><td>看情况</td></tr><tr><td>文本字号、粗细、字体</td><td><code>fontsize</code>、<code>fontweight</code>、<code>family</code></td></tr></tbody></table><p>字体族主要有：</p><ul><li>serif：Times New Roman，主要论文</li><li>sans-serif：Arial</li><li>monospace：Courier New，主要代码</li><li>cursive(手写体&#x2F;花体)</li><li>fantasy(装饰体)</li></ul><p>解决中文乱码问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>, <span class="string">&#x27;Microsoft YaHei&#x27;</span>, <span class="string">&#x27;KaiTi&#x27;</span>, <span class="string">&#x27;SimSun&#x27;</span>]  <span class="comment"># 设置常用中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 正常显示负号</span></span><br></pre></td></tr></table></figure><h3 id="OO模式"><a href="#OO模式" class="headerlink" title="OO模式"></a>OO模式</h3><p>进入OO模式的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()  <span class="comment"># OO 接口，创建 Figure 和 Axes</span></span><br></pre></td></tr></table></figure><p>Axes(子图)常用操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ax.set_title(<span class="string">&quot;Title&quot;</span>)  <span class="comment"># 设置标题</span></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;X&quot;</span>)     <span class="comment"># x轴标签</span></span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Y&quot;</span>)     <span class="comment"># y轴标签</span></span><br><span class="line">ax.grid(<span class="literal">True</span>)          <span class="comment"># 显示网格</span></span><br></pre></td></tr></table></figure><p>Axis(坐标轴)常用操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ax.set_xlim(low, high)  <span class="comment"># x 轴范围</span></span><br><span class="line">ax.set_ylim(low, high)  <span class="comment"># y 轴范围</span></span><br><span class="line">ax.set_xticks([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])  <span class="comment"># 指定 x 轴刻度</span></span><br><span class="line">ax.set_yticks([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])           <span class="comment"># 指定 y 轴刻度</span></span><br></pre></td></tr></table></figure><p>Artist有两种类型：<code>primitives</code> 和<code>containers</code></p><p><code>primitive</code>是最基础的绘图对象，用于具体显示数据和形状</p><table><thead><tr><th>Artist 类型</th><th>描述</th></tr></thead><tbody><tr><td><strong>Line2D</strong></td><td>折线、曲线、散点图</td></tr><tr><td><strong>Text</strong></td><td>文字、标签、标题</td></tr><tr><td><strong>Patch</strong></td><td>各种二维形状：矩形、圆、多边形、柱状、扇形(饼图)等</td></tr><tr><td><strong>Collection</strong></td><td>一组类似元素，如散点图点集合、柱状图柱子集合等</td></tr></tbody></table><h3 id="Line2D"><a href="#Line2D" class="headerlink" title="Line2D"></a>Line2D</h3><h4 id="线绘制"><a href="#线绘制" class="headerlink" title="线绘制"></a>线绘制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">100</span>)</span><br><span class="line">y1= np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line">fig, ax = plt.subplots()  <span class="comment"># fig=画布, ax=子图坐标系</span></span><br><span class="line">ax.plot(</span><br><span class="line">    x, y1,</span><br><span class="line">    color=<span class="string">&#x27;blue&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, linewidth=<span class="number">2</span>,</span><br><span class="line">    marker=<span class="string">&#x27;o&#x27;</span>, markersize=<span class="number">4</span>,</span><br><span class="line">    label=<span class="string">&#x27;sin(x)&#x27;</span> <span class="comment"># 图例标签</span></span><br><span class="line">)</span><br><span class="line">ax.plot(</span><br><span class="line">    x, y2,</span><br><span class="line">    color=<span class="string">&#x27;red&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, linewidth=<span class="number">2</span>,</span><br><span class="line">    marker=<span class="string">&#x27;s&#x27;</span>, markersize=<span class="number">4</span>,</span><br><span class="line">    label=<span class="string">&#x27;cos(x)&#x27;</span></span><br><span class="line">)</span><br><span class="line">ax.set_title(<span class="string">&quot;Sine and Cosine Functions&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;x&quot;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;y&quot;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">ax.grid(<span class="literal">True</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;upper right&#x27;</span>) <span class="comment"># 图例放在右上角</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="多子图subplot"><a href="#多子图subplot" class="headerlink" title="多子图subplot"></a>多子图subplot</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line"><span class="comment"># 创建两个子图坐标系</span></span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">12</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">ax1.plot(</span><br><span class="line">    x, y1,</span><br><span class="line">    color=<span class="string">&#x27;blue&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, linewidth=<span class="number">2</span>,</span><br><span class="line">    marker=<span class="string">&#x27;o&#x27;</span>, markersize=<span class="number">4</span>,</span><br><span class="line">    label=<span class="string">&#x27;sin(x)&#x27;</span></span><br><span class="line">)</span><br><span class="line">ax1.set_title(<span class="string">&quot;Sine Function&quot;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">ax1.grid(<span class="literal">True</span>)</span><br><span class="line">ax1.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(</span><br><span class="line">    x, y2,</span><br><span class="line">    color=<span class="string">&#x27;red&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, linewidth=<span class="number">2</span>,</span><br><span class="line">    marker=<span class="string">&#x27;s&#x27;</span>, markersize=<span class="number">4</span>,</span><br><span class="line">    label=<span class="string">&#x27;cos(x)&#x27;</span></span><br><span class="line">)</span><br><span class="line">ax2.set_title(<span class="string">&quot;Cosine Function&quot;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">ax2.grid(<span class="literal">True</span>)</span><br><span class="line">ax2.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()  <span class="comment"># 自动调整布局，避免标题/标签重叠</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="散点图scatter"><a href="#散点图scatter" class="headerlink" title="散点图scatter"></a>散点图scatter</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">x = rng.random(<span class="number">50</span>) * <span class="number">10</span> <span class="comment"># 50个[0,10)随机数</span></span><br><span class="line">y = <span class="number">2</span> * x + rng.standard_normal(<span class="number">50</span>) * <span class="number">2</span>  <span class="comment"># 带点噪声的直线</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="comment"># 绘制散点图</span></span><br><span class="line">sc = ax.scatter(</span><br><span class="line">    x, y,</span><br><span class="line">    s=<span class="number">80</span>,                <span class="comment"># 点大小，也可以根据值</span></span><br><span class="line">    c=x,                 <span class="comment"># 按x的值映射颜色</span></span><br><span class="line">    cmap=<span class="string">&quot;viridis&quot;</span>,      <span class="comment"># 颜色映射</span></span><br><span class="line">    alpha=<span class="number">0.8</span>,           <span class="comment"># 透明度</span></span><br><span class="line">    edgecolor=<span class="string">&quot;black&quot;</span>    <span class="comment"># 边框颜色</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 添加颜色条</span></span><br><span class="line">fig.colorbar(sc, ax=ax, label=<span class="string">&quot;X value&quot;</span>)</span><br><span class="line"><span class="comment"># 设置标题和坐标轴</span></span><br><span class="line">ax.set_title(<span class="string">&quot;Scatter Plot Example&quot;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;X&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h3><p>在实际中最常见的矩形图是<code>hist直方图</code>和<code>bar条形图</code></p><p>二者的区别：</p><ul><li><p><code>hist</code>：输入一堆数据，Matplotlib 自动分箱并统计</p></li><li><p><code>bar</code>：自己提供类别 + 数值，Matplotlib 直接画出来</p></li></ul><h4 id="直方图hist"><a href="#直方图hist" class="headerlink" title="直方图hist"></a>直方图hist</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">rng = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据(正态分布)</span></span><br><span class="line">data = rng.normal(loc=<span class="number">0</span>, scale=<span class="number">1</span>, size=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="comment"># 返回每个区间里的频数，分箱的边界以及每个柱子对应的矩形对象</span></span><br><span class="line">counts, bin_edges, patches = ax.hist(</span><br><span class="line">    data,</span><br><span class="line">    bins=<span class="number">40</span>,              <span class="comment"># 分箱数量</span></span><br><span class="line">    <span class="comment"># color=&#x27;skyblue&#x27;,    # 填充色，如果不后续填充</span></span><br><span class="line">    edgecolor=<span class="string">&#x27;black&#x27;</span>,    <span class="comment"># 边框色</span></span><br><span class="line">    alpha=<span class="number">0.7</span>,            <span class="comment"># 透明度</span></span><br><span class="line">    density=<span class="literal">False</span>,        <span class="comment"># 是否显示密度(False=频数)</span></span><br><span class="line">    label=<span class="string">&#x27;Data&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每个柱子，根据区间位置设置颜色</span></span><br><span class="line"><span class="keyword">for</span> count, edge_left, edge_right, patch <span class="keyword">in</span> <span class="built_in">zip</span>(counts, bin_edges[:-<span class="number">1</span>], bin_edges[<span class="number">1</span>:], patches):</span><br><span class="line">    <span class="comment"># 区间中心点</span></span><br><span class="line">    center = <span class="number">0.5</span> * (edge_left + edge_right)</span><br><span class="line">    <span class="keyword">if</span> center &gt;= <span class="number">0</span>:   <span class="comment"># 如果区间中心 &gt;= 0 → 染红</span></span><br><span class="line">        patch.set_facecolor(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:             <span class="comment"># 如果区间中心 &lt; 0 → 染蓝</span></span><br><span class="line">        patch.set_facecolor(<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&quot;Histogram Example&quot;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Value&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="条形图bar"><a href="#条形图bar" class="headerlink" title="条形图bar"></a>条形图bar</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别与数值</span></span><br><span class="line">categories = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]</span><br><span class="line">values = [<span class="number">23</span>, <span class="number">17</span>, <span class="number">35</span>, <span class="number">29</span>]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">bars = ax.bar(</span><br><span class="line">    x=np.arange(<span class="built_in">len</span>(categories)),  <span class="comment"># 类别位置 (0,1,2,3)</span></span><br><span class="line">    height=values,                 <span class="comment"># 对应的数值</span></span><br><span class="line">    color=<span class="string">&quot;orangered&quot;</span>, edgecolor=<span class="string">&quot;black&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 设置刻度标签</span></span><br><span class="line">ax.set_xticks(np.arange(<span class="built_in">len</span>(categories)))</span><br><span class="line">ax.set_xticklabels(categories)</span><br><span class="line"><span class="comment"># 添加标题与标签</span></span><br><span class="line">ax.set_title(<span class="string">&quot;Bar Chart Example&quot;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Category&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Value&quot;</span>)</span><br><span class="line"><span class="comment"># 在柱子上标注数值</span></span><br><span class="line"><span class="keyword">for</span> bar <span class="keyword">in</span> bars:</span><br><span class="line">    height = bar.get_height()</span><br><span class="line">    ax.text(bar.get_x() + bar.get_width()/<span class="number">2</span>, height,</span><br><span class="line">            <span class="string">f&quot;<span class="subst">&#123;height&#125;</span>&quot;</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="饼图pie"><a href="#饼图pie" class="headerlink" title="饼图pie"></a>饼图pie</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">sizes = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">25</span>]</span><br><span class="line">labels = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]</span><br><span class="line">colors = [<span class="string">&quot;skyblue&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;lightgreen&quot;</span>, <span class="string">&quot;pink&quot;</span>]</span><br><span class="line">explode = [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>]  <span class="comment"># 突出 B</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 画饼图</span></span><br><span class="line">ax.pie(</span><br><span class="line">    x=sizes,             <span class="comment"># 每个扇区的数值(自动归一化为百分比)</span></span><br><span class="line">    labels=labels,       <span class="comment"># 扇区对应的类别标签</span></span><br><span class="line">    colors=colors,       <span class="comment"># 每个扇区的颜色</span></span><br><span class="line">    explode=explode,     <span class="comment"># 控制扇区“突出”效果</span></span><br><span class="line">    autopct=<span class="string">&quot;%1.1f%%&quot;</span>,   <span class="comment"># 显示百分比</span></span><br><span class="line">    startangle=<span class="number">90</span>,       <span class="comment"># 从90度开始绘制</span></span><br><span class="line">    shadow=<span class="literal">True</span>          <span class="comment"># 添加阴影</span></span><br><span class="line">)</span><br><span class="line">ax.set_title(<span class="string">&quot;Pie Chart Example&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux学习</title>
      <link href="/posts/1123.html"/>
      <url>/posts/1123.html</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><ol><li><p>计算机由哪两个主要部分组成？</p><p>硬件和软件</p></li><li><p>操作系统是什么？有什么作用？</p><p>操作系统是软件的一类</p><p>主要作用是协助用户调度硬件工作，充当用户和计算机硬件之间的桥梁</p></li></ol><p>操作形式分为两种：</p><ol><li>图形化：和windows一样用鼠标操作</li><li>命令行（远程）</li></ol><p><font color='Violetred'>在Linux下命令行使用率更高，更好用</font></p><p>可以借助第三方软件FinalSHell命令行操作Linux</p><p>连接注意用户名，SSH服务设置，虚拟机网卡</p><h3 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h3><p>Linux的目录结构是一个树型结构</p><p>Windows系统可以拥有多个盘符，如C盘、D盘、E盘</p><p>Linux没有盘符这个概念，只有一个根目录<code>/</code>，所有文件都在它下面</p><ul><li>绝对路径：以根目录为起点，描述路径的一种写法，路径描述以<code>/</code>开头</li><li>相对路径：以当前目录为起点，描述路径的一种写法，路径描述无需以<code>/</code>开头</li></ul><h4 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h4><ul><li><code>.</code>：表示当前目录，比如cd.&#x2F;Desktop表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致</li><li><code>..</code>：表示上一级目录，比如cd..即可切换到上一级目录，cd ..&#x2F;..切换到上二级的目录</li><li><code>~</code>：表示HOME目录，比如：cd～即可切换到HOME目录或cd ~&#x2F;Desktop，切换到HOME内的Desktop目录</li></ul><h4 id="HOME目录"><a href="#HOME目录" class="headerlink" title="HOME目录"></a>HOME目录</h4><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p><ul><li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p></li><li><p>root用户的HOME目录，在：<code>/root</code></p></li></ul><p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>功能：列出文件夹信息</p><p>语法：<code>ls [-l -h -a] [参数]</code></p><ul><li><p>参数：被查看的文件夹，不提供参数，表示查看当前工作目录</p></li><li><p>-l：以列表（竖向排列）展示内容，显示更多信息</p></li><li><p>-h：以易于阅读的形式（必须与l一起使用，会显示文件大小单位KB之类的）</p></li><li><p>-a：显示隐藏内容</p></li></ul><p>在Linux中以<code>.</code>开头的，均是隐藏的</p><p>默认不显示出来，需要<code>-a</code>选项才可查看到</p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>功能：切换工作目录</p><p>语法：<code>cd [目标目录]</code></p><ul><li>cd命令无需选项，只有参数，表示要切换到哪个目录下</li><li>cd命令直接执行，不写参数，表示回到用户的HOME目录</li></ul><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>功能：展示当前工作目录</p><p>语法：<code>pwd</code></p><ul><li>无选项，无参数</li></ul><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>功能：创建文件夹</p><p>语法：<code>mkdir [-p] 参数</code></p><ul><li>参数：必填，被创建文件夹的路径，相对路径或绝对路径均可</li><li>选项：-p，可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li></ul><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>功能：创建文件</p><p>语法：<code>touch 参数</code></p><ul><li>参数：被创建的文件路径</li></ul><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>功能：查看文件内容</p><p>语法：<code>cat 参数</code></p><ul><li>参数：被查看的文件路径</li></ul><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>功能：查看文件，可以支持翻页查看</p><p>语法：<code>more 参数</code></p><ul><li>参数：被查看的文件路径</li><li><code>空格</code>键翻页；<code>q</code>退出查看</li></ul><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>功能：复制文件、文件夹</p><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li>参数1，被复制的</li><li>参数2，要复制去的地方</li><li>选项：-r，可选，复制文件夹使用，表示递归</li></ul><p>示例：</p><ul><li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li><li>cp a.txt test&#x2F;，复制当前目录a.txt到test文件夹内</li><li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li></ul><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>功能：移动文件、文件夹</p><p>语法：<code>mv 参数1 参数2</code></p><ul><li>参数1：被移动的</li><li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li></ul><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>功能：删除文件、文件夹</p><p>语法：<code>rm [-r -f] 参数...参数</code></p><ul><li>参数：支持多个，每一个表示被删除的，空格进行分隔</li><li>选项：-r，删除文件夹使用</li><li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li><li>参数1 参数2 ….. 参数N 表示要删除的文件或文件夹路径，空格隔开</li></ul><p>普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示</p><p>所以一般普通用户用不到-f选项</p><p>切换root用户:su - root</p><p>rm命令很危险，一定要注意，特别是切换到root用户的时候</p><p>rm命令支持通配符*，用来做模糊匹配</p><ul><li><code>test*</code> 匹配所有以字符串 <code>test</code> 开头的文件名</li><li><code>*test</code> 匹配所有以字符串 <code>test</code> 结尾的文件名</li><li><code>*test*</code> 匹配文件名中包含 “test” 的文件</li></ul><p>使用时需要<code>&quot;&quot;</code>括起来</p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>功能：查看命令的程序本体文件路径</p><p>语法：<code>which 参数</code></p><ul><li>参数：被查看的命令</li></ul><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>功能：搜索文件</p><p>按文件名查找：</p><p>语法：<code>find 路径 -name 参数</code></p><ul><li>路径，搜索的起始路径</li><li>参数，被查找的文件名，支持通配符*</li></ul><p>按文件大小查找：</p><p>语法：<code>find 路径 -size +|-n[kMG] </code></p><ul><li>+、-表示大于和小于</li><li>n表示大小数字</li><li>kMG表示大小单位，k（小写字母）表示kb，M表示MB，G表示GB</li></ul><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>功能：从文件中通过关键字过滤文件行</p><p>语法：<code>grep [-n] 关键字 文件路径</code></p><ul><li>选项-n，可选，表示在结果中显示匹配的行的行号</li><li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用<code>&quot;&quot;</code>将关键字包围起来</li><li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li></ul><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>功能：统计文件的行数、单词数量 </p><p>语法：<code>wc [-l -w -m -c] 文件路径</code></p><ul><li>选项，-l，统计行数</li><li>选项，-w，统计单词数量 </li><li>选项，-m，统计字符数量</li><li>选项，-c，统计bytes数量</li></ul><h4 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符|</h4><p>写法：<code>|</code></p><p>功能：将符号左边的结果，作为符号右边的输入</p><p>示例：</p><p><code>cat test.txt | grep A</code>，将cat test.txt的结果，作为grep命令的输入，用来过滤<code>A</code>关键字</p><p>可以支持嵌套：</p><p><code>cat test.txt | grep A | grep S</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git拉取上传代码</title>
      <link href="/posts/33349.html"/>
      <url>/posts/33349.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>打开项目，此时项目中是没有 .git 文件的</p></li><li><p>在【鼠标右击】弹出的菜单中，点击【Git Bash Here】</p></li><li><p>在命令窗口中输入：git init</p></li><li><p>在命令窗口中输入：git remote add origin (仓库地址) [相当于绑定仓库了]</p><p>输入：git branch -M main(仅第一次)</p></li><li><p>添加需要提交的文件：git add (目录下文件) or git add.</p></li><li><p>准备上传：git commit -m “备注信息”</p></li><li><p>提交上传请求：git push origin main</p></li></ol><p>以后上传只需要 5-7 步即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🛠️基础工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++演讲比赛管理系统</title>
      <link href="/posts/603975454.html"/>
      <url>/posts/603975454.html</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>比赛规则：</p><ul><li>学校举行一场演讲比赛，共有12个人参加，比赛共两轮，第一轮为淘汰赛，第二轮为决赛</li><li>每名选手都有对应的编号，如10001～10012</li><li>比赛方式：分组比赛，每组6个人</li><li>第一轮分为两个小组，整体按照选手编号进行抽签后顺序演讲</li><li>十个评委分别给每名选手打分，去除最高分和最低分，求的平均分为本轮选手的成绩</li><li>当小组演讲完后，淘汰组内排名最后的三个选手，前三名晋级，进入下一轮的比赛</li><li>第二轮为决赛，前三名胜出</li><li>每轮比赛过后需要显示晋级选手的信息</li></ul><p>程序功能：</p><ul><li>开始演讲比赛：完成整届比赛的流程，每个比塞阶段需要给用户一个提示，用户按任意键后继续下一个阶段</li><li>查看往届记录：查看之前比赛前三名结果，每次比赛都会记录到文件中，文件用.csv后缀名保存</li><li>清空比塞记录：将文件中数据清空</li><li>退出比赛程序：可以退出当前程序</li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>先创建speechManager类，将功能集成到类中</p><p>创建空构造和析构函数避免可能出现的报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPEECHMANAGER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPEECHMANAGER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">speechManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">speechManager</span>();</span><br><span class="line">    ~<span class="built_in">speechManager</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SPEECHMANAGER_H</span></span></span><br></pre></td></tr></table></figure><p>speechManager类中添加属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;one; <span class="comment">// 第一轮比赛编号</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;two; <span class="comment">// 第二轮比赛编号</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;victory; <span class="comment">// 冠亚季编号</span></span><br><span class="line">map&lt;<span class="type">int</span>,Speaker&gt; speaker; <span class="comment">// 存储选手信息</span></span><br><span class="line"><span class="type">int</span> Index; <span class="comment">// 比赛轮次</span></span><br><span class="line"><span class="type">bool</span> fileisempty; <span class="comment">// 判断文件是否为空</span></span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;string&gt;&gt; record; <span class="comment">// 存放往届记录的容器</span></span><br></pre></td></tr></table></figure><p>初始化代码写为一个函数，方便后续clear操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;one.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;two.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;victory.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;speaker.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;record.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;Index = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单功能"><a href="#菜单功能" class="headerlink" title="菜单功能"></a>菜单功能</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::showMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Welcome to Speech Manager&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;1. Start the speech contest&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;2. View the past record&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;3. Clear the record&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;0. Exit the system&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Press any key to continue: &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="退出功能"><a href="#退出功能" class="headerlink" title="退出功能"></a>退出功能</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::exitSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Welcome to the next use!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建选手"><a href="#创建选手" class="headerlink" title="创建选手"></a>创建选手</h2><p>先创建选手类，选手属性只有名字和得分，得分可能有两轮写为数组形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Speaker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Speaker</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Speaker</span>() = <span class="keyword">default</span>;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">double</span> score[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>speechManager类中添加创建函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::createSpeaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string name_tag = <span class="string">&quot;ABCDEFGHIJKL&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;name_tag.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        string name = <span class="string">&quot;Speaker&quot;</span>;</span><br><span class="line">        <span class="comment">// error: string name = &quot;Speaker&quot; + name_tag[i];</span></span><br><span class="line">        <span class="comment">// &quot;Speaker_&quot;是char*类型，name_tag[i]是char类型, 无法直接加</span></span><br><span class="line">        <span class="comment">// 进入string容器后+被重定义</span></span><br><span class="line">        name += name_tag[i];</span><br><span class="line">        Speaker sp;</span><br><span class="line">        sp.name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;one.<span class="built_in">push_back</span>(<span class="number">10001</span>+i);</span><br><span class="line">        <span class="keyword">this</span>-&gt;speaker.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">10001</span>+i, sp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><p>比赛流程为：第一轮抽签→评比分数→展示晋级→第二轮抽签→评比分数→展示成绩</p><p>然后将每部分实现即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::startspeech</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一轮比赛开始</span></span><br><span class="line">    <span class="comment">// 抽签</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">draw_lots</span>();</span><br><span class="line">    <span class="comment">// 比赛</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">speechcontest</span>();</span><br><span class="line">    <span class="comment">// 展示晋级成绩</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">showscore</span>();</span><br><span class="line">    <span class="comment">// 第二轮比赛开始</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Index++;</span><br><span class="line">    <span class="comment">// 抽签</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">draw_lots</span>();</span><br><span class="line">    <span class="comment">// 比赛</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">speechcontest</span>();</span><br><span class="line">    <span class="comment">// 展示晋级成绩</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">showscore</span>();</span><br><span class="line">    <span class="comment">// 保存分数到文件中</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">saverecord</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The speech contest is over!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 重置属性</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">reset</span>(); <span class="comment">// 少了这步会导致新完成的比赛读不到</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽签"><a href="#抽签" class="headerlink" title="抽签"></a>抽签</h3><p>把两轮的写到一个函数中，由Index来分类</p><p>抽签其实就是用shuffle函数打乱容器内元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::draw_lots</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Drawing of lots for round &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;Index &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The order as follow: &quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;Index == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">shuffle</span>(<span class="keyword">this</span>-&gt;one.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;one.<span class="built_in">end</span>(),</span><br><span class="line">            <span class="built_in">mt19937</span>(<span class="built_in">random_device</span>()())); <span class="comment">// 创建一个临时的 random_device 对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;one.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="keyword">this</span>-&gt;one[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="keyword">this</span>-&gt;one.<span class="built_in">size</span>()/<span class="number">2</span><span class="number">-1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;Index == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">shuffle</span>(<span class="keyword">this</span>-&gt;two.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;two.<span class="built_in">end</span>(),</span><br><span class="line">            <span class="built_in">mt19937</span>(<span class="built_in">random_device</span>()()));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; it : <span class="keyword">this</span>-&gt;two)</span><br><span class="line">            cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="评比分数"><a href="#评比分数" class="headerlink" title="评比分数"></a>评比分数</h3><p>由于第一轮第二轮每组比赛的人数都是6，可以写到一起</p><p>创建两个临时容器，一个用来存储成绩和编号键值对(成绩作为key方便排序)，另一个用来存储比赛人员的编号</p><p>根据Index的值来读取系统中存储的比赛人员编号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::speechcontest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;Round &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;Index &lt;&lt; <span class="string">&quot; speech contest started!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    multimap&lt;<span class="type">double</span>,<span class="type">int</span>,greater&lt;&gt;&gt; groupscore; <span class="comment">// 临时容器，存储成绩和编号</span></span><br><span class="line">    <span class="comment">// 成绩放在前面是为了方便排序</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>; <span class="comment">//记录人员数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v_Src; <span class="comment">// 比赛人员容器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;Index == <span class="number">1</span>)</span><br><span class="line">        v_Src = <span class="keyword">this</span>-&gt;one;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;Index == <span class="number">2</span>)</span><br><span class="line">        v_Src = <span class="keyword">this</span>-&gt;two;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = v_Src.<span class="built_in">begin</span>(); it != v_Src.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        deque&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i&lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="comment">// 评委打分</span></span><br><span class="line">            random_device rd;</span><br><span class="line">            <span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">            <span class="function">uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">60.0</span>, <span class="number">100.0</span>)</span></span>;</span><br><span class="line">            <span class="type">double</span> score = <span class="built_in">dist</span>(gen);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; score &lt;&lt; &quot;\t&quot;;</span></span><br><span class="line">            d.<span class="built_in">push_back</span>(score);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 去除最高分和最低分</span></span><br><span class="line">        d.<span class="built_in">pop_front</span>();</span><br><span class="line">        d.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 计算平均分</span></span><br><span class="line">        <span class="type">double</span> avg = <span class="built_in">accumulate</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">0.0</span>) / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(d.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// *it是编号，将avg存入对应成绩数组</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;speaker[*it].score[<span class="keyword">this</span>-&gt;Index<span class="number">-1</span>] = avg;</span><br><span class="line">        groupscore.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(avg, *it));</span><br><span class="line">        <span class="keyword">if</span> (num%<span class="number">6</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Rank of group &quot;</span> &lt;&lt; num/<span class="number">6</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt;endl;</span><br><span class="line">            <span class="comment">// 展示小组成绩</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; it : groupscore) &#123;</span><br><span class="line">                cout &lt;&lt; it.second &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">                cout &lt;&lt; <span class="keyword">this</span>-&gt;speaker[it.second].name&lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">                cout &lt;&lt; <span class="keyword">this</span>-&gt;speaker[it.second].score[<span class="keyword">this</span>-&gt;Index<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取出前三名</span></span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = groupscore.<span class="built_in">begin</span>();</span><br><span class="line">                it != groupscore.<span class="built_in">end</span>() &amp;&amp; count &lt; <span class="number">3</span> ; it++, count++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;Index==<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;two.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;Index==<span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;victory.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        groupscore.<span class="built_in">clear</span>();</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;Round &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;Index &lt;&lt; <span class="string">&quot; speech contest complete!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="展示分数"><a href="#展示分数" class="headerlink" title="展示分数"></a>展示分数</h3><p>第一轮晋级的取two容器中的内容，第二轮决赛的取victory容器中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::showscore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;Index &lt;&lt;<span class="string">&quot; round advanced contestants as follow: &quot;</span> &lt;&lt;endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v_Src;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;Index == <span class="number">1</span>) &#123;</span><br><span class="line">        v_Src = <span class="keyword">this</span>-&gt;two;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;Index == <span class="number">2</span>) &#123;</span><br><span class="line">        v_Src = <span class="keyword">this</span>-&gt;victory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp; it : v_Src) &#123;</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;speaker[it].name&lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;speaker[it].score[<span class="keyword">this</span>-&gt;Index<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保存记录"><a href="#保存记录" class="headerlink" title="保存记录"></a>保存记录</h3><p>添加头文件fstream，将结果写到csv文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::saverecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;speech.csv&quot;</span>, ios::out|ios::app);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : <span class="keyword">this</span>-&gt;victory) &#123;</span><br><span class="line">        ofs &lt;&lt; it &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;speaker[it].score[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ofs &lt;&lt; endl;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---- record save! ----&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看记录"><a href="#查看记录" class="headerlink" title="查看记录"></a>查看记录</h2><p>查看肯定要读取文件，这个时候又增加了标识符和新容器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> fileisempty; <span class="comment">// 判断文件是否为空</span></span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;string&gt;&gt; record; <span class="comment">// 存放往届记录的容器</span></span><br></pre></td></tr></table></figure><p>读取文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::loadrecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;speech.csv&quot;</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;fileisempty = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File does not exist!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ifs &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ifs.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;fileisempty = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File is empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ifs.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件不为空</span></span><br><span class="line">    fileisempty = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 将刚刚读的放回去</span></span><br><span class="line">    ifs.<span class="built_in">putback</span>(ch);</span><br><span class="line">    string data;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">1</span>; <span class="comment">// 第index届</span></span><br><span class="line">    <span class="keyword">while</span> (ifs&gt;&gt;data) &#123;</span><br><span class="line">        <span class="comment">// 当遇到换行符时会停止当前读取，将换行符留在输入流中</span></span><br><span class="line">        <span class="comment">// 下一次循环时会跳过换行符，读取下一行内容</span></span><br><span class="line">        vector&lt;string&gt; record; <span class="comment">// 创建存储空间,每次要清空</span></span><br><span class="line">        <span class="type">int</span> pos = <span class="number">-1</span>; <span class="comment">// 查,位置</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            pos = data.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>,start);</span><br><span class="line">            <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            string temp = data.<span class="built_in">substr</span>(start, pos-start);</span><br><span class="line">            start = pos<span class="number">+1</span>;</span><br><span class="line">            record.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;record.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(index,record));</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断文件是否为空，不为空则读取其中内容，并按键值读出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::showrecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;fileisempty) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File is empty or does exist!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; it : <span class="keyword">this</span>-&gt;record) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Result of No.&quot;</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot; speech contest:&quot;</span> &lt;&lt;endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; it.second.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                cout &lt;&lt; it.second[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                    cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="清空记录"><a href="#清空记录" class="headerlink" title="清空记录"></a>清空记录</h2><p>为了方便清空以及之前的一些刷新，新增reset函数</p><p>方便一些需要刷新内存的情况，比如完成一场比赛后如果不刷新会查询不到新的记录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">createSpeaker</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">loadrecord</span>();</span><br><span class="line">&#125;</span><br><span class="line">speechManager::<span class="built_in">speechManager</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">speechManager::clearrecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sure about deletion?&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1.yes\t2.no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> select;</span><br><span class="line">    cin &gt;&gt; select;</span><br><span class="line">    <span class="keyword">if</span> (select == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;speech.csv&quot;</span>,ios::trunc)</span></span>;</span><br><span class="line">        ofs.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">reset</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success delete!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;User cancle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 👨‍💻C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++职工管理系统</title>
      <link href="/posts/2426107671.html"/>
      <url>/posts/2426107671.html</url>
      
        <content type="html"><![CDATA[<p>对于一个职工管理系统：</p><p>公司中职工分为三类：普通员工、经理、老板，显示信息时，需要显示职工编号、职工姓名、职工岗位</p><p>管理系统中需要实现的功能如下：</p><ul><li>退出管理程序：退出当前管理系统</li><li>增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号</li><li>显示职工信息：显示公司内部所有职工的信息</li><li>删除离职职工：按照编号删除指定的职工</li><li>修改职工信息：按照编号修改职工个人信息</li><li>查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息</li><li>按照编号排序：按照职工编号，进行排序，排序规则由用户指定</li><li>清空所有文档：清空文件中记录的所有职工信息（清空前需要再次确认，防止误册）</li></ul><h2 id="函数框架"><a href="#函数框架" class="headerlink" title="函数框架"></a>函数框架</h2><p>在main函数中仅调用，实现通过头文件导入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;WorkerManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WorkerManager wm;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        wm.<span class="built_in">Show_Menu</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter your choice: &quot;</span>;</span><br><span class="line">        cin &gt;&gt; choice;</span><br><span class="line">        <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                wm.<span class="built_in">Add_Emp</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                wm.<span class="built_in">Show_Emp</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                wm.<span class="built_in">Del_Emp</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                wm.<span class="built_in">Mod_Emp</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                wm.<span class="built_in">Find_Emp</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                wm.<span class="built_in">Sort_Emp</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                wm.<span class="built_in">Clear_Emp</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                wm.<span class="built_in">ExitSystem</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Invalid Choice.&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><p>在管理系统中，我们需要记录的是员工数量，<font color='Violetred'>存放员工信息的指针数组</font>，并且判断存储文件是否为空的标识符，同时需要构建各个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WORKERMANAGER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORKERMANAGER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once <span class="comment">// 确保头文件只被编译一次</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Worker.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILENAME <span class="string">&quot;empFile.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WorkerManager</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show_Menu</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ExitSystem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add_Emp</span><span class="params">()</span></span>;    <span class="comment">// 添加员工</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span></span>;       <span class="comment">// 保存结果</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_Empnum</span><span class="params">()</span></span>;  <span class="comment">// 获取文件中员工数目</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init_Emp</span><span class="params">()</span></span>;   <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show_Emp</span><span class="params">()</span></span>;   <span class="comment">// 展示内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Del_Emp</span><span class="params">()</span></span>;    <span class="comment">// 删除</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">IsExist_Emp</span><span class="params">(<span class="type">int</span> id)</span></span>; <span class="comment">// 判断是否存在</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mod_Emp</span><span class="params">()</span></span>;    <span class="comment">// 修改员工内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Find_Emp</span><span class="params">()</span></span>;   <span class="comment">// 查找</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sort_Emp</span><span class="params">()</span></span>;   <span class="comment">// 排序</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear_Emp</span><span class="params">()</span></span>;  <span class="comment">// 清空</span></span><br><span class="line">    ~<span class="built_in">WorkerManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_EmpNum;</span><br><span class="line">    Worker ** m_Emparray; <span class="comment">// 重点，指针数组</span></span><br><span class="line">    <span class="type">bool</span> m_FileIsEmpty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于有多种员工，所以员工分别写成类，并且多态</p><p>但统一的属性是一样的，名字，Id，部门(Id)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WORKER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORKER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once <span class="comment">// 确保头文件只被编译一次</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Worker</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Id;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_DeptId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//WORKER_H</span></span></span><br></pre></td></tr></table></figure><p>展示信息和获取部门名称对于不同的员工不一样，函数写为虚函数，Worker成为抽象类</p><p>员工分为三种，Staff，Manager，Boss</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STAFF_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAFF_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once <span class="comment">// 确保头文件只被编译一次</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Worker.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Staff</span> :<span class="keyword">public</span> Worker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Staff</span>(<span class="type">int</span> id, string name, <span class="type">int</span> DeptId);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>先导入Worker头文件，创建Staff继承Worker，然后重写虚函数</p><p>在具体类中实现信息展示以及构建函数，方便后续new开辟</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Staff.h&quot;</span></span></span><br><span class="line">Staff::<span class="built_in">Staff</span>(<span class="type">int</span> id, string name, <span class="type">int</span> DeptId) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_DeptId = DeptId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Staff::showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Id: &quot;</span> &lt;&lt; m_Id;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\tName: &quot;</span> &lt;&lt; m_Name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\tPost: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getDeptName</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Staff::getDeptName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Staff&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Manager和Boss写法类似</p><p>至此可以在main中测试能否分别产生三种类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test code</span></span><br><span class="line"><span class="comment">Worker *worker = new Staff(1, &quot;John&quot;, 1);</span></span><br><span class="line"><span class="comment">worker-&gt;showInfo();</span></span><br><span class="line"><span class="comment">delete worker;</span></span><br><span class="line"><span class="comment">worker = new Manager(2, &quot;Ben&quot;, 2);</span></span><br><span class="line"><span class="comment">worker-&gt;showInfo();</span></span><br><span class="line"><span class="comment">delete worker;</span></span><br><span class="line"><span class="comment">worker = new Boss(3, &quot;Alice&quot;, 3);</span></span><br><span class="line"><span class="comment">worker-&gt;showInfo();</span></span><br><span class="line"><span class="comment">delete worker;*/</span></span><br></pre></td></tr></table></figure><p>使用virtual后产生一个虚函数指针vfptr能够通过父类指针或引用指向子类对象</p><h3 id="目录函数"><a href="#目录函数" class="headerlink" title="目录函数"></a>目录函数</h3><p>最简单的一步，只需要写提示内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Show_Menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Welcome to the WorkerManager System&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;***** 0.Exit &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;***** 1.Add Worker Information &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;***** 2.Show Worker Information &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;***** 3.Delete Worker Information &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;***** 4.Modify Worker Information &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;***** 5.Find Worker Information &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;***** 6.Sort Worker Information &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;***** 7.Clear All Information &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main中每次触发结束后都会重新展示以上内容</p><h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><p>同理只要退出系统提示，但要在函数中加上exit(0)，代表退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::ExitSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Welcome to the next use!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>为了让结果保存，不会每次重新启动程序就为空，先使用fstream输出</p><p>在WorkerManager.h 中定义 #define FILENAME “empFile.txt”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(FILENAME,ios::out);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++) &#123;</span><br><span class="line">        ofs &lt;&lt; <span class="keyword">this</span>-&gt;m_Emparray[i]-&gt;m_Id &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">this</span>-&gt;m_Emparray[i]-&gt;m_Name &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">this</span>-&gt;m_Emparray[i]-&gt;m_DeptId &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使得指针数组中的内容被读入文件中并保存</p><h3 id="获取已有员工数"><a href="#获取已有员工数" class="headerlink" title="获取已有员工数"></a>获取已有员工数</h3><p>既然文件能够被保存，在启动前需要读取文件内容，来获取已有的员工数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WorkerManager::get_Empnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(FILENAME,ios::in);</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> DeptId;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; DeptId) &#123;</span><br><span class="line">        num ++;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取后返回已有员工数</p><h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h3><p>将文件中的内容用于系统初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::init_Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(FILENAME,ios::in);</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> DeptId;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; DeptId)</span><br><span class="line">    &#123;</span><br><span class="line">        Worker * worker = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (DeptId == <span class="number">1</span>) &#123;</span><br><span class="line">            worker = <span class="keyword">new</span> <span class="built_in">Staff</span>(id,name,DeptId);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DeptId == <span class="number">2</span>) &#123;</span><br><span class="line">            worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(id,name,DeptId);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DeptId == <span class="number">3</span>) &#123;</span><br><span class="line">            worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(id,name,DeptId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Emparray[index] = worker;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先创建一个Worker *的空指针，因为要根据不同类型new</p><p>最后将new出来的地址存入指针数组中</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>将刚刚的内容集成到构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">WorkerManager::<span class="built_in">WorkerManager</span>() &#123;</span><br><span class="line">    <span class="comment">// 文件不存在</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(FILENAME,ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File not found, initialize&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Emparray = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">        ifs.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ifs &gt;&gt; ch;</span><br><span class="line">    <span class="comment">// 文件存在数据为空</span></span><br><span class="line">    <span class="keyword">if</span> (ifs.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Emparray = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">        ifs.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="keyword">this</span> -&gt; <span class="built_in">get_Empnum</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The EmpNum in File: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_EmpNum = num;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Emparray = <span class="keyword">new</span> Worker*[<span class="keyword">this</span>-&gt;m_EmpNum];</span><br><span class="line">    <span class="comment">// 将文件数据存入数组</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">init_Emp</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断文件是否存在，不存在让m_FileIsEmpty为true，并且人数为0，数组指针指向null，return跳出，同理文件存在但数据为空</p><p>如果不为空则计算已有人数，然后new Worker*数组 出来用于初始化存储指针地址；</p><p>可以在构造函数底部增加测试代码判断是否能够正常读取文件中已有的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test code</span></span><br><span class="line"><span class="comment"> for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) &#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;Id:&quot; &lt;&lt; this-&gt;m_Emparray[i]-&gt;m_Id</span></span><br><span class="line"><span class="comment">    &lt;&lt; &quot; Name:&quot; &lt;&lt; this-&gt;m_Emparray[i]-&gt;m_Name</span></span><br><span class="line"><span class="comment">    &lt;&lt; &quot; dId:&quot; &lt;&lt; this-&gt;m_Emparray[i]-&gt;m_DeptId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><h2 id="增加职工"><a href="#增加职工" class="headerlink" title="增加职工"></a>增加职工</h2><p>刚刚已经完成了文件保存以及系统数据初始化的过程，接下来要实现系统的第一个功能增加职工</p><p>需要考虑增加多少人，数量是否合法，合法后输入员工的信息，注意Id是区别员工的唯一标志(因为名字可能同名)，所以在输入Id后需要判断这个Id是否已经存在，存在则跳出重新输入</p><p>在这个过程中需要开辟一块新的指针数组空间，用于存放新的指针数组，将原来的拷贝过去后再增加内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Add_Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the number of Employee: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> addNum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; addNum;</span><br><span class="line">    <span class="keyword">if</span> (addNum &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> newEmpNum = <span class="keyword">this</span>-&gt;m_EmpNum + addNum;</span><br><span class="line">        <span class="keyword">auto</span> ** newSpace = <span class="keyword">new</span> Worker*[newEmpNum]; <span class="comment">// 动态分配一个指针数组</span></span><br><span class="line">        <span class="comment">// 将原来空间数据拷贝到新空间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Emparray!= <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++) &#123;</span><br><span class="line">                newSpace[i] = <span class="keyword">this</span>-&gt;m_Emparray[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加新数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; addNum; i++) &#123;</span><br><span class="line">            <span class="type">int</span> id;</span><br><span class="line">            string name;</span><br><span class="line">            <span class="type">int</span> dSelect;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Enter &quot;</span> &lt;&lt; i<span class="number">+1</span> &lt;&lt; <span class="string">&quot;th new Employee ID: &quot;</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; id;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsExist_Emp</span>(id)!=<span class="number">-1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Employee ID already exists, please try again&quot;</span> &lt;&lt; endl;</span><br><span class="line">                i -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Enter &quot;</span> &lt;&lt; i<span class="number">+1</span> &lt;&lt; <span class="string">&quot;th new Employee Name: &quot;</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; name;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Enter &quot;</span> &lt;&lt; i<span class="number">+1</span> &lt;&lt; <span class="string">&quot;th new Employee Post: &quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;1.Staff&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;2.Manager&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;3.Boss&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; dSelect;</span><br><span class="line">            Worker *worker = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">switch</span> (dSelect) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: worker = <span class="keyword">new</span> <span class="built_in">Staff</span>(id,name,dSelect);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(id,name,dSelect);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(id,name,dSelect);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将创建的指针保存到数组中</span></span><br><span class="line">            newSpace[<span class="keyword">this</span>-&gt;m_EmpNum+i] = worker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_Emparray;   <span class="comment">// 释放原有指针数组空间</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Emparray = newSpace; <span class="comment">// 更新新空间指向</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_EmpNum = newEmpNum;  <span class="comment">// 更新新员工数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Successfullu Add &quot;</span>&lt;&lt; addNum &lt;&lt; <span class="string">&quot; New Workers &quot;</span> &lt;&lt;endl;</span><br><span class="line">        <span class="comment">// 保存数据</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">save</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error num&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断员工是否存在"><a href="#判断员工是否存在" class="headerlink" title="判断员工是否存在"></a>判断员工是否存在</h3><p>根据Id搜索判断这个员工是否存在，以-1作为不存在的值，遍历指针数组中的内容，找到具体的索引值返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WorkerManager::IsExist_Emp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Emparray[i]-&gt;m_Id == id) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="展示内容"><a href="#展示内容" class="headerlink" title="展示内容"></a>展示内容</h2><p>比较复杂和重要的功能在刚刚都已经开发好了，后续只要调用即可</p><p>先判断文件内容是否为空，然后多态调用类的成员函数showInfo()，遍历指针数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Show_Emp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断文件是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File is empty or does not exist! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++) &#123;</span><br><span class="line">            <span class="comment">// 利用多态调用</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Emparray[i]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h2><p>先找到这个员工存不存在，存在的话让其后续的指针数组整体往前移一位，整体记录的人员数减1即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Del_Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File is empty or does not exist! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please enter Worker Id&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        cin &gt;&gt; id;</span><br><span class="line">        <span class="type">int</span> index = <span class="keyword">this</span>-&gt;<span class="built_in">IsExist_Emp</span>(id);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>) <span class="comment">// 职工存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum<span class="number">-1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;m_Emparray[i] = <span class="keyword">this</span>-&gt;m_Emparray[i<span class="number">+1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_EmpNum--; <span class="comment">// 记录人员个数减1</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">save</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Successfully Delete &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Worker does not exist! &quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h2><p>修改其实类似添加，需要先找到Id所在的索引，然后重新输入，把new的新地址覆盖原来指针数组在索引位置的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Mod_Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File is empty or does not exist! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please enter Worker Id&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        cin &gt;&gt; id;</span><br><span class="line">        <span class="type">int</span> index = <span class="keyword">this</span>-&gt;<span class="built_in">IsExist_Emp</span>(id);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_Emparray[index];</span><br><span class="line">            <span class="type">int</span> newId;</span><br><span class="line">            string newName;</span><br><span class="line">            <span class="type">int</span> newDeptId;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Find this worker, please enter new information\nnew Id: &quot;</span>;</span><br><span class="line">            cin &gt;&gt; newId;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new Name: &quot;</span>;</span><br><span class="line">            cin &gt;&gt; newName;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new DeptId: &quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;1.Staff&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;2.Manager&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;3.Boss&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; newDeptId;</span><br><span class="line">            Worker *worker = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">switch</span> (newDeptId) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    worker = <span class="keyword">new</span> <span class="built_in">Staff</span>(id,newName,newDeptId);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(id,newName,newDeptId);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(id,newName,newDeptId);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Emparray[index] = worker;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Successfully Modified id: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Worker does not exist! &quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">save</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找功能"><a href="#查找功能" class="headerlink" title="查找功能"></a>查找功能</h2><p>查找方式分为两种，一种是Id索引，和刚刚的IsExist_Emp相同，调用即可，另一种是根据名字，需要遍历内容，最后使用类的成员函数info信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Find_Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File is empty or does not exist! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please choose the method:&quot;</span>&lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1.Find Worker Id&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2.Find Worker Name&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> select;</span><br><span class="line">        cin &gt;&gt; select;</span><br><span class="line">        <span class="keyword">if</span> (select == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> id;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Please enter Worker Id: &quot;</span>;</span><br><span class="line">            cin &gt;&gt; id;</span><br><span class="line">            <span class="type">int</span> index = <span class="keyword">this</span>-&gt;<span class="built_in">IsExist_Emp</span>(id);</span><br><span class="line">            <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Successfully find this worker, the information as follow:&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">this</span>-&gt;m_Emparray[index]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Worker does not exist! &quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            string name;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Please enter Worker Name: &quot;</span>;</span><br><span class="line">            cin &gt;&gt; name;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Emparray[i]-&gt;m_Name == name) &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;m_Emparray[i]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Worker does not exist! &quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;The error choice! &quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序功能"><a href="#排序功能" class="headerlink" title="排序功能"></a>排序功能</h2><p>排序Id采用了选择排序法(也可以冒泡，但是选择排序相比冒泡我感觉更直观)</p><p>选择排序方式，升序或者降序，从第0个排序到第Num-1个，最后一个不用排序了</p><ul><li>每次从未排序部分选出最大(小)元素</li><li>将其放到已排序序列的末尾</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Sort_Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File is empty or does not exist! &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please choose sort method:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1.Ascending order&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2.Descending order&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> select;</span><br><span class="line">        cin &gt;&gt; select;</span><br><span class="line">        <span class="keyword">if</span> (select != <span class="number">1</span> &amp;&amp; select != <span class="number">2</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error choice! &quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> minormax = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; <span class="keyword">this</span>-&gt;m_EmpNum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Emparray[minormax]-&gt;m_Id &gt; <span class="keyword">this</span>-&gt;m_Emparray[j]-&gt;m_Id)</span><br><span class="line">                        minormax = j;</span><br><span class="line">                <span class="keyword">if</span> (select == <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Emparray[minormax]-&gt;m_Id &lt; <span class="keyword">this</span>-&gt;m_Emparray[j]-&gt;m_Id)</span><br><span class="line">                        minormax = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i!=minormax) &#123;</span><br><span class="line">                Worker *temp = <span class="keyword">this</span>-&gt;m_Emparray[i];</span><br><span class="line">                <span class="keyword">this</span>-&gt;m_Emparray[i] = <span class="keyword">this</span>-&gt;m_Emparray[minormax];</span><br><span class="line">                <span class="keyword">this</span>-&gt;m_Emparray[minormax] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Successfully sorted! &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">save</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Show_Emp</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="清空功能"><a href="#清空功能" class="headerlink" title="清空功能"></a>清空功能</h2><p>清除函数，一是要让文件内容清空重新创建，采用ios::trunc可以实现，二是要清除原来开辟的区域，并且让人数置0，空文件标识改为true</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Clear_Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Are you sure want to clear?&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1.Yes\t2.No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> select;</span><br><span class="line">    cin &gt;&gt; select;</span><br><span class="line">    <span class="keyword">if</span> (select == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">ofstream <span class="title">ofs</span><span class="params">(FILENAME,ios::trunc)</span></span>; <span class="comment">// 删除后重新创建文件</span></span><br><span class="line">        ofs.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Emparray!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_Emparray[i];</span><br><span class="line">                <span class="keyword">this</span>-&gt;m_Emparray[i] = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_Emparray;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Emparray = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Successfully cleared! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数和clear函数相同，但是不删除数据，只释放内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WorkerManager::~<span class="built_in">WorkerManager</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Emparray != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Emparray[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_Emparray[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> [] <span class="keyword">this</span>-&gt;m_Emparray;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Emparray = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 👨‍💻C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS2理论</title>
      <link href="/posts/3894864178.html"/>
      <url>/posts/3894864178.html</url>
      
        <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>VScode配置模板</p><p>cpp：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ROS2 C++ Node Template&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ros2cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  需求:&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  步骤:&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;    1.包含头文件；&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;    2.初始化 ROS2 客户端；&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;    3.定义节点类；&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;    &quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;    4.调用spin函数,并传入节点对象指针;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;    5.释放资源。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;*/&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;// 1.包含头文件；&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;#include \&quot;rclcpp/rclcpp.hpp\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;// 3.自定义节点类&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;class $&#123;1:MyNode&#125;: public rclcpp::Node&#123; &quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;public:&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;    $1():Node(\&quot;mynode_node_cpp\&quot;)&#123;  // 节点名称一般小写&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;        RCLCPP_INFO(this-&gt;get_logger(),\&quot;创建成功!\&quot;);&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;    &#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;&#125;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;int main(int argc, char ** argv)&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  // 2.初始化 ROS2 客户端；&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  rclcpp::init(argc,argv);&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  // 4.调用spin函数,并传入节点类对象;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  rclcpp::spin(std::make_shared&lt;$1&gt;()); &quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  // 5.释放资源。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  rclcpp::shutdown();&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  return 0;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A cpp file template&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>launch.py：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ROS2 Launch Template&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ros2_launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;from launch import LaunchDescription&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;from launch_ros.actions import Node&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;def generate_launch_description():&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;    return LaunchDescription([])&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A template for ROS2 launch files&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在ROS2中：</p><ul><li>节点创建方法设为public</li><li>内部组件(publisher&#x2F;subscriber等)设为private</li></ul><p>ROS 组件通常加下划线后缀表示成员变量(client_)，节点实例常用简单名称表示主要对象(client)</p><p><strong>常见函数：</strong></p><p><code>std::bind(&amp;MyNode::Fuc,this,_[i])</code>绑定成员函数</p><ul><li>第一个参数表示对象的成员函数的指针 </li><li>第二个参数表示对象的地址 </li><li>后面为输入参数留空 <code>using std::placeholders::_[i]</code></li></ul><p><code>std::make_shared&lt;MyNode&gt;()</code>创建节点指针</p><ul><li>&lt;&gt;内为节点类型</li><li>返回值为<code>std::shared_ptr</code>类型对象</li></ul><p><font color='Violetred'>注意，创建函数的时候<code>SharedPtr</code> 已经代表指针，不要带&amp;</font></p><p><code>using namespace std::placeholders</code> 实现函数占位符</p><p><code>using namespace std::chrono_literals</code> 可以直接输入时间</p><p>C++ lambda函数：匿名函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><h2 id="ROS2概述与环境搭建"><a href="#ROS2概述与环境搭建" class="headerlink" title="ROS2概述与环境搭建"></a>ROS2概述与环境搭建</h2><h3 id="ROS2简介"><a href="#ROS2简介" class="headerlink" title="ROS2简介"></a>ROS2简介</h3><p>整个ROS生态由通信（Plumbing）、工具（Tools）、功能（Capabilities）与社区（Community）四大部分组成</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/ROS%E7%BB%84%E6%88%90%E4%BD%93%E7%B3%BB.png" alt="ROS组成体系"></p><p>ROS2是全新一代机器人操作系统，不只是功能增强的ROS1</p><p>本文档采用的是ROS2的humble版本，运行在Linux（Ubuntu 22.04）操作系统上</p><h3 id="ROS2对比ROS"><a href="#ROS2对比ROS" class="headerlink" title="ROS2对比ROS"></a>ROS2对比ROS</h3><p>ROS 1：围绕一个集中式的 ROS Master 节点构建，它负责节点发现、注册、连接建立（主题、服务、动作服务器&#x2F;客户端）和参数服务器。节点间通信主要使用 <strong>TCPROS&#x2F;UDPROS</strong> 等自定义协议</p><p>ROS 2：采用完全去中心化的设计，它基于数据分发服务 (DDS) 标准作为其默认的中间件。DDS 本身就是一个成熟、标准化、去中心化的发布&#x2F;订阅框架，内置了丰富的服务质量和发现机制</p><p>ROS2移除 Master 消除了单点故障，构建系统从Catkin→Ament &#x2F; Colcon</p><h3 id="ROS2安装"><a href="#ROS2安装" class="headerlink" title="ROS2安装"></a>ROS2安装</h3><p>虚拟机部分转ROS文档</p><p>安装Ubuntu后需要把当前用户设为管理员，否则sudo会失败</p><p>大致步骤如下：</p><ol><li>准备1：设置语言环境；</li><li>准备2：启动Ubuntu universe存储库；</li><li>设置软件源；</li><li>安装ROS2；</li><li>配置环境。</li></ol><p><strong>准备1：设置语言环境</strong></p><p>请先检查本地语言环境是否支持UTF-8编码，可调用如下指令检查并设置UTF-8编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">locale  # 检查是否支持 UTF-8</span><br><span class="line">sudo apt update &amp;&amp; sudo apt install locales</span><br><span class="line">sudo locale-gen en_US en_US.UTF-8</span><br><span class="line">sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8</span><br><span class="line">export LANG=en_US.UTF-8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：语言环境可以不同，但必须支持UTF-8编码</p><p><strong>准备2：启动Ubuntu universe存储库</strong></p><p>打开软件与更新(Software &amp; Updates)窗口，确保启动了universe存储库，以保证可以下载”社区维护的免费和开源软件“</p><p>下载自可以改为清华源</p><p><strong>设置软件源</strong></p><p>先将ROS 2 apt存储库添加到系统，用apt授权的GPG密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install curl gnupg lsb-release</span><br><span class="line">sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg</span><br></pre></td></tr></table></figure><p>然后将存储库添加到源列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null</span><br></pre></td></tr></table></figure><p><strong>安装ROS2</strong></p><p>首先更新apt存储库缓存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>然后升级已安装的软件(ROS2软件包建立在经常更新的Ubuntu系统上，在安装新软件包之前请确保系统是最新的)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>安装桌面版ROS2(建议)，包含ROS、RViz、示例与教程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-humble-desktop</span><br></pre></td></tr></table></figure><p>过程中可能会报错，安装工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install aptitude </span><br><span class="line">sudo aptitude install xxx  # 根据方案来解决安装报错问题</span><br></pre></td></tr></table></figure><p><strong>配置环境</strong></p><p>终端下，执行ROS2程序时，需要调用如下命令配置环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/humble/setup.bash</span><br></pre></td></tr></table></figure><p>每次新开终端时，都得执行上述命令，或者将配置环境指令写入 ”~&#x2F;.bashrc“ 文件，则以后新开终端不再需要手动配置环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/humble/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p>安装测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node</span><br><span class="line">ros2 run turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p><strong>安装colcon构建工具</strong></p><p>colcon是一个命令行工具，用于改进编译，测试和使用多个软件包的工作流程</p><p>安装命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-colcon-common-extensions</span><br></pre></td></tr></table></figure><p>安装完colcon之后，就可以在ROS2中编写应用程序了</p><p><strong>运行优化</strong></p><p>每次终端中执行工作空间下的节点时，都需要调用<code>. install/setup.bash</code>指令，使用不便，可以将该指令的调用添加进<code>~/setup.bash</code>，操作格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /&#123;工作空间路径&#125;/install/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="ROS2集成开发环境"><a href="#ROS2集成开发环境" class="headerlink" title="ROS2集成开发环境"></a>ROS2集成开发环境</h3><p>在刚刚的过程会发现ubuntu频繁需要密码，打开terminal，输入seahorse</p><p>右键Login更改密码，将新密码设为空即可</p><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><p>在 ROS 中，需要频繁的使用到终端，且可能需要同时开启多个窗口，推荐使用<strong>Terminator</strong></p><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install terminator</span><br></pre></td></tr></table></figure><p>常用快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Alt+Up                          //移动到上面的终端</span><br><span class="line">Alt+Down                        //移动到下面的终端</span><br><span class="line">Alt+Left                        //移动到左边的终端</span><br><span class="line">Alt+Right                       //移动到右边的终端</span><br><span class="line">Ctrl+Shift+O                    //水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端</span><br></pre></td></tr></table></figure><h4 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h4><p>不要下Ubuntu software里的，可能无法输入中文</p><p>去官网下deb文件，下载后在终端中打开，输入命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i xxxx.deb</span><br></pre></td></tr></table></figure><p>vscode 下载插件：Chinese，C++，CMake，Cmake Tools，Python，Msg Language Support，URDF，vscode-pdf，YAML，XML</p><p>快捷键配置：向上向下复制行；向上向下移动</p><p><a href="https://blog.csdn.net/qq_38463737/article/details/125505154">VS Code设置打开新窗口不覆盖前窗口</a></p><p><a href="https://blog.csdn.net/qq_70703397/article/details/129281455">VSCode设置自动保存</a></p><p>在VSCode中，cpp文件中的<code>#include &quot;rclcpp/rclcpp.hpp&quot;</code>包含语句会抛出异常，这是因为没有设置VSCode配置文件中 includepath属性，可以按照如下步骤解决此问题：</p><ol><li>将鼠标移到错误提示语句，此时会出现弹窗；</li><li>点击弹窗中的快速修复，会有新的弹窗，再点击<code>编辑&quot;includePath&quot;设置</code>；</li><li>在新页面中，包含路径属性对应的文本域中，换行输入被包含的路径<code>/opt/ros/humble/include/**</code></li></ol><h4 id="git"><a href="#git" class="headerlink" title="git"></a>git</h4><p>安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><p>在本教程中会经常使用<code>git clone 仓库地址</code>的方式来将Git仓库拷贝到本地</p><h4 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h4><p>可以通过编译指令<code>colcon</code>和ROS2内置的工具指令<code>ros2</code>来实现功能包的创建、编译、查找与执行等相关操作</p><blockquote><p><code>colcon</code> 是官方推荐的构建工具，<code>CMake</code> 是底层的构建系统</p></blockquote><p><strong>创建</strong></p><p>新建功能包语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create [包名] --build-type [构建类型] --dependencies [依赖列表] --node-name [可执行程序名称]</span><br></pre></td></tr></table></figure><p>格式解释：</p><ul><li>–build-type：是指功能包的构建类型，有cmake、ament_cmake(c++)、ament_python(python)三种类型可选；</li><li>–dependencies：所依赖的功能包列表，空格分割多个功能包；</li><li>–node-name：可执行程序的名称，会自动生成对应的源文件并生成配置文件</li></ul><p><strong>编译</strong></p><p>编译功能包语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br><span class="line">colcon build --packages-select [功能包列表]</span><br></pre></td></tr></table></figure><p>前者会构建工作空间下的所有功能包，后者可以构建指定功能包</p><p>编译后刷新环境变量才可以执行（如果在.bashrc文件中已经添加则不需要）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. install/setup.bash</span><br></pre></td></tr></table></figure><blockquote><p>从ROS1的<code>source ./devel/setup.bash</code> -&gt; . install&#x2F;setup.bash</p></blockquote><p><strong>查找</strong></p><p>在<code>ros2 pkg</code>命令下包含了多个查询功能包相关信息的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg executables ([包名]) # 输出所有功能包或指定功能包下的可执行程序。</span><br><span class="line">ros2 pkg list # 列出所有功能包</span><br><span class="line">ros2 pkg prefix [包名] # 列出功能包路径</span><br><span class="line">ros2 pkg xml # 输出功能包的package.xml内容</span><br></pre></td></tr></table></figure><p><strong>执行</strong></p><p>执行命令语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run [功能包] [可执行程序] [参数]</span><br></pre></td></tr></table></figure><h3 id="ROS2体系框架"><a href="#ROS2体系框架" class="headerlink" title="ROS2体系框架"></a>ROS2体系框架</h3><h4 id="ROS2文件系统"><a href="#ROS2文件系统" class="headerlink" title="ROS2文件系统"></a>ROS2文件系统</h4><p>立足系统架构，ROS2可以划分为三层</p><p><strong>操作系统层（OS Layer）</strong></p><p>ROS虽然称之为机器人操作系统，但实质只是构建机器人应用程序的软件开发工具包，ROS必须依赖于传统意义的操作系统</p><p><strong>中间层（Middleware Layer）</strong></p><p>主要由数据分发服务DDS与ROS2封装的关于机器人开发的中间件组成。DDS是一种去中心化的数据通讯方式，ROS2还引入了服务质量管理 （Quality of Service）机制，借助该机制可以保证在某些较差网络环境下也可以具备良好的通讯效果。ROS2中间件则主要由客户端库、DDS抽象层与进程内通讯API构成</p><p><strong>应用层（Application Layer）</strong></p><p>指开发者构建的应用程序，在应用程序中是以功能包为核心的，在功能包中可以包含源码、数据定义、接口等内容</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/1.5.1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.webp" alt="1.5.1文件系统"></p><p>对于一般开发者而言，工作内容主要集中在应用层，开发者一般通过实现具有某一特定功能的功能包来构建机器人应用程序</p><p>功能包是ROS2应用程序的核心，但是功能包不能直接构建，必须依赖于工作空间，一个ROS2工作空间的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">WorkSpace --- 自定义的工作空间。</span><br><span class="line">    |--- build：存储中间文件的目录，该目录下会为每一个功能包创建一个单独子目录。</span><br><span class="line">    |--- install：安装目录，该目录下会为每一个功能包创建一个单独子目录。</span><br><span class="line">    |--- log：日志目录，用于存储日志文件。</span><br><span class="line">    |--- src：用于存储功能包源码的目录。</span><br><span class="line">        |-- C++功能包</span><br><span class="line">            |-- package.xml：包信息，比如:包名、版本、作者、依赖项。</span><br><span class="line">            |-- CMakeLists.txt：配置编译规则，比如源文件、依赖项、目标文件。</span><br><span class="line">            |-- src：C++源文件目录。</span><br><span class="line">            |-- include：头文件目录。</span><br><span class="line">            |-- msg：消息接口文件目录。</span><br><span class="line">            |-- srv：服务接口文件目录。</span><br><span class="line">            |-- action：动作接口文件目录。</span><br><span class="line">        |-- Python功能包</span><br><span class="line">            |-- package.xml：包信息，比如:包名、版本、作者、依赖项。</span><br><span class="line">            |-- setup.py：与C++功能包的CMakeLists.txt类似。</span><br><span class="line">            |-- setup.cfg：功能包基本配置文件。</span><br><span class="line">            |-- resource：资源目录。</span><br><span class="line">            |-- test：存储测试相关文件。</span><br><span class="line">            |-- 功能包同名目录：Python源文件目录。</span><br></pre></td></tr></table></figure><p>无论是Python功能包还是C++功能包，都可以自定义一些配置文件相关的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-- C++或Python功能包</span><br><span class="line">    |-- launch：存储launch文件。</span><br><span class="line">    |-- rviz：存储rviz2配置相关文件。</span><br><span class="line">    |-- urdf：存储机器人建模文件。</span><br><span class="line">    |-- params：存储参数文件。</span><br><span class="line">    |-- world：存储仿真环境相关文件。</span><br><span class="line">    |-- map：存储导航所需地图文件。</span><br><span class="line">    |-- ......</span><br></pre></td></tr></table></figure><h5 id="源文件说明"><a href="#源文件说明" class="headerlink" title="源文件说明"></a>源文件说明</h5><p>无论是C++实现还是Python实现，都是直接实例化的Node对象</p><p>更推荐以继承Node的方式来创建节点对象</p><p>C++继承Node实现示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">newNode</span>: <span class="keyword">public</span> rclcpp::Node&#123; <span class="comment">// newNode继承ROS2节点基类</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 公共访问区域</span></span><br><span class="line">    <span class="built_in">newNode</span>():<span class="built_in">Node</span>(<span class="string">&quot;node_name&quot;</span>)&#123; <span class="comment">// 调用父类Node构造函数newNode()</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;hello world!&quot;</span>); <span class="comment">// this 是指向当前对象实例的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc,argv); <span class="comment">// ROS2初始化</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;newNode&gt;(); <span class="comment">// 创建类实例,()内传参</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>(); <span class="comment">// 资源清理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python继承Node实现示例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">newNode</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&quot;node_name_py&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.get_logger().info(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    rclpy.init()</span><br><span class="line">    node = newNode() </span><br><span class="line">    rclpy.shutdown()</span><br></pre></td></tr></table></figure><p>之所以继承比直接实例化Node更被推荐，是因为继承方式可以在一个进程内组织多个节点，这对于提高节点间的通信效率是很有帮助的，但是直接实例化则与该功能不兼容</p><p><strong>初始化与资源释放在程序中起什么作用？</strong></p><ol><li><p>前提：构建的程序可能由若干步骤或阶段组成</p><p>初始化–&gt;节点对象–日志输出–&gt;数据的发布—&gt;数据订阅–&gt;…–&gt;资源释放</p></li><li><p>不同步骤或阶段之间涉及到数据的传递</p></li><li><p>使用context(上下文)对象进行数据传递，这是一个容器，可以存储数据，也可以从中读取数据</p></li><li><p>初始化其实就是要创建context对象，资源释放就是要销毁context对象</p></li></ol><h5 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h5><p>C++功能包的构建信息主要包含在package.xml与CMakeLists.txt中</p><p>Python功能包的构建信息则主要包含在package.xml和setup.py中</p><p><strong>package.xml</strong></p><p>不管是何种类型的功能包，package.xml的格式都是类似的，在该文件中包含了包名、版本、作者、依赖项的信息，可以为colcon构建工具确定功能包的编译顺序</p><p>一个简单的package.xml示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-model href=<span class="string">&quot;http://download.ros.org/schema/package_format3.xsd&quot;</span> schematypens=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>pkg01_helloworld_cpp<span class="tag">&lt;/<span class="name">name</span>&gt;</span> 包名</span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> 包的版本号</span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span> 包的描述信息</span><br><span class="line">  <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;[联系者邮箱]&quot;</span>&gt;</span>ros2<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span> 维护者信息</span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO: License declaration<span class="tag">&lt;/<span class="name">license</span>&gt;</span> 软件协议</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_auto<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_common<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build_type</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">build_type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>package：根标签，format属性用来声明文件的格式版本</p><p>依赖项：</p><ul><li><p>buildtool_depend：声明编译工具依赖；</p></li><li><p>build_depend：声明编译依赖；</p></li><li><p>build_export_depend：声明根据此包构建库所需依赖；</p></li><li><p>exec_depend：声明执行时依赖；</p><blockquote><p>build_depend，build_export_depend，exec_depend很多时候是一样的</p></blockquote></li><li><p>depend：相当于<build_depend>、<build_export_depend>、<exec_depend>三者的集成；</p></li><li><p>test_depend：声明测试依赖；</p></li><li><p>doc_depend：声明构建文档依赖</p></li></ul><p><strong>CMakeLists.txt</strong></p><p>C++功能包中需要配置CMakeLists.txt文件，该文件描述了如何构建C++功能包</p><p>一个简单的CMakeLists.txt示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 声明cmake的最低版本</span><br><span class="line">cmake_minimum_required(VERSION 3.8)</span><br><span class="line"># 包名，需要与package.xml中的包名一致</span><br><span class="line">project(pkg01_helloworld_cpp)</span><br><span class="line"></span><br><span class="line">if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES &quot;Clang&quot;)</span><br><span class="line">  add_compile_options(-Wall -Wextra -Wpedantic)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"># find dependencies</span><br><span class="line">find_package(ament_cmake REQUIRED)</span><br><span class="line"># 引入外部依赖包</span><br><span class="line">find_package(rclcpp REQUIRED)</span><br><span class="line"></span><br><span class="line"># 映射源文件与可执行文件</span><br><span class="line">add_executable(helloworld src/helloworld.cpp)</span><br><span class="line"># 设置目标依赖库</span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  helloworld</span><br><span class="line">  &quot;rclcpp&quot;</span><br><span class="line">)</span><br><span class="line"># 定义安装规则</span><br><span class="line">install(TARGETS helloworld</span><br><span class="line">  DESTINATION lib/$&#123;PROJECT_NAME&#125;)</span><br><span class="line"></span><br><span class="line">if(BUILD_TESTING)</span><br><span class="line">  find_package(ament_lint_auto REQUIRED)</span><br><span class="line">  # the following line skips the linter which checks for copyrights</span><br><span class="line">  # comment the line when a copyright and license is added to all source files</span><br><span class="line">  set(ament_cmake_copyright_FOUND TRUE)</span><br><span class="line">  # the following line skips cpplint (only works in a git repo)</span><br><span class="line">  # comment the line when this package is in a git repo and when</span><br><span class="line">  # a copyright and license is added to all source files</span><br><span class="line">  set(ament_cmake_cpplint_FOUND TRUE)</span><br><span class="line">  ament_lint_auto_find_test_dependencies()</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">ament_package()</span><br></pre></td></tr></table></figure><p><strong>setup.py</strong></p><p>Python功能包中需要配置setup.py文件，该文件描述了如何构建Python功能包</p><p>一个简单的setup.py示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">package_name = <span class="string">&#x27;pkg02_helloworld_py&#x27;</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=package_name, <span class="comment"># 包名</span></span><br><span class="line">    version=<span class="string">&#x27;0.0.0&#x27;</span>,   <span class="comment"># 版本</span></span><br><span class="line">    packages=[package_name], <span class="comment"># 功能包列表</span></span><br><span class="line">    data_files=[ <span class="comment">#需要被安装的文件以及安装路径</span></span><br><span class="line">        (<span class="string">&#x27;share/ament_index/resource_index/packages&#x27;</span>,</span><br><span class="line">            [<span class="string">&#x27;resource/&#x27;</span> + package_name]),</span><br><span class="line">        (<span class="string">&#x27;share/&#x27;</span> + package_name, [<span class="string">&#x27;package.xml&#x27;</span>]),</span><br><span class="line">    ],</span><br><span class="line">    install_requires=[<span class="string">&#x27;setuptools&#x27;</span>], <span class="comment"># 安装依赖</span></span><br><span class="line">    zip_safe=<span class="literal">True</span>,</span><br><span class="line">    maintainer=<span class="string">&#x27;ros2&#x27;</span>, <span class="comment"># 维护者</span></span><br><span class="line">    maintainer_email=<span class="string">&#x27;ros2@todo.todo&#x27;</span>, <span class="comment"># 维护者 email</span></span><br><span class="line">    description=<span class="string">&#x27;TODO: Package description&#x27;</span>, <span class="comment"># 包描述</span></span><br><span class="line">    license=<span class="string">&#x27;TODO: License declaration&#x27;</span>, <span class="comment"># 软件协议</span></span><br><span class="line">    tests_require=[<span class="string">&#x27;pytest&#x27;</span>], <span class="comment"># 测试依赖</span></span><br><span class="line">    entry_points=&#123;</span><br><span class="line">        <span class="string">&#x27;console_scripts&#x27;</span>: [</span><br><span class="line">            <span class="comment"># 映射源文件与可执行文件</span></span><br><span class="line">            <span class="string">&#x27;helloworld = pkg02_helloworld_py.helloworld:main&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>所以不建议修改包名</p><h4 id="ROS2核心模块"><a href="#ROS2核心模块" class="headerlink" title="ROS2核心模块"></a>ROS2核心模块</h4><p><strong>通信模块</strong></p><p><strong>功能包</strong></p><p>安装方式：</p><ul><li><p>二进制安装</p><p>ROS官方或社区提供的功能包可以很方便的通过二进制方式安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-[ROS2版本代号]-[功能包名称]</span><br></pre></td></tr></table></figure><blockquote><p>可以调用<code>apt search ros-ROS2版本代号-* | grep -i [关键字]</code>格式的命令，根据关键字查找所需的功能包</p></blockquote></li><li><p>源码安装</p><p>一般从github获取源码，下载命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [仓库地址]</span><br></pre></td></tr></table></figure><p>源码下载后，需要自行编译</p></li></ul><p><strong>分布式</strong></p><p>ROS2是一个分布式架构，不同的ROS2设备之间可以方便的实现通信，这在多机器人设备协同中是极其重要的</p><p><strong>终端命令与rqt</strong></p><p>rqt是一个图形化工具，它的功能与命令行工具类似，但是图形化的交互方式更为友好</p><p><strong>launch文件</strong></p><p>通过launch文件，可以批量的启动ROS2节点，这是在构建大型项目时启动多节点的常用方式</p><p><strong>TF坐标变换</strong></p><p>TF坐标变换可以实现机器人不同部件或不同机器人之间的相对位置关系的转换</p><p><strong>可视化</strong></p><p>ROS2内置了三维可视化工具rviz2，它可以图形化的方式显示机器人模型或显示机器人系统中的一些抽象数据</p><h4 id="ROS2技术支持"><a href="#ROS2技术支持" class="headerlink" title="ROS2技术支持"></a>ROS2技术支持</h4><p><a href="https://docs.ros.org/en/humble/">ROS 2 文档 — ROS 2 文档：Humble 文档</a></p><h4 id="ROS2应用方向"><a href="#ROS2应用方向" class="headerlink" title="ROS2应用方向"></a>ROS2应用方向</h4><p><strong>NAV2</strong></p><p>Nav2项目继承自ROS Navigation Stack。该项目旨在可以让移动机器人从A点安全的移动到B点。它也可以应用于涉及机器人导航的其他应用，例如跟随动态点。Nav2将用于实现路径规划、运动控制、动态避障和恢复行为等一系列功能</p><p><strong>OpenCV</strong></p><p><a href="https://opencv.org/">OpenCV</a>（Open Source Computer Vision Library）是一个开源的计算机视觉和机器学习软件库。OpenCV旨在为计算机视觉应用程序提供通用基础架构，并加速机器感知在商业产品中的使用。OpenCV允许企业轻松地使用和修改代码</p><p><strong>MoveIt</strong></p><p><a href="https://moveit.ros.org/">MoveIt</a>是一组ROS软件包， 主要包含运动规划、碰撞检测、运动学、3D感知、操作控制等功能。它可以用于构建机械臂的高级行为。MoveIt现在可以用于市面上的大多数机械臂，并被许多大公司使用</p><p><strong>The Autoware Foundation</strong></p><p><a href="https://www.autoware.org/">Autoware Foundation</a>是ROS下属的非营利组织，支持实现自动驾驶的开源项目。Autoware基金会在企业发展和学术研究之间创造协同效应，为每个人提供自动驾驶技术</p><p><strong>F1 Tenth</strong></p><p><a href="https://f1tenth.org/">F1 Tenth</a>是将模型车改为无人车的竞速赛事，是一个由研究人员、工程师和自主系统爱好者组成的国际社区。它最初于 2016 年在宾夕法尼亚大学成立，但后来扩展到全球许多其他机构</p><p><strong>microROS</strong></p><p>在基于ROS的机器人应用中，<a href="https://micro.ros.org/">micro-ROS</a>正在弥合性能有限的微控制器和一般处理器之间的差距。micro-ROS在各种嵌入式硬件上运行，使ROS能直接应用于机器人硬件</p><p><strong>Open Robotics</strong></p><p><a href="https://www.openrobotics.org/">Open Robotics</a>与全球ROS社区合作，为机器人创建开放的软件和硬件平台，包括 ROS1、ROS2、Gazebo模拟器和Ignition模拟器。Open Robotics使用这些平台解决一些重要问题，并通过为各种客户组织提供软件和硬件开发服务来帮助其他人做同样的事情。</p><p><strong>PX4</strong></p><p><a href="https://px4.io/">PX4</a>是一款用于无人机和其他无人驾驶车辆的开源飞行控制软件。该项目为无人机开发人员提供了一套灵活的工具，用于共享技术并为无人机应用程序创建量身定制解决方案</p><h2 id="ROS2通信机制核心"><a href="#ROS2通信机制核心" class="headerlink" title="ROS2通信机制核心"></a>ROS2通信机制核心</h2><h3 id="通信机制简介"><a href="#通信机制简介" class="headerlink" title="通信机制简介"></a>通信机制简介</h3><p><strong>节点</strong></p><p>在通信时，不论采用何种方式，通信对象的构建都依赖于节点(Node)，在ROS2中，一般情况下每个节点都对应某一单一的功能模块</p><p>一个完整的机器人系统可能由许多协同工作的节点组成，ROS2中的单个可执行文件(C++程序或Python程序)可以包含一个或多个节点</p><p><strong>话题</strong></p><p>话题(Topic)是一个纽带，具有相同话题的节点可以关联在一起，这正是通信的前提。ROS2是跨语言的，只要二者使用了相同的话题，就可以实现数据的交互。</p><p><strong>通信模型</strong></p><p>在ROS2中，常用的通信模型有四种：</p><ol><li>话题通信：是一种单向通信模型，在通信双方中，发布方发布数据，订阅方订阅数据，数据流单向的由发布方传输到订阅方</li><li>服务通信：是一种基于请求响应的通信模型，在通信双方中，客户端发送请求数据到服务端，服务端响应结果给客户端</li><li>动作通信：是一种带有连续反馈的通信模型，在通信双方中，客户端发送请求数据到服务端，服务端响应结果给客户端，但是在服务端接收到请求到产生最终响应的过程中，会发送连续的反馈信息到客户端</li><li>参数服务：是一种基于共享的通信模型，在通信双方中，服务端可以设置数据，而客户端可以连接服务端并操作服务端数据</li></ol><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-06-30_22-06-00.webp" alt="Snipaste_2025-06-30_22-06-00"></p><p><strong>接口</strong></p><p>在通信过程中，需要传输数据，就必然涉及到数据载体，即要以特定格式传输数据</p><p>在ROS2中，数据载体称之为接口(interfaces)，通信时使用的数据载体一般需要使用接口文件定义</p><p>常用的接口文件有三种：msg文件、srv文件与action文件，每种文件都可以按照一定格式定义特定数据类型的“变量”</p><ul><li><p>msg文件</p><p>用于定义话题通信中数据载体的接口文件，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int64 num1</span><br><span class="line">int64 num2</span><br></pre></td></tr></table></figure><p>在文件中声明了一些被传输的变量数据</p></li><li><p>srv文件</p><p>用于定义服务通信中数据载体的接口文件，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 num1</span><br><span class="line">int64 num2</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure><p>文件中声明的数据被<code>---</code>分割为两部分，上半部分用于声明请求数据，下半部分用于声明响应数据</p></li><li><p>action文件</p><p>用于定义动作通信中数据载体的接口文件，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int64 num</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br><span class="line">---</span><br><span class="line">float64 progress</span><br></pre></td></tr></table></figure><p>文件中声明的数据被<code>---</code>分割为三部分，上半部分用于声明请求数据，中间部分用于声明响应数据，下半部分用于声明连续反馈数据</p></li></ul><p>可以使用的字段类型有：</p><ul><li>int8, int16, int32, int64 (或者无符号类型: uint*)</li><li>float32, float64</li><li>string</li><li>time, duration</li><li>其他msg文件</li><li>变长数组和定长数组</li></ul><p>ROS中还有一种特殊类型：<code>Header</code>，标头包含时间戳和ROS2中常用的坐标帧信息，许多接口文件的第一行包含<code>Header</code>标头</p><p><font color='Violetred'>参数通信的数据无需定义接口文件</font>，参数通信时数据会被封装为参数对象，参数客户端和服务端操作的都是参数对象</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>请先创建工作空间<code>ws01_plumbing</code>，本章以及第3章代码部分内容存储在该工作空间下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ws01_plumbing/src</span><br><span class="line">cd ws01_plumbing/src</span><br><span class="line">colcon build</span><br></pre></td></tr></table></figure></li><li><p>实际应用中一般建议创建专门的接口功能包定义接口文件，当前教程也遵循这一建议，预先创建教程所需使用的接口功能包</p><blockquote><p>需要注意的是，目前为止无法在Python功能包中定义接口文件</p></blockquote><p>终端下进入工作空间的<code>src</code>目录，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake [base_interfaces]</span><br></pre></td></tr></table></figure><p>该功能包将用于保存本章教程中自定义的接口文件</p></li></ol><p><font color='Violetred'>注意</font>：功能包可以在vscode里创建，但是工作空间建议在终端先创建好，再用vscode打开</p><h3 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h3><p>话题通信是ROS中使用频率最高的一种通信模式，话题通信是基于<strong>发布订阅</strong>模式</p><blockquote><p>一个节点发布消息，另一个节点订阅该消息</p></blockquote><p>像雷达、摄像头、GPS…. 等等传感器数据的采集都是使用话题通信</p><p>数据发布对象称为发布方，数据订阅对象称之为订阅方，发布方和订阅方通过话题相关联，消息的流向是单向的</p><p>话题通信的发布方与订阅方是一种多对多的关系，这意味着数据会出现交叉传输的情况</p><p><font color='Violetred'>可以通过<code>rqt</code>命令查看话题之间的关系</font></p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/2.2话题通信模型2 (1).gif" alt="2.2话题通信模型2 (1)" style="zoom: 80%;" /><blockquote><p>与ROS1不同的是，现在不需要master了，不存在master挂了整个系统崩溃的情况</p></blockquote><p><font color='Violetred'>话题通信一般应用于不断更新的、少逻辑处理的数据传输场景</font></p><p>关于消息接口的使用有多种方式：</p><ol><li>在ROS2中通过std_msgs包封装了一些原生的数据类型，这些原生数据类型也可以作为话题通信的载体，不过这些数据一般只包含一个 data 字段，而std_msgs包中其他的接口文件也比较简单，结构的单一意味着功能上的局限性，当传输一些结构复杂的数据时，就显得力不从心了；</li><li>在ROS2中还预定义了许多标准话题消息接口，这在实际工作中有着广泛的应用，比如：sensor_msgs包中定义了许多关于传感器消息的接口（雷达、摄像头、点云……），geometry_msgs包中则定义了许多几何消息相关的接口（坐标点、坐标系、速度指令……）；</li><li>如果上述接口文件都不能满足需求，那么就可以自定义接口消息；</li></ol><h4 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h4><p>需求1：编写话题通信实现，发布方以某个频率发布一段文本，订阅方订阅消息，并输出在终端</p><p>需求2：编写话题通信实现，发布方以某个频率发布自定义接口消息，订阅方订阅消息，并输出在终端</p><p>需求1和需求2的主要区别在于消息载体，前者可以使用原生的数据类型，后者需要自定义接口消息</p><p>终端下进入工作空间的src目录，调用命令分别创建C++功能包和Python功能包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create cpp01_topic --build-type ament_cmake --dependencies rclcpp std_msgs base_interfaces [--node-name demo01_talker]</span><br><span class="line">ros2 pkg create py01_topic --build-type ament_python --dependencies rclpy std_msgs base_interfaces [--node-name demo01_talker_str_py]</span><br></pre></td></tr></table></figure><blockquote><p>对比ros1好处：CMakeList里自动配置，python现在依赖的setup.py也会自动配置</p><p>本笔记不记录python，只针对C++进行学习</p></blockquote><h4 id="原生消息"><a href="#原生消息" class="headerlink" title="原生消息"></a>原生消息</h4><p><strong>发布方实现</strong></p><p>功能包cpp01_topic的src目录下</p><p>demo01_talker_str.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  需求：以某个固定频率发送文本“hello world!”，文本后缀编号，每发送一条消息，编号递增1。</span></span><br><span class="line"><span class="comment">  步骤：</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1.创建发布方；</span></span><br><span class="line"><span class="comment">      3-2.创建定时器；</span></span><br><span class="line"><span class="comment">      3-3.组织消息并发布。</span></span><br><span class="line"><span class="comment">    4.调用spin函数，并传入节点对象指针；</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals; <span class="comment">// 可以直接输入时间单位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义类节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Talker</span>: <span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Talker</span>():<span class="built_in">Node</span>(<span class="string">&quot;talker_node_cpp&quot;</span>),<span class="built_in">count</span>(<span class="number">0</span>)&#123; <span class="comment">// 调用基类构造函数设置节点名</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;发布节点创建！&quot;</span>);</span><br><span class="line">    <span class="comment">// 3-1.创建发布方；</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      模板：被发布的消息类型；</span></span><br><span class="line"><span class="comment">      &lt;&gt;内为消息类型</span></span><br><span class="line"><span class="comment">      参数:</span></span><br><span class="line"><span class="comment">        1.话题名称;</span></span><br><span class="line"><span class="comment">        2.QOS(消息队列长度）</span></span><br><span class="line"><span class="comment">      返回值：发布对象指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;std_msgs::msg::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 3-2.创建定时器；</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">      1.时问间隔;-&gt; 引入 using namespace std::chrono_literals</span></span><br><span class="line"><span class="comment">      2.回调函数;</span></span><br><span class="line"><span class="comment">    返回值：定时器对象指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">1</span>s,std::<span class="built_in">bind</span>(&amp;Talker::on_timer,<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    std::bind()</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">      1.要绑定的函数指针（&amp;Talker::on_timer）</span></span><br><span class="line"><span class="comment">      2.调用该函数的对象（this当前节点）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">on_timer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 3-3.组织消息并发布</span></span><br><span class="line">    <span class="keyword">auto</span> message =std_msgs::msg::<span class="built_in">String</span>();</span><br><span class="line">    message.data = <span class="string">&quot;hello world!&quot;</span>+std::<span class="built_in">to_string</span>(count++);</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;发布方数据:%s&quot;</span>,message.data.<span class="built_in">c_str</span>());</span><br><span class="line">    publisher_-&gt;<span class="built_in">publish</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line">  rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr publisher_;</span><br><span class="line">  rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数，并传入节点类对象；</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;Talker&gt;()); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>订阅方实现</strong></p><p>功能包cpp01_topic的src目录下</p><p>demo02_listener_str.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    需求：订阅发布方发布的消息，并输出到终端。</span></span><br><span class="line"><span class="comment">    步骤：</span></span><br><span class="line"><span class="comment">        1.包含头文件；</span></span><br><span class="line"><span class="comment">        2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">        3.定义节点类；</span></span><br><span class="line"><span class="comment">            3-1.创建订阅方；</span></span><br><span class="line"><span class="comment">            3-2.处理订阅到的消息。</span></span><br><span class="line"><span class="comment">        4.调用spin函数，并传入节点对象指针；</span></span><br><span class="line"><span class="comment">        5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1; <span class="comment">// 引入函数参数占位符</span></span><br><span class="line"><span class="comment">// 可以直接使用 _1 和 _2 代替冗长的 std::placeholders::_1</span></span><br><span class="line"><span class="comment">// _1 表示新函数对象的第一个参数 _2 表示新函数对象的 第二个参数 以此类推</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.定义节点类；</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Listener</span>: <span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Listener</span>(): <span class="built_in">Node</span>(<span class="string">&quot;listener_node_cpp&quot;</span>)&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;订阅方创建！&quot;</span>);</span><br><span class="line">        <span class="comment">// 3-1.创建订阅方；</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            模板：消息类型;</span></span><br><span class="line"><span class="comment">            参数:</span></span><br><span class="line"><span class="comment">                1.话题名称;</span></span><br><span class="line"><span class="comment">                2.QOS，队列长度；</span></span><br><span class="line"><span class="comment">            返回值：订阅对象指针</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        subcription_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;std_msgs::msg::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">10</span>,</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;Listener::do_cb,<span class="keyword">this</span>,_1));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_cb</span><span class="params">(<span class="type">const</span> std_msgs::msg::String &amp;msg)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 3-2.解析并输出数据</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;订阅的消息：&#x27;%s&#x27;&quot;</span>,msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr subcription_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">    <span class="comment">// 4.调用spin函数，并传入节点对象指针</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;Listener&gt;());</span><br><span class="line">    <span class="comment">// 5.释放资源；</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMakeLists.txt中发布和订阅程序核心配置如下，注意增加listener部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo01_talker_str src/demo01_talker_str.cpp)</span><br><span class="line">add_executable(demo02_listener_str src/demo02_listener_str.cpp)</span><br><span class="line"></span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  demo01_talker_str</span><br><span class="line">  &quot;rclcpp&quot;</span><br><span class="line">  &quot;std_msgs&quot;</span><br><span class="line">)</span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  demo02_listener_str</span><br><span class="line">  &quot;rclcpp&quot;</span><br><span class="line">  &quot;std_msgs&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">install(TARGETS </span><br><span class="line">  demo01_talker_str</span><br><span class="line">  demo02_listener_str</span><br><span class="line">  DESTINATION lib/$&#123;PROJECT_NAME&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>CMakeLists配置包括<code>add_executable</code>、<code>ament_target_dependencies</code>、<code>install</code>三部分</p></blockquote><p><strong>编译</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select cpp01_topic</span><br></pre></td></tr></table></figure><h4 id="配置接口消息"><a href="#配置接口消息" class="headerlink" title="配置接口消息"></a>配置接口消息</h4><p><strong>创建并编辑 .msg 文件</strong></p><p>功能包base_interfaces下新建 msg 文件夹，msg文件夹下新建Student.msg文件，文件中输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string   name</span><br><span class="line">int32    age</span><br><span class="line">float64  height</span><br></pre></td></tr></table></figure><p><strong>编辑配置文件</strong></p><p>在package.xml中需要添加一些依赖包</p><blockquote><p>不用特别记忆，调用<code>ros2 pkg list | grep -i rosidl</code></p><p><code>rosidl</code> 是 ROS 2 的核心组件，代表了ROS 接口定义语言</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编译依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 执行依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明当前包所属的功能包组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 删除部分</span></span><br><span class="line"><span class="comment">&lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt;</span></span><br><span class="line"><span class="comment">&lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>为了将<code>.msg</code>文件转换成对应的C++和Python代码，还需要在CMakeLists.txt中添加如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加依赖</span><br><span class="line">find_package(rosidl_default_generators REQUIRED)</span><br><span class="line"></span><br><span class="line"># 为接口文件生成源码</span><br><span class="line">rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;</span><br><span class="line">  &quot;msg/Student.msg&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>编译功能包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select base_interfaces</span><br></pre></td></tr></table></figure><p>编译完成之后，在工作空间下的nstall目录下将生成<code>Student.msg</code>文件对应的C++和Python文件</p><p><strong>测试</strong></p><p>通过如下命令查看文件定义以及编译是否正常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. install/setup.bash</span><br><span class="line">ros2 interface show base_interfaces/msg/Student</span><br></pre></td></tr></table></figure><p>正常情况下，终端将会输出与<code>Student.msg</code>文件一致的内容</p><h4 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h4><p><strong>准备</strong></p><p>C++文件中包含自定义消息相关头文件时，可能会抛出异常，可以配置VSCode中c_cpp_properties.json文件，在文件中的 includePath属性下添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;workspaceFolder&#125;/install/base_interfaces/include/**</span><br></pre></td></tr></table></figure><p>其他接口文件或接口包的使用也与此同理</p><p><strong>修改配置文件</strong></p><p>package.xml无需修改，CMakeLists.txt文件需要修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo03_talker_stu src/demo03_talker_stu.cpp)</span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  demo03_talker_stu</span><br><span class="line">  &quot;rclcpp&quot;</span><br><span class="line">  &quot;std_msgs&quot;</span><br><span class="line">  &quot;base_interfaces&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_executable(demo04_listener_stu src/demo04_listener_stu.cpp)</span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  demo04_listener_stu</span><br><span class="line">  &quot;rclcpp&quot;</span><br><span class="line">  &quot;std_msgs&quot;</span><br><span class="line">  &quot;base_interfaces&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">install(TARGETS </span><br><span class="line">  demo01_talker_str</span><br><span class="line">  demo02_listener_str</span><br><span class="line">  demo03_talker_stu</span><br><span class="line">  demo04_listener_stu</span><br><span class="line">  DESTINATION lib/$&#123;PROJECT_NAME&#125;)</span><br></pre></td></tr></table></figure><p><strong>发布方实现</strong></p><p>功能包cpp01_topic的src目录下</p><p>demo03_talker_stu.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  需求：以某个固定频率发送文本学生信息，包含学生的姓名、年龄、身高等数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_interfaces/msg/student.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals; <span class="comment">// 可以直接输入时间单位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义类节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TalkerStu</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TalkerStu</span>():<span class="built_in">Node</span>(<span class="string">&quot;talkerstu_node_cpp&quot;</span>),<span class="built_in">count</span>(<span class="number">0</span>)&#123; <span class="comment">// 调用基类构造函数设置节点</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;发布节点创建！&quot;</span>);</span><br><span class="line">    <span class="comment">// 3-1.创建发布方；</span></span><br><span class="line">    publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;base_interfaces::msg::Student&gt;(<span class="string">&quot;chatter_stu&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 3-2.创建定时器；</span></span><br><span class="line">    timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">1</span>s,std::<span class="built_in">bind</span>(&amp;TalkerStu::on_timer,<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">on_timer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 3-3.组织消息并发布</span></span><br><span class="line">    <span class="keyword">auto</span> stu = base_interfaces::msg::<span class="built_in">Student</span>();</span><br><span class="line">    stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    stu.age = count++;</span><br><span class="line">    stu.height = <span class="number">1.65</span>;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;学生信息:name=%s,age=%d,height=%.2f&quot;</span>,</span><br><span class="line">    stu.name.<span class="built_in">c_str</span>(),stu.age,stu.height);</span><br><span class="line">    publisher_-&gt;<span class="built_in">publish</span>(stu);</span><br><span class="line">  &#125;</span><br><span class="line">  rclcpp::Publisher&lt;base_interfaces::msg::Student&gt;::SharedPtr publisher_;</span><br><span class="line">  rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数，并传入节点类对象；</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;TalkerStu&gt;()); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>订阅方实现</strong></p><p>功能包cpp01_topic的src目录下</p><p>demo04_listener_stu.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    需求：订阅发布方发布的学生消息，并输出到终端。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_interfaces/msg/student.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1; <span class="comment">// 表示&quot;这里保留一个位置，实际参数将在调用时传入&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.定义节点类；</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListenerStu</span>: <span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ListenerStu</span>(): <span class="built_in">Node</span>(<span class="string">&quot;listenerstu_node_cpp&quot;</span>)&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;订阅方创建！&quot;</span>);</span><br><span class="line">        <span class="comment">// 3-1.创建订阅方；</span></span><br><span class="line">        subcription_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;base_interfaces::msg::Student&gt;(<span class="string">&quot;chatter_stu&quot;</span>,<span class="number">10</span>,</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;ListenerStu::do_cb,<span class="keyword">this</span>,_1));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_cb</span><span class="params">(<span class="type">const</span> base_interfaces::msg::Student &amp;stu)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 3-2.解析并输出数据</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;订阅的学生消息:name=%s,age=%d,height=%.2f&quot;</span>,</span><br><span class="line">        stu.name.<span class="built_in">c_str</span>(),stu.age,stu.height);</span><br><span class="line">    &#125;</span><br><span class="line">    rclcpp::Subscription&lt;base_interfaces::msg::Student&gt;::SharedPtr subcription_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">    <span class="comment">// 4.调用spin函数，并传入节点对象指针</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;ListenerStu&gt;());</span><br><span class="line">    <span class="comment">// 5.释放资源；</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行即可</p><h3 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h3><p>服务通信也是ROS中一种极其常用的通信模式，服务通信是基于<strong>请求响应</strong>模式的，是一种应答机制</p><blockquote><p>一个节点A向另一个节点B发送请求，B接收处理请求并产生响应结果返回给A</p></blockquote><p>服务通信更适用于对实时性有要求、具有一定逻辑处理的应用场景</p><p>发送请求数据的对象称为客户端，接收请求并发送响应的对象称之为服务端，同话题通信一样，客户端和服务端也通过话题相关联，不同的是服务通信的数据传输是双向交互式的</p><p>一般是一对多的关系(一个服务器，多个服务端)</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/2.3服务通信模型2 (1).gif" alt="2.3服务通信模型2 (1)" style="zoom:80%;" /><h4 id="案例需求-1"><a href="#案例需求-1" class="headerlink" title="案例需求"></a>案例需求</h4><p>需求：编写服务通信，客户端可以提交两个整数到服务端，服务端接收请求并解析两个整数求和，然后将结果响应回客户端</p><p>终端下进入工作空间的src目录，调用命令创建C++功能包，同时创建一个cpp文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create cpp02_service --build-type ament_cmake --dependencies rclcpp base_interfaces --node-name demo01_server</span><br></pre></td></tr></table></figure><h4 id="配置接口消息-1"><a href="#配置接口消息-1" class="headerlink" title="配置接口消息"></a>配置接口消息</h4><p><strong>创建并编辑 .srv 文件</strong></p><p>功能包base_interfaces下新建srv文件夹，srv文件夹下新建AddInts.srv文件，文件中输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int32 num1</span><br><span class="line">int32 num2</span><br><span class="line">---</span><br><span class="line">int32 sum</span><br></pre></td></tr></table></figure><p><strong>编辑配置文件</strong></p><p>srv文件与msg文件的包依赖一致</p><p>如果是新建的功能包添加srv文件，那么直接参考定义msg文件时package.xml 配置即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编译依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 执行依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明当前包所属的功能包组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于使用的同一个工作空间，无需修改</p><p>为了将<code>.srv</code>文件转换成对应的C++和Python代码，还需要在CMakeLists.txt中添加如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(rosidl_default_generators REQUIRED) # 添加依赖</span><br><span class="line">rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;</span><br><span class="line">  &quot;msg/Student.msg&quot;</span><br><span class="line">  &quot;srv/AddInts.srv&quot; # 增添部分</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>编译</strong></p><p>终端中进入当前工作空间，编译功能包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select base_interfaces</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><p>编译完成之后，在工作空间下的 install 目录下将生成<code>AddInts.srv</code>文件对应的C++和Python文件</p><p>可以在终端下进入工作空间，通过如下命令查看文件定义以及编译是否正常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. install/setup.bash</span><br><span class="line">ros2 interface show base_interfaces/srv/AddInts</span><br></pre></td></tr></table></figure><p>正常情况下，终端将会输出与<code>AddInts.srv</code>文件一致的内容</p><h4 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h4><p>CMakeLists配置参考话题通信</p><p><strong>服务端实现</strong></p><p>功能包cpp02_service的src目录下</p><p>demo01_server.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  需求：编写服务端，接收客户端发送请求，提取其中两个整型数据，相加后将结果响应回客户端。</span></span><br><span class="line"><span class="comment">  步骤：</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1.创建服务端；</span></span><br><span class="line"><span class="comment">      3-2.处理请求数据并响应结果。</span></span><br><span class="line"><span class="comment">    4.调用spin函数，并传入节点对象指针；</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_interfaces/srv/add_ints.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> base_interfaces::srv::AddInts;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义类节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddIntsServer</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AddIntsServer</span>():<span class="built_in">Node</span>(<span class="string">&quot;addints_server_node_cpp&quot;</span>)&#123; </span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;服务端创建成功！&quot;</span>);</span><br><span class="line">    <span class="comment">// 3-1.创建服务端；</span></span><br><span class="line">    <span class="comment">/* 模板：服务接口类型;</span></span><br><span class="line"><span class="comment">     参数:</span></span><br><span class="line"><span class="comment">    1.服务话题;</span></span><br><span class="line"><span class="comment">    2.回调函数。</span></span><br><span class="line"><span class="comment">     返回值：服务对象指针</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    server = <span class="keyword">this</span>-&gt;<span class="built_in">create_service</span>&lt;AddInts&gt;(<span class="string">&quot;add_ints&quot;</span>,</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;AddIntsServer::add,<span class="keyword">this</span>,_1,_2));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 3-2.处理请求数据并响应结果。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> AddInts::Request::SharedPtr req,<span class="type">const</span> AddInts::Response::SharedPtr res)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    res-&gt;sum = req-&gt;num1 + req-&gt;num2;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;请求数据:(%d,%d),响应结果:%d&quot;</span>, req-&gt;num1, req-&gt;num2, res-&gt;sum);</span><br><span class="line">  &#125;</span><br><span class="line">  rclcpp::Service&lt;AddInts&gt;::SharedPtr server;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数，并传入节点类对象；</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;AddIntsServer&gt;()); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 service call /add_ints base_interfaces/srv/AddInts &quot;&#123;&#x27;num1&#x27;:10,&#x27;num2&#x27;:2&#125;&quot;</span><br></pre></td></tr></table></figure><p>&#x2F;add_ints是服务的话题名称，后面跟数据类型，可以[TAB]查看</p><p>输入参数的写法需要注意</p><p><strong>客户端实现</strong></p><p>注意客户端不需要挂起，不需要spin</p><p>功能包cpp02_service的src目录下</p><p>demo02_client.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  需求：编写客户端，发送两个整型变量作为请求数据，并处理响应结果。</span></span><br><span class="line"><span class="comment">  步骤：</span></span><br><span class="line"><span class="comment">    前提：main中需要验证提交参数是否正确</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1.创建客户端；</span></span><br><span class="line"><span class="comment">      3-2.等待服务连接；</span></span><br><span class="line"><span class="comment">      3-3.组织请求数据并发送；</span></span><br><span class="line"><span class="comment">    4.创建对象指针调用其功能</span></span><br><span class="line"><span class="comment">      调用连接服务函数，根据连接结果进行下一步</span></span><br><span class="line"><span class="comment">      连接成功后，调用请求发送函数</span></span><br><span class="line"><span class="comment">      处理响应结果</span></span><br><span class="line"><span class="comment">    5.释放资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_interfaces/srv/add_ints.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> base_interfaces::srv::AddInts;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals; <span class="comment">// 可以直接输入时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义类节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddIntsClient</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AddIntsClient</span>():<span class="built_in">Node</span>(<span class="string">&quot;addints_client_node_cpp&quot;</span>)&#123;  </span><br><span class="line">  <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;客户端创建成功！&quot;</span>); </span><br><span class="line">    <span class="comment">// 3-1.创建客户端</span></span><br><span class="line">    client_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_client</span>&lt;AddInts&gt;(<span class="string">&quot;add_ints&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3-2.等待服务连接；</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">connect_server</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 循环以5s时间连接服务器，直到服务器连接成功</span></span><br><span class="line">      <span class="keyword">while</span>(!client_-&gt;<span class="built_in">wait_for_service</span>(<span class="number">5</span>s)) <span class="comment">// 连接上返回true，超过时间返回false</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 对ctrl+c作出特殊处理</span></span><br><span class="line">        <span class="comment">// 按下ctrl+c是结束R0S2程序，意味着要释放资源，例如关闭context，无法再调用类this</span></span><br><span class="line">        <span class="comment">// rclcpp::get_logger(&quot;name&quot;)创建 logger 对象不依赖于context</span></span><br><span class="line">        <span class="keyword">if</span> (!rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;强制退出！&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;服务连接中，请稍候...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3-3.组织请求数据并发送；</span></span><br><span class="line">    <span class="comment">//编写发送请求函数，参数是两个整型数据，返回值是提交请求后服务端的返回结果</span></span><br><span class="line">    rclcpp::Client&lt;AddInts&gt;::<span class="function">FutureAndRequestId <span class="title">send_request</span><span class="params">(<span class="type">int32_t</span> num1,<span class="type">int32_t</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> request = std::<span class="built_in">make_shared</span>&lt;AddInts::Request&gt;();</span><br><span class="line">      request-&gt;num1 = num1;</span><br><span class="line">      request-&gt;num2 = num2;</span><br><span class="line">      <span class="keyword">return</span> client_-&gt;<span class="built_in">async_send_request</span>(request);</span><br><span class="line">      <span class="comment">// async_send_request返回: a FutureAndRequestId instance.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  rclcpp::Client&lt;AddInts&gt;::SharedPtr client_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_ERROR</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;请提交两个int数据&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 客户端不需要spin</span></span><br><span class="line">  <span class="comment">// 3-1 创建客户端对象</span></span><br><span class="line">  <span class="keyword">auto</span> client = std::<span class="built_in">make_shared</span>&lt;AddIntsClient&gt;(); </span><br><span class="line">  <span class="comment">// 根据连接结果做进一步处理</span></span><br><span class="line">  <span class="type">bool</span> flag = client-&gt;<span class="built_in">connect_server</span>();</span><br><span class="line">  <span class="keyword">if</span>(!flag)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_ERROR</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;服务器连接失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用请求提交函数，接收并处理响应结果。</span></span><br><span class="line">  <span class="comment">// 发送异步请求</span></span><br><span class="line">  <span class="keyword">auto</span> response = client-&gt;<span class="built_in">send_request</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]),<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line">  <span class="comment">// 处理响应</span></span><br><span class="line">  <span class="comment">// 判断是否成功</span></span><br><span class="line">  <span class="keyword">if</span> (rclcpp::<span class="built_in">spin_until_future_complete</span>(client,response) == rclcpp::FutureReturnCode::SUCCESS)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(client-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;请求正常处理&quot;</span>);</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(client-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;响应结果:%d!&quot;</span>, response.<span class="built_in">get</span>()-&gt;sum);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(client-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;请求异常&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动作通信"><a href="#动作通信" class="headerlink" title="动作通信"></a>动作通信</h3><p>导航是一个过程，是耗时操作，如果使用服务通信，那么只有在导航结束时，才会产生响应结果，而在导航过程中，节点A是不会获取到任何反馈的，从而可能出现程序”假死”的现象</p><p>更合理的方案应该是：导航过程中，可以连续反馈当前机器人状态信息，当导航终止时，再返回最终的执行结果</p><p>在ROS中，该实现策略称为action 通信，适用于耗时的请求响应场景，用以获取连续的状态反馈</p><p>功能而言动作通信类似于服务通信，动作客户端可以发送请求到动作服务端，并接收动作服务端响应的最终结果，不过动作通信可以在请求响应过程中获取连续反馈，并且也可以向动作服务端发送任务取消请求</p><p>底层实现而言动作通信是建立在话题通信和服务通信之上的，目标发送实现是对服务通信的封装，结果的获取也是对服务通信的封装，而连续反馈则是对话题通信的封装</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/2.4action通信模型 (1).gif" alt="2.4action通信模型 (1)" style="zoom: 80%;" /><h4 id="案例需求-2"><a href="#案例需求-2" class="headerlink" title="案例需求"></a>案例需求</h4><p>需求：编写动作通信，动作客户端提交一个整型数据N，动作服务端接收请求数据并累加1-N之间的所有整数，将最终结果返回给动作客户端，且每累加一次都需要计算当前运算进度并反馈给动作客户端</p><p>终端下进入工作空间的src目录，调用命令创建C++功能包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create cpp03_action --build-type ament_cmake --dependencies rclcpp rclcpp_action base_interfaces --node-name demo01_action_server</span><br></pre></td></tr></table></figure><h4 id="配置接口消息-2"><a href="#配置接口消息-2" class="headerlink" title="配置接口消息"></a>配置接口消息</h4><p><strong>创建并编辑 .action 文件</strong></p><p>功能包base_interfaces下新建action文件夹，action文件夹下新建Progress.action文件，文件中输入如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int64 num</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br><span class="line">---</span><br><span class="line">float64 progress</span><br></pre></td></tr></table></figure><p><strong>编辑配置文件</strong></p><p>如果单独构建action功能包，需要在package.xml中需要添加一些依赖包，具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt;</span><br><span class="line">&lt;depend&gt;action_msgs&lt;/depend&gt;</span><br><span class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</span><br></pre></td></tr></table></figure><p>使用的是之前的包，已经为 msg 、srv 文件添加过了一些依赖，所以 package.xml 中添加如下内容即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt;</span><br><span class="line">&lt;depend&gt;action_msgs&lt;/depend&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意，和之前的是有差异的，之前是<code>  &lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;</code></p></blockquote><p>为了将<code>.action</code>文件转换成对应的C++和Python代码，还需要在CMakeLists.txt 中添加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find_package(rosidl_default_generators REQUIRED) # 添加依赖</span><br><span class="line"></span><br><span class="line">rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;</span><br><span class="line">  &quot;msg/Student.msg&quot;</span><br><span class="line">  &quot;srv/AddInts.srv&quot;</span><br><span class="line">  &quot;action/Progress.action&quot; # 增添的部分</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>编译</strong></p><p>终端中进入当前工作空间，编译功能包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select base_interfaces</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><p>编译完成之后，在工作空间下的 install 目录下将生成<code>Progress.action</code>文件对应的C++和Python文件</p><p>也可以在终端下进入工作空间，通过如下命令查看文件定义以及编译是否正常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. install/setup.bash</span><br><span class="line">ros2 interface show base_interfaces/action/Progress</span><br></pre></td></tr></table></figure><h4 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h4><p>CMakeLists配置参考话题通信</p><p><strong>动作服务端实现</strong></p><p>cpp03_action的src目录下</p><p>demo01_action_server.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  需求：编写动作服务端，需要解析客户端提交的数字，遍历该数字并累加求和，最终结果响应回</span></span><br><span class="line"><span class="comment">       客户端，且请求响应过程中需要生成连续反馈。</span></span><br><span class="line"><span class="comment">  分析:</span></span><br><span class="line"><span class="comment">    1.创建动作服务端对象;</span></span><br><span class="line"><span class="comment">    2. 处理提交的目标值;</span></span><br><span class="line"><span class="comment">    3.生成连续反馈;</span></span><br><span class="line"><span class="comment">    4.响应最终结果；</span></span><br><span class="line"><span class="comment">    5.处理取消请求。</span></span><br><span class="line"><span class="comment">  步骤：</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1.创建动作服务端对象；</span></span><br><span class="line"><span class="comment">      3-2.处理提交的目标值（回调函数）；</span></span><br><span class="line"><span class="comment">      3-3.处理取消请求（回调函数）</span></span><br><span class="line"><span class="comment">      3-4.生成连续反馈与最终响应（回调涵数）</span></span><br><span class="line"><span class="comment">    4.调用spin函数，并传入节点对象指针；</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_action/rclcpp_action.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_interfaces/action/progress.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> base_interfaces::action::Progress;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br><span class="line"><span class="comment">// using namespace std::placeholders; 或者直接这一句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义类节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProgressActionServer</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ProgressActionServer</span>():<span class="built_in">Node</span>(<span class="string">&quot;progressa_action_server_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;action 服务端创建成功!&quot;</span>);</span><br><span class="line">  <span class="comment">// 3-1.创建动作服务端对象；</span></span><br><span class="line">  <span class="comment">/* 参数列表</span></span><br><span class="line"><span class="comment">      (NodeT node, </span></span><br><span class="line"><span class="comment">      const std::string &amp;name, </span></span><br><span class="line"><span class="comment">      rclcpp_action::Server&lt;ActionT&gt;::GoalCallback handle_goal, </span></span><br><span class="line"><span class="comment">      rclcpp_action::Server&lt;ActionT&gt;::CancelCallback handle_cancel, </span></span><br><span class="line"><span class="comment">      rclcpp_action::Server&lt;ActionT&gt;::AcceptedCallback handle_accepted</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  server_ = rclcpp_action::<span class="built_in">create_server</span>&lt;Progress&gt;(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      <span class="string">&quot;get_sum&quot;</span>,</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;ProgressActionServer::handle_goal,<span class="keyword">this</span>,_1,_2),</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;ProgressActionServer::handle_cancel,<span class="keyword">this</span>,_1),</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;ProgressActionServer::handle_accepted,<span class="keyword">this</span>,_1));</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;动作服务端创建，等待请求...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  rclcpp_action::Server&lt;Progress&gt;::SharedPtr server_;</span><br><span class="line">  <span class="comment">// 3-2.处理提交的目标值（回调函数）；</span></span><br><span class="line">  <span class="comment">// GoalCallback =  std::function&lt;GoalResponse(const GoalUUID &amp;, std::shared_ptr&lt;const typename ActionT::Goal&gt;)&gt;;</span></span><br><span class="line">  <span class="function">rclcpp_action::GoalResponse <span class="title">handle_goal</span><span class="params">(<span class="type">const</span> rclcpp_action::GoalUUID &amp; uuid, std::shared_ptr&lt;<span class="type">const</span> Progress::Goal&gt; goal)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    (<span class="type">void</span>)uuid; <span class="comment">// 标识目前没用上,避免警告</span></span><br><span class="line">    <span class="comment">// 业务逻辑：判断的端提交数字是否大于1，是接受，不是拒绝</span></span><br><span class="line">    <span class="keyword">if</span>(goal-&gt;num&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;提交的目标值必须大于1&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> rclcpp_action::GoalResponse::REJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;提交目标成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3-3.处理取消请求（回调函数）</span></span><br><span class="line">  <span class="comment">// CancelCallback = std::function&lt;CancelResponse(std::shared_ptr&lt;ServerGoalHandle&lt;ActionT&gt;&gt;)&gt;;</span></span><br><span class="line">  <span class="function">rclcpp_action::CancelResponse <span class="title">handle_cancel</span><span class="params">(std::shared_ptr&lt;rclcpp_action::ServerGoalHandle&lt;Progress&gt;&gt; goal_handle)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    (<span class="type">void</span>)goal_handle;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;接收到取消请求&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> rclcpp_action::CancelResponse::ACCEPT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3-4.生成连续反馈与最终响应（回调涵数）  </span></span><br><span class="line">  <span class="comment">// AcceptedCallback = std::function&lt;void (std::shared_ptr&lt;ServerGoalHandle&lt;ActionT&gt;&gt;)&gt;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::shared_ptr&lt;rclcpp_action::ServerGoalHandle&lt;Progress&gt;&gt; goal_handle)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 生成连续反馈</span></span><br><span class="line">    <span class="comment">// 首先要获取目标值，然后遍历，追历中进行累加，且每循环一次就计算进度，并作为连续反馈发布</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;开始执行任务&quot;</span>);</span><br><span class="line">    <span class="type">int</span> num = goal_handle-&gt;<span class="built_in">get_goal</span>()-&gt;num;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> progress = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">double</span> progress_pro;</span><br><span class="line">    <span class="comment">// void publish_feedback(std::shared_ptr&lt;base_interfaces::action::Progress_Feedback&gt; feedback_msg)</span></span><br><span class="line">    <span class="keyword">auto</span> feedback = std::<span class="built_in">make_shared</span>&lt;Progress::Feedback&gt;();</span><br><span class="line">    <span class="keyword">auto</span> result = std::<span class="built_in">make_shared</span>&lt;Progress::Result&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置休眠</span></span><br><span class="line">    <span class="function">rclcpp::Rate <span class="title">rate</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 检查取消请求</span></span><br><span class="line">      <span class="keyword">if</span> (goal_handle-&gt;<span class="built_in">is_canceling</span>()) &#123;</span><br><span class="line">        result-&gt;sum = sum;</span><br><span class="line">    <span class="comment">// void canceled(std::shared_ptr&lt;base_interfaces::action::Progress_Result&gt; result_msg)</span></span><br><span class="line">        goal_handle-&gt;<span class="built_in">canceled</span>(result);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;任务取消!当前计算结果为%d&quot;</span>, sum);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sum += i; </span><br><span class="line">      progress = i/ (<span class="type">double</span>) num; <span class="comment">// 计算进度</span></span><br><span class="line">      feedback-&gt;progress = progress;</span><br><span class="line">      progress_pro = progress * <span class="number">100</span>;</span><br><span class="line">      goal_handle-&gt;<span class="built_in">publish_feedback</span>(feedback);</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;任务进行中，当前进度%.2f%%&quot;</span>,progress_pro);</span><br><span class="line">      rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 形成最终响应结果</span></span><br><span class="line">    <span class="comment">// void succeed(std::shared_ptr&lt;base_interfaces::action::Progress_Result&gt; result_msg)</span></span><br><span class="line">    <span class="keyword">if</span>(rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      result-&gt;sum = sum;</span><br><span class="line">      goal_handle-&gt;<span class="built_in">succeed</span>(result);</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;任务完成，最终结果:%d&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handle_accepted</span><span class="params">(std::shared_ptr&lt;rclcpp_action::ServerGoalHandle&lt;Progress&gt;&gt; goal_handle)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 新建线程处理耗时的主逻辑</span></span><br><span class="line">    std::thread&#123;std::<span class="built_in">bind</span>(&amp;ProgressActionServer::execute,<span class="keyword">this</span>,_1),goal_handle&#125;.<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数，并传入节点类对象；</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;ProgressActionServer&gt;()); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写回调函数查看源码</p><p>create_server -&gt; Server</p></blockquote><p><strong>动作客户端实现</strong></p><p>cpp03_action的src目录下</p><p>demo02_action_client.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  需求：编写动作客户端，可以发送一个整型数据到服务端，并处理服务端的连续反馈和最终响应结果。</span></span><br><span class="line"><span class="comment">  步骤：</span></span><br><span class="line"><span class="comment">    前提：可以解析终端下动态传入的参数</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1.创建动作客户端；</span></span><br><span class="line"><span class="comment">      3-2.发送请求;</span></span><br><span class="line"><span class="comment">      3-3.处理关于目标值的服务端响应（回调函数）</span></span><br><span class="line"><span class="comment">      3-4.处理连续反馈（回调函数）</span></span><br><span class="line"><span class="comment">      3-5.处理最终响应（回调函数）</span></span><br><span class="line"><span class="comment">    4.调用spin函数，并传入节点对象指针；</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_action/rclcpp_action.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_interfaces/action/progress.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> base_interfaces::action::Progress;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals; <span class="comment">// 可以直接输入时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义类节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProgressActionClient</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ProgressActionClient</span>():<span class="built_in">Node</span>(<span class="string">&quot;progress_action_client_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;action 客户端创建成功!&quot;</span>);</span><br><span class="line">  <span class="comment">// 3-1.创建动作客户端；</span></span><br><span class="line">  <span class="comment">/* 参数列表</span></span><br><span class="line"><span class="comment">  NodeT node, </span></span><br><span class="line"><span class="comment">  const std::string &amp;name</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  client_ = rclcpp_action::<span class="built_in">create_client</span>&lt;Progress&gt;(<span class="keyword">this</span>,<span class="string">&quot;get_sum&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3-2.发送请求;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send_goal</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.需要连接到服务端</span></span><br><span class="line">    <span class="keyword">if</span>(!client_-&gt;<span class="built_in">wait_for_action_server</span>(<span class="number">5</span>s))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;服务器连接失败！&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 发送具体请求</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    std::shared_future&lt;rclcpp_action::ClientGoalHandle&lt;base_interfaces::action::Progress&gt;::SharedPtr&gt; </span></span><br><span class="line"><span class="comment">    async_send_goal(</span></span><br><span class="line"><span class="comment">        const base_interfaces::action::Progress::Goal &amp;goal,</span></span><br><span class="line"><span class="comment">        const rclcpp_action::Client&lt;base_interfaces::action::Progress&gt;::SendGoalOptions &amp;options)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">auto</span> goal = Progress::<span class="built_in">Goal</span>();</span><br><span class="line">    goal.num = num;</span><br><span class="line">    rclcpp_action::Client&lt;Progress&gt;::SendGoalOptions options;</span><br><span class="line">    options.goal_response_callback = std::<span class="built_in">bind</span>(&amp;ProgressActionClient::goal_response_callback,<span class="keyword">this</span>,_1);</span><br><span class="line">    options.feedback_callback = std::<span class="built_in">bind</span>(&amp;ProgressActionClient::feedback_callback,<span class="keyword">this</span>,_1,_2);</span><br><span class="line">    options.result_callback = std::<span class="built_in">bind</span>(&amp;ProgressActionClient::result_callback,<span class="keyword">this</span>,_1);</span><br><span class="line">    <span class="keyword">auto</span> future = client_ -&gt; <span class="built_in">async_send_goal</span>(goal,options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">cancel_goal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (client_) &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;发送取消请求&quot;</span>);</span><br><span class="line">      client_-&gt;<span class="built_in">async_cancel_all_goals</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  rclcpp_action::Client&lt;Progress&gt;::SharedPtr client_;</span><br><span class="line">  <span class="comment">// 3-3.处理关于目标值的服务端响应（回调函数）</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    using GoalHandle = ClientGoalHandle&lt;ActionT&gt;;</span></span><br><span class="line"><span class="comment">    using GoalResponseCallback = std::function&lt;void (typename GoalHandle::SharedPtr)&gt;;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">goal_response_callback</span><span class="params">(rclcpp_action::ClientGoalHandle&lt;Progress&gt;::SharedPtr goal_handle)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!goal_handle)&#123;</span><br><span class="line">      <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;目标请求被服务端拒绝!&quot;</span>);</span><br><span class="line">      rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;目标处理中!目标ID: %s&quot;</span>,<span class="built_in">goal_uuid_to_string</span>(goal_handle-&gt;<span class="built_in">get_goal_id</span>()).<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3-4.处理连续反馈（回调函数）</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    using GoalHandle = ClientGoalHandle&lt;ActionT&gt;;</span></span><br><span class="line"><span class="comment">    using FeedbackCallback =</span></span><br><span class="line"><span class="comment">    std::function&lt;void (</span></span><br><span class="line"><span class="comment">        typename ClientGoalHandle&lt;ActionT&gt;::SharedPtr,</span></span><br><span class="line"><span class="comment">        const std::shared_ptr&lt;const Feedback&gt;)&gt;;</span></span><br><span class="line"><span class="comment">    using FeedbackCallback = typename GoalHandle::FeedbackCallback;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">feedback_callback</span><span class="params">(rclcpp_action::ClientGoalHandle&lt;Progress&gt;::SharedPtr goal_handle, <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> Progress::Feedback&gt; feedback)</span></span>&#123;</span><br><span class="line">    (<span class="type">void</span>)goal_handle;</span><br><span class="line">    <span class="type">double</span> progress = feedback-&gt;progress;</span><br><span class="line">    <span class="type">double</span> progress_pro = progress * <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;当前进度:%.2f%%&quot;</span>,progress_pro);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3-5.处理最终响应（回调函数）</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    using ResultCallback = typename GoalHandle::ResultCallback;</span></span><br><span class="line"><span class="comment">    template&lt;typename ActionT&gt;</span></span><br><span class="line"><span class="comment">    class ClientGoalHandle &#123; struct WrappedResult &#125;</span></span><br><span class="line"><span class="comment">    using ResultCallback = std::function&lt;void (const WrappedResult &amp; result)&gt;;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">result_callback</span><span class="params">(<span class="type">const</span> rclcpp_action::ClientGoalHandle&lt;Progress&gt;::WrappedResult &amp; result)</span></span>&#123;</span><br><span class="line">    <span class="comment">// result.code</span></span><br><span class="line">    <span class="comment">// 通过状态码判断结果状态</span></span><br><span class="line">    <span class="keyword">if</span>(result.code == rclcpp_action::ResultCode::SUCCEEDED)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;最终结果:%ld&quot;</span>,result.result-&gt;sum);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(result.code == rclcpp_action::ResultCode::ABORTED)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;任务被中止!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(result.code == rclcpp_action::ResultCode::CANCELED)&#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;任务被取消!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;未知异常!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将UUID转换为可读字符串</span></span><br><span class="line">  <span class="function">std::string <span class="title">goal_uuid_to_string</span><span class="params">(<span class="type">const</span> rclcpp_action::GoalUUID&amp; uuid)</span> </span>&#123;</span><br><span class="line">      std::stringstream ss;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> byte : uuid) &#123;</span><br><span class="line">          ss &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(byte);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!= <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_ERROR</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;请提交一个&gt;1的整型数据!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数，并传入节点类对象；</span></span><br><span class="line">  <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;ProgressActionClient&gt;();</span><br><span class="line">  node-&gt;<span class="built_in">send_goal</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">  <span class="comment">// 添加键盘监听线程</span></span><br><span class="line">  <span class="function">std::thread <span class="title">input_thread</span><span class="params">([node]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    RCLCPP_INFO(node-&gt;get_logger(), <span class="string">&quot;按 &#x27;c&#x27; 键取消目标&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span> (rclcpp::ok()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">char</span> c = std::cin.get();</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">if</span> (c == <span class="string">&#x27;c&#x27;</span> || c == <span class="string">&#x27;C&#x27;</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        node-&gt;cancel_goal();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br><span class="line">  input_thread.<span class="built_in">detach</span>();</span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(node); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写回调函数查看源码</p><p>SendGoalOptions</p></blockquote><h3 id="参数服务"><a href="#参数服务" class="headerlink" title="参数服务"></a>参数服务</h3><p>参数服务是以共享的方式实现不同节点之间数据交互的一种通信模式</p><p>保存参数的节点称之为参数服务端，调用参数的节点称之为参数客户端</p><p>参数客户端与参数服务端的交互是基于请求响应的，且参数通信的实现本质上对服务通信的进一步封装</p><p>参数服务保存的数据类似于编程中“全局变量”的概念，可以在不同的节点之间共享数据</p><h4 id="案例需求-3"><a href="#案例需求-3" class="headerlink" title="案例需求"></a>案例需求</h4><p>需求：在参数服务端设置一些参数，参数客户端访问服务端并操作这些参数</p><p>终端下进入工作空间的src目录，调用命令创建C++功能包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create cpp04_param --build-type ament_cmake --dependencies rclcpp --node-name demo00_param</span><br></pre></td></tr></table></figure><h4 id="参数数据类型"><a href="#参数数据类型" class="headerlink" title="参数数据类型"></a>参数数据类型</h4><p>在ROS2中，参数由键、值和描述符三部分组成，其中键是字符串类型，值可以是bool、int64、float64、string、byte[]、bool[]、int64[]、float64[]、string[]中的任一类型，描述符默认情况下为空，但是可以设置参数描述、参数数据类型、取值范围或其他约束等信息</p><p>C++客户端对应的类是<code>rclcpp::Parameter</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  需求：</span></span><br><span class="line"><span class="comment">  步骤：</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1 参数对象创建</span></span><br><span class="line"><span class="comment">      3-2 参数对象解析</span></span><br><span class="line"><span class="comment">    4.调用spin函数，并传入节点对象指针；</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义类节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParam</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyParam</span>():<span class="built_in">Node</span>(<span class="string">&quot;my_param_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">  <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;参数API创建成功!&quot;</span>);</span><br><span class="line">    <span class="comment">// 3-1 参数对象创建</span></span><br><span class="line">    <span class="function">rclcpp::Parameter <span class="title">p1</span><span class="params">(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;tiger&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">rclcpp::Parameter <span class="title">p2</span><span class="params">(<span class="string">&quot;width&quot;</span>,<span class="number">0.15</span>)</span></span>; <span class="comment">//参数值为浮点类型</span></span><br><span class="line">    <span class="function">rclcpp::Parameter <span class="title">p3</span><span class="params">(<span class="string">&quot;wheels&quot;</span>,<span class="number">2</span>)</span></span>; <span class="comment">//参数值为整型</span></span><br><span class="line">    <span class="comment">// 3-2 参数对象解析</span></span><br><span class="line">    <span class="comment">// 获取参数值</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;car_name = %s&quot;</span>, p<span class="number">1.</span><span class="built_in">as_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;car_width = %.2f&quot;</span>, p<span class="number">2.</span><span class="built_in">as_double</span>());</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;wheels = %ld&quot;</span>, p<span class="number">3.</span><span class="built_in">as_int</span>());</span><br><span class="line">    <span class="comment">// 获取参数键</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;p1 name = %s&quot;</span>,p<span class="number">1.</span><span class="built_in">get_name</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 获取参数数据类型</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;p1 type_name = %s&quot;</span>, p<span class="number">1.</span><span class="built_in">get_type_name</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 将参数值转换成字符串类型</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;p2 value_to_msg = %s&quot;</span>, p<span class="number">2.</span><span class="built_in">value_to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数，并传入节点类对象；</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;MyParam&gt;()); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h4><p>packages.xml无需修改，配置CMakeList</p><p><strong>参数服务端</strong></p><p>cpp04_param的src目录下</p><p>demo01_param_server.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  需求：</span></span><br><span class="line"><span class="comment">  步骤：</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">        3-1.声明参数；</span></span><br><span class="line"><span class="comment">        3-2.查询参数；</span></span><br><span class="line"><span class="comment">        3-3.修改参数；</span></span><br><span class="line"><span class="comment">        3-4.删除参数。</span></span><br><span class="line"><span class="comment">    4.调用spin函数，并传入节点对象指针；</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义类节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParamServer</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 允许删除 需要通过NodeOptions声明</span></span><br><span class="line">    <span class="built_in">ParamServer</span>():<span class="built_in">Node</span>(<span class="string">&quot;param_server_node_cpp&quot;</span>,rclcpp::<span class="built_in">NodeOptions</span>().<span class="built_in">allow_undeclared_parameters</span>(<span class="literal">true</span>))&#123;  </span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;参数服务器创建成功!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">declare_param</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;----------增加----------&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明参数并设置默认值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">declare_parameter</span>(<span class="string">&quot;car_name&quot;</span>,<span class="string">&quot;tiger&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">declare_parameter</span>(<span class="string">&quot;height&quot;</span>,<span class="number">1.50</span>); </span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">declare_parameter</span>(<span class="string">&quot;wheels&quot;</span>,<span class="number">4</span>); </span><br><span class="line">        <span class="comment">// set_parameter才可删除</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">set_parameter</span>(rclcpp::<span class="built_in">Parameter</span>(<span class="string">&quot;undcl_test&quot;</span>,<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_param</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;----------查询----------&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定查询</span></span><br><span class="line">        rclcpp::Parameter car_name = <span class="keyword">this</span>-&gt;<span class="built_in">get_parameter</span>(<span class="string">&quot;car_name&quot;</span>);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;car_name:%s&quot;</span>,car_name.<span class="built_in">as_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 判断包含</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;包含car_name? %d&quot;</span>,<span class="keyword">this</span>-&gt;<span class="built_in">has_parameter</span>(<span class="string">&quot;car_name&quot;</span>));</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;包含car_type? %d&quot;</span>,<span class="keyword">this</span>-&gt;<span class="built_in">has_parameter</span>(<span class="string">&quot;car_type&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取所有</span></span><br><span class="line">        <span class="keyword">auto</span> params = <span class="keyword">this</span>-&gt;<span class="built_in">get_parameters</span>(&#123;<span class="string">&quot;car_name&quot;</span>,<span class="string">&quot;height&quot;</span>,<span class="string">&quot;wheels&quot;</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;param : params)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;name = %s, value = %s&quot;</span>, param.<span class="built_in">get_name</span>().<span class="built_in">c_str</span>(), param.<span class="built_in">value_to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_param</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;----------修改----------&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">set_parameter</span>(rclcpp::<span class="built_in">Parameter</span>(<span class="string">&quot;height&quot;</span>,<span class="number">1.75</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_param</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;----------删除----------&quot;</span>);</span><br><span class="line">        <span class="comment">//this-&gt;undeclare_parameter(&quot;car_name&quot;); //会报错，无法删除</span></span><br><span class="line">        <span class="comment">// RCLCPP_INFO(this-&gt;get_logger(),&quot;删除后还包含car_name吗? %d&quot;,this-&gt;has_parameter(&quot;car_name&quot;)); </span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">undeclare_parameter</span>(<span class="string">&quot;undcl_test&quot;</span>);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;删除后还包含undcl_test吗? %d&quot;</span>,<span class="keyword">this</span>-&gt;<span class="built_in">has_parameter</span>(<span class="string">&quot;undcl_test&quot;</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数，并传入节点类对象；</span></span><br><span class="line">  <span class="keyword">auto</span> paramServer = std::<span class="built_in">make_shared</span>&lt;ParamServer&gt;();</span><br><span class="line">  paramServer-&gt;<span class="built_in">declare_param</span>();</span><br><span class="line">  paramServer-&gt;<span class="built_in">get_param</span>();</span><br><span class="line">  paramServer-&gt;<span class="built_in">update_param</span>();</span><br><span class="line">  paramServer-&gt;<span class="built_in">del_param</span>();</span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(paramServer); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数客户端</strong></p><p>cpp04_param的src目录下</p><p>demo02_param_client.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    需求：编写参数客户端，获取或修改服务端参数。</span></span><br><span class="line"><span class="comment">    步骤：</span></span><br><span class="line"><span class="comment">        1.包含头文件；</span></span><br><span class="line"><span class="comment">        2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">        3.定义节点类；</span></span><br><span class="line"><span class="comment">            3-1.创建参数客户端对象</span></span><br><span class="line"><span class="comment">            3-2.连接到客户端</span></span><br><span class="line"><span class="comment">            3-3.查询参数</span></span><br><span class="line"><span class="comment">            3-4.修改参数</span></span><br><span class="line"><span class="comment">        4.创建节点对象指针，调用参数操作函数；</span></span><br><span class="line"><span class="comment">        5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义类节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParamClient</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ParamClient</span>():<span class="built_in">Node</span>(<span class="string">&quot;param_client_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;参数客户端创建成功!&quot;</span>);</span><br><span class="line">    <span class="comment">// 3-1.创建参数客户端对象</span></span><br><span class="line">    <span class="comment">// 参数1: 当前对象节点 参数2: 远程连接节点</span></span><br><span class="line">    param_client = std::<span class="built_in">make_shared</span>&lt;rclcpp::SyncParametersClient&gt;(<span class="keyword">this</span>,<span class="string">&quot;param_server_node_cpp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3-2.连接到客户端</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connect_server</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(!param_client-&gt;<span class="built_in">wait_for_service</span>(<span class="number">5</span>s))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rclcpp::<span class="built_in">ok</span>())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;服务连接中...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_param</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;-----------参数客户端查询参数-----------&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取某个参数</span></span><br><span class="line">      std::string car_name = param_client-&gt;<span class="built_in">get_parameter</span>&lt;std::string&gt;(<span class="string">&quot;car_name&quot;</span>);</span><br><span class="line">      <span class="type">double</span> height = param_client-&gt;<span class="built_in">get_parameter</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;height&quot;</span>);</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;car_name=%s,height=%.2f&quot;</span>,car_name.<span class="built_in">c_str</span>(),height);</span><br><span class="line">      <span class="comment">// 获取多个参数</span></span><br><span class="line">      <span class="keyword">auto</span> params = param_client-&gt;<span class="built_in">get_parameters</span>(&#123;<span class="string">&quot;car_name&quot;</span>,<span class="string">&quot;height&quot;</span>,<span class="string">&quot;wheels&quot;</span>&#125;);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;param : params)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;%s = %s&quot;</span>,param.<span class="built_in">get_name</span>().<span class="built_in">c_str</span>(),param.<span class="built_in">value_to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;包含car_name吗?%d&quot;</span>,param_client-&gt;<span class="built_in">has_parameter</span>(<span class="string">&quot;car_name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_param</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;-----------参数客户端修改参数-----------&quot;</span>);</span><br><span class="line">      param_client-&gt;<span class="built_in">set_parameters</span>(&#123;rclcpp::<span class="built_in">Parameter</span>(<span class="string">&quot;car_name&quot;</span>,<span class="string">&quot;Mouse&quot;</span>),</span><br><span class="line">      rclcpp::<span class="built_in">Parameter</span>(<span class="string">&quot;height&quot;</span>,<span class="number">2.0</span>),</span><br><span class="line">      rclcpp::<span class="built_in">Parameter</span>(<span class="string">&quot;width&quot;</span>,<span class="number">0.15</span>),  <span class="comment">// 设置一个不存在的参数，必须在参数服务端声明allow_undeclared_parameters(true)</span></span><br><span class="line">      rclcpp::<span class="built_in">Parameter</span>(<span class="string">&quot;wheels&quot;</span>,<span class="number">6</span>)&#125;);</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;新设置的参数:%.2f&quot;</span>,param_client-&gt;<span class="built_in">get_parameter</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;width&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  rclcpp::SyncParametersClient::SharedPtr param_client;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数，并传入节点类对象；</span></span><br><span class="line">  <span class="keyword">auto</span> client = std::<span class="built_in">make_shared</span>&lt;ParamClient&gt;();</span><br><span class="line">  <span class="type">bool</span> flag = client-&gt;<span class="built_in">connect_server</span>();</span><br><span class="line">  <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  client-&gt;<span class="built_in">get_param</span>();</span><br><span class="line">  client-&gt;<span class="built_in">update_param</span>();</span><br><span class="line">  client-&gt;<span class="built_in">get_param</span>();</span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：服务通信不是通过服务话题关联吗？为什么参数客户端是通过参数服务端的节点名称关联？</p><ol><li>参数服务端启动后，底层封装了多个服务通信的服务端；</li><li>每个服务端的话题，都是采用&#x2F;服务端节点名称&#x2F;XXXX;</li><li>参数客户端创建后，也会封装多个服务通信的客户端；</li><li>这些客户端与服务端相呼应，也要使用相同的话题，因此客户端再创建时需要使用服务端节点名称</li></ol><h3 id="本章小节"><a href="#本章小节" class="headerlink" title="本章小节"></a>本章小节</h3><p>无论何种通信机制，实现框架都是类似的</p><p>比如：通信必然涉及到双方，双方需要通过“话题”关联，通信还都必然涉及到数据，一般可以通过接口文件来定义数据格式</p><p>不同的通信机制其实现模型也存在明显差异</p><ul><li>话题通信是基于广播的单向数据交互模式</li><li>服务通信是基于请求响应的问答式交数据互模式</li><li>动作通信则是在请求响应的过程中又包含连续反馈的数据交互模式</li><li>参数服务是基于服务通信的，可以在不同节点间实现数据共享</li></ul><h2 id="ROS2通信机制补充"><a href="#ROS2通信机制补充" class="headerlink" title="ROS2通信机制补充"></a>ROS2通信机制补充</h2><p>ROS2程序构建时可能遇到的问题：</p><ol><li>怎么实现分布式架构？</li><li>不同工作空间下的功能包重名时会出现什么问题？</li><li>怎么管理功能包？</li><li>节点重名怎么处理？</li><li>话题重名怎么处理？</li></ol><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>分布式通信是指可以通过网络在不同主机之间实现数据交互的一种通信策略</p><p>ROS2所基于的中间件是DDS，当处于同一网络中时，通过DDS的域ID机制(ROS_DOMAIN_ID)可以实现分布式</p><p>大致流程：在启动节点之前，可以设置域ID的值，不同节点如果域ID相同，那么可以自由发现并通信</p><p>默认情况下，所有节点启动时所使用的域ID为0，换言之，只要保证在同一网络，不需要做任何配置，不同ROS2设备上的不同节点即可实现分布式通信</p><p>如果要将不同节点划分为多个组，那么可以在终端中启动节点前设置该节点的域ID(比如设置为6)，具体执行命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ROS_DOMAIN_ID=6</span><br></pre></td></tr></table></figure><p>上述指令执行后，该节点将被划分到ID为6的域内</p><p>如果要为当前设备下的所有节点设置统一的域ID，那么可以执行如下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export ROS_DOMAIN_ID=6&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p>执行完毕后再重新启动终端，运行的所有节点将自动被划分到ID为6的域内</p><p><strong>注意</strong></p><p>在设置ROS_DOMAIN_ID的值时并不是随意的，也是有一定约束的：</p><ol><li>建议ROS_DOMAIN_ID的取值在[0,101] 之间，包含0和101；</li><li>每个域ID内的节点总数是有限制的，需要小于等于120个；</li><li>如果域ID为101，那么该域的节点总数需要小于等于54个</li></ol><p><strong>DDS 域 ID 值的计算规则</strong>(补充内容)</p><p>DDS是基于TCP&#x2F;IP或UDP&#x2F;IP网络通信协议的，网络通信时需要指定端口号，端口号由2个字节的无符号整数表示，其取值范围在[0,65535]之间</p><p>端口号的分配也是有其规则的，并非可以任意使用的，根据DDS协议规定<font color='Violetred'>以7400作为起始端口</font>，也即可用端口为[7400,65535]，又已知按照DDS协议默认情况下，<font color='Violetred'>每个域ID占用250个端口</font>，那么域ID的个数为：(65535-7400)&#x2F;250 &#x3D; 232(个)，对应的其取值范围为[0,231]</p><p>操作系统还会设置一些预留端口，在DDS中使用端口时，还需要避开这些预留端口，以免使用中产生冲突，不同的操作系统预留端口又有所差异，其最终结果是，在Linux下，可用的域ID为[0,101]与[215-231]，在Windows和Mac中可用的域ID为[0,166]</p><p>综上，为了兼容多平台，建议<font color='Violetred'>域ID在[0,101] 范围内取值</font></p><p>每个域ID默认占用250个端口，且每个ROS2节点需要占用两个端口，另外，按照DDS协议每个域ID的端口段内，第1、2个端口是Discovery Multicast端口与User Multicast端口，从第11、12个端口开始是域内第一个节点的Discovery Unicast端口与User Unicast，后续节点所占用端口依次顺延，那么一个域ID中的最大节点个数为：(250-10)&#x2F;2 &#x3D; 120(个)</p><p>特殊情况：域ID值为101时，其后半段端口属于操作系统的预留端口，其节点最大个数为54个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">域 ID 与节点所占用端口示意</span><br><span class="line"></span><br><span class="line">Domain ID:      0</span><br><span class="line">Participant ID: 0</span><br><span class="line"></span><br><span class="line">Discovery Multicast Port: 7400</span><br><span class="line">User Multicast Port:      7401</span><br><span class="line">Discovery Unicast Port:   7410</span><br><span class="line">User Unicast Port:        7411</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">Domain ID:      1</span><br><span class="line">Participant ID: 2</span><br><span class="line">Discovery Multicast Port: 7650</span><br><span class="line">User Multicast Port:      7651</span><br><span class="line">Discovery Unicast Port:   7664</span><br><span class="line">User Unicast Port:        7665</span><br><span class="line"></span><br><span class="line"># 第1个域+250 节点ID为2-&gt;第三个节点 7660开始 (7660 7661) (7662 7663) (7664 7665) </span><br></pre></td></tr></table></figure><h3 id="工作空间覆盖"><a href="#工作空间覆盖" class="headerlink" title="工作空间覆盖"></a>工作空间覆盖</h3><p>同一工作空间下不允许出现功能包重名的情况，但是当存在多个工作空间时，不同工作空间下的功能包是可以重名的，那么当功能包重名时，会调用哪一个呢？</p><p>所谓工作空间覆盖，是指不同工作空间存在重名功能包时，重名功能包的调用会产生覆盖的情况，<font color='Violetred'>需要极力避免</font></p><p><strong>演示</strong></p><p>在不同的工作空间下创建turtlesim功能包</p><p>ws00_helloworld -&gt; turtlesim_node |  ws01_plumbing -&gt; turtlesim_node</p><p>在 ~&#x2F;.bashrc 文件下追加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /home/ros2/ws00_helloworld/install/setup.bash</span><br><span class="line">source /home/ros2/ws01_plumbing/install/setup.bash</span><br></pre></td></tr></table></figure><p>新建终端运行 ros2 run turtlesim turtlesim_node</p><p>会发现执行的是 ws01_plumbing 功能包下的 turtlesim</p><p>这与~&#x2F;.bashrc中不同工作空间的setup.bash文件的加载顺序有关：</p><ol><li>ROS2 会解析 ~&#x2F;.bashrc 文件，并生成全局环境变量 AMENT_PREFIX_PATH 与 PYTHONPATH，两个环境变量取值分别对应了 ROS2 中 C++ 和 Python 功能包，环境变量的值由功能包名称组成</li><li><font color='Violetred'>对于自定义的工作空间而言，后加载的配置文件优先级更高，后配置的工作空间的功能包在环境变量值组成的前部，但是ROS2系统的setup.bash文件不适用此规则，无论该文件在哪加载，优先级始终最低</font></li><li>调用功能包时，会按照 AMENT_PREFIX_PATH 或 PYTHONPATH 中包配置顺序从前往后依次查找相关功能包，查找到功能包时会停止搜索</li></ol><p><strong>隐患</strong></p><ol><li>可能会出现功能包调用混乱，出现实际调用与预期调用结果不符的情况；</li><li>即便可以通过 ~&#x2F;.bashrc 来配置不同工作空间的优先级，但是经过测试，修改 ~&#x2F;.bashrc 文件之后不一定马上生效，还需要删除工作空间下build与install目录重新编译，才能生效，这个过程繁琐且有不确定性</li></ol><h3 id="元功能包"><a href="#元功能包" class="headerlink" title="元功能包"></a>元功能包</h3><p>在ROS2中，提供了一种方式可以将不同的功能包打包成一个功能包，当安装某个功能模块时，直接调用打包后的功能包即可，该包又称之为元功能包(metapackage)</p><p>例如：<code>sudo apt install ros-&lt;ros2-distro&gt;-desktop</code> 命令安装 ros2 时就使用了元功能包，该元功能包依赖于 ROS2 中的其他一些功能包，安装该包时会一并安装依赖</p><p>新建一个功能包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create tutorails_plumbing</span><br></pre></td></tr></table></figure><p>修改 package.xml 文件，添加执行时所依赖的包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>base_interfaces<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>cpp01_topic<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>cpp02_service<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>cpp03_action<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>cpp04_param<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这个方法可以学习如何查看别人的包</p><h3 id="节点重名"><a href="#节点重名" class="headerlink" title="节点重名"></a>节点重名</h3><p>由于节点名称一致，虽然实际有多个节点但是在计算图上显示一个，并且节点名称也会和话题名称、服务名称、动作名称、参数等产生关联，届时也可能会导致通信逻辑上的混乱</p><p>避免重名问题，一般有两种策略：</p><ol><li>名称重映射，也即为节点起别名；</li><li>命名空间，是为节点名称添加前缀，可以有多级，格式：&#x2F;xxx&#x2F;yyy&#x2F;zzz</li></ol><p>这也是在 ROS2 中解决重名问题的常用策略</p><p>上述两种策略的实现途径主要有如下三种：</p><ol><li>ros2 run 命令实现；</li><li>launch 文件实现；</li><li>编码实现</li></ol><h4 id="run2-run"><a href="#run2-run" class="headerlink" title="run2 run"></a>run2 run</h4><p><strong>设置命名空间</strong></p><p>语法：ros2 run 包名 节点名 –ros-args –remap __ns:&#x3D;命名空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node --ros-args --remap __ns:=/t1</span><br></pre></td></tr></table></figure><p><strong>名称重映射</strong></p><p>语法：</p><ul><li>ros2 run 包名 节点名 –ros-args –remap __name:&#x3D;新名称</li><li>ros2 run 包名 节点名 –ros-args –remap __node:&#x3D;新名称</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node --ros-args --remap __name:=turtle1</span><br></pre></td></tr></table></figure><p><strong>命名空间与名称重映射叠加</strong></p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node --ros-args --remap __ns:=/t1 --remap __name:=turtle1</span><br></pre></td></tr></table></figure><h4 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h4><p>关于launch文件的基本使用可以参考launch部分</p><p><strong>python方式</strong></p><p>可以通过类 <code>launch_ros.actions.Node</code>来创建被启动的节点对象，在对象的构造函数中提供了 name 和 namespace 参数来设置节点的名称与命名空间，使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LaunchDescription([</span><br><span class="line">        Node(package=<span class="string">&quot;turtlesim&quot;</span>,executable=<span class="string">&quot;turtlesim_node&quot;</span>,name=<span class="string">&quot;turtle1&quot;</span>),</span><br><span class="line">        Node(package=<span class="string">&quot;turtlesim&quot;</span>,executable=<span class="string">&quot;turtlesim_node&quot;</span>,namespace=<span class="string">&quot;t1&quot;</span>),</span><br><span class="line">        Node(package=<span class="string">&quot;turtlesim&quot;</span>,executable=<span class="string">&quot;turtlesim_node&quot;</span>,namespace=<span class="string">&quot;t1&quot;</span>, name=<span class="string">&quot;turtle1&quot;</span>)</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p><strong>XML方式</strong></p><p>可以通过 node 标签中 name 和 namespace 属性来设置节点的名称与命名空间，使用示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">exec</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;turtle1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">exec</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;t1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">exec</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;t1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;turtle1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>YAML方式</strong></p><p>可以通过 node 属性中 name 和 namespace 属性来设置节点的名称与命名空间，使用示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">launch:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">node:</span></span><br><span class="line">    <span class="attr">pkg:</span> <span class="string">turtlesim</span></span><br><span class="line">    <span class="attr">exec:</span> <span class="string">turtlesim_node</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">turtle1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">node:</span></span><br><span class="line">    <span class="attr">pkg:</span> <span class="string">turtlesim</span></span><br><span class="line">    <span class="attr">exec:</span> <span class="string">turtlesim_node</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">t1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">node:</span></span><br><span class="line">    <span class="attr">pkg:</span> <span class="string">turtlesim</span></span><br><span class="line">    <span class="attr">exec:</span> <span class="string">turtlesim_node</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">t1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">turtle1</span></span><br></pre></td></tr></table></figure><p>运行方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 launch [包名] [可执行程序]</span><br></pre></td></tr></table></figure><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>在 rclcpp 和 rclpy 中，节点类的构造函数中，都分别提供了设置节点名称与命名空间的参数</p><p>rclcpp中节点类的构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Node</span> (<span class="type">const</span> std::string &amp;node_name, <span class="type">const</span> NodeOptions &amp;options=<span class="built_in">NodeOptions</span>())</span><br><span class="line"><span class="built_in">Node</span> (<span class="type">const</span> std::string &amp;node_name, <span class="type">const</span> std::string &amp;namespace_, <span class="type">const</span> NodeOptions &amp;options=<span class="built_in">NodeOptions</span>())</span><br></pre></td></tr></table></figure><p>构造函数1中可以直接通过node_name设置节点名称，构造函数2既可以通过node_name设置节点名称也可以通过namespace_设置命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyNode</span>():<span class="built_in">Node</span>(<span class="string">&quot;my_node_cpp&quot;</span>,<span class="string">&quot;ns&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="话题重名"><a href="#话题重名" class="headerlink" title="话题重名"></a>话题重名</h3><p>在 ROS2 不同的节点之间通信都依赖于话题，话题名称也可能出现重名的情况，话题重名时，系统虽然不会抛出异常，但是通过相同话题名称关联到一起的节点可能并不属于同一通信逻辑，从而导致通信错乱，甚至出现异常,这种情况下可能就需要将相同的话题名称设置为不同</p><p>又或者，两个节点是属于同一通信逻辑的，但是节点之间话题名称不同，导致通信失败。这种情况下就需要将两个节点的话题名称由不同修改为相同</p><p>与节点重名的解决思路类似的，为了避免话题重名问题，一般有两种策略：</p><ol><li>名称重映射，也即为话题名称起别名；</li><li>命名空间，是为话题名称添加前缀，可以有多级，格式：&#x2F;xxx&#x2F;yyy&#x2F;zzz</li></ol><p><font color='Violetred'>需要注意的是，通过命名空间设置话题名称时，需要保证话题是非全局话题</font></p><p>与节点重名解决方案类似的，修改话题名称的方式主要有如下三种：</p><ol><li>ros2 run 命令实现；</li><li>launch 文件实现；</li><li>编码实现</li></ol><h4 id="run2-run-1"><a href="#run2-run-1" class="headerlink" title="run2 run"></a>run2 run</h4><p><strong>设置命名空间</strong></p><p>该实现与节点重名的方法相同</p><p>语法：ros2 run 包名 节点名 –ros-args –remap __ns:&#x3D;命名空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node --ros-args --remap __ns:=/t1</span><br></pre></td></tr></table></figure><p><strong>话题名称重映射</strong></p><p>语法：ros2 run 包名 节点名 –ros-args –remap 原话题名称:&#x3D;新话题名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node --ros-args --remap /turtle1/cmd_vel:=/cmd_vel</span><br></pre></td></tr></table></figure><p>当为节点添加命名空间时，节点下的所有非全局话题都会前缀命名空间，而重映射的方式只是修改指定话题</p><h4 id="launch-1"><a href="#launch-1" class="headerlink" title="launch"></a>launch</h4><p><strong>python方式</strong></p><p>可以通过类 <code>launch_ros.actions.Node</code>的构造函数中的参数 remappings 修改话题名称，使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LaunchDescription([</span><br><span class="line">        Node(package=<span class="string">&quot;turtlesim&quot;</span>,executable=<span class="string">&quot;turtlesim_node&quot;</span>,namespace=<span class="string">&quot;t1&quot;</span>),</span><br><span class="line">        Node(package=<span class="string">&quot;turtlesim&quot;</span>,</span><br><span class="line">            executable=<span class="string">&quot;turtlesim_node&quot;</span>,</span><br><span class="line">            remappings=[(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>,<span class="string">&quot;/cmd_vel&quot;</span>)]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p><strong>XML方式</strong></p><p>通过 node 标签的子标签 remap（属性from取值为被修改的话题名称，属性to的取值为修改后的话题名称） 修改话题名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">exec</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;t1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">exec</span>=<span class="string">&quot;turtlesim_node&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/turtle1/cmd_vel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/cmd_vel&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>YAML方式</strong></p><p>通过 node 属性中 remap（属性from取值为被修改的话题名称，属性to的取值为修改后的话题名称） 修改话题名称</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">launch:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">node:</span></span><br><span class="line">    <span class="attr">pkg:</span> <span class="string">turtlesim</span></span><br><span class="line">    <span class="attr">exec:</span> <span class="string">turtlesim_node</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">t1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">node:</span></span><br><span class="line">    <span class="attr">pkg:</span> <span class="string">turtlesim</span></span><br><span class="line">    <span class="attr">exec:</span> <span class="string">turtlesim_node</span></span><br><span class="line">    <span class="attr">remap:</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">from:</span> <span class="string">&quot;/turtle1/cmd_vel&quot;</span></span><br><span class="line">        <span class="attr">to:</span> <span class="string">&quot;/cmd_vel</span></span><br></pre></td></tr></table></figure><h4 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h4><p>话题名称大致可以分为三种类型:</p><ul><li>全局话题(话题参考ROS系统，与节点命名空间平级)；</li><li>相对话题(话题参考的是节点的命名空间，与节点名称平级)；</li><li>私有话题(话题参考节点名称，是节点名称的子级)</li></ul><p><strong>全局话题</strong></p><p>定义时以<code>/</code>开头的名称，和命名空间、节点名称无关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;(&quot;/topic/chatter&quot;, 10);</span><br></pre></td></tr></table></figure><p>话题名称为 &#x2F;topic&#x2F;chatter，与命名空间 xxx 以及节点名称 yyy 无关</p><p><strong>相对话题</strong></p><p>非<code>/</code>开头的名称，参考命名空间设置话题名称，和节点名称无关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;(&quot;topic/chatter&quot;, 10);</span><br></pre></td></tr></table></figure><p>话题名称为 &#x2F;xxx&#x2F;topic&#x2F;chatter，与命名空间 xxx 有关，与节点名称 yyy 无关</p><p><strong>私有话题</strong></p><p>以<code>~/</code>开头的名称，和命名空间、节点名称都有关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;(&quot;~/topic/chatter&quot;, 10);</span><br></pre></td></tr></table></figure><p>话题名称为 &#x2F;xxx&#x2F;yyy&#x2F;topic&#x2F;chatter，使用命名空间 xxx 以及节点名称 yyy 作为话题名称前缀</p><p>话题名称设置规则在rclcpp与rclpy中基本一致，且上述规则也同样适用于ros2 run指令与launch文件</p><h3 id="时间相关API"><a href="#时间相关API" class="headerlink" title="时间相关API"></a>时间相关API</h3><h4 id="Rate"><a href="#Rate" class="headerlink" title="Rate"></a>Rate</h4><p>示例：周期性输出一段文本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNode</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyNode</span>():<span class="built_in">Node</span>(<span class="string">&quot;time_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;创建成功!&quot;</span>);</span><br><span class="line">        <span class="built_in">demo_rate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">demo_rate</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 1. 创建Rate对象</span></span><br><span class="line">      <span class="function">rclcpp::Rate <span class="title">rate</span><span class="params">(<span class="number">500</span>ms)</span></span>;  <span class="comment">// 设置时间间隔</span></span><br><span class="line">      <span class="comment">// rclcpp::Rate rate(1.0); // 设置频率，输入浮点型数据</span></span><br><span class="line">      <span class="comment">// 2. 调用Rate的sleep函数</span></span><br><span class="line">      <span class="keyword">while</span> (rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数,并传入节点类对象;</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;MyNode&gt;()); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h4><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNode</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyNode</span>():<span class="built_in">Node</span>(<span class="string">&quot;time_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;创建成功!&quot;</span>);</span><br><span class="line">        <span class="comment">// demo_rate();</span></span><br><span class="line">        <span class="built_in">demo_time</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">demo_time</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 1. 创建 Time 对象</span></span><br><span class="line">      <span class="function">rclcpp::Time <span class="title">t1</span><span class="params">(<span class="number">500000000L</span>)</span></span>; <span class="comment">// 0.5s</span></span><br><span class="line">      <span class="function">rclcpp::Time <span class="title">t2</span><span class="params">(<span class="number">2</span>,<span class="number">500000000L</span>)</span></span>; <span class="comment">// 2.5s</span></span><br><span class="line">      <span class="comment">// rclcpp::Time right_now = this-&gt;get_clock()-&gt;now();</span></span><br><span class="line">      rclcpp::Time right_now = <span class="keyword">this</span>-&gt;<span class="built_in">now</span>();</span><br><span class="line">      <span class="comment">// 2. 调用Time对象函数</span></span><br><span class="line">      <span class="comment">// 秒为单位的输出 和 纳秒为单位的输出</span></span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;s = %.2f, ns = %ld&quot;</span>,t<span class="number">1.</span><span class="built_in">seconds</span>(),t<span class="number">1.</span><span class="built_in">nanoseconds</span>());  </span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;s = %.2f, ns = %ld&quot;</span>,t<span class="number">2.</span><span class="built_in">seconds</span>(),t<span class="number">2.</span><span class="built_in">nanoseconds</span>());</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;s = %.2f, ns = %ld&quot;</span>,right_now.<span class="built_in">seconds</span>(),right_now.<span class="built_in">nanoseconds</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数,并传入节点类对象;</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;MyNode&gt;()); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Time</code> 的典型场景</p><ul><li>为消息添加时间戳（如 <code>sensor_msgs/msg/Image</code> 的 <code>header.stamp</code>）</li><li>记录事件发生的具体时刻（如机器人到达某个位置的时间）</li></ul><h4 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h4><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNode</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyNode</span>():<span class="built_in">Node</span>(<span class="string">&quot;time_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;创建成功!&quot;</span>);</span><br><span class="line">        <span class="comment">// demo_rate();</span></span><br><span class="line">        <span class="comment">// demo_time();</span></span><br><span class="line">        <span class="built_in">demo_duration</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">demo_duration</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 1. 创建 Duraiton 对象</span></span><br><span class="line">      <span class="function">rclcpp::Duration <span class="title">du1</span><span class="params">(<span class="number">1</span>s)</span></span>; <span class="comment">// 1s</span></span><br><span class="line">      <span class="function">rclcpp::Duration <span class="title">du2</span><span class="params">(<span class="number">2</span>,<span class="number">500000000</span>)</span></span>; <span class="comment">// 2.5s</span></span><br><span class="line">      <span class="comment">// 2. 调用 Duration 函数</span></span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;s = %.2f, ns = %ld&quot;</span>,du<span class="number">1.</span><span class="built_in">seconds</span>(),du<span class="number">1.</span><span class="built_in">nanoseconds</span>());</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;s = %.2f, ns = %ld&quot;</span>,du<span class="number">2.</span><span class="built_in">seconds</span>(),du<span class="number">2.</span><span class="built_in">nanoseconds</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Duration</code> 的典型场景</p><ul><li>设置定时器周期</li><li>实现延时等待</li></ul><p>问题：Time与Duration有什么区别？</p><p>API使用类似，但二者有着本质区别：</p><p>rclcpp:Time t2(2,500000000L) –&gt; 指的是一个具体时刻(时间点)</p><p>rclcpp::Duration du2(2,500000000) –&gt; 指的是一个时间段</p><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>Time ± Duration → Time：时间点加减时间段 → 新时间点</p><p>Time - Time → Duration：两个时间点相减 → 时间段</p><p>Duration ± Duration → Duration：时间段加减 → 新时间段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNode</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyNode</span>():<span class="built_in">Node</span>(<span class="string">&quot;time_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;创建成功!&quot;</span>);</span><br><span class="line">        <span class="comment">// demo_rate();</span></span><br><span class="line">        <span class="comment">// demo_time();</span></span><br><span class="line">        <span class="comment">// demo_duration();</span></span><br><span class="line">        <span class="built_in">demo_opt</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">demo_opt</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="function">rclcpp::Time <span class="title">t1</span><span class="params">(<span class="number">10</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="function">rclcpp::Time <span class="title">t2</span><span class="params">(<span class="number">30</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="function">rclcpp::Duration <span class="title">du1</span><span class="params">(<span class="number">8</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="function">rclcpp::Duration <span class="title">du2</span><span class="params">(<span class="number">17</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="comment">// 比较</span></span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;t1 &gt;= t2 ? %d&quot;</span>,t1 &gt;= t2);</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;t1 &lt; t2 ? %d&quot;</span>,t1 &lt; t2);</span><br><span class="line">      rclcpp::Duration du3 = t2 - t1;</span><br><span class="line">      rclcpp::Time t3 = t1 + du1;</span><br><span class="line">      rclcpp::Time t4 = t1 - du1;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;t3 = %.2f&quot;</span>,t<span class="number">3.</span><span class="built_in">seconds</span>());  </span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;t4 = %.2f&quot;</span>,t<span class="number">4.</span><span class="built_in">seconds</span>()); </span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;du3 = %.2f&quot;</span>,du<span class="number">3.</span><span class="built_in">seconds</span>()); </span><br><span class="line">      <span class="comment">// 比较</span></span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;du1 &gt;= du2 ? %d&quot;</span>, du1 &gt;= du2);</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;du1 &lt; du2 ? %d&quot;</span>, du1 &lt; du2);</span><br><span class="line">      <span class="comment">// 数学运算</span></span><br><span class="line">      rclcpp::Duration du4 = du1 * <span class="number">3.0</span>;</span><br><span class="line">      rclcpp::Duration du5 = du1 + du2;</span><br><span class="line">      rclcpp::Duration du6 = du1 - du2;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;du4 = %.2f&quot;</span>,du<span class="number">4.</span><span class="built_in">seconds</span>()); </span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;du5 = %.2f&quot;</span>,du<span class="number">5.</span><span class="built_in">seconds</span>()); </span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;du6 = %.2f&quot;</span>,du<span class="number">6.</span><span class="built_in">seconds</span>()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Duration 可以负数，但 Time 不可以负数</p><h3 id="通信机制工具"><a href="#通信机制工具" class="headerlink" title="通信机制工具"></a>通信机制工具</h3><p>在ROS2中，通信机制相关的工具有两种类型，分别是命令行工具和图形化工具（rqt）</p><p>前者是一系列终端命令的集合，后者则是ROS2基于QT框架，针对机器人开发的一系列可视化工具的集合</p><h4 id="命令工具"><a href="#命令工具" class="headerlink" title="命令工具"></a>命令工具</h4><p>关于命令的使用一般都会提供帮助文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令 -h -&gt; ros2 node -h</span><br><span class="line">命令 --help -&gt; ros2 node -help</span><br></pre></td></tr></table></figure><p>常用命令整合：</p><blockquote><p>ros2 interace 整合了rosmsg</p><p>ROS2 将消息、服务、动作等抽象为“接口”，简化工具链</p></blockquote><table><thead><tr><th>命令</th><th>参数</th></tr></thead><tbody><tr><td>ros2 node</td><td>info → 输出节点信息<br />list → 输出运行中的节点的列表</td></tr><tr><td>ros2 interace</td><td>list → 输出所有可用的接口消息<br />package → 输出指定功能包下的接口<br />packages → 输出全部包含接口消息的功能包<br />proto → 输出接口消息原型<br />show → 输出接口消息定义格式</td></tr><tr><td>ros2 topic</td><td>bw → 输出话题消息传输占用的带宽<br />delay → 输出带有 header 的话题延迟<br />echo → 输出某个话题下的消息<br />find → 根据类型查找话题<br />hz → 输出消息发布频率<br />info → 输出话题相关信息<br />list → 输出运行中的话题列表<br />pub → 向指定话题发布消息<br />type → 输出话题使用的接口类型</td></tr><tr><td>ros2 service</td><td>call → 向某个服务发送请求<br />find → 根据类型查找服务<br />list → 输出运行中的服务列表<br />type → 输出服务使用的接口类型</td></tr><tr><td>ros2 action</td><td>info → 输出指定动作的相关信息<br />list → 输出运行中的动作的列表<br />send_goal → 向指定动作发送请求</td></tr><tr><td>ros2 param</td><td>delete → 删除参数<br />describe → 输出参数的描述信息<br />dump → 将节点参数写入到磁盘文件<br />get → 获取某个参数<br />list → 输出可用的参数的列表<br />load → 从磁盘文件加载参数到节点<br />set → 设置参数</td></tr></tbody></table><h4 id="rqt工具箱"><a href="#rqt工具箱" class="headerlink" title="rqt工具箱"></a>rqt工具箱</h4><p>一般只要安装的是desktop版本就会默认安装rqt工具箱</p><p>常用的启动命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt</span><br></pre></td></tr></table></figure><p>启动rqt之后，可以通过plugins添加所需的插件</p><p>可以在rqt中向话题发送消息</p><h2 id="ROS2通信机制实操"><a href="#ROS2通信机制实操" class="headerlink" title="ROS2通信机制实操"></a>ROS2通信机制实操</h2><p>终端下进入工作空间的src目录，调用如下命令创建C++功能包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create cpp07_exercise --build-type ament_cmake --dependencies rclcpp turtlesim base_interfaces geometry_msgs rclcpp_action</span><br></pre></td></tr></table></figure><h3 id="话题通信案例"><a href="#话题通信案例" class="headerlink" title="话题通信案例"></a>话题通信案例</h3><p>需求：启动两个turtlesim_node节点，节点2中的乌龟自动调头180°，可以通过键盘控制节点1中的乌龟运动，但是不能控制节点2的乌龟，需要自实现功能：可以根据乌龟1的速度生成并发布控制乌龟2运动的速度指令，最终两只乌龟做镜像运动</p><p>核心实现是如何订阅乌龟1的速度并生成发布控制乌龟2运动的速度指令的，并且该节点需要在掉头完毕后启动</p><p>package.xml文件无需修改</p><p>CMakeLists.txt中配置launch文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">install(TARGETS </span><br><span class="line">  test01_topic</span><br><span class="line">  DESTINATION lib/$&#123;PROJECT_NAME&#125;)</span><br><span class="line"># 增加</span><br><span class="line">install(DIRECTORY launch DESTINATION share/$&#123;PROJECT_NAME&#125;)</span><br></pre></td></tr></table></figure><p><strong>launch文件</strong></p><p>启动小乌龟节点，查看action类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ros2 action list</span><br><span class="line">ros2 action info /turtle1/rotate_absolute</span><br><span class="line">ros2 action send_goal /turtle1/rotate_absolute </span><br></pre></td></tr></table></figure><p>后面不清楚的就[TAB]补齐即可</p><p>明确在终端如何通过命令控制乌龟运动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> ExecuteProcess,RegisterEventHandler</span><br><span class="line"><span class="keyword">from</span> launch.event_handlers <span class="keyword">import</span> OnProcessExit</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    <span class="comment"># 1. 启动两个turtlesim_node，其中一个设置命名空间</span></span><br><span class="line">    t1 = Node(package=<span class="string">&quot;turtlesim&quot;</span>,executable=<span class="string">&quot;turtlesim_node&quot;</span>)</span><br><span class="line">    t2 = Node(package=<span class="string">&quot;turtlesim&quot;</span>,executable=<span class="string">&quot;turtlesim_node&quot;</span>,namespace=<span class="string">&quot;t2&quot;</span>)</span><br><span class="line">    <span class="comment"># 2. 控制第二个乌龟掉头</span></span><br><span class="line">    rotate = ExecuteProcess(</span><br><span class="line">        cmd = [<span class="string">&quot;ros2 action send_goal /t2/turtle1/rotate_absolute turtlesim/action/RotateAbsolute \&quot;&#123;&#x27;theta&#x27;:3.14&#125;\&quot;&quot;</span>], <span class="comment"># 记得转义字符</span></span><br><span class="line">        output = <span class="string">&quot;both&quot;</span>,</span><br><span class="line">        shell = <span class="literal">True</span>  <span class="comment"># cmd当成终端指令执行</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 3. 调用自定义的节点，并且节点调用顺序有要求</span></span><br><span class="line">    test01 = Node(package=<span class="string">&quot;cpp07_exercise&quot;</span>,executable=<span class="string">&quot;test01_topic&quot;</span>)</span><br><span class="line">    <span class="comment"># 4. 控制节点启动,需要通过注册事件完成</span></span><br><span class="line">    <span class="comment"># 创建事件注册对象，在对象中声明针对哪个目标节点，在哪个事件触发时，执行哪种操作</span></span><br><span class="line">    register_rotate_exit_event = RegisterEventHandler(</span><br><span class="line">        <span class="comment"># 创建一个新对象，监听rotate的启动，退出后启动test01</span></span><br><span class="line">        event_handler = OnProcessExit(</span><br><span class="line">            target_action=rotate, <span class="comment"># 目标节点</span></span><br><span class="line">            on_exit=test01) <span class="comment"># 触发事件</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> LaunchDescription([t1,t2,rotate,register_rotate_exit_event])</span><br></pre></td></tr></table></figure><p><strong>速度订阅与发布</strong></p><p>test01_topic.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  需求：订阅窗口1中乌龟的位姿信息，解析出线速度和角速度，生成控制窗口2乌龟运动的指令并发布</span></span><br><span class="line"><span class="comment">  明确：</span></span><br><span class="line"><span class="comment">      订阅话题：/turtle1/pose</span></span><br><span class="line"><span class="comment">      订阅消息：turtlesim/msg/Pose</span></span><br><span class="line"><span class="comment">              x: 0.0</span></span><br><span class="line"><span class="comment">              y: 0.0</span></span><br><span class="line"><span class="comment">              theta: 0.0</span></span><br><span class="line"><span class="comment">              linear_velocity: 0.0</span></span><br><span class="line"><span class="comment">              angular_velocity: 0.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      发布话题：/t2/turtle1/cmd_vel</span></span><br><span class="line"><span class="comment">      发布消息：geometry_msgs/msg/Twist</span></span><br><span class="line"><span class="comment">              linear:</span></span><br><span class="line"><span class="comment">                x: 0.0</span></span><br><span class="line"><span class="comment">                y: 0.0</span></span><br><span class="line"><span class="comment">                z: 0.0</span></span><br><span class="line"><span class="comment">              angular:</span></span><br><span class="line"><span class="comment">                x: 0.0  翻滚</span></span><br><span class="line"><span class="comment">                y: 0.0  俯仰</span></span><br><span class="line"><span class="comment">                z: 0.0  左右转</span></span><br><span class="line"><span class="comment">  步骤：</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1 创建发布方</span></span><br><span class="line"><span class="comment">      3-2 创建订阅方(订阅乌龟1位姿，解析速度)</span></span><br><span class="line"><span class="comment">      3-3 订阅方回调函数处理速度，并生成发布控制乌龟2的指令</span></span><br><span class="line"><span class="comment">    4.调用spin函数,并传入节点对象指针;</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/twist.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/msg/pose.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test01PubSub</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test01PubSub</span>():<span class="built_in">Node</span>(<span class="string">&quot;test01_pub_sub_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;创建成功!&quot;</span>);</span><br><span class="line">        <span class="comment">// 3-1 创建发布方</span></span><br><span class="line">        twist_pub_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;geometry_msgs::msg::Twist&gt;(<span class="string">&quot;/t2/turtle1/cmd_vel&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 3-2 创建订阅方(订阅乌龟1位姿，解析速度)</span></span><br><span class="line">        pose_sub_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;turtlesim::msg::Pose&gt;(<span class="string">&quot;/turtle1/pose&quot;</span>,<span class="number">10</span>,std::<span class="built_in">bind</span>(&amp;Test01PubSub::do_pose,<span class="keyword">this</span>,_1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_pose</span><span class="params">(<span class="type">const</span> turtlesim::msg::Pose &amp; pose)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 处理速度，并生成发布控制乌龟2的指令</span></span><br><span class="line">      geometry_msgs::msg::Twist twist;</span><br><span class="line">      twist.linear.x = (pose.linear_velocity); <span class="comment">// 线速度不变</span></span><br><span class="line">      twist.angular.z = -(pose.angular_velocity); <span class="comment">// 角速度取反</span></span><br><span class="line">      twist_pub_-&gt;<span class="built_in">publish</span>(twist);</span><br><span class="line">    &#125;</span><br><span class="line">    rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr twist_pub_;</span><br><span class="line">    rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr pose_sub_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数,并传入节点类对象;</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;Test01PubSub&gt;()); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BUG描述：乌龟1后退时，乌龟2仍然前进</p><p>BUG原因：</p><ol><li>和乌龟位姿发布有关，当乌龟实际速度为负数时，位姿中的速度仍是正数；</li><li>发布的乌龟2的速度，与位姿中的线速度一致</li></ol><p>BUG修复：(修改源码)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p-&gt;linear_velocity = std::sqrt(lin_vel_x_ * lin_vel_x_ + lin_vel_y_ * lin_vel_y_);</span></span><br><span class="line">p-&gt;linear_velocity = lin_vel_x_;</span><br></pre></td></tr></table></figure><h3 id="服务通信案例"><a href="#服务通信案例" class="headerlink" title="服务通信案例"></a>服务通信案例</h3><p>需求：在turtlesim_node节点的窗体中在指定位置生成一只新乌龟并可以输出两只乌龟之间的直线距离</p><p>需要关注的问题有两个：</p><ol><li>如何在指定位置生成一只新乌龟？</li><li>计算两只乌龟的距离应该使用何种通信模式又如何实现？</li></ol><p>问题1可以通过调用turtlesim_node内置的名称为&#x2F;spawn的服务功能来实现新乌龟的创建；</p><p>问题2可以通过服务通信来实现，客户端发送新生成的乌龟的位姿到服务端，服务端根据该坐标以及原生乌龟的坐标计算距离并响应。当然如果使用服务通信，还需要自定义服务接口</p><p><strong>自定义接口消息</strong></p><p>功能包base_interfaces_demo的srv目录下，新建srv文件Distance.srv</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float32 x</span><br><span class="line">float32 y</span><br><span class="line">float32 theta</span><br><span class="line">---</span><br><span class="line">float32 distance</span><br></pre></td></tr></table></figure><p>CMakeList.txt配置(其余部分之前配置过)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 为接口文件生成源码</span><br><span class="line">rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;</span><br><span class="line">  &quot;msg/Student.msg&quot;</span><br><span class="line">  &quot;srv/AddInts.srv&quot;</span><br><span class="line">  &quot;action/Progress.action&quot;</span><br><span class="line">  &quot;srv/Distance.srv&quot; # 新增</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>检查是否配置成功；</p><p>先创建cpp和launch.py文件，配置功能包目录下的CMakeList，launch文件的配置因为用的是同一功能包不需要重复</p><p><strong>launch文件</strong></p><p>服务端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    <span class="comment"># 1. turtlesim node</span></span><br><span class="line">    t1 = Node(package=<span class="string">&quot;turtlesim&quot;</span>,executable=<span class="string">&quot;turtlesim_node&quot;</span>)</span><br><span class="line">    <span class="comment"># 2. 自定义的服务端</span></span><br><span class="line">    server = Node(package=<span class="string">&quot;cpp07_exercise&quot;</span>,executable=<span class="string">&quot;test02_server&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> LaunchDescription([t1,server])</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> ExecuteProcess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    <span class="comment"># 1. 指定位置生成一只新乌龟</span></span><br><span class="line">    x = <span class="number">6.0</span></span><br><span class="line">    y = <span class="number">9.0</span></span><br><span class="line">    theta = <span class="number">1.57</span></span><br><span class="line">    name = <span class="string">&quot;t2&quot;</span></span><br><span class="line">    spawn = ExecuteProcess(</span><br><span class="line">        cmd = [<span class="string">&quot;ros2 service call /spawn turtlesim/srv/Spawn \&quot;&#123;&#x27;x&#x27;: &quot;</span></span><br><span class="line">               + <span class="built_in">str</span>(x) +<span class="string">&quot;,&#x27;y&#x27;: &quot;</span>+ <span class="built_in">str</span>(y) +</span><br><span class="line">               <span class="string">&quot;,&#x27;theta&#x27;: &quot;</span>+ <span class="built_in">str</span>(theta) +</span><br><span class="line">               <span class="string">&quot;,&#x27;name&#x27;:&#x27;&quot;</span>+ name +<span class="string">&quot;&#x27;&#125;\&quot;&quot;</span>], <span class="comment"># 记得转义字符</span></span><br><span class="line">        output = <span class="string">&quot;both&quot;</span>,</span><br><span class="line">        shell = <span class="literal">True</span>  <span class="comment"># cmd当成终端指令执行</span></span><br><span class="line">    )</span><br><span class="line">    client = Node(package=<span class="string">&quot;cpp07_exercise&quot;</span>,</span><br><span class="line">                  executable=<span class="string">&quot;test02_client&quot;</span>,</span><br><span class="line">                  arguments=[<span class="built_in">str</span>(x),<span class="built_in">str</span>(y),<span class="built_in">str</span>(theta)])</span><br><span class="line">    <span class="comment"># 相当于ros2 run cpp07_exercise test02_client 6 9 0.0 --ros-args</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 调用客户端发送目标点坐标 </span></span><br><span class="line">    <span class="keyword">return</span> LaunchDescription([spawn,client])</span><br></pre></td></tr></table></figure><p><strong>服务端实现</strong></p><p>test02_server.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  需求:解析客户端提交的目标点坐标，获取原生乌龟坐标，计算二者距离并响应回客户端。</span></span><br><span class="line"><span class="comment">  步骤:</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1.创建一个订阅方（原生乌龟位姿/turtlel/pose)；</span></span><br><span class="line"><span class="comment">      3-2.创建一个服务端；</span></span><br><span class="line"><span class="comment">      3-3.回调函数需要解析客户端数据并响应结果到客户端。</span></span><br><span class="line"><span class="comment">    4.调用spin函数,并传入节点对象指针;</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/msg/pose.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_interfaces/srv/distance.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> base_interfaces::srv::Distance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test02Server</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test02Server</span>():<span class="built_in">Node</span>(<span class="string">&quot;test02_server_node_cpp&quot;</span>),<span class="built_in">x</span>(<span class="number">0.0</span>),<span class="built_in">y</span>(<span class="number">0.0</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;创建成功!&quot;</span>);</span><br><span class="line">        pose_sub_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;turtlesim::msg::Pose&gt;(<span class="string">&quot;/turtle1/pose&quot;</span>,<span class="number">10</span>,std::<span class="built_in">bind</span>(&amp;Test02Server::pose_cb,<span class="keyword">this</span>,_1));</span><br><span class="line">        server_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_service</span>&lt;Distance&gt;(<span class="string">&quot;distance&quot;</span>,std::<span class="built_in">bind</span>(&amp;Test02Server::distance_cb,<span class="keyword">this</span>,_1,_2));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr pose_sub_;</span><br><span class="line">    rclcpp::Service&lt;Distance&gt;::SharedPtr server_;</span><br><span class="line">    <span class="type">float</span> x,y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pose_cb</span><span class="params">(<span class="type">const</span> turtlesim::msg::Pose::SharedPtr pose)</span></span>&#123;</span><br><span class="line">      x = pose-&gt;x;</span><br><span class="line">      y = pose-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">distance_cb</span><span class="params">(<span class="type">const</span> Distance::Request::SharedPtr request,<span class="type">const</span> Distance::Response::SharedPtr response)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 解析目标点坐标</span></span><br><span class="line">      <span class="type">float</span> goal_x = request-&gt;x;</span><br><span class="line">      <span class="type">float</span> goal_y = request-&gt;y;</span><br><span class="line">      <span class="comment">// 计算距离</span></span><br><span class="line">      <span class="type">float</span> distance_x = goal_x - x;</span><br><span class="line">      <span class="type">float</span> distance_y = goal_y - y;</span><br><span class="line">      <span class="type">float</span> distance = std::<span class="built_in">sqrt</span>(distance_x * distance_x + distance_y * distance_y);</span><br><span class="line">      <span class="comment">// 设置进响应</span></span><br><span class="line">      response-&gt;distance = distance;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;目标坐标:(%.2f,%.2f),距离:%.2f&quot;</span>,goal_x,goal_y,response-&gt;distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数,并传入节点类对象;</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;Test02Server&gt;()); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现</strong></p><p>test02_client.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  需求：客户端需要提交目标点坐标，并解析响应结果。</span></span><br><span class="line"><span class="comment">  步骤：</span></span><br><span class="line"><span class="comment">    0.解析传入的数据</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1.构造函数创建客户端;</span></span><br><span class="line"><span class="comment">      3-2.客户端需要连接服务端;</span></span><br><span class="line"><span class="comment">      3-3.发送请求数据。</span></span><br><span class="line"><span class="comment">    4.调用对象服务连接、发送请求、处理响应相关函数;</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_interfaces/srv/distance.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> base_interfaces::srv::Distance;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test02Client</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test02Client</span>():<span class="built_in">Node</span>(<span class="string">&quot;test02_client_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;创建成功!&quot;</span>);</span><br><span class="line">        <span class="comment">// 3-1.构造函数创建客户端;</span></span><br><span class="line">        distance_client_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_client</span>&lt;Distance&gt;(<span class="string">&quot;distance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3-2.客户端需要连接服务端;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connect_server</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!distance_client_-&gt;<span class="built_in">wait_for_service</span>(<span class="number">1</span>s))&#123;</span><br><span class="line">          <span class="keyword">if</span> (!rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;客户端退出！&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;服务连接中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rclcpp::Client&lt;Distance&gt;::<span class="function">FutureAndRequestId <span class="title">send_goal</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> theta)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> request = std::<span class="built_in">make_shared</span>&lt;Distance::Request&gt;();</span><br><span class="line">      request-&gt;x = x;</span><br><span class="line">      request-&gt;y = y;</span><br><span class="line">      request-&gt;theta = theta;</span><br><span class="line">      <span class="keyword">return</span> distance_client_-&gt;<span class="built_in">async_send_request</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    rclcpp::Client&lt;Distance&gt;::SharedPtr distance_client_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">5</span>) <span class="comment">// 5是因为还有name，一共其实是4个参数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;请传入目标的位姿参数:(x,y,theta)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用对象服务连接、处理响应相关函数</span></span><br><span class="line">  <span class="keyword">auto</span> client = std::<span class="built_in">make_shared</span>&lt;Test02Client&gt;();</span><br><span class="line">  <span class="comment">// 解析提交的参数</span></span><br><span class="line">  <span class="type">float</span> goal_x = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="type">float</span> goal_y = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> goal_theta = <span class="built_in">atoi</span>(argv[<span class="number">3</span>]);</span><br><span class="line">  <span class="type">bool</span> flag = client-&gt;<span class="built_in">connect_server</span>();</span><br><span class="line">  <span class="keyword">if</span>(!flag)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;服务连接失败!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送请求</span></span><br><span class="line">  <span class="keyword">auto</span> distance_future = client-&gt;<span class="built_in">send_goal</span>(goal_x,goal_y,goal_theta);</span><br><span class="line">  <span class="comment">// 判断响应状态</span></span><br><span class="line">  <span class="keyword">if</span>(rclcpp::<span class="built_in">spin_until_future_complete</span>(client,distance_future)==rclcpp::FutureReturnCode::SUCCESS)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(client-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;两只乌龟相距%.2f米。&quot;</span>,distance_future.<span class="built_in">get</span>()-&gt;distance);</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_ERROR</span>(client-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;获取距离服务失败!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动作通信案例"><a href="#动作通信案例" class="headerlink" title="动作通信案例"></a>动作通信案例</h3><p>需求：处理请求发送的目标点，控制乌龟向该目标点运动，并连续反馈乌龟与目标点之间的剩余距离</p><p>在上述案例与服务通信案例类似，需要关注控制原生乌龟向目标乌龟运动并连续反馈剩余距离应该使用何种通信模式又如何实现？</p><p>思路：可以通过动作通信来实现，动作客户端发送目标信息到动作服务端，服务端根据该坐标以及原生乌龟的坐标计计算出二者距离，计算速度并控制原生乌龟运动。当然如果使用动作通信，还需要自定义动作接口。</p><p><strong>动作接口文件</strong></p><p>功能包base_interfaces_demo的action目录下，新建action文件Nav.action</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">float32 goal_x</span><br><span class="line">float32 goal_y</span><br><span class="line">float32 goal_theta</span><br><span class="line">---</span><br><span class="line">float32 turtle_x</span><br><span class="line">float32 turtle_y</span><br><span class="line">float32 turtle_theta</span><br><span class="line">---</span><br><span class="line">float32 distance</span><br></pre></td></tr></table></figure><p>编辑CMakeList(其余之前配置过)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 为接口文件生成源码</span><br><span class="line">rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;</span><br><span class="line">  &quot;msg/Student.msg&quot;</span><br><span class="line">  &quot;srv/AddInts.srv&quot;</span><br><span class="line">  &quot;srv/Distance.srv&quot;</span><br><span class="line">  &quot;action/Progress.action&quot;</span><br><span class="line">  &quot;action/Nav.action&quot; #新增</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>launch文件</strong></p><p>launch和服务通信的基本相同，复制内容修改节点即可</p><p>服务端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    <span class="comment"># 1. turtlesim node</span></span><br><span class="line">    t1 = Node(package=<span class="string">&quot;turtlesim&quot;</span>,executable=<span class="string">&quot;turtlesim_node&quot;</span>)</span><br><span class="line">    <span class="comment"># 2. 自定义的服务端</span></span><br><span class="line">    server = Node(package=<span class="string">&quot;cpp07_exercise&quot;</span>,executable=<span class="string">&quot;test03_action_server&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> LaunchDescription([t1,server])</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> ExecuteProcess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    x = <span class="number">6.0</span></span><br><span class="line">    y = <span class="number">9.0</span></span><br><span class="line">    theta = <span class="number">1.57</span></span><br><span class="line">    client = Node(package=<span class="string">&quot;cpp07_exercise&quot;</span>,</span><br><span class="line">                  executable=<span class="string">&quot;test03_action_client&quot;</span>,</span><br><span class="line">                  arguments=[<span class="built_in">str</span>(x),<span class="built_in">str</span>(y),<span class="built_in">str</span>(theta)])</span><br><span class="line">    <span class="comment"># 相当于ros2 run cpp07_exercise test02_client 6 9 0.0 --ros-args</span></span><br><span class="line">    <span class="comment"># 调用客户端发送目标点坐标 </span></span><br><span class="line">    <span class="keyword">return</span> LaunchDescription([client])</span><br></pre></td></tr></table></figure><p><strong>动作服务端</strong></p><p>按住ctrl  点击create_server→Server</p><p>根据模板编写action服务端的创建代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> GoalCallback = std::function&lt;<span class="built_in">GoalResponse</span>(</span><br><span class="line">      <span class="type">const</span> GoalUUID &amp;, std::shared_ptr&lt;<span class="type">const</span> <span class="keyword">typename</span> ActionT::Goal&gt;)&gt;;</span><br><span class="line"><span class="keyword">using</span> CancelCallback = std::function&lt;<span class="built_in">CancelResponse</span>(std::shared_ptr&lt;ServerGoalHandle&lt;ActionT&gt;&gt;)&gt;;</span><br><span class="line"><span class="keyword">using</span> AcceptedCallback = std::function&lt;<span class="built_in">void</span> (std::shared_ptr&lt;ServerGoalHandle&lt;ActionT&gt;&gt;)&gt;;</span><br></pre></td></tr></table></figure><p>test03_action_server.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  需求:处理客户端发送的控制乌龟向目标点运动，且要连续反馈剩余距离</span></span><br><span class="line"><span class="comment">  步骤:</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1.创建原生乌龟位姿订阅方，回调函数中获取乌龟位姿；</span></span><br><span class="line"><span class="comment">      3-2.创建原生乌龟速度发布方；</span></span><br><span class="line"><span class="comment">      3-3.创建动作服务端；</span></span><br><span class="line"><span class="comment">      3-4.解析动作客户端发送的请求；</span></span><br><span class="line"><span class="comment">      3-5.处理动作客户端发送的取消请求；</span></span><br><span class="line"><span class="comment">      3-6.创建新线程处理主逻辑请求；</span></span><br><span class="line"><span class="comment">      3-7.新线程产生连续反馈并响应最终结果。</span></span><br><span class="line"><span class="comment">    4.调用spin函数,并传入节点对象指针;</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/msg/pose.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/twist.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_action/rclcpp_action.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_interfaces/action/nav.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="keyword">using</span> base_interfaces::action::Nav;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test03ActionServer</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test03ActionServer</span>():<span class="built_in">Node</span>(<span class="string">&quot;test03_action_server_node_cpp&quot;</span>),<span class="built_in">x</span>(<span class="number">0.0</span>),<span class="built_in">y</span>(<span class="number">0.0</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;动作服务端创建成功!&quot;</span>);</span><br><span class="line">        <span class="comment">// 3-1.创建原生乌龟位姿订阅方，回调函数中获取乌龟位姿</span></span><br><span class="line">        pose_sub_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;turtlesim::msg::Pose&gt;(<span class="string">&quot;/turtle1/pose&quot;</span>,<span class="number">10</span>,std::<span class="built_in">bind</span>(&amp;Test03ActionServer::pose_cb,<span class="keyword">this</span>,_1));</span><br><span class="line">        <span class="comment">// 3-2.创建原生乌龟速度发布方；</span></span><br><span class="line">        cmd_vel_pub_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;geometry_msgs::msg::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 3-3.创建动作服务端；</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        (NodeT node, </span></span><br><span class="line"><span class="comment">        const std::string &amp;name,</span></span><br><span class="line"><span class="comment">        rclcpp_action::Server&lt;ActionT&gt;::GoalCallback handle_goal, </span></span><br><span class="line"><span class="comment">        rclcpp_action::Server&lt;ActionT&gt;::CancelCallback handle_cancel, </span></span><br><span class="line"><span class="comment">        rclcpp_action::Server&lt;ActionT&gt;::AcceptedCallback handle_accepted</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        action_server_ = rclcpp_action::<span class="built_in">create_server</span>&lt;Nav&gt;(</span><br><span class="line">          <span class="keyword">this</span>,</span><br><span class="line">          <span class="string">&quot;nav&quot;</span>,</span><br><span class="line">          std::<span class="built_in">bind</span>(&amp;Test03ActionServer::handle_goal,<span class="keyword">this</span>,_1,_2),</span><br><span class="line">          std::<span class="built_in">bind</span>(&amp;Test03ActionServer::handle_cancel,<span class="keyword">this</span>,_1),</span><br><span class="line">          std::<span class="built_in">bind</span>(&amp;Test03ActionServer::handle_accepted,<span class="keyword">this</span>,_1));</span><br><span class="line">          <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;动作服务端创建，等待请求...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr pose_sub_;</span><br><span class="line">    rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr cmd_vel_pub_;</span><br><span class="line">    rclcpp_action::Server&lt;Nav&gt;::SharedPtr action_server_;</span><br><span class="line">    <span class="type">float</span> x,y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pose_cb</span><span class="params">(<span class="type">const</span> turtlesim::msg::Pose::SharedPtr pose)</span></span>&#123;</span><br><span class="line">      x = pose-&gt;x;</span><br><span class="line">      y = pose-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3-4.解析动作客户端发送的请求；</span></span><br><span class="line">    <span class="function">rclcpp_action::GoalResponse <span class="title">handle_goal</span><span class="params">(<span class="type">const</span> rclcpp_action::GoalUUID &amp; uuid, std::shared_ptr&lt;<span class="type">const</span> Nav::Goal&gt; goal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      (<span class="type">void</span>)uuid; <span class="comment">// 标识目前没用上,避免警告</span></span><br><span class="line">      <span class="comment">// 判断目标的x,y值是否超出框</span></span><br><span class="line">      <span class="type">float</span> goal_x = goal-&gt;goal_x;</span><br><span class="line">      <span class="type">float</span> goal_y = goal-&gt;goal_y;</span><br><span class="line">      <span class="keyword">if</span>(goal_x &lt; <span class="number">0</span> || goal_x &gt; <span class="number">11.08</span> || goal_y &lt; <span class="number">0</span> || goal_y &gt; <span class="number">11.08</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;无效目标值!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rclcpp_action::GoalResponse::REJECT;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;目标点合法!&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">rclcpp_action::CancelResponse <span class="title">handle_cancel</span><span class="params">(std::shared_ptr&lt;rclcpp_action::ServerGoalHandle&lt;Nav&gt;&gt; goal_handle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      (<span class="type">void</span>)goal_handle;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;接收到取消请求!&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> rclcpp_action::CancelResponse::ACCEPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主逻辑处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::shared_ptr&lt;rclcpp_action::ServerGoalHandle&lt;Nav&gt;&gt; goal_handle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;开始执行任务......&quot;</span>);</span><br><span class="line">      <span class="comment">// 创建连续反馈对象指针；</span></span><br><span class="line">      <span class="keyword">auto</span> feedback = std::<span class="built_in">make_shared</span>&lt;Nav::Feedback&gt;();</span><br><span class="line">      <span class="comment">// 创建最终结果对象指针；</span></span><br><span class="line">      <span class="keyword">auto</span> result = std::<span class="built_in">make_shared</span>&lt;Nav::Result&gt;();</span><br><span class="line">      <span class="comment">// 生成连续反馈</span></span><br><span class="line">      <span class="function">rclcpp::Rate <span class="title">rate</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 任务执行中，关于客户端发送取消请求的处理；</span></span><br><span class="line">        <span class="keyword">if</span>(goal_handle-&gt;<span class="built_in">is_canceling</span>())&#123;</span><br><span class="line">          goal_handle-&gt;<span class="built_in">canceled</span>(result);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析目标点坐标与原生乌龟位姿数据；</span></span><br><span class="line">        <span class="type">float</span> goal_x = goal_handle-&gt;<span class="built_in">get_goal</span>()-&gt;goal_x;</span><br><span class="line">        <span class="type">float</span> goal_y = goal_handle-&gt;<span class="built_in">get_goal</span>()-&gt;goal_y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算剩余距离并发布</span></span><br><span class="line">        <span class="type">float</span> distance_x = goal_x - x;</span><br><span class="line">        <span class="type">float</span> distance_y = goal_y - y;</span><br><span class="line">        <span class="type">float</span> distance = std::<span class="built_in">sqrt</span>(distance_x * distance_x + distance_y * distance_y);</span><br><span class="line">        feedback-&gt;distance = distance;</span><br><span class="line">        goal_handle-&gt;<span class="built_in">publish_feedback</span>(feedback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算速度指令并发布</span></span><br><span class="line">        <span class="type">float</span> scale = <span class="number">0.5</span>;</span><br><span class="line">        geometry_msgs::msg::Twist twist;</span><br><span class="line">        twist.linear.x = scale * distance_x;</span><br><span class="line">        twist.linear.y = scale * distance_y;</span><br><span class="line">        cmd_vel_pub_-&gt;<span class="built_in">publish</span>(twist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(distance &lt; <span class="number">0.05</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;导航至目标点！&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 生成最终响应</span></span><br><span class="line">      <span class="keyword">if</span>(rclcpp::<span class="built_in">ok</span>())&#123;</span><br><span class="line">        result-&gt;turtle_x = x;</span><br><span class="line">        result-&gt;turtle_y = y;</span><br><span class="line">        goal_handle-&gt;<span class="built_in">succeed</span>(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_accepted</span><span class="params">(std::shared_ptr&lt;rclcpp_action::ServerGoalHandle&lt;Nav&gt;&gt; goal_handle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">// 新建线程处理耗时的主逻辑</span></span><br><span class="line">      std::thread&#123;std::<span class="built_in">bind</span>(&amp;Test03ActionServer::execute,<span class="keyword">this</span>,_1),goal_handle&#125;.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.调用spin函数,并传入节点类对象;</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;Test03ActionServer&gt;()); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test03_action_client.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  需求:向动作服务端发送目标点数据，并处理响应数据。</span></span><br><span class="line"><span class="comment">  步骤:</span></span><br><span class="line"><span class="comment">    0.解析launch文件传入的参数</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1.创建动作客户端；</span></span><br><span class="line"><span class="comment">      3-2.发送请求数据，并处理服务端响应；</span></span><br><span class="line"><span class="comment">      3-3.处理目标响应；</span></span><br><span class="line"><span class="comment">      3-4.处理响应的连续反馈；</span></span><br><span class="line"><span class="comment">      3-5.处理最终响应。</span></span><br><span class="line"><span class="comment">    4.调用spin函数,并传入节点对象指针;</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_action/rclcpp_action.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_interfaces/action/nav.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="keyword">using</span> base_interfaces::action::Nav;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test03ActionClient</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test03ActionClient</span>():<span class="built_in">Node</span>(<span class="string">&quot;test03_action_client_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;动作客户端创建成功!&quot;</span>);</span><br><span class="line">      <span class="comment">// 3-1.创建动作客户端；</span></span><br><span class="line">      client_ = rclcpp_action::<span class="built_in">create_client</span>&lt;Nav&gt;(<span class="keyword">this</span>,<span class="string">&quot;nav&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3-2.发送请求数据，并处理服务端响应；</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send_goal</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> theta)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 连接服务端</span></span><br><span class="line">      <span class="keyword">if</span>(!client_ -&gt; <span class="built_in">wait_for_action_server</span>(<span class="number">10</span>s))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;连接超时!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 组织发送数据</span></span><br><span class="line">      Nav::Goal goal;</span><br><span class="line">      goal.goal_x = x;</span><br><span class="line">      goal.goal_y = y;</span><br><span class="line">      goal.goal_theta = theta;</span><br><span class="line">      rclcpp_action::Client&lt;Nav&gt;::SendGoalOptions options;</span><br><span class="line">      options.goal_response_callback = std::<span class="built_in">bind</span>(&amp;Test03ActionClient::goal_response_callback,<span class="keyword">this</span>,_1);</span><br><span class="line">      options.feedback_callback = std::<span class="built_in">bind</span>(&amp;Test03ActionClient::feedback_callback,<span class="keyword">this</span>,_1,_2);</span><br><span class="line">      options.result_callback = std::<span class="built_in">bind</span>(&amp;Test03ActionClient::result_callback,<span class="keyword">this</span>,_1);</span><br><span class="line">      client_-&gt;<span class="built_in">async_send_goal</span>(goal,options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    rclcpp_action::Client&lt;Nav&gt;::SharedPtr client_;</span><br><span class="line">    <span class="comment">// 将UUID转换为可读字符串</span></span><br><span class="line">    <span class="function">std::string <span class="title">goal_uuid_to_string</span><span class="params">(<span class="type">const</span> rclcpp_action::GoalUUID&amp; uuid)</span> </span>&#123;</span><br><span class="line">      std::stringstream ss;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> byte : uuid) &#123;</span><br><span class="line">          ss &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(byte);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3-3.处理目标响应；</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">goal_response_callback</span><span class="params">(rclcpp_action::ClientGoalHandle&lt;Nav&gt;::SharedPtr goal_handle)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!goal_handle)&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;目标请求被服务端拒绝!&quot;</span>);</span><br><span class="line">        rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;目标处理中!目标ID: %s&quot;</span>,<span class="built_in">goal_uuid_to_string</span>(goal_handle-&gt;<span class="built_in">get_goal_id</span>()).<span class="built_in">c_str</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3-4.处理响应的连续反馈；</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">feedback_callback</span><span class="params">(rclcpp_action::ClientGoalHandle&lt;Nav&gt;::SharedPtr goal_handle, <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> Nav::Feedback&gt; feedback)</span></span>&#123;</span><br><span class="line">      (<span class="type">void</span>)goal_handle;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;剩余距离:%.2f&quot;</span>,feedback-&gt;distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3-5.处理最终响应。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">result_callback</span><span class="params">(<span class="type">const</span> rclcpp_action::ClientGoalHandle&lt;Nav&gt;::WrappedResult &amp; result)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 通过状态码判断结果状态</span></span><br><span class="line">      <span class="keyword">if</span>(result.code == rclcpp_action::ResultCode::SUCCEEDED)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),</span><br><span class="line">          <span class="string">&quot;乌龟最终坐标:(%.2f,%.2f),航向:%.2f&quot;</span>,</span><br><span class="line">          result.result-&gt;turtle_x,</span><br><span class="line">          result.result-&gt;turtle_y,</span><br><span class="line">          result.result-&gt;turtle_theta);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(result.code == rclcpp_action::ResultCode::ABORTED)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;任务被中止!&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(result.code == rclcpp_action::ResultCode::CANCELED)&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;任务被取消!&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;未知异常!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">5</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;请传入合法的目标位姿参数:(x,y,theta)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 不能直接spin</span></span><br><span class="line">  <span class="keyword">auto</span> client = std::<span class="built_in">make_shared</span>&lt;Test03ActionClient&gt;();</span><br><span class="line">  client-&gt;<span class="built_in">send_goal</span>(<span class="built_in">atof</span>(argv[<span class="number">1</span>]),<span class="built_in">atof</span>(argv[<span class="number">2</span>]),<span class="built_in">atof</span>(argv[<span class="number">3</span>]));</span><br><span class="line">  <span class="comment">// 4.调用spin函数,并传入节点类对象;</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(client); </span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数服务案例分析"><a href="#参数服务案例分析" class="headerlink" title="参数服务案例分析"></a>参数服务案例分析</h3><p>需求：动态修改乌龟窗口的背景颜色</p><p>配置自配</p><p><strong>launch文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    t = Node(package=<span class="string">&quot;turtlesim&quot;</span>,executable=<span class="string">&quot;turtlesim_node&quot;</span>)</span><br><span class="line">    param = Node(package=<span class="string">&quot;cpp07_exercise&quot;</span>,executable=<span class="string">&quot;test04_param&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LaunchDescription([t,param])</span><br></pre></td></tr></table></figure><p>test04_param.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  需求: 修改turtlesim_node的背景颜色</span></span><br><span class="line"><span class="comment">  步骤:</span></span><br><span class="line"><span class="comment">    1.包含头文件；</span></span><br><span class="line"><span class="comment">    2.初始化 ROS2 客户端；</span></span><br><span class="line"><span class="comment">    3.定义节点类；</span></span><br><span class="line"><span class="comment">      3-1.创建参数客户端；</span></span><br><span class="line"><span class="comment">      3-2.连接参数服务端；</span></span><br><span class="line"><span class="comment">      3-3.更新参数。</span></span><br><span class="line"><span class="comment">    4.创建对象指针,并调用其函数;</span></span><br><span class="line"><span class="comment">    5.释放资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.包含头文件；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.自定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test04Param</span>: <span class="keyword">public</span> rclcpp::Node&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test04Param</span>():<span class="built_in">Node</span>(<span class="string">&quot;test04_param_node_cpp&quot;</span>)&#123;  <span class="comment">// 节点名称一般小写</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;参数服务器创建成功!&quot;</span>);</span><br><span class="line">        <span class="comment">// 3-1.创建参数客户端</span></span><br><span class="line">        client_ = std::<span class="built_in">make_shared</span>&lt;rclcpp::SyncParametersClient&gt;(<span class="keyword">this</span>,<span class="string">&quot;/turtlesim&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3-2.连接参数服务端</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connect_server</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!client_-&gt;<span class="built_in">wait_for_service</span>(<span class="number">5</span>s))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>),<span class="string">&quot;强制退出！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;服务连接中...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3-3.更新参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_param</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 背景色渐变修改</span></span><br><span class="line">        <span class="comment">// background_r[0,255]</span></span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        red = client_-&gt;<span class="built_in">get_parameter</span>&lt;<span class="type">int32_t</span>&gt;(<span class="string">&quot;background_r&quot;</span>);</span><br><span class="line">        <span class="function">rclcpp::Rate <span class="title">rate</span><span class="params">(<span class="number">30.0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 编写循环，修改参数</span></span><br><span class="line">        <span class="type">int</span> count = red;</span><br><span class="line">        <span class="keyword">while</span>(rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* </span></span><br><span class="line"><span class="comment">            计数器在[0,255)递增，[255,510]递减，大于等于510时归0</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          count &lt; <span class="number">255</span> ? red +=  <span class="number">5</span> : red -= <span class="number">5</span>;</span><br><span class="line">          count += <span class="number">5</span>;</span><br><span class="line">          <span class="keyword">if</span>(count&gt;=<span class="number">510</span>) count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 修改服务器参数</span></span><br><span class="line">          client_-&gt;<span class="built_in">set_parameters</span>(&#123;rclcpp::<span class="built_in">Parameter</span>(<span class="string">&quot;background_r&quot;</span>,red)&#125;);</span><br><span class="line">          <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;red = %d&quot;</span>, red);</span><br><span class="line">          rate.<span class="built_in">sleep</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    rclcpp::SyncParametersClient::SharedPtr client_;</span><br><span class="line">    <span class="type">int32_t</span> red;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2.初始化 ROS2 客户端；</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">  <span class="comment">// 4.创建对象指针,并调用其函数</span></span><br><span class="line">  <span class="keyword">auto</span> client = std::<span class="built_in">make_shared</span>&lt;Test04Param&gt;();</span><br><span class="line">  <span class="comment">// 判断连接状态</span></span><br><span class="line">  <span class="keyword">if</span>(!client-&gt;<span class="built_in">connect_server</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  client-&gt;<span class="built_in">update_param</span>();</span><br><span class="line">  <span class="comment">// 5.释放资源。</span></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 🤖ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秦皇岛出游</title>
      <link href="/posts/2715330630.html"/>
      <url>/posts/2715330630.html</url>
      
        <content type="html"><![CDATA[<h2 id="秦皇岛"><a href="#秦皇岛" class="headerlink" title="秦皇岛"></a>秦皇岛</h2><p>那么近那么美周末到河北(doge)</p><p><a href="https://guinness.autonavi.com/activity/2020CommonLanding/index.html?id=default&local=1&logId=&logParams=&gd_from=jinisi&schema=amapuri://ajx_favorites/folder?data=%257B%2522ugcId%2522%253A%252215389456410187854006%2522%252C%2522forceCustom%2522%253Atrue%252C%2522pathId%2522%253A6%252C%2522isCreatorShare%2522%253Atrue%257D&share_from=favorites_FavoriteFolder&share_from_type=AJX&share_type=image&share_lastClickSpm=">高德地图链接</a></p><p><font color='Violetred'>🏖️day1：</font></p><p>T5603北京站 -&gt; 北戴河站(10:48-13:25) -&gt; 租电动车 -&gt; 蔚蓝海岸 -&gt; 🌇老虎石看日落 -&gt; 绕海边骑行 -&gt; 海鲜自助(遇见) -&gt; 酒店</p><p>蔚蓝海岸：免费浴场，但是脏的很，玩完沙滩冲脚2r&#x2F;min，一般，有个猫的天空之城图书店还可以，可以盖章</p><p>老虎石：好看，人多，旺季根本没机会停电动车，建议淡季时候再考虑去这看日落，不过确实好看</p><p>海鲜自助：遇见有学生价，而且一般海鲜自助都是吃两个小时，这家店整体还可以，也有烤榴莲，吃了四大锅包回本的（皮皮虾一般，生蚝太好了）</p><blockquote><p>北戴河电动车管的特别严，需要严格戴头盔and规定停车区停车，不然要被拖车且罚钱</p><p>租电动车特别划算！！！</p></blockquote><p>🧾账单：</p><ul><li><p>🚅T5603：41.5</p></li><li><p>🛵电动车：41.9&#x2F;2</p></li><li><p>🛌酒店：101&#x2F;2</p></li><li><p>🦞海鲜自助：132 (划算)</p></li></ul><p>合计 244.95</p><p><font color='Violetred'>🌊day2</font></p><p>🌅海天一色(起不来没看成) -&gt; 酒店 -&gt; 北戴河站 -&gt; 还车 -&gt; G1299山海关站(10:20-10:47) -&gt;  邱记太子锅 -&gt; 老龙头景区 -&gt; 打车回金梦海湾海滩旁酒店 -&gt; 秦皇小巷</p><p>老龙头：付费的还是比免费的海岸好得多，好玩好看且干净，值得一去</p><p>海鲜饺子：一般，但是吃的确实饱，可能是因为前一天海鲜吃太多了</p><p>秦皇小巷：干净的小吃街，价格没有太离谱，但是也没有特别好吃</p><blockquote><p>市区这边电动车太贵了，如果第一天就到这边的可以考虑租，街上的一小时19，建议按天租，或者直接共享助力车3r&#x2F;30min</p></blockquote><p>🧾账单：</p><ul><li>🚅G1299：20</li><li>🚕打车：29.46</li><li>🛌海景公寓：147.84&#x2F;2  淡季超划算，阳台可以看海</li><li>🥘太子锅：179&#x2F;2</li><li>🎫老龙头门票：25 (学生+美团优惠)</li><li>🥟海鲜饺子：94&#x2F;2</li></ul><p>合计 284.88</p><p><font color='Violetred'>day3</font></p><p>西港花园(熬夜了没去成) -&gt; 秦皇岛站返北京</p><p>🎒带的：</p><ul><li><p>🕶️墨镜</p></li><li><p>🩴洞洞鞋</p></li><li><p>🧴防晒霜</p></li><li><p>🧢帽子</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 🧳旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS机器人系统</title>
      <link href="/posts/3254549402.html"/>
      <url>/posts/3254549402.html</url>
      
        <content type="html"><![CDATA[<h2 id="机器人系统仿真"><a href="#机器人系统仿真" class="headerlink" title="机器人系统仿真"></a>机器人系统仿真</h2><p>在 ROS 中，仿真实现主要涉及的内容：</p><ul><li>对机器人建模(URDF)</li><li>创建仿真环境(Gazebo)</li><li>感知环境(Rviz)</li></ul><p>如果安装的是完整版ros，Gazebo和Rviz默认安装</p><p><strong>URDF</strong>：Unified Robot Description Format</p><p>可以以一种 XML 的方式描述机器人的部分结构，比如底盘、摄像头、激光雷达、机械臂以及不同关节的自由度…..，该文件可以被 C++ 内置的解释器转换成可视化的机器人模型，是 ROS 中实现机器人仿真的重要组件</p><p><strong>rviz</strong>：ROS Visualization Tool</p><p>以三维方式显示ROS消息，可以将数据进行可视化表达</p><p><strong>Gazebo</strong>：</p><p>Gazebo是一款3D动态模拟器，用于显示机器人模型并创建仿真环境，能够在复杂的室内和室外环境中准确有效地模拟机器人</p><p>三者应用中，只是创建 URDF 意义不大，一般需要结合 Gazebo 或 Rviz 使用，在 Gazebo 或 Rviz 中可以将 URDF 文件解析为图形化的机器人模型，一般的使用组合为:</p><ul><li>如果非仿真环境，那么使用 URDF 结合 Rviz 直接显示感知的真实环境信息</li><li>如果是仿真环境，那么需要使用 URDF 结合 Gazebo 搭建仿真环境，并结合 Rviz 显示感知的虚拟环境信息</li></ul><p>仿真缺陷：</p><p>机器人在仿真环境与实际环境下的表现差异较大，仿真并不能完全做到模拟真实的物理世界，存在一些”失真”的情况</p><ol><li><p>仿真器所使用的物理引擎目前还不能够完全精确模拟真实世界的物理情况</p></li><li><p>仿真器构建的是关节驱动器（电机&amp;齿轮箱）、传感器与信号通信的绝对理想情况，目前不支持模拟实际硬件缺陷或者一些临界状态等情形</p></li></ol><p>素材链接:</p><ul><li><p><a href="https://github.com/zx595306686/sim_demo.git">https://github.com/zx595306686/sim_demo.git</a></p><blockquote><p>在虚拟机中git clone下载</p></blockquote></li></ul><h3 id="URDF集成Rviz"><a href="#URDF集成Rviz" class="headerlink" title="URDF集成Rviz"></a>URDF集成Rviz</h3><p>URDF与Rviz的集成较之于URDF与Gazebo的集成更为简单</p><p>需求描述：在 Rviz 中显示一个盒状机器人</p><p>实现流程：</p><ol><li>新建功能包，导入依赖</li><li>核心：编写 urdf 文件</li><li>核心：在 launch 文件集成 URDF 与 Rviz</li><li>在 Rviz 中显示机器人模型</li></ol><p><strong>创建功能包</strong>：</p><p>创建一个新的功能包，名称自定义，导入依赖包：<code>urdf</code>与<code>xacro</code></p><blockquote><p>这个时候目录下是没有src文件的，因为不需要编码</p><p><code>xacro</code>(XML Macros)是 ROS中用于简化机器人模型描述的核心工具包，专门用于处理 URDF文件</p></blockquote><p>在当前功能包下，再新建几个目录：</p><p><code>urdf</code>: 存储 urdf 文件的目录</p><p><code>meshes</code>:机器人模型渲染文件(暂不使用)</p><p><code>config</code>: 配置文件</p><p><code>launch</code>: 存储 launch 启动文件</p><p><strong>编写 URDF 文件</strong>：</p><p>在urdf文件夹下新建子级文件夹urdf和xacro</p><p>urdf文件夹中添加一个<code>.urdf</code>文件，复制如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;mycar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.5 0.2 0.1&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>在 launch 文件中集成 URDF 与 Rviz</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 在参数服务器载入urdf文件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 参数名name固定 robot_description --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> = <span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>= <span class="string">&quot;$(find urdf01_rviz)/urdf/urdf/demo01.urdf&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 启动 rviz --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span>  <span class="attr">pkg</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">type</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">name</span> = <span class="string">&quot;rviz&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>在 Rviz 中显示机器人模型</strong>：</p><p>rviz 启动后，会发现并没有盒装的机器人模型，这是因为默认情况下没有添加机器人显示组件，需要手动添加，添加方式如下</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/01_URDF文件执行rviz配置01.webp" alt="01_URDF文件执行rviz配置01" style="zoom: 67%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/02_URDF文件执行rviz配置02.webp" alt="02_URDF文件执行rviz配置02" style="zoom:67%;" /><p><strong>优化 rviz 启动</strong></p><p>重复启动<code>launch</code>文件时，Rviz 之前的组件配置信息不会自动保存，需要重复执行显示操作，为了方便使用，可以使用如下方式优化：</p><p>首先，将当前配置保存进<code>config</code>目录</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/10_rviz配置保存.webp" alt="10_rviz配置保存" style="zoom:67%;" /><p>launch文件中 Rviz 的启动配置添加参数：<code>args</code>，值设置为 <code>-d 配置文件路径</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span>  <span class="attr">pkg</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">type</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">name</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">args</span> = <span class="string">&quot;-d $(find urdf01_rviz)/config/show_car.rviz&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>再启动时，就可以包含之前的组件配置了，使用更方便快捷</p><h3 id="URDF语法"><a href="#URDF语法" class="headerlink" title="URDF语法"></a>URDF语法</h3><p>URDF 文件是一个标准的 XML 文件，在 ROS 中预定义了一系列的标签用于描述机器人模型</p><p>机器人模型可能较为复杂，但是 ROS 的 URDF 中机器人的组成却是较为简单，</p><p>URDF主要有四类标签</p><ul><li>robot 根标签，类似于 launch文件中的launch标签</li><li>link 连杆标签</li><li>joint 关节标签</li><li>gazebo</li></ul><p>joint标签对应的数据在模型中是不可见的</p><p>gazebo标签不是机器人模型必须的，只有在仿真时才需设置，用于配置仿真环境所需参数</p><p><font color='Violetred'>属性跟在标签的&lt;&gt;内</font></p><p><strong>robot</strong></p><p>urdf 中为了保证 xml 语法的完整性，使用了<code>robot</code>标签作为根标签</p><p>所有的 link 和 joint 以及其他标签都必须包含在 robot 标签内</p><p>在该标签内可以通过 name 属性设置机器人模型的名称</p><h4 id="link"><a href="#link" class="headerlink" title="link"></a>link</h4><p>urdf 中的 link 标签用于描述机器人某个部件(也即刚体部分)的外观和物理属性</p><p>比如: 机器人底座、轮子、激光雷达、摄像头…</p><p>每一个部件都对应一个 link，在 link 标签内，可以设计该部件的形状、尺寸、颜色、惯性(inertial)矩阵、碰撞(collision)参数等一系列属性</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/20250610link.webp" alt="20250610link" style="zoom:50%;" /><p>属性：name —&gt; 为连杆命名</p><p>子标签：</p><p>visual —&gt; 描述外观(对应的数据是可视的)</p><ul><li><p>geometry 设置连杆的形状</p><ul><li><p>标签1: box(盒状)</p><ul><li>属性：size &#x3D; “[x] [y] [z]”  单位为m</li></ul></li><li><p>标签2: cylinder(圆柱)</p><ul><li>属性：radius&#x3D;“ ” length&#x3D;“ ”</li></ul></li><li><p>标签3: sphere(球体)</p><ul><li>属性：radius&#x3D;“ ”</li></ul></li><li><p>标签4: mesh(为连杆添加皮肤)</p><ul><li><p>属性：filename&#x3D;资源路径</p><p>资源路径格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package://&lt;packagename&gt;/&lt;path&gt;/文件</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>origin 设置偏移量与倾斜弧度</p><ul><li><p>属性1：xyz&#x3D;”[x] [y] [z]”</p></li><li><p>属性2：rpy&#x3D;”[翻滚] [俯仰] [偏航]”</p><blockquote><p>逆着轴方向看逆时针旋转为正</p><p>偏移多在joint中实现</p></blockquote></li></ul></li><li><p>metrial 设置材料属性(颜色)</p><ul><li>属性: name</li><li>标签: color<ul><li>属性: rgba&#x3D;”[红] [绿] [蓝] [透明度]”  取值均[0,1]</li></ul></li></ul></li><li><p>collision —&gt; 连杆的碰撞属性</p></li><li><p>Inertial —&gt; 连杆的惯性矩阵</p></li></ul><p>urdf文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span> = <span class="string">&quot;car&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span> =<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可视化标签 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 1.形状 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 立方体 --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;box size = &quot;0.2 0.2 0.2&quot; /&gt; --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 圆柱 --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;cylinder radius = &quot;0.2&quot; length = &quot;2&quot; /&gt; --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 球体 --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;sphere radius = &quot;0.2&quot; /&gt; --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 皮肤 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">filename</span> = <span class="string">&quot;package://urdf01_rviz/meshes/autolabor_mini.stl&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 2. 偏移量和倾斜弧度 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.57 0 1.57&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 3. 颜色 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span> = <span class="string">&quot;car_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span> = <span class="string">&quot;0.3 0.4 0.2 1&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="joint"><a href="#joint" class="headerlink" title="joint"></a>joint</h4><p>urdf 中的 joint 标签用于描述机器人关节的运动学和动力学属性，还可以指定关节运动的安全极限</p><p>机器人的两个部件(分别称之为 parent link 与 child link)以”关节”的形式相连接</p><p>不同的关节有不同的运动形式：旋转、滑动、固定、旋转速度、旋转角度限制….</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/官方02_link.webp" alt="官方02_link" style="zoom:50%;" /><p>属性：</p><ul><li>name —&gt; 为关节命名</li><li>type —&gt; 关节运动形式<ul><li><font color='Violetred'>continuous</font>：旋转关节，可以绕单轴无限旋转</li><li>revolute：旋转关节，类似于 continues，但是有旋转角度限制</li><li>prismatic：滑动关节，沿某一轴线移动的关节，有位置极限</li><li>planer：平面关节，允许在平面正交方向上平移或旋转</li><li>floating：浮动关节，允许进行平移、旋转运动</li><li><font color='Violetred'>fixed</font>：固定关节，不允许运动的特殊关节</li></ul></li></ul><p>子标签</p><ul><li><p>parent(必需的)</p><p>parent link的名字是一个强制的属性：</p><ul><li>link：父级连杆的名字，是这个link在机器人结构树中的名字</li></ul></li><li><p>child(必需的)</p><p>child link的名字是一个强制的属性：</p><ul><li>link：子级连杆的名字，是这个link在机器人结构树中的名字</li></ul></li><li><p>origin</p><ul><li>属性：xyz&#x3D;各轴线上的偏移量 rpy&#x3D;各轴线上的偏移弧度</li></ul></li><li><p>axis</p><ul><li>属性：xyz用于设置围绕哪个关节轴运动</li></ul></li></ul><p>需求：创建机器人模型，底盘为长方体，在长方体的前面添加一摄像头，摄像头可以沿着 Z 轴 360 度旋转</p><p>urdf文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span> = <span class="string">&quot;car&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 底盘link --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span> = <span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span> = <span class="string">&quot;0.3 0.2 0.1&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span> = <span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span> = <span class="string">&quot;car_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span> = <span class="string">&quot;0.3 0.4 0.2 0.5&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 摄像头link --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span> = <span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.02 0.05 0.05&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.027&quot;</span> <span class="attr">rpy</span> = <span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span> = <span class="string">&quot;camere_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span> = <span class="string">&quot;0 0 1 0.5&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3. 关节 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span>  <span class="attr">name</span> = <span class="string">&quot;camerabase&quot;</span> <span class="attr">type</span> = <span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父级link --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span> = <span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 子级link --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span> = <span class="string">&quot;camera&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置偏移量 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意这里的偏移是两个坐标系之间的偏移, 要考虑不嵌入需要另外增加偏移量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span> = <span class="string">&quot;-0.12 0 0.05&quot;</span> <span class="attr">rpy</span> =<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置关节旋转参考的坐标轴 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>launch文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 在参数服务器载入urdf文件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 参数名name固定 robot_description --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> = <span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>= <span class="string">&quot;$(find urdf01_rviz)/urdf/urdf/demo03.urdf&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 启动 rviz --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span>  <span class="attr">pkg</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">type</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">name</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">args</span> = <span class="string">&quot;-d $(find urdf01_rviz)/config/show_car.rviz&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        只有这两句:</span></span><br><span class="line"><span class="comment">            表现:设置显示的位置与颜色异常</span></span><br><span class="line"><span class="comment">            提示:No transform from [camera] to [base_link]   </span></span><br><span class="line"><span class="comment">            原因:rviz中显示URDF时，必须发布不同部件之间的坐标系关系</span></span><br><span class="line"><span class="comment">            解决:ROS中提供了关于机器人模型显示的坐标发布相关节点（两个）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  关节状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  机器人状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>状态发布节点在此是必须的</p><p>关节运动控制节点(可选)，会生成关节控制的UI，用于测试关节运动是否正常</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可选:用于控制关节运动的节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，摄像头的偏移设置为0.027是为了避免旋转控制时0.025和底盘贴合可能出现旋转抖动现象</p></blockquote><p><strong>base_footprint优化urdf</strong></p><p>前面实现的机器人模型是半沉到地下的，因为默认情况下底盘的中心点位于地图原点上</p><p>可以将初始 link 设置为一个尺寸极小的 link(比如半径为 0.001m 的球体，或边长为 0.001m 的立方体)，然后再在初始 link 上添加底盘等刚体，这样虽然仍然存在初始link半沉的现象，但是基本可以忽略了</p><p>这个初始 link 一般称之为 base_footprint，在rviz中将坐标系换为base_footprint发现机器人已经回到地面，这种方法避免了偏移导致的混乱</p><p>修改后的urdf文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span> = <span class="string">&quot;car&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加一个尺寸极小的link,再去关联base_link,</span></span><br><span class="line"><span class="comment">    关节高度和base_link下沉一致(半个底盘高度)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span> = <span class="string">&quot;base_footprint&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span> = <span class="string">&quot;0.001 0.001 0.001&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 底盘link --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span> = <span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span> = <span class="string">&quot;0.3 0.2 0.1&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span> = <span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span> = <span class="string">&quot;car_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span> = <span class="string">&quot;0.3 0.4 0.2 0.5&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 摄像头link --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span> = <span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.02 0.05 0.05&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.027&quot;</span> <span class="attr">rpy</span> = <span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span> = <span class="string">&quot;camere_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span> = <span class="string">&quot;0 0 1 0.5&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关联base_footprint 与base_link--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span>  <span class="attr">name</span> = <span class="string">&quot;link2footfrint&quot;</span> <span class="attr">type</span> = <span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父级link --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span> = <span class="string">&quot;base_footprint&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 子级link --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span> = <span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置偏移量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span> = <span class="string">&quot;0 0 0.05&quot;</span> <span class="attr">rpy</span> =<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!-- 3. 关节 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span>  <span class="attr">name</span> = <span class="string">&quot;camera2base&quot;</span> <span class="attr">type</span> = <span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父级link --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span> = <span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 子级link --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span> = <span class="string">&quot;camera&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置偏移量 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意这里的偏移是两个坐标系之间的偏移, 要考虑不嵌入需要另外增加偏移量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span> = <span class="string">&quot;-0.12 0 0.05&quot;</span> <span class="attr">rpy</span> =<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置关节旋转参考的坐标轴 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="urdf实操"><a href="#urdf实操" class="headerlink" title="urdf实操"></a>urdf实操</h4><p>需求描述：创建一个四轮圆柱状机器人模型，底盘为圆柱状，半径 10cm，高 8cm，四轮由两个驱动轮和两个万向支撑轮组成，两个驱动轮半径为 3.25cm，轮胎宽度1.5cm，两个万向轮为球状，半径 0.75cm，底盘离地间距为 1.5cm(与万向轮直径一致)</p><p>偏移多使用joint来实现，link内origin一般都设为0，这样能保证坐标原点在物体中心</p><blockquote><p>可以这么理解，joint改变了两个坐标系原点的位置，link不改变原点位置，只是改变了偏移量</p></blockquote><p>实现流程：</p><p>创建机器人模型可以分步骤实现</p><ol><li>新建 urdf 文件，并与 launch 文件集成</li><li>搭建底盘</li><li>在底盘上添加两个驱动轮</li><li>在底盘上添加两个万向轮</li></ol><p>launch文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find urdf01_rviz)/urdf/urdf/test.urdf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">type</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">name</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">args</span> = <span class="string">&quot;-d $(find urdf01_rviz)/config/show_car.rviz&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  关节状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  机器人状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加控制关节运动的节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>urdf文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;mycar&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置 base_footprint  --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.001&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加底盘 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        参数</span></span><br><span class="line"><span class="comment">            形状:圆柱 </span></span><br><span class="line"><span class="comment">            半径:10cm -&gt; 0.1m</span></span><br><span class="line"><span class="comment">            高度:8cm  -&gt; 0.08m</span></span><br><span class="line"><span class="comment">            离地:1.5cm-&gt; 0.015m</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.08&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 偏移尽量去joint设置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;base_link_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.8 0.3 0.1 0.5&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加关节 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;base_link2base_footprint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_footprint&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关节z设置: 车身高度/2 + 离地距离 0.08/2+0.015--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.055&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加驱动轮 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        驱动轮是侧翻的圆柱</span></span><br><span class="line"><span class="comment">        参数</span></span><br><span class="line"><span class="comment">            半径: 3.25 cm -&gt; 0.0325m</span></span><br><span class="line"><span class="comment">            宽度: 1.5  cm -&gt; 0.015m</span></span><br><span class="line"><span class="comment">            颜色: 黑色 -&gt; (0,0,0)</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;left_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.0325&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.015&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;wheel_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;right_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.0325&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.015&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;-1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;wheel_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加关节 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关节设置:</span></span><br><span class="line"><span class="comment">            x = 0</span></span><br><span class="line"><span class="comment">            y = 底盘的半径 + 轮胎宽度 / 2 = 10 + 1.5/2 = 10.75cm = 0.1075m</span></span><br><span class="line"><span class="comment">            z = 离地间距 + 底盘长度 / 2 - 轮胎半径 = 1.5 + 4 - 3.25 = 2.25(cm)</span></span><br><span class="line"><span class="comment">            axis = 0 1 0</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;left_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;left_wheel&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.1075 -0.0225&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;right_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;right_wheel&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 -0.1075 -0.0225&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加万向轮(支撑轮) --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        参数</span></span><br><span class="line"><span class="comment">            形状: 球体</span></span><br><span class="line"><span class="comment">            半径: 0.75 cm</span></span><br><span class="line"><span class="comment">            颜色: 黑色</span></span><br><span class="line"><span class="comment">    --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;front_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.0075&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;wheel_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;back_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.0075&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;wheel_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        关节设置:</span></span><br><span class="line"><span class="comment">        x = 自定义</span></span><br><span class="line"><span class="comment">        y = 0</span></span><br><span class="line"><span class="comment">        z = 底盘长度 / 2 + 离地间距 - 轮胎半径 = 0.08 / 2 + 0.015 / 2 = 0.0475 </span></span><br><span class="line"><span class="comment">        axis= 1 1 1</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;front_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;front_wheel&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.08 0.0 -0.0475&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;1 1 1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;back_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;back_wheel&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;-0.08 0.0 -0.0475&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;1 1 1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码似乎有些冗长，复用性差</p><h4 id="urdf工具"><a href="#urdf工具" class="headerlink" title="urdf工具"></a>urdf工具</h4><p>在 ROS 中，提供了一些工具来方便 URDF 文件的编写</p><ul><li><code>check_urdf</code>命令可以检查复杂的 urdf 文件是否存在语法问题</li><li><code>urdf_to_graphiz</code>命令可以查看 urdf 模型结构，显示不同 link 的层级关系</li></ul><p>首先需要安装，安装命令：<code>sudo apt install liburdfdom-tools</code></p><p>在urdf所在文件夹打开终端，调用<code>check_urdf [urdf文件]</code>，如果不抛出异常，说明文件合法，否则非法</p><p>进入urdf文件所属目录，调用:<code>urdf_to_graphiz [urdf文件]</code>，当前目录下会生成 pdf 文件，使用<code>evince</code>命令可以查看pdf</p><h3 id="URDF优化"><a href="#URDF优化" class="headerlink" title="URDF优化"></a>URDF优化</h3><p>前面 URDF 文件构建机器人模型的过程中，存在若干问题</p><ol><li>在设计关节的位置时，需要按照一定的公式计算，公式是固定的，但是在 URDF 中依赖于人工计算，存在不便，容易计算失误，且当某些参数发生改变时，还需要重新计算</li><li>URDF 中的部分内容是高度重复的，驱动轮与支撑轮的设计实现，不同轮子只是部分参数不同，形状、颜色、翻转量都是一致的，在实际应用中，构建复杂的机器人模型时，更是易于出现高度重复的设计，按照一般的编程涉及到重复代码应该考虑封装</li></ol><p>在 ROS 中，已经给出了类似编程的优化方案，称之为<strong>Xacro</strong></p><p>Xacro 是 XML Macros 的缩写，Xacro 是一种 XML 宏语言，是可编程的 XML</p><p>Xacro 可以声明变量，可以通过数学运算求解，使用流程控制控制执行顺序，还可以通过类似函数的实现，封装固定的逻辑，将逻辑中需要的可变的数据以参数的方式暴露出去，从而提高代码复用率以及程序的安全性。</p><h4 id="Xacro体验"><a href="#Xacro体验" class="headerlink" title="Xacro体验"></a>Xacro体验</h4><p><font color='Violetred'>注意：该案例编写生成的是非法的 URDF 文件，目的在于演示 Xacro 的极简使用以及优点</font></p><p>编写 Xacro 文件，以变量的方式封装属性(常量半径、高度、车轮半径…)，以函数的方式封装重复实现(车轮的添加)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;mycar&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 属性封装 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0325&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0015&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;PI&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.1415927&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;lidi_space&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.015&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 宏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;wheel_func&quot;</span> <span class="attr">params</span>=<span class="string">&quot;wheel_name flag&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;wheel_name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;$&#123;PI / 2&#125; 0 0&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;wheel_color&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0 0 0 0.3&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 3-2.joint --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;wheel_name&#125;2link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>  /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;$&#123;wheel_name&#125;_wheel&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">                x 无偏移</span></span><br><span class="line"><span class="comment">                y 车体半径</span></span><br><span class="line"><span class="comment">                z z= 车体高度 / 2 + 离地间距 - 车轮半径</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 $&#123;0.1 * flag&#125; $&#123;(base_link_length / 2 + lidi_space - wheel_radius) * -1&#125;&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:wheel_func</span> <span class="attr">wheel_name</span>=<span class="string">&quot;left&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:wheel_func</span> <span class="attr">wheel_name</span>=<span class="string">&quot;right&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>命令行进入 xacro文件所属目录，执行:<code>rosrun xacro xacro xxx.xacro &gt; xxx.urdf</code>, 会将 xacro 文件解析为 urdf 文件(同一目录下)</p><h4 id="Xacro语法详解"><a href="#Xacro语法详解" class="headerlink" title="Xacro语法详解"></a>Xacro语法详解</h4><p>xacro 提供了可编程接口，类似于计算机语言，包括变量声明调用、函数声明与调用等语法实现</p><p>在使用 xacro 生成 urdf 时，根标签<code>robot</code>中必须包含命名空间声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;</span><br></pre></td></tr></table></figure><p><strong>属性与算数运算</strong></p><p>用于封装 URDF 中的一些字段，比如：PAI 值，小车的尺寸，轮子半径 ….</p><p>属性定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;PI&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.1415927&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>属性调用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- $&#123;属性名称&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">UseProperty</span> <span class="attr">name</span> = <span class="string">&quot;$&#123;PI&#125;&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure><p>算术运算：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--$&#123;数学表达式&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">UseProperty1</span> <span class="attr">result</span> = <span class="string">&quot;$&#123;PI/2&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>宏</strong></p><p>类似于函数实现，提高代码复用率，优化代码结构，提高安全性</p><p>宏定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;宏名称&quot;</span> <span class="attr">params</span>=<span class="string">&quot;参数列表(多参数之间使用空格分隔)&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    参数调用格式: $&#123;参数名&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p>宏调用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:宏名称</span> <span class="attr">参数1</span>=<span class="string">&quot;&quot;</span> <span class="attr">参数2</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>文件包含</strong></p><p>机器人由多部件组成，不同部件可能封装为单独的 xacro 文件，最后再将不同的文件集成，组合为完整机器人，可以使用文件包含实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;my_base.xacro&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;my_camera.xacro&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;my_laser.xacro&quot;</span> /&gt;</span></span><br><span class="line">      ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Xacro完整使用"><a href="#Xacro完整使用" class="headerlink" title="Xacro完整使用"></a>Xacro完整使用</h4><p>需求描述：使用 Xacro 优化 URDF 版的小车底盘模型实现</p><p>编写 Xacro 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mycar&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 封装常量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;PI&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.1415927&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;footprint_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.001&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 宏:黑色设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 底盘属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;ground_distance&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.015&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置 base_footprint  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;footprint_radius&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- 添加底盘 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;base_length&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;base_link_color&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.8 0.3 0.1 0.5&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加关节 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;base_link2base_footprint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_footprint&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关节z设置: 车身高度/2 + 离地距离--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 $&#123;base_length/2 + ground_distance&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0325&quot;</span> /&gt;</span><span class="comment">&lt;!-- 半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.015&quot;</span> /&gt;</span><span class="comment">&lt;!-- 宽度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_joint_z&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;-(base_length/2 + ground_distance - wheel_radius)&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮宏 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        direction: left or right</span></span><br><span class="line"><span class="comment">        flag: 1 or -1</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span> = <span class="string">&quot;wheel_func&quot;</span> <span class="attr">params</span>=<span class="string">&quot;direction flag&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;direction&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;$&#123;flag*PI/2&#125; 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;direction&#125;_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;$&#123;direction&#125;_wheel&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 $&#123;flag*(base_radius)&#125; $&#123;wheel_joint_z&#125;&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:wheel_func</span> <span class="attr">direction</span>=<span class="string">&quot;left&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:wheel_func</span> <span class="attr">direction</span>=<span class="string">&quot;right&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 万向轮属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span> = <span class="string">&quot;support_wheel_radius&quot;</span> <span class="attr">value</span> =<span class="string">&quot;0.0075&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_wheel_joint_z&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;-(base_length/2 + ground_distance - support_wheel_radius)&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 万向轮(支撑轮)宏 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span> = <span class="string">&quot;add_support_wheel&quot;</span> <span class="attr">params</span>=<span class="string">&quot;direction flag&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;direction&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;direction&#125;_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;$&#123;direction&#125;_wheel&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;flag*(base_radius - support_wheel_radius)&#125; 0.0 $&#123;support_wheel_joint_z&#125;&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;1 1 1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_support_wheel</span> <span class="attr">direction</span>=<span class="string">&quot;front&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_support_wheel</span> <span class="attr">direction</span>=<span class="string">&quot;back&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对比之前的版本实现了代码复用</p><p>集成launch文件：<font color='Violetred'>在 launch 文件中直接加载 xacro</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;param name=&quot;robot_description&quot; textfile=&quot;$(find urdf01_rviz)/urdf/urdf/test.urdf&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span> = <span class="string">&quot;$(find xacro)/xacro $(find urdf01_rviz)/urdf/xacro/test.urdf.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">type</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">name</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">args</span> = <span class="string">&quot;-d $(find urdf01_rviz)/config/show_car.rviz&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  关节状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  机器人状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加控制关节运动的节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span> = <span class="string">&quot;$(find xacro)/xacro $(find urdf01_rviz)/urdf/xacro/test.urdf.xacro&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加载<code>robot_description</code>时使用<code>command</code>属性，属性值就是调用 xacro 功能包的 xacro 程序直接解析 xacro 文件</p><h4 id="Xacro实操"><a href="#Xacro实操" class="headerlink" title="Xacro实操"></a>Xacro实操</h4><p>需求描述：在前面小车底盘基础之上，添加摄像头和雷达传感器</p><p>实现分析：</p><p>机器人模型由多部件组成，可以将不同组件设置进单独文件，最终通过文件包含实现组件的拼装。</p><p>实现流程：</p><ol><li>首先编写摄像头和雷达的 xacro 文件</li><li>然后再编写一个组合文件，组合底盘、摄像头与雷达</li><li>最后，通过 launch 文件启动 Rviz 并显示模型</li></ol><p>**摄像头Xacro **</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span> <span class="attr">name</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 摄像头属性 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        连杆属性：厚度、宽度、高度</span></span><br><span class="line"><span class="comment">        关节属性：x y z</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.02&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头长度(x) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_width&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.02&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头宽度(y) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_height&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.02&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头高度(z) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头安装的x坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_y&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头安装的y坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_z&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;base_length / 2 + camera_height / 2&#125;&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头安装的z坐标:底盘高度 / 2 + 摄像头高度 / 2  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 摄像头关节以及link --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;$&#123;camera_length&#125; $&#123;camera_width&#125; $&#123;camera_height&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;camera2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;camera&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;camera_x&#125; $&#123;camera_y&#125; $&#123;camera_z&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>雷达Xacro</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span> <span class="attr">name</span>=<span class="string">&quot;laser&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 雷达支架 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.15&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支架长度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支架半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支架安装的x坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_y&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支架安装的y坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_z&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;base_length / 2 + support_length / 2&#125;&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支架安装的z坐标:底盘高度 / 2 + 支架高度 / 2  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;support&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;support_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;support_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.8 0.2 0.0 0.8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;support2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;support&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;support_x&#125; $&#123;support_y&#125; $&#123;support_z&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 雷达属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;laser_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 雷达长度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;laser_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.03&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 雷达半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;laser_x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 雷达安装的x坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;laser_y&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 雷达安装的y坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;laser_z&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;support_length / 2 + laser_length / 2&#125;&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 雷达安装的z坐标:支架高度 / 2 + 雷达高度 / 2  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 雷达关节以及link --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;laser&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;laser_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;laser_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;laser2support&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;support&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;laser&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;laser_x&#125; $&#123;laser_y&#125; $&#123;laser_z&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>组合底盘摄像头与雷达</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组合小车底盘与摄像头与雷达 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;base.urdf.xacro&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;camera.urdf.xacro&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser.urdf.xacro&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>launch 文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find urdf01_rviz)/urdf/xacro/combination.urdf.xacro&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">type</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">name</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">args</span> = <span class="string">&quot;-d $(find urdf01_rviz)/config/show_car.rviz&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  关节状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  机器人状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加控制关节运动的节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Rviz控制运动"><a href="#Rviz控制运动" class="headerlink" title="Rviz控制运动"></a>Rviz控制运动</h3><p>Arbotix 是一款控制电机、舵机的控制板，并提供相应的 ros 功能包</p><p>这个功能包不仅可以驱动真实的 Arbotix 控制板，它还提供一个差速控制器，通过接受速度控制指令更新机器人的 joint 状态，从而帮助我们实现机器人在 rviz 中的运动</p><p>Arbotix使用流程：</p><ol><li>安装 Arbotix</li><li>创建新功能包，准备机器人 urdf、xacro 文件</li><li>添加 Arbotix 配置文件</li><li>编写 launch 文件配置 Arbotix</li><li>启动 launch 文件并控制机器人模型运动</li></ol><p><strong>安装 Arbotix</strong></p><p>方式1：命令行调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-&lt;&lt;VersionName()&gt;&gt;-arbotix</span><br><span class="line">sudo apt-get install ros-noetic-arbotix</span><br></pre></td></tr></table></figure><p>将 &lt;&lt;VsersionName()&gt;&gt; 替换成当前 ROS 版本名称，如果提示功能包无法定位，请采用方式2</p><p>方式2：源码安装</p><p>先从 github 下载源码，然后调用 catkin_make 编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vanadiumlabs/arbotix_ros.git</span><br></pre></td></tr></table></figure><p><strong>创建新功能包，准备机器人 urdf、xacro</strong></p><p>urdf 和 xacro 调用上一讲实现即可</p><p><strong>添加 arbotix 所需的配置文件</strong></p><p>在config文件夹下增加文件<code>control.yaml</code></p><p>范本：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该文件是控制器配置,一个机器人模型可能有多个控制器，比如: 底盘、机械臂、夹持器(机械手)....</span></span><br><span class="line"><span class="comment"># 因此，根 name 是 controller</span></span><br><span class="line"><span class="attr">controllers:</span> &#123;</span><br><span class="line">   <span class="comment"># 单控制器设置</span></span><br><span class="line">   <span class="attr">base_controller:</span> &#123;</span><br><span class="line">          <span class="comment">#类型: 差速控制器</span></span><br><span class="line">       <span class="attr">type:</span> <span class="string">diff_controller</span>,</span><br><span class="line">       <span class="comment">#参考坐标(一般是根坐标系)</span></span><br><span class="line">       <span class="attr">base_frame_id:</span> <span class="string">base_footprint</span>, </span><br><span class="line">       <span class="comment">#两个轮子之间的间距</span></span><br><span class="line">       <span class="attr">base_width:</span> <span class="number">0.2</span>,</span><br><span class="line">       <span class="comment">#控制频率</span></span><br><span class="line">       <span class="attr">ticks_meter:</span> <span class="number">2000</span>, </span><br><span class="line">       <span class="comment">#PID控制参数，使机器人车轮快速达到预期速度</span></span><br><span class="line">       <span class="attr">Kp:</span> <span class="number">12</span>, </span><br><span class="line">       <span class="attr">Kd:</span> <span class="number">12</span>, </span><br><span class="line">       <span class="attr">Ki:</span> <span class="number">0</span>, </span><br><span class="line">       <span class="attr">Ko:</span> <span class="number">50</span>, </span><br><span class="line">       <span class="comment">#加速限制</span></span><br><span class="line">       <span class="attr">accel_limit:</span> <span class="number">1.0</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>launch 文件中配置 arbotix 节点</strong></p><p>增添部分</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;arbotix&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;arbotix_python&quot;</span> <span class="attr">type</span>=<span class="string">&quot;arbotix_driver&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find my_urdf05_rviz)/config/hello.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sim&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>node 调用了 arbotix_python 功能包下的 arbotix_driver 节点</p></li><li><p>rosparam：arbotix 驱动机器人运行时，需要获取机器人信息，可以通过 file 加载配置文件</p></li><li><p>param：在仿真环境下，需要配置 sim 为 true</p></li></ul><p><strong>启动 launch 文件并控制机器人模型运动</strong></p><p>配置 rviz：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-06-15_19-48-15.webp" alt="Snipaste_2025-06-15_19-48-15" style="zoom: 50%;" /><p>控制小车运动：</p><p>发布 cmd_vel 话题消息控制小车运动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub -r 10 /cmd_vel [TAB] [TAB]</span><br></pre></td></tr></table></figure><h3 id="URDF集成Gazebo"><a href="#URDF集成Gazebo" class="headerlink" title="URDF集成Gazebo"></a>URDF集成Gazebo</h3><h4 id="基本集成流程"><a href="#基本集成流程" class="headerlink" title="基本集成流程"></a>基本集成流程</h4><p><strong>创建功能包</strong></p><p>导入依赖包: urdf、xacro、gazebo_ros、gazebo_ros_control、gazebo_plugins</p><p><strong>编写URDF文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;mycar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.5 0.2 0.1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 1 0.0 0.5&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置碰撞参数 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果是标准几何物体,直接复制 visual 的 geometry 和 origin 即可--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.5 0.2 0.1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置惯性矩阵 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 相当于设置重心偏移,如果质量均匀基本就和关节一样 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 不同维度上的惯性值 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;1&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- gzebo有自己的颜色设置标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span> =<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意这里Gazobo和颜色首字母必须大写 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Red<span class="tag">&lt;/<span class="name">material</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 URDF 需要与 Gazebo 集成时，和 Rviz 有明显区别：</p><p>1.必须使用 collision 标签，因为既然是仿真环境，那么必然涉及到碰撞检测，collision 提供碰撞检测的依据。</p><p>2.必须使用 inertial 标签，此标签标注了当前机器人某个刚体部分的惯性矩阵，用于一些力学相关的仿真计算。</p><p>3.颜色设置，也需要重新使用 gazebo 标签标注，因为之前的颜色设置为了方便调试包含透明度，仿真环境下没有此选项</p><p><strong>启动Gazebo并显示模型</strong></p><p>launch 文件实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将 Urdf 文件的内容加载到参数服务器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span> = <span class="string">&quot;$(find urdf02_gazebo)/urdf/demo01_helloworld.urdf&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动 gazebo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在 gazebo 中显示机器人模型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model mycar -param robot_description&quot;</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码解释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 启动 Gazebo 的仿真环境，当前环境为空环境 --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model mycar -param robot_description&quot;</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    在 Gazebo 中加载一个机器人模型，该功能由 gazebo_ros 下的 spawn_model 提供:</span></span><br><span class="line"><span class="comment">    -urdf 加载的是 urdf 文件</span></span><br><span class="line"><span class="comment">    -model mycar 模型名称是 mycar</span></span><br><span class="line"><span class="comment">    -param robot_description 从参数 robot_description 中载入模型</span></span><br><span class="line"><span class="comment">    -x 模型载入的 x 坐标</span></span><br><span class="line"><span class="comment">    -y 模型载入的 y 坐标</span></span><br><span class="line"><span class="comment">    -z 模型载入的 z 坐标</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h4><p>较之于 rviz，gazebo在集成 URDF 时，需要做些许修改</p><p>比如：必须添加 collision 碰撞属性相关参数、必须添加 inertial 惯性矩阵相关参数</p><p>另外，如果直接移植 Rviz 中机器人的颜色设置是没有显示的，颜色设置也必须做相应的变更</p><p><strong>collision</strong></p><p>如果机器人link是标准的几何体形状，和link的visual属性设置一致即可</p><p><strong>inertial</strong></p><p>惯性矩阵的设置需要结合link的质量与外形参数动态生成，标准的球体、圆柱与立方体的惯性矩阵公式如下(封装为 xacro 实现)：</p><p>球体惯性矩阵：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Macro for inertia matrix --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;sphere_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p>圆柱惯性矩阵：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;cylinder_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r h&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">iyz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*r*r/2&#125;&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p>立方体惯性矩阵：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;Box_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m l w h&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(w*w + h*h)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(h*h + l*l)/12&#125;&quot;</span> <span class="attr">iyz</span>= <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*(l*l + w*w)/12&#125;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原则上，除了 base_footprint 外，机器人的每个刚体部分都需要设置惯性矩阵，且惯性矩阵必须经计算得出，如果随意定义刚体部分的惯性矩阵，那么可能会导致机器人在 Gazebo 中出现抖动，移动等现象</p><p>在 gazebo 中显示 link 的颜色，必须要使用指定的标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;link节点名称&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Blue<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>material 标签中，设置的值区分大小写，颜色可以设置为 Red Blue Green Black</p><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>需求描述：将之前的机器人模型(xacro版)显示在 gazebo 中</p><p>实现流程：</p><ol><li>需要编写封装惯性矩阵算法的 xacro 文件</li><li>为机器人模型中的每一个 link 添加 collision 和 inertial 标签，并且重置颜色属性</li><li>在 launch 文件中启动 gazebo 并添加机器人模型</li></ol><p><strong>编写封装惯性矩阵算法的 xacro 文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Macro for inertia matrix --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;sphere_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;cylinder_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r h&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">iyz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*r*r/2&#125;&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;Box_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m l w h&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(w*w + h*h)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(h*h + l*l)/12&#125;&quot;</span> <span class="attr">iyz</span>= <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*(l*l + w*w)/12&#125;&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>复制相关 xacro 文件，并设置 collision inertial 以及 color 等参数</strong></p><p>将上一节的xacro文件复制一份进行修改</p><p>以底盘为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">...  </span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_mass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加底盘 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;base_length&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;base_length&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 调用惯性矩阵函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xacro:cylinder_inertial_matrix</span> <span class="attr">m</span>=<span class="string">&quot;$&#123;base_mass&#125;&quot;</span> <span class="attr">r</span>=<span class="string">&quot;$&#123;base_radius&#125;&quot;</span> <span class="attr">h</span>=<span class="string">&quot;$&#123;base_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Yellow<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_mass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span> /&gt;</span><span class="comment">&lt;!-- 质量 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮宏 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        direction: left or right</span></span><br><span class="line"><span class="comment">        flag: 1 or -1</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span> = <span class="string">&quot;wheel_func&quot;</span> <span class="attr">params</span>=<span class="string">&quot;direction flag&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;direction&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;$&#123;flag*PI/2&#125; 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;$&#123;flag*PI/2&#125; 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xacro:cylinder_inertial_matrix</span> <span class="attr">m</span>=<span class="string">&quot;$&#123;wheel_mass&#125;&quot;</span> <span class="attr">r</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">h</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;$&#123;direction&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Red<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:wheel_func</span> <span class="attr">direction</span>=<span class="string">&quot;left&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:wheel_func</span> <span class="attr">direction</span>=<span class="string">&quot;right&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">&lt;!-- 万向轮属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span> = <span class="string">&quot;support_wheel_mass&quot;</span> <span class="attr">value</span> =<span class="string">&quot;0.01&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 万向轮(支撑轮)宏 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span> = <span class="string">&quot;add_support_wheel&quot;</span> <span class="attr">params</span>=<span class="string">&quot;direction flag&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;direction&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xacro:sphere_inertial_matrix</span> <span class="attr">m</span>=<span class="string">&quot;$&#123;support_wheel_mass&#125;&quot;</span> <span class="attr">r</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;$&#123;direction&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Red<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_support_wheel</span> <span class="attr">direction</span>=<span class="string">&quot;front&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_support_wheel</span> <span class="attr">direction</span>=<span class="string">&quot;back&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要删除原有visual下的material标签，然后在link标签内增加collision标签以及调用惯性矩阵函数，在link标签外使用gazebo下的material附加颜色</p><p>如果机器人模型在 Gazebo 中产生了抖动，滑动，缓慢位移诸如此类情况，需要考虑：</p><ol><li>惯性矩阵是否设置了，且设置是否正确合理</li><li>车轮翻转需要依赖于 PI 值，如果 PI 值精度偏低，也可能导致上述情况产生</li></ol><p>同理修改camera和laser，具体代码不附</p><h4 id="仿真环境搭建"><a href="#仿真环境搭建" class="headerlink" title="仿真环境搭建"></a>仿真环境搭建</h4><p>到目前为止，我们已经可以将机器人模型显示在 Gazebo 之中了，但是当前默认情况下，在 Gazebo 中机器人模型是在 empty world 中，并没有类似于房间、家具、道路、树木… 之类的仿真物</p><p>Gazebo 中创建仿真实现方式有两种：</p><ul><li>方式1: 直接添加内置组件创建仿真环境</li><li>方式2: 手动绘制仿真环境(更为灵活)</li></ul><p>也还可以直接下载使用官方或第三方提高的仿真环境插件</p><p>将之前下载的资源中box_house.world移动到当前功能包目录下的worlds文件夹中</p><p>改写launch文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find urdf02_gazebo)/urdf/xacro/combination.urdf.xacro&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动 gazebo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find urdf02_gazebo)/worlds/box_house.world&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在 gazebo 中显示机器人模型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model mycar -param robot_description&quot;</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>核心代码：启动 empty_world 后，再根据<code>arg</code>加载自定义的仿真环境</p><p>注意，<font color='Violetred'>arg的name固定，只能是<code>world_name</code></font></p><p>当前 Gazebo 提供的仿真道具有限，还可以下载官方支持，可以提供更为丰富的仿真实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/osrf/gazebo_models</span><br></pre></td></tr></table></figure><p>将得到的gazebo_models文件夹内容复制到 &#x2F;usr&#x2F;share&#x2F;gazebo-*&#x2F;models</p><p>重启 Gazebo，选择左侧菜单栏的 insert 可以选择并插入相关道具了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun gazebo_ros gazebo</span><br></pre></td></tr></table></figure><h3 id="URDF、Gazebo与Rviz综合应用"><a href="#URDF、Gazebo与Rviz综合应用" class="headerlink" title="URDF、Gazebo与Rviz综合应用"></a>URDF、Gazebo与Rviz综合应用</h3><p>本节中大量配置文件来源于官方网站，但是网站已经更新到ROS2了，可能有的直接复制教程里面的了</p><h4 id="机器人运动控制"><a href="#机器人运动控制" class="headerlink" title="机器人运动控制"></a>机器人运动控制</h4><p>gazebo 中已经可以正常显示机器人模型了，那么如何像在 rviz 中一样控制机器人运动呢？</p><p>需要涉及到ros中的组件：ros_control</p><p>ros_control 是一组软件包，它包含了控制器接口，控制器管理器，传输和硬件接口</p><p>ros_control 是一套规范，不同的机器人平台只要按照这套规范实现，那么就可以保证与ROS 程序兼容，通过这套规范，实现了一种可插拔的架构设计，大大提高了程序设计的效率与灵活性</p><p>运动控制实现流程Gazebo：</p><ol><li>编写一个单独的 xacro 文件，为机器人模型添加传动装置以及控制器</li><li>将此文件集成进xacro文件</li><li>启动 Gazebo 并发布 &#x2F;cmd_vel 消息控制机器人运动</li></ol><p>为 joint 添加传动装置以及控制器：</p><p>新建 Xacro 文件，配置两轮差速：(直接复制)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_move&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 传动实现:用于连接控制器与关节 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;joint_trans&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Transmission is important to link the joints and the controller --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;_trans&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/VelocityJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;_motor&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/VelocityJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 每一个驱动轮都需要配置传动装置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 需要修改的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:joint_trans</span> <span class="attr">joint_name</span>=<span class="string">&quot;left_wheel2base_link&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:joint_trans</span> <span class="attr">joint_name</span>=<span class="string">&quot;right_wheel2base_link&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;differential_drive_controller&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_diff_drive.so&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rosDebugLevel</span>&gt;</span>Debug<span class="tag">&lt;/<span class="name">rosDebugLevel</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">publishWheelTF</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publishWheelTF</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">robotNamespace</span>&gt;</span>/<span class="tag">&lt;/<span class="name">robotNamespace</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">publishTf</span>&gt;</span>1<span class="tag">&lt;/<span class="name">publishTf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">publishWheelJointState</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publishWheelJointState</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>100.0<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">legacyMode</span>&gt;</span>true<span class="tag">&lt;/<span class="name">legacyMode</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">leftJoint</span>&gt;</span>left_wheel2base_link<span class="tag">&lt;/<span class="name">leftJoint</span>&gt;</span> <span class="comment">&lt;!-- 左轮 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rightJoint</span>&gt;</span>right_wheel2base_link<span class="tag">&lt;/<span class="name">rightJoint</span>&gt;</span> <span class="comment">&lt;!-- 右轮 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wheelSeparation</span>&gt;</span>$&#123;base_link_radius * 2&#125;<span class="tag">&lt;/<span class="name">wheelSeparation</span>&gt;</span> <span class="comment">&lt;!-- 车轮间距 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wheelDiameter</span>&gt;</span>$&#123;wheel_radius * 2&#125;<span class="tag">&lt;/<span class="name">wheelDiameter</span>&gt;</span> <span class="comment">&lt;!-- 车轮直径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">broadcastTF</span>&gt;</span>1<span class="tag">&lt;/<span class="name">broadcastTF</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wheelTorque</span>&gt;</span>30<span class="tag">&lt;/<span class="name">wheelTorque</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wheelAcceleration</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">wheelAcceleration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">commandTopic</span>&gt;</span>cmd_vel<span class="tag">&lt;/<span class="name">commandTopic</span>&gt;</span> <span class="comment">&lt;!-- 运动控制话题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">odometryFrame</span>&gt;</span>odom<span class="tag">&lt;/<span class="name">odometryFrame</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">odometryTopic</span>&gt;</span>odom<span class="tag">&lt;/<span class="name">odometryTopic</span>&gt;</span> <span class="comment">&lt;!-- 里程计话题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">robotBaseFrame</span>&gt;</span>base_footprint<span class="tag">&lt;/<span class="name">robotBaseFrame</span>&gt;</span> <span class="comment">&lt;!-- 根坐标系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将上述 xacro 文件集成进总的机器人模型xacro文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 包含惯性矩阵 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;head.xacro&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组合小车底盘与摄像头与雷达 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;base.urdf.xacro&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;camera.urdf.xacro&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser.urdf.xacro&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运动控制 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find urdf02_gazebo)/urdf/gazebo/move.xacro&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>launch文件不变（先启动gazebo虚拟环境，再启动rviz）</p><p>使用命令控制小车运动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun teleop_twist_keyboard  teleop_twist_keyboard.py</span><br></pre></td></tr></table></figure><h4 id="Rviz查看里程计信息"><a href="#Rviz查看里程计信息" class="headerlink" title="Rviz查看里程计信息"></a>Rviz查看里程计信息</h4><p>里程计：利用从移动传感器获得的数据来估计物体位置随时间的变化而改变的方法</p><p>启动 Rviz（<font color='Violetred'>记住一定是带上两个状态发布节点一起</font>）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">type</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">name</span> = <span class="string">&quot;rviz&quot;</span> <span class="attr">args</span> = <span class="string">&quot;-d $(find urdf01_rviz)/config/show_car.rviz&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  关节状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  机器人状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行 launch 文件后，在 Rviz 中添加图示组件：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/21_Rviz显示里程计数据.webp" alt="21_Rviz显示里程计数据" style="zoom: 50%;" /><h4 id="雷达信息仿真"><a href="#雷达信息仿真" class="headerlink" title="雷达信息仿真"></a>雷达信息仿真</h4><p>雷达仿真基本流程:</p><ol><li>已经创建完毕的机器人模型，编写一个单独的 xacro 文件，为机器人模型添加雷达配置；</li><li>将此文件集成进xacro文件；</li><li>启动 Gazebo，使用 Rviz 显示雷达信息。</li></ol><p>新建 Xacro 文件，配置雷达传感器信息：(直接复制)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 雷达 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;laser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;ray&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rplidar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pose</span>&gt;</span>0 0 0 0 0 0<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">visualize</span>&gt;</span>true<span class="tag">&lt;/<span class="name">visualize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>5.5<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ray</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scan</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 雷达参数 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">horizontal</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 采样个数,与仿真压力挂钩 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">samples</span>&gt;</span>360<span class="tag">&lt;/<span class="name">samples</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">resolution</span>&gt;</span>1<span class="tag">&lt;/<span class="name">resolution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 采样弧度范围 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">min_angle</span>&gt;</span>-3<span class="tag">&lt;/<span class="name">min_angle</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">max_angle</span>&gt;</span>3<span class="tag">&lt;/<span class="name">max_angle</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">horizontal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">scan</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 采样距离范围 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">range</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">min</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">min</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">max</span>&gt;</span>30.0<span class="tag">&lt;/<span class="name">max</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 距离精度 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resolution</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">resolution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">range</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 仿真噪声 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noise</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>gaussian<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mean</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">mean</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">stddev</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">stddev</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">noise</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ray</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_rplidar&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_laser.so&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">topicName</span>&gt;</span>/scan<span class="tag">&lt;/<span class="name">topicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>laser<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>gazebo reference &#x2F; frameName 这两个位置的名称和定义雷达的link名称需要相同</p><p>集成到总的xacro 文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!-- 雷达 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find urdf02_gazebo)/urdf/gazebo/laser.xacro&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>launch文件不变，先启动gazebo再启动rviz</p><p>添加雷达信息显示插件</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/雷达仿真2.webp" alt="雷达仿真2" style="zoom: 50%;" /><h4 id="摄像头信息仿真"><a href="#摄像头信息仿真" class="headerlink" title="摄像头信息仿真"></a>摄像头信息仿真</h4><p>步骤类似雷达</p><p>新建 Xacro 文件，配置摄像头传感器信息：(直接复制)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 被引用的link --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 类型设置为 camara --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;camera&quot;</span> <span class="attr">name</span>=<span class="string">&quot;camera_node&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>30.0<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span> <span class="comment">&lt;!-- 更新频率 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 摄像头基本信息设置 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">camera</span> <span class="attr">name</span>=<span class="string">&quot;head&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">horizontal_fov</span>&gt;</span>1.3962634<span class="tag">&lt;/<span class="name">horizontal_fov</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">width</span>&gt;</span>1280<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">height</span>&gt;</span>720<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">format</span>&gt;</span>R8G8B8<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clip</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">near</span>&gt;</span>0.02<span class="tag">&lt;/<span class="name">near</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">far</span>&gt;</span>300<span class="tag">&lt;/<span class="name">far</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">clip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noise</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>gaussian<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mean</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">mean</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">stddev</span>&gt;</span>0.007<span class="tag">&lt;/<span class="name">stddev</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">noise</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">camera</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 核心插件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_camera&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_camera.so&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 为话题设置一个命名空间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cameraName</span>&gt;</span>/camera<span class="tag">&lt;/<span class="name">cameraName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageTopicName</span>&gt;</span>image_raw<span class="tag">&lt;/<span class="name">imageTopicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cameraInfoTopicName</span>&gt;</span>camera_info<span class="tag">&lt;/<span class="name">cameraInfoTopicName</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- link名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>camera<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hackBaseline</span>&gt;</span>0.07<span class="tag">&lt;/<span class="name">hackBaseline</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK3</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionT1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionT1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionT2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionT2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>集成到总的xacro文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!-- 摄像头 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find urdf02_gazebo)/urdf/gazebo/camera.xacro&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>launch文件不变，先启动gazebo再启动rviz</p><p>在 Rviz 中添加摄像头组件</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/摄像头仿真3.webp" alt="摄像头仿真3" style="zoom:50%;" /><h4 id="kinect信息仿真"><a href="#kinect信息仿真" class="headerlink" title="kinect信息仿真"></a>kinect信息仿真</h4><p>kinect是深度信息摄像头</p><p>步骤类似上述</p><p>新建 Xacro 文件，配置 kinetic传感器信息(直接复制)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;kinect link名称&quot;</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;depth&quot;</span> <span class="attr">name</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">always_on</span>&gt;</span>true<span class="tag">&lt;/<span class="name">always_on</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>20.0<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">camera</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">horizontal_fov</span>&gt;</span>$&#123;60.0*PI/180.0&#125;<span class="tag">&lt;/<span class="name">horizontal_fov</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">format</span>&gt;</span>R8G8B8<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">width</span>&gt;</span>640<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">height</span>&gt;</span>480<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">clip</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">near</span>&gt;</span>0.05<span class="tag">&lt;/<span class="name">near</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">far</span>&gt;</span>8.0<span class="tag">&lt;/<span class="name">far</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">clip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">camera</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;kinect_camera_controller&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_openni_kinect.so&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cameraName</span>&gt;</span>camera<span class="tag">&lt;/<span class="name">cameraName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>10<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">imageTopicName</span>&gt;</span>rgb/image_raw<span class="tag">&lt;/<span class="name">imageTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">depthImageTopicName</span>&gt;</span>depth/image_raw<span class="tag">&lt;/<span class="name">depthImageTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pointCloudTopicName</span>&gt;</span>depth/points<span class="tag">&lt;/<span class="name">pointCloudTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cameraInfoTopicName</span>&gt;</span>rgb/camera_info<span class="tag">&lt;/<span class="name">cameraInfoTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">depthImageCameraInfoTopicName</span>&gt;</span>depth/camera_info<span class="tag">&lt;/<span class="name">depthImageCameraInfoTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>kinect link名称<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">baseline</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">baseline</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k1</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k2</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k3</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k3</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_t1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_t1</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_t2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_t2</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pointCloudCutoff</span>&gt;</span>0.4<span class="tag">&lt;/<span class="name">pointCloudCutoff</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以把上一步camera的xacro注释掉，把camera换成kinect</p><p>集成到总的xacro 文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!-- 摄像头 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;xacro:include filename=&quot;$(find urdf02_gazebo)/urdf/gazebo/camera.xacro&quot;/&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- kinect --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find urdf02_gazebo)/urdf/gazebo/kinect.xacro&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>launch文件不变，先启动gazebo再启动rviz</p><p>kinect 点云数据显示：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/点云数据_默认.webp" alt="点云数据_默认" style="zoom:50%;" /><p>但在rviz中显示时错位</p><p>原因：在kinect中图像数据与点云数据使用了两套坐标系统，且两套坐标系统位姿并不一致</p><p>在插件中为kinect设置坐标系，修改配置文件的<code>&lt;frameName&gt;</code>标签内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frameName</span>&gt;</span>camera_depth<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br></pre></td></tr></table></figure><p>发布新设置的坐标系到kinect连杆的坐标变换关系，在启动rviz的launch中，添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加点云坐标系到kinect坐标系的变化=换  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf2_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">args</span> =<span class="string">&quot; 0 0 0 -1.57 0 -1.57 /camera /camera_depth&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>为什么是-1.57：逆着轴方向看逆时针旋转为正</p><p>启动rviz，重新显示</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章主要介绍了ROS中仿真实现涉及的三大知识点：</p><ul><li>URDF(Xacro)</li><li>Rviz</li><li>Gazebo</li></ul><p>URDF 是用于描述机器人模型的 xml 文件，可以使用不同的标签具代表不同含义，URDF 编写机器人模型代码冗余，xacro 可以优化 URDF 实现，代码实现更为精简、高效、易读</p><p>rviz需要<strong>已有数据</strong>，强调把已有的数据可视化显示</p><p>rviz提供了很多插件，这些插件可以显示图像、模型、路径等信息，但是前提都是这些数据已经以话题、参数的形式发布，rviz做的事情就是订阅这些数据，并完成可视化的渲染</p><p>gazebo是<strong>三维物理仿真平台</strong>，创建虚拟的仿真环境，**不需要数据，而是创造数据，**不仅可以仿真机器人的运动功能，还可以仿真机器人的传感器数据</p><h2 id="机器人导航-仿真"><a href="#机器人导航-仿真" class="headerlink" title="机器人导航(仿真)"></a>机器人导航(仿真)</h2><p>导航是机器人系统中最重要的模块之一</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在ROS中机器人导航(Navigation)由多个功能包组合实现，ROS 中又称之为导航功能包集</p><p>关于导航模块，官方介绍：一个二维导航堆栈，它接收来自里程计、传感器流和目标姿态的信息，并输出发送到移动底盘的安全速度命令</p><p>ROS 中导航相关的功能包集为机器人导航提供了一套通用的实现，开发者不再需要关注于导航算法、硬件交互等偏复杂、偏底层的实现，这些实现都由更专业的研发人员管理、迭代和维护，开发者可以更专注于上层功能，而对于导航功能的调用，只需要根据自身机器人相关参数合理设置各模块的配置文件即可</p><blockquote><p>简而言之调参</p></blockquote><h4 id="导航模块简介"><a href="#导航模块简介" class="headerlink" title="导航模块简介"></a>导航模块简介</h4><p>ROS 官方为了提供了一张导航功能包集的图示，该图中囊括了 ROS 导航的一些关键技术：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/02_导航官方架构.webp" alt="02_导航官方架构" style="zoom: 80%;" /><p>这个图的解读：</p><p>先看图例：</p><ul><li>provided node：必须节点</li><li>optional provided node：可选择节点</li><li>platform specific node：平台相关节点</li></ul><p>外部数据输入：</p><ul><li><strong>map_server</strong>：读取或发布静态环境地图（occupancy grid），供全局规划器和代价地图使用</li><li><strong>sensor sources</strong>：各类传感器数据（激光雷达、深度相机等），用于构建局部环境的代价地图</li><li><strong>odometry source</strong>：里程计数据（车轮编码器、惯导等），提供机器人相对运动信息</li><li><strong>amcl</strong>：自适应 Monte‑Carlo 本地化（Adaptive Monte Carlo Localization），结合传感器与地图给出机器人在地图中的全局位姿</li><li><strong>sensor transforms</strong>：TF 数 据，负责把各个传感器坐标系和机器人基座（base_link）坐标系对齐</li></ul><p>move_base 核心：</p><ul><li><strong>global_costmap</strong>：用静态地图（map_server）以及部分传感器数据（静态障碍）构建的全局代价栅格（occupancy grid），主要用于规划从当前位置到目标位置的全局路径</li><li><strong>global_planner</strong>：基于 <code>global_costmap</code> 和 <code>amcl</code> 提供的位姿，运行 A*、Dijkstra 或 Navfn 等算法，生成一条从起点到目标点的全局路径</li><li><strong>local_costmap</strong>：动态地整合传感器实时数据，构建机器人周围的局部代价栅格，用于避障</li><li><strong>local_planner</strong>：接收全局路径（waypoints）和 <code>local_costmap</code>，生成实际的速度命令（线速度、角速度）给底层运动控制器（base controller），在避障的同时跟踪全局路径</li><li><strong>recovery_behaviors</strong>：当局部规划失败（如被障碍物完全包围、无法前进）时，触发恢复行为：比如向后退、旋转扫描、清空局部地图等，尝试脱困</li></ul><p>底层执行：</p><ul><li><strong>base controller</strong>：接收 <code>local_planner</code> 输出的速度指令，驱动机器人底盘（电机、差分驱动或者四轮全向等）去移动</li></ul><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-06-21_16-22-29.jpg" alt="Snipaste_2025-06-21_16-22-29" style="zoom:80%;" /><p>总结下来，涉及的关键技术有如下五点:</p><ol><li>全局地图</li><li>自身定位</li><li>路径规划</li><li>运动控制</li><li>环境感知</li></ol><p>机器人导航实现与无人驾驶类似，关键技术也是由上述五点组成，只是无人驾驶是基于室外的，而当前介绍的机器人导航更多是基于室内的</p><p><strong>全局地图</strong>：</p><ol><li><strong>SLAM</strong>(simultaneous localization and mapping)，也称为CML (Concurrent Mapping and Localization)，即时定位与地图构建</li><li>SLAM问题：机器人在未知环境中从一个未知位置开始移动,在移动过程中根据位置估计和地图进行自身定位，同时在自身定位的基础上建造增量式地图，以绘制出外部环境的完全地图</li><li>如果要完成 SLAM ，机器人必须要具备感知外界环境的能力，尤其是要具备获取周围环境深度信息的能力。感知的实现需要依赖于传感器，比如：激光雷达、摄像头、RGB-D摄像头…</li><li>SLAM 可以用于地图生成，而生成的地图还需要被保存以待后续使用，在 ROS 中保存地图的功能包是 map_server</li></ol><p>SLAM 虽然是机器人导航的重要技术之一，但是二者并不等价，确切的讲，SLAM 只是实现地图构建和即时定位</p><p><strong>自身定位</strong>：</p><p>导航开始和过程中，机器人都需要确定当前自身的位置</p><p>如果在室外，那么 GPS 是一个不错的选择，而如果室内、隧道、地下或一些特殊的屏蔽 GPS 信号的区域，由于 GPS 信号弱化甚至完全不可用，那么就必须另辟蹊径了</p><p>前面提到的 SLAM 就可以实现自身定位，除此之外，ROS 中还提供了一个用于定位的功能包：amcl (ROS1&#x2F;Ros2 经典实现已经老化与不够鲁棒)</p><p><strong>路径规划：</strong></p><p>在 ROS 中提供了 move_base 包来实现路径规则，该功能包主要由两大规划器组成：</p><ol><li><p>全局路径规划(gloable_planner)</p><p>根据给定的目标点和全局地图实现总体的路径规划，使用 Dijkstra 或 A* 算法进行全局路径规划，计算最优路线，作为全局路线</p></li><li><p>本地时时规划(local_planner)</p><p>在实际导航过程中，机器人可能无法按照给定的全局最优路线运行，本地规划的作用就是使用一定算法(Dynamic Window Approaches) 来实现障碍物的规避，并选取当前最优路径以尽量符合全局最优路径</p></li></ol><p><strong>运动控制</strong>：</p><p>导航功能包集假定通过话题”cmd_vel”发布<code>geometry_msgs/Twist</code>类型的消息，这个消息基于机器人的基坐标系，传递的是运动命令。这意味着必须有一个节点订阅”cmd_vel”话题，将该话题上的速度命令转换为电机命令并发送</p><h4 id="导航之坐标系"><a href="#导航之坐标系" class="headerlink" title="导航之坐标系"></a>导航之坐标系</h4><p>定位实现需要依赖于机器人自身，机器人需要逆向推导参考系原点并计算坐标系相对关系，该过程实现常用方式有两种：</p><ul><li>通过里程计定位：时时收集机器人的速度信息计算并发布机器人坐标系与父级参考系的相对关系</li><li>通过传感器定位：通过传感器收集外界环境信息通过匹配计算并发布机器人坐标系与父级参考系的相对关系</li></ul><p>两种定位方式都有各自的优缺点</p><p>里程计定位:</p><ul><li>优点：里程计定位信息是连续的，没有离散的跳跃</li><li>缺点：里程计存在<font color='Violetred'>累计误差</font>，不利于长距离或长期定位</li></ul><p>传感器定位:</p><ul><li>优点：比里程计定位更精准；</li><li>缺点：传感器定位会出现跳变的情况，且传感器定位在标志物较少的环境下，其定位精度会大打折扣</li></ul><p><strong>坐标系变换</strong>：</p><p>上述两种定位实现中，机器人坐标系一般使用机器人模型中的根坐标系(base_link 或 base_footprint)</p><ul><li>里程计定位时，父级坐标系一般称之为 odom</li><li>传感器定位时，父级参考系一般称之为 map</li></ul><p>当二者结合使用时，map 和 odom 都是机器人模型根坐标系的父级，这是不符合坐标变换中”单继承”的原则的</p><p>一般会将转换关系设置为：<font color='Violetred'>map -&gt; odom -&gt; base_link 或 base_footprint</font></p><blockquote><p>因为map一般精度更高</p></blockquote><h4 id="导航条件说明"><a href="#导航条件说明" class="headerlink" title="导航条件说明"></a>导航条件说明</h4><p><strong>硬件</strong></p><p>虽然导航功能包集被设计成尽可能的通用，在使用时仍然有三个主要的硬件限制：</p><ol><li>它是为差速驱动的轮式机器人设计的。它假设底盘受到理想的运动命令的控制并可实现预期的结果，命令的格式为：x速度分量，y速度分量，$\theta$分量</li><li>它需要在底盘上安装一个单线激光雷达，这个激光雷达用于构建地图和定位</li><li>导航功能包集是为正方形的机器人开发的，所以<font color='Violetred'>方形或圆形的机器人将是性能最好的</font>。 它也可以工作在任意形状和大小的机器人上，但是较大的机器人将很难通过狭窄的空间</li></ol><p><strong>软件</strong></p><p>在仿真环境下，机器人可以正常接收 &#x2F;cmd_vel 消息，并发布里程计消息，传感器消息发布也正常，也即导航模块中的运动控制和环境感知实现完毕</p><p>主要关注于: 使用 SLAM 绘制地图、地图服务、自身定位与路径规划</p><h3 id="导航实现"><a href="#导航实现" class="headerlink" title="导航实现"></a>导航实现</h3><p><strong>准备工作</strong></p><p>先安装相关的ROS功能包：</p><ul><li><p>安装 gmapping 包(用于构建地图)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-gmapping</span><br></pre></td></tr></table></figure></li><li><p>安装地图服务包(用于保存与读取地图)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-map-server</span><br></pre></td></tr></table></figure></li><li><p>安装 navigation 包(用于定位以及路径规划)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-navigation</span><br></pre></td></tr></table></figure></li></ul><p>安装map-server时会出现错误，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是</span><br><span class="line">因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件</span><br><span class="line">包尚未被创建或是它们已被从新到(Incoming)目录移出。</span><br><span class="line">下列信息可能会对解决问题有所帮助：</span><br><span class="line"></span><br><span class="line">下列软件包有未满足的依赖关系：</span><br><span class="line"> ros-noetic-map-server : 依赖: libsdl-image1.2-dev 但是它将不会被安装</span><br><span class="line">                         依赖: libsdl1.2-dev 但是它将不会被安装</span><br><span class="line">E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系</span><br></pre></td></tr></table></figure><p>需要通过降级兼容，安装 <code>aptitude</code> 工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install aptitude</span><br><span class="line">sudo aptitude install libsdl-image1.2-dev libsdl1.2-dev</span><br></pre></td></tr></table></figure><blockquote><p>选择 n y y</p><p>参考文章：<a href="https://blog.csdn.net/2301_78615366/article/details/135299929">ROS安装软件包有未满足的依赖关系应如何解决</a></p></blockquote><p>新建功能包，并导入依赖: gmapping map_server amcl move_base</p><blockquote><p>因为不需要编码，roscpp rospy可以不导入</p></blockquote><h4 id="SLAM建图"><a href="#SLAM建图" class="headerlink" title="SLAM建图"></a>SLAM建图</h4><p>SLAM算法有多种，当前选用gmapping</p><p>gmapping可以根据移动机器人里程计数据和激光雷达数据来绘制二维的栅格地图</p><p>gmapping 功能包中的核心节点是 slam_gmapping</p><p><strong>节点内容</strong></p><p>订阅的Topic：</p><ul><li>tf (tf&#x2F;tfMessage) ：用于雷达、底盘与里程计之间的坐标变换消息</li><li>scan(sensor_msgs&#x2F;LaserScan)：SLAM所需的雷达信息</li></ul><p>发布的Topic：</p><ul><li>map_metadata(nav_msgs&#x2F;MapMetaData)：地图元数据，包括地图的宽度、高度、分辨率等，该消息会固定更新</li><li>map(nav_msgs&#x2F;OccupancyGrid)：地图栅格数据，一般会在rviz中以图形化的方式显示</li><li>~entropy(std_msgs&#x2F;Float64)：机器人姿态分布熵估计(值越大，不确定性越大)</li></ul><blockquote><p>注意，~代表私有，具体见基础知识部分的名称重名</p></blockquote><p>服务：</p><ul><li>dynamic_map(nav_msgs&#x2F;GetMap)：用于获取地图数据</li></ul><p>参数（参数较多，下面是几个较为常用的参数）：</p><ul><li>~base_frame(string, default:”base_link”)：机器人基坐标系</li><li>~map_frame(string, default:”map”)：地图坐标系</li><li>~odom_frame(string, default:”odom”)：里程计坐标系</li><li>~map_update_interval(float, default: 5.0)：地图更新频率，根据指定的值设计更新间隔</li><li>~maxUrange(float, default: 80.0)：激光探测的最大可用范围(超出此阈值，被截断)</li><li>~maxRange(float)：激光探测的最大范围</li></ul><p>所需的坐标变换：</p><ul><li>雷达坐标系→基坐标系：一般由 robot_state_publisher 或 static_transform_publisher 发布</li><li>基坐标系→里程计坐标系：一般由里程计节点发布</li></ul><p>发布的坐标变换：</p><ul><li>地图坐标系→里程计坐标系</li></ul><p><strong>gmapping使用</strong></p><p>launch文件：(直接复制)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 仿真环境下value设为true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- gmapping节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gmapping&quot;</span> <span class="attr">type</span>=<span class="string">&quot;slam_gmapping&quot;</span> <span class="attr">name</span>=<span class="string">&quot;slam_gmapping&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置雷达话题 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;scan&quot;</span> <span class="attr">to</span>=<span class="string">&quot;scan&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置关键参数:坐标系 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_footprint&quot;</span>/&gt;</span><span class="comment">&lt;!--底盘坐标系--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;map&quot;</span>/&gt;</span> <span class="comment">&lt;!--地图坐标系--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;odom&quot;</span>/&gt;</span> <span class="comment">&lt;!--里程计坐标系--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;map_update_interval&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;maxUrange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;16.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sigma&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;kernelSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;lstep&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;astep&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;iterations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;lsigma&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.075&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ogain&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;lskip&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;srr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;srt&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;stt&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;linearUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;angularUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;temporalUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;resampleThreshold&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;particles&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;xmin&quot;</span> <span class="attr">value</span>=<span class="string">&quot;-50.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ymin&quot;</span> <span class="attr">value</span>=<span class="string">&quot;-50.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;xmax&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ymax&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;delta&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;llsamplerange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.01&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;llsamplestep&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.01&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;lasamplerange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.005&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;lasamplestep&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.005&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以保存 rviz 配置并后期直接使用--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $(find nav_demo)/config/nav.rviz&quot;/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动过程：</p><ol><li>先启动 Gazebo 仿真环境</li><li>然后再启动地图绘制的 launch 文件</li><li>启动键盘键盘控制节点，用于控制机器人运动建图</li><li>在 rviz 中添加组件，显示栅格地图</li></ol><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/slam演示.webp" alt="slam演示" style="zoom:50%;" /><p>可以通过键盘控制gazebo中的机器人运动</p><p>机器人跑一圈会获得完整地图数据</p><p>接下来要保存地图，编写一个launch文件，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;filename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find nav_demo)/map/nav&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;map_save&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map_saver&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-f $(arg filename)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SLAM建图完毕后，执行该launch文件即可</p><p>在指定路径下会生成两个文件，xxx.pgm 与 xxx.yaml</p><p>xxx.pgm 本质是一张图片，直接使用图片查看程序即可打开</p><p>xxx.yaml 保存的是地图的元数据信息，用于描述图片</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明图片路径,图片也可以根据需求编辑</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">/home/ros/demo05_ws/src/nav_demo/map/nav.pgm</span></span><br><span class="line"><span class="comment"># 地图刻度尺 米/每像素</span></span><br><span class="line"><span class="attr">resolution:</span> <span class="number">0.050000</span></span><br><span class="line"><span class="comment"># 地图位姿信息(相对于rviz原点,x,y,偏航角)</span></span><br><span class="line"><span class="attr">origin:</span> [<span class="number">-50.000000</span>, <span class="number">-50.000000</span>, <span class="number">0.000000</span>]</span><br><span class="line"><span class="comment"># 白色是可通行区域，黑色是障碍物，蓝灰是未知区域</span></span><br><span class="line"><span class="comment"># 占用阈值</span></span><br><span class="line"><span class="attr">occupied_thresh:</span> <span class="number">0.65</span></span><br><span class="line"><span class="comment"># 空闲阈值</span></span><br><span class="line"><span class="attr">free_thresh:</span> <span class="number">0.196</span></span><br><span class="line"><span class="comment"># 二者结合用于判断是不是障碍物</span></span><br><span class="line"><span class="comment"># 取反</span></span><br><span class="line"><span class="attr">negate:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>map_server 中障碍物计算规则：</p><ol><li><p>地图中的每一个像素取值在 [0,255] 之间，白色为 255，黑色为 0，该值设为 x；</p></li><li><p>map_server 会将像素值作为判断是否是障碍物的依据，首先计算比例：p &#x3D; (255 - x) &#x2F; 255.0，白色为0，黑色为1</p><blockquote><p>negate为true，则p &#x3D; x &#x2F; 255.0</p></blockquote></li><li><p>根据步骤2计算的比例判断是否是障碍物，如果 p &gt; occupied_thresh 那么视为障碍物，如果 p &lt; free_thresh 那么视为无物</p></li></ol><h4 id="地图服务"><a href="#地图服务" class="headerlink" title="地图服务"></a>地图服务</h4><p><strong>map_server节点</strong></p><p>发布话题：</p><ul><li>map_metadata（nav_msgs &#x2F; MapMetaData）：发布地图元数据</li><li>map（nav_msgs &#x2F; OccupancyGrid）：地图数据</li></ul><p>服务：</p><ul><li>static_map（nav_msgs &#x2F; GetMap）：通过此服务获取地图</li></ul><p>参数：</p><ul><li>〜frame_id（字符串，默认值：“map”）：地图坐标系</li></ul><p>通过 map_server 的 map_server 节点可以读取栅格地图数据，编写 launch 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置地图的配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span> <span class="attr">default</span>=<span class="string">&quot;nav.yaml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运行地图服务器，并且加载设置的地图--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">args</span>=<span class="string">&quot;$(find nav_demo)/map/$(arg map)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行该launch文件，该节点会发布话题：map(nav_msgs&#x2F;OccupancyGrid)</p><p>在 rviz 中使用 map 组件可以显示栅格地图</p><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>SLAM中也包含定位算法实现，不过SLAM的定位是用于构建全局地图的，是属于导航开始之前的阶段</p><p>当前定位是用于导航中，机器人需要按照设定的路线运动，通过定位可以判断机器人的实际轨迹是否符合预期</p><p>AMCL(adaptive Monte Carlo Localization) 是用于2D移动机器人的概率定位系统，它实现了自适应（或KLD采样）蒙特卡洛定位方法，可以根据已有地图使用粒子滤波器推算机器人位置</p><p>amcl已经被集成到了navigation包</p><p>订阅的Topic：</p><ul><li><p>scan(sensor_msgs&#x2F;LaserScan)：激光雷达数据</p></li><li><p>tf(tf&#x2F;tfMessage)：坐标变换消息</p></li><li><p>initialpose(geometry_msgs&#x2F;PoseWithCovarianceStamped)：用来初始化粒子滤波器的均值和协方差</p></li><li><p>map(nav_msgs&#x2F;OccupancyGrid)：获取地图数据</p></li></ul><p>发布的Topic：</p><ul><li><p>amcl_pose(geometry_msgs&#x2F;PoseWithCovarianceStamped)：机器人在地图中的位姿估计</p></li><li><p>particlecloud(geometry_msgs&#x2F;PoseArray)：位姿估计集合，rviz中可以被 PoseArray 订阅然后图形化显示机器人的位姿估计集合。</p></li><li><p>tf(tf&#x2F;tfMessage)：发布从 odom 到 map 的转换</p></li></ul><p>服务：</p><ul><li><p>global_localization(std_srvs&#x2F;Empty)：初始化全局定位的服务</p></li><li><p>request_nomotion_update(std_srvs&#x2F;Empty)：手动执行更新和发布更新的粒子的服务</p></li><li><p>set_map(nav_msgs&#x2F;SetMap)：手动设置新地图和姿态的服务</p></li></ul><p>调用的服务：</p><ul><li>static_map(nav_msgs&#x2F;GetMap)：调用此服务获取地图数据</li></ul><p>参数：</p><ul><li><p>~odom_model_type(string, default:”diff”)：里程计模型选择”diff”,”omni”,”diff-corrected”,”omni-corrected” (diff 差速、omni 全向轮)</p></li><li><p>~odom_frame_id(string, default:”odom”)：里程计坐标系</p></li><li><p>~base_frame_id(string, default:”base_link”)：机器人坐标系</p></li><li><p>~global_frame_id(string, default:”map”)：地图坐标系</p></li></ul><p>里程计本身也是可以协助机器人定位的，不过里程计存在累计误差且一些特殊情况时(车轮打滑)会出现定位错误的情况</p><p>amcl 则可以通过估算机器人在地图坐标系下的姿态，再结合里程计提高定位准确度</p><p><strong>编写amcl节点相关的launch文件</strong></p><p>找到amcl功能包的example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscd amcl</span><br><span class="line">ls examples/</span><br><span class="line">gedit examples/amcl_diff.launch</span><br></pre></td></tr></table></figure><p>修改案例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;amcl&quot;</span> <span class="attr">type</span>=<span class="string">&quot;amcl&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amcl&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Publish scans from best pose at a max of 10 Hz --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_model_type&quot;</span> <span class="attr">value</span>=<span class="string">&quot;diff&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha5&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;gui_publish_rate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_max_beams&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;min_particles&quot;</span> <span class="attr">value</span>=<span class="string">&quot;500&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_particles&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;kld_err&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;kld_z&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.99&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- translation std dev, m --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha3&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_alpha4&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_hit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_short&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_z_rand&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_sigma_hit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_lambda_short&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_model_type&quot;</span> <span class="attr">value</span>=<span class="string">&quot;likelihood_field&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;param name=&quot;laser_model_type&quot; value=&quot;beam&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;laser_likelihood_max_dist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_min_d&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;update_min_a&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 里程计坐标系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_frame_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;odom&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置机器人坐标系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_frame_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_footprint&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 地图坐标系默认,不写 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;resample_interval&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;transform_tolerance&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;recovery_alpha_slow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;recovery_alpha_fast&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写测试launch文件</p><p>amcl节点是不可以单独运行的，运行 amcl 节点之前，需要先加载全局地图，然后启动 rviz 显示定位结果，上述节点可以集成进launch文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动rviz --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动地图服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/launch/nav03_map_server.launch&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- amcl --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/launch/nav04_amcl.launch&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行：</p><ol><li>先启动 Gazebo 仿真环境</li><li>启动键盘控制节点</li><li>启动集成地图服务、amcl 与 rviz 的 launch 文件</li><li>在启动的 rviz 中，添加RobotModel、Map组件，分别显示机器人模型与地图，添加 posearray 插件，设置topic为particlecloud来显示 amcl 预估的当前机器人的位姿，箭头越是密集，说明当前机器人处于此位置的概率越高</li><li>通过键盘控制机器人运动，会发现 posearray 也随之而改变</li></ol><h4 id="路径规划"><a href="#路径规划" class="headerlink" title="路径规划"></a>路径规划</h4><p>在ROS的导航功能包集navigation中提供了 move_base 功能包，用于实现此功能，包在之前已经安装</p><p>move_base 功能包提供了基于<font color='Violetred'>动作(action)</font>的路径规划实现，move_base 可以根据给定的目标点，控制机器人底盘运动至目标位置，并且在运动过程中会连续反馈机器人自身的姿态与目标点的状态信息</p><blockquote><p>Actions 是一种客户端&#x2F;服务器 (Client&#x2F;Server) 模式的通信方式，专为<strong>长时间运行、可抢占的任务</strong>而设计，并提供<strong>进度反馈</strong>和<strong>结果</strong></p><p>Actions 实际上是建立在 Topics 和 Services (服务) 之上的更高级别的抽象</p></blockquote><p>move_base主要由全局路径规划与本地路径规划组成</p><p>move_base功能包中的核心节点是：move_base</p><p>动作订阅：</p><ul><li><p>move_base&#x2F;goal(move_base_msgs&#x2F;MoveBaseActionGoal)：move_base 的运动规划目标</p></li><li><p>move_base&#x2F;cancel(actionlib_msgs&#x2F;GoalID)：取消目标</p></li></ul><p>动作发布：</p><ul><li><p>move_base&#x2F;feedback(move_base_msgs&#x2F;MoveBaseActionFeedback)：连续反馈的信息，包含机器人底盘坐标</p></li><li><p>move_base&#x2F;status(actionlib_msgs&#x2F;GoalStatusArray)：发送到move_base的目标状态信息</p></li><li><p>move_base&#x2F;result(move_base_msgs&#x2F;MoveBaseActionResult)：操作结果(此处为空)</p></li></ul><p>订阅的Topic：</p><ul><li>move_base_simple&#x2F;goal(geometry_msgs&#x2F;PoseStamped)：运动规划目标(与action相比，没有连续反馈，无法追踪机器人执行状态)</li></ul><p>发布的Topic：</p><ul><li>cmd_vel(geometry_msgs&#x2F;Twist)：输出到机器人底盘的运动控制消息</li></ul><p>服务：</p><ul><li><p>~make_plan(nav_msgs&#x2F;GetPlan)：请求该服务，可以获取给定目标的规划路径，但是并不执行该路径规划</p></li><li><p>~clear_unknown_space(std_srvs&#x2F;Empty)：允许用户直接清除机器人周围的未知空间</p></li><li><p>~clear_costmaps(std_srvs&#x2F;Empty)：允许清除代价地图中的障碍物，可能会导致机器人与障碍物碰撞，请慎用</p></li></ul><h5 id="代价地图"><a href="#代价地图" class="headerlink" title="代价地图"></a>代价地图</h5><p>ROS中的地图其实就是一张图片，这张图片有宽度、高度、分辨率等元数据，在图片中使用灰度值来表示障碍物存在的概率</p><p>SLAM构建的地图在导航中是不可以直接使用的：</p><ol><li>SLAM构建的地图是静态地图，而导航过程中，障碍物信息是可变的，导航中需要时时获取障碍物信息；</li><li>在靠近障碍物边缘时，机器人可能由于惯性、不规则形体会与障碍物产生碰撞，所以最好在地图的障碍物边缘设置警戒区</li></ol><p>因此静态地图无法直接应用于导航，其基础之上需要添加一些辅助信息的地图</p><p><strong>组成</strong></p><p>代价地图有两张：global_costmap(全局代价地图) 和 local_costmap(本地代价地图)，前者用于全局路径规划，后者用于本地路径规划</p><p>两张代价地图都可以多层叠加：</p><ol><li>静态地图层，SLAM构建的静态地图</li><li>障碍地图层，传感器感知的障碍物信息</li><li>膨胀层，在以上两层地图上进行膨胀（向外扩张），以避免机器人的外壳会撞上障碍物</li><li>自定义层，根据业务自设计的地图数据</li></ol><p><strong>碰撞算法</strong></p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/碰撞算法.webp" alt="碰撞算法" style="zoom:50%;" /><p>上图中，横轴是距离机器人中心的距离，纵轴是代价地图中栅格的灰度值</p><ul><li>致命障碍：栅格值为254，此时障碍物与机器人中心重叠，必然发生碰撞；</li><li>内切障碍：栅格值为253，此时障碍物处于机器人的内切圆内，必然发生碰撞；</li><li>外切障碍：栅格值为[128,252]，此时障碍物处于其机器人的外切圆内，处于碰撞临界，不一定发生碰撞；</li><li>非自由空间：栅格值为(0,127]，此时机器人处于障碍物附近，属于危险警戒区，进入此区域，将来可能会发生碰撞；</li><li>自由区域：栅格值为0，此处机器人可以自由通过；</li><li>未知区域：栅格值为255，还没探明是否有障碍物</li></ul><h5 id="move-base使用"><a href="#move-base使用" class="headerlink" title="move_base使用"></a>move_base使用</h5><p><strong>launch文件模板</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;move_base&quot;</span> <span class="attr">type</span>=<span class="string">&quot;move_base&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">name</span>=<span class="string">&quot;move_base&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> <span class="attr">clear_params</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- costmap_common_params.yaml 加载到两个空间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/param/costmap_common_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;global_costmap&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/param/costmap_common_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;local_costmap&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/param/local_costmap_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/param/global_costmap_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/param/base_local_planner_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动了 move_base 功能包下的 move_base 节点，respawn 为 false，意味着该节点关闭后，不会被重启；</p><p>clear_params 为 true，意味着每次启动该节点都要清空私有参数然后重新载入；</p><p><strong>配置文件</strong></p><p>关于配置文件的编写，可以参考一些成熟的机器人的路径规划实现</p><p><a href="https://github.com/ROBOTIS-GIT/turtlebot3">ROBOTIS-GIT&#x2F;turtlebot3: ROS packages for Turtlebot3</a></p><p><font color='Violetred'>costmap_common_params.yaml</font></p><p>该文件是move_base 在全局路径规划与本地路径规划时调用的通用参数，包括：机器人的尺寸、距离障碍物的安全距离、传感器信息等</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器人几何参，如果机器人是圆形，设置 robot_radius,如果是其他形状设置 footprint</span></span><br><span class="line"><span class="attr">robot_radius:</span> <span class="number">0.12</span> <span class="comment">#圆形</span></span><br><span class="line"><span class="comment"># footprint: [[-0.12, -0.12], [-0.12, 0.12], [0.12, 0.12], [0.12, -0.12]] #案例是方形，四个点的坐标</span></span><br><span class="line"></span><br><span class="line"><span class="attr">obstacle_range:</span> <span class="number">3.0</span> <span class="comment"># 用于障碍物探测，比如: 值为 3.0，意味着检测到距离小于 3 米的障碍物时，就会引入代价地图</span></span><br><span class="line"><span class="attr">raytrace_range:</span> <span class="number">3.5</span> <span class="comment"># 用于清除障碍物，比如：值为 3.5，意味着清除代价地图中 3.5 米以外的障碍物</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#膨胀半径，扩展在碰撞区域以外的代价区域，使得机器人规划路径避开障碍物</span></span><br><span class="line"><span class="attr">inflation_radius:</span> <span class="number">0.2</span></span><br><span class="line"><span class="comment">#代价比例系数，越大则代价值越小</span></span><br><span class="line"><span class="attr">cost_scaling_factor:</span> <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#地图类型</span></span><br><span class="line"><span class="attr">map_type:</span> <span class="string">costmap</span></span><br><span class="line"><span class="comment">#导航包所需要的传感器</span></span><br><span class="line"><span class="attr">observation_sources:</span> <span class="string">scan</span></span><br><span class="line"><span class="comment">#对传感器的坐标系和数据进行配置。这个也会用于代价地图添加和清除障碍物。例如，你可以用激光雷达传感器用于在代价地图添加障碍物，再添加kinect用于导航和清除障碍物。</span></span><br><span class="line"><span class="attr">scan:</span> &#123;<span class="attr">sensor_frame:</span> <span class="string">laser</span>, <span class="attr">data_type:</span> <span class="string">LaserScan</span>, <span class="attr">topic:</span> <span class="string">scan</span>, <span class="attr">marking:</span> <span class="literal">true</span>, <span class="attr">clearing:</span> <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>global_costmap_params.yaml</p><p>该文件用于全局代价地图参数设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global_costmap:</span></span><br><span class="line">  <span class="attr">global_frame:</span> <span class="string">map</span> <span class="comment">#地图坐标系</span></span><br><span class="line">  <span class="attr">robot_base_frame:</span> <span class="string">base_footprint</span> <span class="comment">#机器人坐标系</span></span><br><span class="line">  <span class="comment"># 以此实现坐标变换</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">update_frequency:</span> <span class="number">1.0</span> <span class="comment">#代价地图更新频率，全局地图频率不会太高</span></span><br><span class="line">  <span class="attr">publish_frequency:</span> <span class="number">1.0</span> <span class="comment">#代价地图的发布频率</span></span><br><span class="line">  <span class="attr">transform_tolerance:</span> <span class="number">0.5</span> <span class="comment">#等待坐标变换发布信息的超时时间，一般不大于0.5</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">static_map:</span> <span class="literal">true</span> <span class="comment"># 是否使用一个地图或者地图服务器来初始化全局代价地图，如果不使用静态地图，这个参数为false.</span></span><br></pre></td></tr></table></figure><p>local_costmap_params.yaml</p><p>该文件用于局部代价地图参数设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_costmap:</span></span><br><span class="line">  <span class="attr">global_frame:</span> <span class="string">odom</span> <span class="comment">#里程计坐标系</span></span><br><span class="line">  <span class="attr">robot_base_frame:</span> <span class="string">base_footprint</span> <span class="comment">#机器人坐标系</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">update_frequency:</span> <span class="number">10.0</span> <span class="comment">#代价地图更新频率，局部地图要大一些</span></span><br><span class="line">  <span class="attr">publish_frequency:</span> <span class="number">10.0</span> <span class="comment">#代价地图的发布频率</span></span><br><span class="line">  <span class="attr">transform_tolerance:</span> <span class="number">0.5</span> <span class="comment">#等待坐标变换发布信息的超时时间</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">static_map:</span> <span class="literal">false</span>  <span class="comment">#不需要静态地图，可以提升导航效果</span></span><br><span class="line">  <span class="attr">rolling_window:</span> <span class="literal">true</span> <span class="comment">#是否使用动态窗口，默认为false，在静态的全局地图中，地图不会变化</span></span><br><span class="line">  <span class="attr">width:</span> <span class="number">3</span> <span class="comment"># 局部地图宽度 单位是 m</span></span><br><span class="line">  <span class="attr">height:</span> <span class="number">3</span> <span class="comment"># 局部地图高度 单位是 m</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="number">0.05</span> <span class="comment"># 局部地图分辨率 单位是 m，一般与静态地图分辨率保持一致</span></span><br></pre></td></tr></table></figure><p>base_local_planner_params</p><p>基本的局部规划器参数配置，这个配置文件设定了机器人的最大和最小速度限制值，也设定了加速度的阈值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TrajectoryPlannerROS:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Robot Configuration Parameters</span></span><br><span class="line">  <span class="attr">max_vel_x:</span> <span class="number">0.5</span> <span class="comment"># X 方向最大速度</span></span><br><span class="line">  <span class="attr">min_vel_x:</span> <span class="number">0.1</span> <span class="comment"># X 方向最小速速</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">max_vel_theta:</span>  <span class="number">1.0</span> <span class="comment"># 角速度</span></span><br><span class="line">  <span class="attr">min_vel_theta:</span> <span class="number">-1.0</span></span><br><span class="line">  <span class="attr">min_in_place_vel_theta:</span> <span class="number">1.0</span> <span class="comment"># 原地旋转角速度</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">acc_lim_x:</span> <span class="number">1.0</span> <span class="comment"># X 加速限制</span></span><br><span class="line">  <span class="attr">acc_lim_y:</span> <span class="number">0.0</span> <span class="comment"># Y 加速限制</span></span><br><span class="line">  <span class="attr">acc_lim_theta:</span> <span class="number">0.6</span> <span class="comment"># 角速度加速限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Goal Tolerance Parameters，目标公差</span></span><br><span class="line">  <span class="attr">xy_goal_tolerance:</span> <span class="number">0.10</span></span><br><span class="line">  <span class="attr">yaw_goal_tolerance:</span> <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Differential-drive robot configuration</span></span><br><span class="line"><span class="comment"># 是否是全向移动机器人</span></span><br><span class="line">  <span class="attr">holonomic_robot:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Forward Simulation Parameters，前进模拟参数</span></span><br><span class="line">  <span class="attr">sim_time:</span> <span class="number">0.8</span> <span class="comment"># 大一些会让局部路径规划贴近全局</span></span><br><span class="line">  <span class="attr">vx_samples:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">vtheta_samples:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">sim_granularity:</span> <span class="number">0.05</span></span><br></pre></td></tr></table></figure><p>以上配置在实操中，可能会出现机器人在本地路径规划时与全局路径规划不符而进入膨胀区域出现假死的情况，如何尽量避免这种情形呢？</p><p>可以采用不同的参数设置策略:</p><ul><li>全局代价地图可以将膨胀半径和障碍物系数设置的偏大一些</li><li>本地代价地图可以将膨胀半径和障碍物系数设置的偏小一些</li></ul><p>这样，在全局路径规划时，规划的路径会尽量远离障碍物，而本地路径规划时，机器人即便偏离全局路径也会和障碍物之间保留更大的自由空间，从而避免了陷入“假死”的情形</p><p><strong>launch文件集成</strong></p><p>如果要实现导航，需要集成地图服务、amcl 、move_base 与 Rviz 等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 地图服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/launch/nav03_map_server.launch&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动AMCL节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/launch/nav04_amcl.launch&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运行move_base节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/launch/nav05_path.launch&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运行rviz --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.先启动 Gazebo 仿真环境(此过程略)；</p><p>2.启动导航相关的 launch 文件；</p><p>3.添加Rviz组件(参考演示结果),可以将配置数据保存，后期直接调用；</p><p>全局代价地图与本地代价地图组件配置如下：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/rviz代价地图.webp" alt="rviz代价地图" style="zoom: 67%;" /><p>全局路径规划与本地路径规划组件配置如下：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/rviz路径规划.webp" alt="rviz路径规划" style="zoom:67%;" /><p>4.通过Rviz工具栏的 2D Nav Goal设置目的地实现导航</p><p>5.可以在导航过程中，添加新的障碍物，机器人也可以自动躲避障碍物</p><h4 id="导航与SLAM建图"><a href="#导航与SLAM建图" class="headerlink" title="导航与SLAM建图"></a>导航与SLAM建图</h4><p>在SLAM建图中是通过键盘控制来实现的，现在想结合自主移动来实现建图</p><p>之前导航实现时，是通过 map_server 包的 map_server 节点来发布地图信息的，如果不先通过SLAM建图，那么如何发布地图信息呢？</p><p>SLAM建图过程中本身就会时时发布地图信息，所以无需再使用map_server，且导航需要定位模块，SLAM本身也是可以实现定位的</p><p>launch文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 集成SLAM与导航,实现自主移动的地图构建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SLAM实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/launch/nav01_slam.launch&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导航move_base --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find nav_demo)/launch/nav05_path.launch&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.首先运行gazebo仿真环境；</p><p>2.然后执行launch文件；</p><p>3.在rviz中通过2D Nav Goal设置目标点，机器人开始自主移动并建图了；</p><p>4.最后可以使用 map_server 保存地图</p><h3 id="导航相关消息"><a href="#导航相关消息" class="headerlink" title="导航相关消息"></a>导航相关消息</h3><p>在上一节的实现中，这些消息已经在rviz中做了可视化处理，比如：地图、雷达、摄像头、里程计、路径规划…的相关消息在rviz中提供了相关组件，本节主要介绍这些消息的具体格式</p><h4 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h4><p>地图相关的消息主要有两个：</p><ul><li><p>nav_msgs&#x2F;MapMetaData：地图元数据，包括地图的宽度、高度、分辨率等。</p></li><li><p>nav_msgs&#x2F;OccupancyGrid：地图栅格数据，一般会在rviz中以图形化的方式显示</p></li></ul><p><strong>nav_msgs&#x2F;MapMetaData</strong></p><p>调用<code>rosmsg info nav_msgs/MapMetaData</code>显示消息内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">time map_load_time</span><br><span class="line">float32 resolution #地图分辨率</span><br><span class="line">uint32 width #地图宽度</span><br><span class="line">uint32 height #地图高度</span><br><span class="line">geometry_msgs/Pose origin #地图位姿数据</span><br><span class="line">  geometry_msgs/Point position</span><br><span class="line">    float64 x</span><br><span class="line">    float64 y</span><br><span class="line">    float64 z</span><br><span class="line">  geometry_msgs/Quaternion orientation</span><br><span class="line">    float64 x</span><br><span class="line">    float64 y</span><br><span class="line">    float64 z</span><br><span class="line">    float64 w</span><br></pre></td></tr></table></figure><p>在地图数据中，未知区域为-1，白色为 255，黑色为 0，map_server 会将像素值作为判断是否是障碍物的依据</p><p><strong>nav_msgs&#x2F;OccupancyGrid</strong></p><p>调用 <code>rosmsg info nav_msgs/OccupancyGrid</code>显示消息内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">#--- 地图元数据</span><br><span class="line">nav_msgs/MapMetaData info</span><br><span class="line">  time map_load_time</span><br><span class="line">  float32 resolution</span><br><span class="line">  uint32 width</span><br><span class="line">  uint32 height</span><br><span class="line">  geometry_msgs/Pose origin</span><br><span class="line">    geometry_msgs/Point position</span><br><span class="line">      float64 x</span><br><span class="line">      float64 y</span><br><span class="line">      float64 z</span><br><span class="line">    geometry_msgs/Quaternion orientation</span><br><span class="line">      float64 x</span><br><span class="line">      float64 y</span><br><span class="line">      float64 z</span><br><span class="line">      float64 w</span><br><span class="line">#--- 地图内容数据，数组长度 = width * height</span><br><span class="line">int8[] data</span><br></pre></td></tr></table></figure><p>值为0-100，判断风险，未知和空闲区域都为0</p><h4 id="里程计"><a href="#里程计" class="headerlink" title="里程计"></a>里程计</h4><p>里程计相关消息是:nav_msgs&#x2F;Odometry，调用<code>rosmsg info nav_msgs/Odometry</code> 显示消息内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">string child_frame_id</span><br><span class="line">geometry_msgs/PoseWithCovariance pose</span><br><span class="line">  geometry_msgs/Pose pose #里程计位姿</span><br><span class="line">    geometry_msgs/Point position</span><br><span class="line">      float64 x</span><br><span class="line">      float64 y</span><br><span class="line">      float64 z</span><br><span class="line">    geometry_msgs/Quaternion orientation</span><br><span class="line">      float64 x</span><br><span class="line">      float64 y</span><br><span class="line">      float64 z</span><br><span class="line">      float64 w</span><br><span class="line">  float64[36] covariance</span><br><span class="line">geometry_msgs/TwistWithCovariance twist</span><br><span class="line">  geometry_msgs/Twist twist #速度</span><br><span class="line">    geometry_msgs/Vector3 linear</span><br><span class="line">      float64 x</span><br><span class="line">      float64 y</span><br><span class="line">      float64 z</span><br><span class="line">    geometry_msgs/Vector3 angular</span><br><span class="line">      float64 x</span><br><span class="line">      float64 y</span><br><span class="line">      float64 z    </span><br><span class="line">  # 协方差矩阵</span><br><span class="line">  float64[36] covariance</span><br></pre></td></tr></table></figure><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>坐标变换相关消息是: tf&#x2F;tfMessage，调用<code>rosmsg info tf/tfMessage</code> 显示消息内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/TransformStamped[] transforms #包含了多个坐标系相对关系数据的数组</span><br><span class="line">  std_msgs/Header header</span><br><span class="line">    uint32 seq</span><br><span class="line">    time stamp</span><br><span class="line">    string frame_id</span><br><span class="line">  string child_frame_id</span><br><span class="line">  geometry_msgs/Transform transform</span><br><span class="line">    geometry_msgs/Vector3 translation</span><br><span class="line">      float64 x</span><br><span class="line">      float64 y</span><br><span class="line">      float64 z</span><br><span class="line">    geometry_msgs/Quaternion rotation</span><br><span class="line">      float64 x</span><br><span class="line">      float64 y</span><br><span class="line">      float64 z</span><br><span class="line">      float64 w</span><br></pre></td></tr></table></figure><h4 id="定位-1"><a href="#定位-1" class="headerlink" title="定位"></a>定位</h4><p>定位相关消息是:geometry_msgs&#x2F;PoseArray，调用<code>rosmsg info geometry_msgs/PoseArray</code>显示消息内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">geometry_msgs/Pose[] poses #预估的点位姿组成的数组</span><br><span class="line">  geometry_msgs/Point position</span><br><span class="line">    float64 x</span><br><span class="line">    float64 y</span><br><span class="line">    float64 z</span><br><span class="line">  geometry_msgs/Quaternion orientation</span><br><span class="line">    float64 x</span><br><span class="line">    float64 y</span><br><span class="line">    float64 z</span><br><span class="line">    float64 w</span><br></pre></td></tr></table></figure><h4 id="目标点与路径规划"><a href="#目标点与路径规划" class="headerlink" title="目标点与路径规划"></a>目标点与路径规划</h4><p>目标点相关消息是:move_base_msgs&#x2F;MoveBaseActionGoal，调用<code>rosmsg info move_base_msgs/MoveBaseActionGoal</code>显示消息内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">actionlib_msgs/GoalID goal_id</span><br><span class="line">  time stamp</span><br><span class="line">  string id</span><br><span class="line">move_base_msgs/MoveBaseGoal goal</span><br><span class="line">  geometry_msgs/PoseStamped target_pose</span><br><span class="line">    std_msgs/Header header</span><br><span class="line">      uint32 seq</span><br><span class="line">      time stamp</span><br><span class="line">      string frame_id</span><br><span class="line">    geometry_msgs/Pose pose #目标点位姿</span><br><span class="line">      geometry_msgs/Point position</span><br><span class="line">        float64 x</span><br><span class="line">        float64 y</span><br><span class="line">        float64 z</span><br><span class="line">      geometry_msgs/Quaternion orientation</span><br><span class="line">        float64 x</span><br><span class="line">        float64 y</span><br><span class="line">        float64 z</span><br><span class="line">        float64 w</span><br></pre></td></tr></table></figure><p>路径规划相关消息是:nav_msgs&#x2F;Path，调用<code>rosmsg info nav_msgs/Path</code>显示消息内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">geometry_msgs/PoseStamped[] poses #由一系列点组成的数组</span><br><span class="line">  std_msgs/Header header</span><br><span class="line">    uint32 seq</span><br><span class="line">    time stamp</span><br><span class="line">    string frame_id</span><br><span class="line">  geometry_msgs/Pose pose</span><br><span class="line">    geometry_msgs/Point position</span><br><span class="line">      float64 x</span><br><span class="line">      float64 y</span><br><span class="line">      float64 z</span><br><span class="line">    geometry_msgs/Quaternion orientation</span><br><span class="line">      float64 x</span><br><span class="line">      float64 y</span><br><span class="line">      float64 z</span><br><span class="line">      float64 w</span><br></pre></td></tr></table></figure><h4 id="激光雷达"><a href="#激光雷达" class="headerlink" title="激光雷达"></a>激光雷达</h4><p>激光雷达相关消息是：sensor_msgs&#x2F;LaserScan，调用<code>rosmsg info sensor_msgs/LaserScan</code>显示消息内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">float32 angle_min #起始扫描角度(rad)</span><br><span class="line">float32 angle_max #终止扫描角度(rad)</span><br><span class="line">float32 angle_increment #测量值之间的角距离(rad)</span><br><span class="line">float32 time_increment #测量间隔时间(s)</span><br><span class="line">float32 scan_time #扫描间隔时间(s)</span><br><span class="line">float32 range_min #最小有效距离值(m)</span><br><span class="line">float32 range_max #最大有效距离值(m)</span><br><span class="line">float32[] ranges #一个周期的扫描数据</span><br><span class="line">float32[] intensities #扫描强度数据，如果设备不支持强度数据，该数组为空</span><br></pre></td></tr></table></figure><h4 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h4><p>深度相机相关消息有:sensor_msgs&#x2F;Image、sensor_msgs&#x2F;CompressedImage、sensor_msgs&#x2F;PointCloud2</p><p>sensor_msgs&#x2F;Image 对应的一般的图像数据</p><p>调用<code>rosmsg info sensor_msgs/Image</code>显示消息内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">uint32 height #高度</span><br><span class="line">uint32 width  #宽度</span><br><span class="line">string encoding #编码格式:RGB、YUV等</span><br><span class="line">uint8 is_bigendian #图像大小端存储模式</span><br><span class="line">uint32 step #一行图像数据的字节数，作为步进参数</span><br><span class="line">uint8[] data #图像数据，长度等于 step * height</span><br></pre></td></tr></table></figure><p>sensor_msgs&#x2F;CompressedImage 对应压缩后的图像数据</p><p>调用<code>rosmsg info sensor_msgs/CompressedImage</code>显示消息内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">string format #压缩编码格式(jpeg、png、bmp)</span><br><span class="line">uint8[] data #压缩后的数据</span><br></pre></td></tr></table></figure><p>sensor_msgs&#x2F;PointCloud2 对应的是点云数据(带有深度信息的图像数据)</p><p>调用<code>rosmsg info sensor_msgs/PointCloud2</code>显示消息内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">uint32 height #高度</span><br><span class="line">uint32 width  #宽度</span><br><span class="line">sensor_msgs/PointField[] fields #每个点的数据类型</span><br><span class="line">  uint8 INT8=1</span><br><span class="line">  uint8 UINT8=2</span><br><span class="line">  uint8 INT16=3</span><br><span class="line">  uint8 UINT16=4</span><br><span class="line">  uint8 INT32=5</span><br><span class="line">  uint8 UINT32=6</span><br><span class="line">  uint8 FLOAT32=7</span><br><span class="line">  uint8 FLOAT64=8</span><br><span class="line">  string name</span><br><span class="line">  uint32 offset</span><br><span class="line">  uint8 datatype</span><br><span class="line">  uint32 count</span><br><span class="line">bool is_bigendian #图像大小端存储模式</span><br><span class="line">uint32 point_step #单点的数据字节步长</span><br><span class="line">uint32 row_step   #一行数据的字节步长</span><br><span class="line">uint8[] data      #存储点云的数组，总长度为 row_step * height</span><br><span class="line">bool is_dense     #是否有无效点</span><br></pre></td></tr></table></figure><h4 id="深度图像转激光数据"><a href="#深度图像转激光数据" class="headerlink" title="深度图像转激光数据"></a>深度图像转激光数据</h4><p>在诸多SLAM算法中，一般都需要订阅激光雷达数据用于构建地图，因为激光雷达可以感知周围环境的深度信息</p><p>深度相机也具备感知深度信息的功能，且最初激光雷达价格比价比较昂贵，可以选用深度相机代替激光雷达</p><p>不过二者发布的消息类型是完全不同的，如果想要实现传感器的置换，那么就需要将深度相机发布的三维的图形信息转换成二维的激光雷达信息</p><p>这一功能就是通过depthimage_to_laserscan来实现的</p><p><strong>缺点</strong>：深度相机较之于激光雷达无论是检测范围还是精度都有不小的差距，SLAM效果可能不如激光雷达理想</p><p>安装包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-depthimage-to-laserscan</span><br></pre></td></tr></table></figure><p>但随着时间发展其实激光雷达价格已经下来了，这一节内容略</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🤖ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS基础知识</title>
      <link href="/posts/626062709.html"/>
      <url>/posts/626062709.html</url>
      
        <content type="html"><![CDATA[<p><font color='Violetred'>注意注意</font>：可以直接学习ROS2，不用从ROS开始</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>c++ 模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python 模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">rospy.init_node(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="ROS环境搭建与初认识"><a href="#ROS环境搭建与初认识" class="headerlink" title="ROS环境搭建与初认识"></a>ROS环境搭建与初认识</h2><h3 id="ROS安装"><a href="#ROS安装" class="headerlink" title="ROS安装"></a>ROS安装</h3><p>具体细节看教程 <a href="http://www.autolabor.com.cn/book/ROSTutorials/chapter1/12-roskai-fa-gong-ju-an-zhuang.html">1.2 ROS安装</a></p><p>采用虚拟机安装 ubuntu，再安装 ROS </p><p>虚拟机软件：<a href="https://www.virtualbox.org/wiki/Downloads">virtualbox(免费)</a>  官网下载软件安装包以及拓展包</p><p>ubuntu版本：ubuntu-20.04.6  <a href="https://mirrors.tuna.tsinghua.edu.cn/">镜像文件下载地址</a></p><p>在下载过程中可能需要修改软件与更新中的下载自(以后安装库的时候经常会碰上)</p><p>在虚拟机中如果出现右键没有反应的情况，按住shift再点</p><p>ROS版本：Noetic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><p>配置环境变量，方便在任意终端中使用 ROS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>安装构建依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</span><br></pre></td></tr></table></figure><p>测试ROS安装环境：</p><ol><li>启动三个命令行(ctrl + alt + T)</li><li>命令行1键入:<code>roscore</code></li><li>命令行2键入:<code>rosrun turtlesim turtlesim_node</code>(此时会弹出图形化界面)</li><li>命令行3键入:<code>rosrun turtlesim turtle_teleop_key</code>(可以控制小乌龟运动)</li></ol><p>以下命令行内容中[ ]包围的为替换内容</p><p>补充ubuntu创建右键快捷键方法：</p><ol><li>在用户主目录里找到“模板“文件夹</li><li>右键在终端打开，<code>sudo gedit 文本文件</code></li><li>保存，可在任何文件夹下创建文本文件了</li></ol><h3 id="ROS集成开发环境"><a href="#ROS集成开发环境" class="headerlink" title="ROS集成开发环境"></a>ROS集成开发环境</h3><p>在刚刚的过程会发现ubuntu频繁需要密码，打开terminal，输入seahorse，点击左上角➕号，新建一个空钥匙环，建立完成后设置为默认，打开一些软件不再提示输入密码了</p><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><p>在 ROS 中，需要频繁的使用到终端，且可能需要同时开启多个窗口，推荐使用<strong>Terminator</strong></p><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install terminator</span><br></pre></td></tr></table></figure><p>常用快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Alt+Up                          //移动到上面的终端</span><br><span class="line">Alt+Down                        //移动到下面的终端</span><br><span class="line">Alt+Left                        //移动到左边的终端</span><br><span class="line">Alt+Right                       //移动到右边的终端</span><br><span class="line">Ctrl+Shift+O                    //水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端</span><br></pre></td></tr></table></figure><h4 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h4><p>下载：<a href="https://code.visualstudio.com/docs?start=true%5B">vscode 下载</a>  选择适用于linux系统的.deb文件</p><p>安装：</p><ul><li>方式1：双击安装即可(或右击选择安装) [可能会出现没反应或闪退行为]</li><li>方式2：<code>sudo dpkg -i xxxx.deb</code> 复制具体的下载文件名称</li></ul><p>vscode 下载插件：c++，CMake，python，ROS</p><p>快捷键配置：向上向下复制行；向上向下移动</p><p>vscode 使用_基本配置：</p><ol><li><p>创建 ROS 工作空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p [工作空间名称]/src(必须得有 src)</span><br><span class="line">cd [工作空间名称]</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure></li><li><p>启动 vscode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure></li><li><p>vscode 中编译 ros</p><p>快捷键 ctrl + shift + B 调用编译，选择<code>catkin_make:build</code>右边的小齿轮配置</p><p>修改<code>.vscode/tasks.json </code>文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;catkin_make:debug&quot;</span><span class="punctuation">,</span> <span class="comment">//代表提示的描述性信息</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span>  <span class="comment">//可以选择shell或者process,如果是shell代码是在shell里面运行一个命令，如果是process代表作为一个进程来运行</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;catkin_make&quot;</span><span class="punctuation">,</span><span class="comment">//这个是我们需要运行的命令</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="comment">//如果需要在命令后面加一些后缀，可以写在这里，比如-DCATKIN_WHITELIST_PACKAGES=“pac1;pac2”</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span><span class="string">&quot;build&quot;</span><span class="punctuation">,</span><span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;reveal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span><span class="comment">//可选always或者silence，代表是否输出信息</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$msCompile&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>创建 ROS 功能包</p><p><font color='Violetred'>选定 src 右击 —&gt; create catkin package</font></p><p>设置包名(helloworld) 添加依赖(roscpp rospy std_msgs)</p></li><li><p>C++ 实现</p><p>在功能包的 src 下新建 cpp 文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 解决中文乱码</span></span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;hello_c&quot;</span>);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;hello vscode&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有代码提示</p><p>修改 <code>.vscode/c_cpp_properties.json</code>，设置 “cppStandard”: “c++17”</p><p>则ctrl+shift+空格提示函数格式</p></li><li><p>python 实现</p><p>在 功能包 下新建 scripts 文件夹，添加 python 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;hello_p&quot;</span>)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;hello vscode! it&#x27;s python&quot;</span>)</span><br></pre></td></tr></table></figure><p><font color='Violetred'>在scripts文件夹下打开终端</font>并添加可执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x *.py</span><br></pre></td></tr></table></figure></li><li><p>配置 CMakeLists.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_executable([自定义名称]</span><br><span class="line">  src/helloworld_c.cpp</span><br><span class="line">)</span><br><span class="line">target_link_libraries([自定义名称]</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">catkin_install_python(PROGRAMS scripts/[文件名].py</span><br><span class="line">  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>编译执行</p><p>编译：ctrl + shift + B</p><p>执行：在 VScode 中添加终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ./devel/setup.bash</span><br></pre></td></tr></table></figure><p>c++：rosrun [包名] [<font color='Violetred'>自定义名称</font>]</p><p>python：rosrun [包名] [<font color='Violetred'>文件名称</font>]</p><p>如果不编译直接执行 python 文件，会抛出异常</p><p>解决方案：</p><ol><li>第一行解释器声明，可以使用绝对路径定位到 python3 的安装路径 #! &#x2F;usr&#x2F;bin&#x2F;python3(不建议)</li><li>创建一个链接符号到 python 命令：<code>sudo ln -s /usr/bin/python3 /usr/bin/python</code>(建议)</li></ol></li></ol><h4 id="launch文件"><a href="#launch文件" class="headerlink" title="launch文件"></a>launch文件</h4><p>解决需要启动多个节点的效率问题</p><p>实现：</p><ol><li><p>选定功能包右击 —&gt; 添加 launch 文件夹</p></li><li><p>选定 launch 文件夹右击 —&gt; 添加 launch 文件</p></li><li><p>编辑 launch 文件内容</p><p>以小乌龟示例程序启动为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;!-- 乌龟GUI --&gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;turtle_GUI&quot; /&gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;turtle_key&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><ul><li>node —&gt; 包含的某个节点</li><li>pkg —–&gt; 功能包</li><li>type —-&gt; 被运行的节点文件</li><li>name –&gt; 为节点命名</li><li>output-&gt; 设置日志的输出目标</li></ul></li><li><p>运行 launch 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch [功能包名] [launch文件名]</span><br></pre></td></tr></table></figure></li><li><p>运行结果：一次性启动了多个节点</p></li></ol><h3 id="ROS架构"><a href="#ROS架构" class="headerlink" title="ROS架构"></a>ROS架构</h3><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/ROS_file.jpg" alt="ROS_file"  /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">WorkSpace --- 自定义的工作空间</span><br><span class="line"></span><br><span class="line">    |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。</span><br><span class="line"></span><br><span class="line">    |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;静态链接库、可执行文件等。</span><br><span class="line"></span><br><span class="line">    |--- src: 源码</span><br><span class="line"></span><br><span class="line">        |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成</span><br><span class="line"></span><br><span class="line">            |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件</span><br><span class="line"></span><br><span class="line">            |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml)</span><br><span class="line"></span><br><span class="line">            |-- scripts 存储python文件</span><br><span class="line"></span><br><span class="line">            |-- src 存储C++源文件</span><br><span class="line"></span><br><span class="line">            |-- include 头文件</span><br><span class="line"></span><br><span class="line">            |-- msg 消息通信格式文件</span><br><span class="line"></span><br><span class="line">            |-- srv 服务通信格式文件</span><br><span class="line"></span><br><span class="line">            |-- action 动作格式文件</span><br><span class="line"></span><br><span class="line">            |-- launch 可一次性运行多个节点 </span><br><span class="line"></span><br><span class="line">            |-- config 配置信息</span><br><span class="line"></span><br><span class="line">        |-- CMakeLists.txt: 编译的基本配置</span><br></pre></td></tr></table></figure><h4 id="文件系统相关命令"><a href="#文件系统相关命令" class="headerlink" title="文件系统相关命令"></a>文件系统相关命令</h4><ol><li><p>增</p><p>catkin_create_pkg 自定义包名 依赖包 &#x3D;&#x3D;&#x3D; 创建新的ROS功能包</p><p>sudo apt install xxx &#x3D;&#x3D;&#x3D; 安装 ROS功能包</p></li><li><p>删</p><p>sudo apt purge xxx &#x3D;&#x3D;&#x3D; 删除某个功能包</p></li><li><p>查</p><p>rospack list &#x3D;&#x3D;&#x3D; 列出所有功能包</p><p>rospack find 包名 &#x3D;&#x3D;&#x3D; 查找某个功能包是否存在，如果存在返回安装路径</p><p>roscd 包名 &#x3D;&#x3D;&#x3D; 进入某个功能包</p><p>rosls 包名 &#x3D;&#x3D;&#x3D; 列出某个包下的文件</p><p>apt search xxx &#x3D;&#x3D;&#x3D; 搜索某个功能包</p></li><li><p>rosed 包名 文件名 &#x3D;&#x3D;&#x3D; 修改功能包文件</p><p>需要安装 vim</p><p>比如:rosed turtlesim Color.msg</p></li><li><p>执行</p><p>roscore &#x3D;&#x3D;&#x3D; 是 ROS 的系统先决条件节点和程序的集合， 必须运行 roscore 才能使 ROS 节点进行通信</p><p>roscore 将启动:</p><ul><li>ros master</li><li>ros 参数服务器</li><li>rosout 日志节点</li></ul><p>rosrun 包名 可执行文件名 &#x3D;&#x3D;&#x3D; 运行指定的ROS节点</p><p>比如:<code>rosrun turtlesim turtlesim_node</code></p><p>roslaunch 包名 launch文件名 &#x3D;&#x3D;&#x3D; 执行某个包下的 launch 文件</p></li></ol><h4 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h4><p>rqt_graph能够创建一个显示当前系统运行情况的动态图形</p><p>计算图可以以点对点的网络形式表现数据交互过程</p><p>运行程序后，启动新终端，键入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_graph</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rqt_graph rqt_graph</span><br></pre></td></tr></table></figure><p>可以看到网络拓扑图，显示不同节点之间的关系</p><h2 id="ROS通信机制"><a href="#ROS通信机制" class="headerlink" title="ROS通信机制"></a>ROS通信机制</h2><h3 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h3><p>话题通信是ROS中使用频率最高的一种通信模式，基于<strong>发布订阅</strong>模式，即一个节点发布消息，另一个节点订阅该消息</p><p>以激光雷达信息的采集处理为例，在 ROS 中有一个节点需要时时的发布当前雷达采集到的数据，导航模块中也有节点会订阅并解析雷达数据</p><p>以此类推，像雷达、摄像头、GPS…. 等等一些传感器数据的采集都使用了话题通信</p><p><font color='Violetred'>话题通信适用于不断更新、少逻辑处理的数据传输场景</font></p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20250519215104543_compressed (1).webp" alt="image-20250519215104543_compressed (1)" style="zoom:67%;" /><ul><li>在工作空间下功能包中，基本每一个可执行文件都会初始化一个节点(node)，并唯一命名</li><li>节点之间通过话题(topic)进行通信</li><li>话题类型就是发布的消息(msg)</li><li>传输的内容需要关注消息类型</li></ul><h4 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h4><p>需求: 实现基本的话题通信，一方发布数据，一方接收数据</p><p><strong>c++实现</strong></p><p>在模型实现中，ROS master 不需要实现，而连接的建立也已经被封装了，需要关注：</p><ol><li>发布方</li><li>接收方</li><li>数据</li></ol><p>发布方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    发布方实现：</span></span><br><span class="line"><span class="comment">        1.包含头文件 </span></span><br><span class="line"><span class="comment">        2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line"><span class="comment">        3.创建节点句柄</span></span><br><span class="line"><span class="comment">        4.创建发布者对象</span></span><br><span class="line"><span class="comment">        5.编写发布逻辑并发布数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 设置编码格式</span></span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;talker&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.创建节点句柄</span></span><br><span class="line">    ros::NodeHandle nh; <span class="comment">//该类封装了 ROS 中的一些常用功能</span></span><br><span class="line">    <span class="comment">// 4.创建发布者对象</span></span><br><span class="line">    <span class="comment">//泛型: 发布的消息类型</span></span><br><span class="line">    <span class="comment">//参数1: 要发布到的话题</span></span><br><span class="line">    <span class="comment">//参数2: 队列中最大保存的消息数，超出此阀值时，早接受到的销毁</span></span><br><span class="line">    ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 5.编写发布逻辑并发布数据</span></span><br><span class="line">    <span class="comment">// 创建发布消息</span></span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    <span class="comment">// 分布频率</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span> <span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 设置编号</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 编写循环</span></span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现字符串拼接</span></span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;hello ---&quot;</span>&lt;&lt; count;</span><br><span class="line">        msg.data = ss.<span class="built_in">str</span>();</span><br><span class="line">        pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">        <span class="comment">//  添加日志</span></span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;发布的数据: %s&quot;</span>,ss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//根据前面制定的发送频率自动休眠</span></span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    订阅方实现：</span></span><br><span class="line"><span class="comment">        1.包含头文件 </span></span><br><span class="line"><span class="comment">        2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line"><span class="comment">        3.创建节点句柄</span></span><br><span class="line"><span class="comment">        4.创建订阅者对象</span></span><br><span class="line"><span class="comment">        5.处理订阅数据</span></span><br><span class="line"><span class="comment">        6.设置循环调用回调函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doMsg</span><span class="params">(<span class="type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;我听见: %s&quot;</span>,msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置编码格式</span></span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;listener&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.创建节点句柄</span></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">// 4.创建订阅者对象</span></span><br><span class="line">    ros::Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;chatter&quot;</span>,<span class="number">10</span>,doMsg);</span><br><span class="line">    <span class="comment">// 5.处理订阅数据</span></span><br><span class="line">    ros::<span class="built_in">spin</span>(); <span class="comment">// 循环读取接收的数据，并调用回调函数处理</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ConstPtr</code> 是 <code>boost::shared_ptr</code>（智能指针），即 <code>msg</code> 是一个<strong>指针</strong></p><p>必须用 <code>-&gt;</code> 访问其成员的 <code>data</code> 字段</p></blockquote><p>配置CmakeList.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo01_pub src/demo01_pub.cpp)</span><br><span class="line">add_executable(demo02_sub src/demo02_sub.cpp)</span><br><span class="line">target_link_libraries(demo01_pub</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">target_link_libraries(demo02_sub</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>vscode 中的 main 函数 声明 <code>int main(int argc, char const *argv[])&#123;&#125;</code>，默认生成 argv 被 const 修饰，需要去除该修饰符</p><p><strong>python实现</strong></p><p>发布方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">实现流程:</span></span><br><span class="line"><span class="string">    1.导包 </span></span><br><span class="line"><span class="string">    2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line"><span class="string">    3.实例化 发布者 对象</span></span><br><span class="line"><span class="string">    4.组织被发布的数据，并编写逻辑发布数据</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;talker_p&quot;</span>)</span><br><span class="line">    <span class="comment">#3.实例化 发布者 对象</span></span><br><span class="line">    pub = rospy.Publisher(<span class="string">&quot;chatter_p&quot;</span>,String,queue_size= <span class="number">10</span> )</span><br><span class="line">    <span class="comment">#4.组织被发布的数据，并编写逻辑发布数据</span></span><br><span class="line">    msg = String()</span><br><span class="line">    <span class="comment">#指定发布频率</span></span><br><span class="line">    rate = rospy.Rate(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#设置计数器</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="comment">#循环发布数据</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        msg.data = <span class="string">&quot;hello---&quot;</span>+<span class="built_in">str</span>(count)</span><br><span class="line">        <span class="comment">#发布数据</span></span><br><span class="line">        pub.publish(msg)</span><br><span class="line">        rate.sleep()</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;写入的数据：%s&quot;</span>,msg.data)</span><br></pre></td></tr></table></figure><p>订阅方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">    实现流程:</span></span><br><span class="line"><span class="string">        1.导包 </span></span><br><span class="line"><span class="string">        2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line"><span class="string">        3.实例化 订阅者 对象</span></span><br><span class="line"><span class="string">        4.处理订阅的消息(回调函数)</span></span><br><span class="line"><span class="string">        5.设置循环调用回调函数</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doMsg</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;I heard:%s&quot;</span>,msg.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;listener_p&quot;</span>)</span><br><span class="line">    <span class="comment"># 3.实例化 订阅者 对象</span></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;chatter_p&quot;</span>,String,doMsg,queue_size=<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 4.处理订阅的消息(回调函数)  </span></span><br><span class="line">    <span class="comment"># 5.设置循环调用回调函数   </span></span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><p>添加可执行权限</p><p>终端下进入 scripts 执行：<code>chmod +x *.py</code></p><p>配置 CMakeLists.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">catkin_install_python(PROGRAMS</span><br><span class="line">  scripts/demo01_pub_p.py</span><br><span class="line">  scripts/demo02_sub_p.py</span><br><span class="line">  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="自定义msg"><a href="#自定义msg" class="headerlink" title="自定义msg"></a>自定义msg</h4><p>msgs只是简单的文本文件，每行具有字段类型和字段名称</p><p>如果需要自定义消息类型，则需要自定义msg</p><p>流程：</p><ol><li>按照固定格式创建 msg 文件</li><li>编辑配置文件</li><li>编译生成可以被 Python 或 C++ 调用的中间文件</li></ol><p>创建自定义消息</p><ol><li><p>定义msg文件</p><p>功能包下新建 msg 目录，添加文件 Person.msg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uint16 age</span><br><span class="line">float64 height</span><br></pre></td></tr></table></figure></li><li><p>编辑配置文件</p><p><strong>package.xml</strong>中添加编译依赖与执行依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><p><strong>CMakeLists.txt</strong>编辑 msg 相关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line"># 需要加入 message_generation,必须有 std_msgs</span><br><span class="line">...</span><br><span class="line"># 配置 msg 源文件</span><br><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  Person.msg</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"># 执行时依赖</span><br><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES demo02_talker_listener</span><br><span class="line">  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>编译依赖find_package内的包</p><p>find_package依赖catkin_package内的包</p><p>如果catkin_package内的包不对，可能编译成功但运行失败</p></li><li><p>编译</p><p>编译后查看</p><p>C++ 需要调用的中间文件(…&#x2F;工作空间&#x2F;devel&#x2F;include&#x2F;包名&#x2F;xxx.h)</p><p>Python 需要调用的中间文件(…&#x2F;工作空间&#x2F;devel&#x2F;lib&#x2F;python3&#x2F;msg&#x2F;xxx.py)</p></li></ol><p><strong>c++实现</strong></p><p>需要先配置 vscode，将前面生成的 head 文件路径配置进 c_cpp_properties.json 的 includepath属性</p><p>发布方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;plumbing_pub_sub/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;发布方：&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;talker_person&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;plumbing_pub_sub::Person&gt;(<span class="string">&quot;chatter_person&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">    plumbing_pub_sub::Person p;</span><br><span class="line">    p.name = <span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line">    p.age = <span class="number">2000</span>;</span><br><span class="line">    p.height = <span class="number">1.45</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pub.<span class="built_in">publish</span>(p);</span><br><span class="line">        p.age += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;我叫:%s,今年%d岁,高%.2f米&quot;</span>, p.name.<span class="built_in">c_str</span>(), p.age, p.height);</span><br><span class="line"></span><br><span class="line">        r.<span class="built_in">sleep</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>订阅方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;plumbing_pub_sub/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPerson</span><span class="params">(<span class="type">const</span> plumbing_pub_sub::Person::ConstPtr&amp; person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;订阅的人信息:%s,%d,%.2f&quot;</span>,person-&gt;name.<span class="built_in">c_str</span>(),person-&gt;age,person-&gt;height);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;订阅方：&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;listener_person&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;chatter_person&quot;</span>,<span class="number">1000</span>,doPerson);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置CMakeList：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">add_executable(person_talker src/person_talker.cpp)</span><br><span class="line">add_executable(person_listener src/person_listener.cpp)</span><br><span class="line"></span><br><span class="line">// 额外配置，避免编译报错</span><br><span class="line">## Add cmake target dependencies of the executable</span><br><span class="line">## same as for the library above</span><br><span class="line">add_dependencies(person_talker $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br><span class="line">add_dependencies(person_listener $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(person_talker</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br><span class="line">target_link_libraries(person_listener</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>add_dependencies如果考虑简单，可以仅将注释的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># add_dependencies($&#123;PROJECT_NAME&#125;_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br></pre></td></tr></table></figure><p>中<code>$&#123;PROJECT_NAME&#125;_node</code>处改为节点名称，其它保留原来格式也是可以的</p></blockquote><p><strong>python实现</strong></p><p>将前面生成的 python 文件路径配置进 settings.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;python.autoComplete.extraPaths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;/opt/ros/noetic/lib/python3/dist-packages&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;/home/ros/demo03_ws/devel/lib/python3/dist-packages&quot;</span> <span class="comment">//添加的</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>发布方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> plumbing_pub_sub.msg <span class="keyword">import</span>  Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;talker_person_p&quot;</span>)</span><br><span class="line">    pub = rospy.Publisher(<span class="string">&quot;chatter_person&quot;</span>,Person,queue_size=<span class="number">1000</span>)</span><br><span class="line">    p = Person()</span><br><span class="line">    p.name = <span class="string">&quot;葫芦娃&quot;</span></span><br><span class="line">    p.age = <span class="number">18</span></span><br><span class="line">    p.height =<span class="number">0.75</span></span><br><span class="line"></span><br><span class="line">    rate = rospy.Rate(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        pub.publish(p)</span><br><span class="line">        rate.sleep()</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;姓名:%s, 年龄:%d, 身高:%.2f&quot;</span>,p.name,p.age,p.height)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>订阅方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> plumbing_pub_sub.msg <span class="keyword">import</span>  Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doPerson</span>(<span class="params">p</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;订阅信息：%s,%d,%.2f&quot;</span>,p.name,p.age,p.height)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;listener_person_p&quot;</span>)</span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;chatter_person&quot;</span>,Person,doPerson,queue_size=<span class="number">1000</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><p>终端下进入 scripts 执行:<code>chmod +x *.py</code></p><p>配置 CMakeLists.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">catkin_install_python(PROGRAMS</span><br><span class="line">  scripts/talker_p.py</span><br><span class="line">  scripts/listener_p.py</span><br><span class="line">  scripts/person_talker.py</span><br><span class="line">  scripts/person_listener.py</span><br><span class="line">  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h3><p>服务通信也是ROS中一种极其常用的通信模式，服务通信是基于<strong>请求响应</strong>模式的，是一种应答机制</p><p>即一个节点A向另一个节点B发送请求，B接收处理请求并产生响应结果返回给A</p><p>服务通信更适用于对时时性有要求、具有一定逻辑处理的应用场景</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-05-22_16-29-54_compressed.webp" alt="Snipaste_2025-05-22_16-29-54_compressed" style="zoom: 67%;" /><p>案例：</p><p>实现两个数字的求和，客户端节点，运行会向服务器发送两个数字，服务器端节点接收两个数字求和并将结果响应回客户端</p><h4 id="自定义srv"><a href="#自定义srv" class="headerlink" title="自定义srv"></a>自定义srv</h4><p>srv 文件内的可用数据类型与 msg 文件一致，且定义 srv 实现流程与自定义 msg 实现流程类似:</p><ol><li>按照固定格式创建srv文件</li><li>编辑配置文件</li><li>编译生成中间文件</li></ol><p>流程：</p><ol><li><p>定义srv文件</p><p>功能包下新建 srv 目录，添加 xxx.srv 文件，请求和响应数据类型之间用<code>---</code>分开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 客户端请求时发送的两个数字</span><br><span class="line">int32 num1</span><br><span class="line">int32 num2</span><br><span class="line">---</span><br><span class="line"># 服务器响应发送的数据</span><br><span class="line">int32 sum</span><br></pre></td></tr></table></figure></li><li><p>编译配置文件</p><p><strong>package.xml</strong>中添加编译依赖与执行依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><p>同话题通信自定义</p><p><strong>CMakeLists.txt</strong>编辑 srv 相关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line"># 需要加入 message_generation,必须有 std_msgs</span><br><span class="line"></span><br><span class="line">add_service_files(</span><br><span class="line">  FILES</span><br><span class="line">  AddInts.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>官网示例没有在 catkin_package 中配置 message_runtime，经测试配置也可以</p></li><li><p>编译，查看包方式同之前</p></li></ol><p>需要先配置 vscode，将前面生成的 head 文件路径配置进 c_cpp_properties.json 的 includepath属性</p><pre><code>  &quot;includePath&quot;: [    &quot;/opt/ros/noetic/include/**&quot;,    &quot;/usr/include/**&quot;,    &quot;/home/ros/demo03_ws/devel/include/**&quot; //增加的  ],</code></pre><p><strong>c++</strong></p><p>服务端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    服务器实现:</span></span><br><span class="line"><span class="comment">        1.包含头文件</span></span><br><span class="line"><span class="comment">        2.初始化 ROS 节点</span></span><br><span class="line"><span class="comment">        3.创建 ROS 句柄</span></span><br><span class="line"><span class="comment">        4.创建 服务 对象</span></span><br><span class="line"><span class="comment">        5.回调函数处理请求并产生响应</span></span><br><span class="line"><span class="comment">        6.由于请求有多个，需要调用 ros::spin()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;plumbing_server_client/AddInts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doNums</span><span class="params">(plumbing_server_client::AddInts::Request &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">            plumbing_server_client::AddInts::Response &amp;resp)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = req.num1;</span><br><span class="line">    <span class="type">int</span> num2 = req.num2;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;服务器接收到的数据为: num1 = %d,num2 = %d&quot;</span>,num1,num2);</span><br><span class="line">    <span class="type">int</span> sum = num1 + num2 ;</span><br><span class="line">    resp.sum = sum;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;处理结果: sum = %d&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;服务器启动&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;AddInts_Server&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::ServiceServer server = nh.<span class="built_in">advertiseService</span>(<span class="string">&quot;AddInts&quot;</span>,doNums);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>服务端的回调函数的参数是 <code>demo03_server_client::AddInts::Request&amp; req</code>，没有<code>ConstPtr</code>， <code>req</code> 是请求对象的<strong>引用</strong>，不是指针</p><p>引用 (<code>req</code>) 的行为和对象实例一致，直接用 <code>.</code> 访问成员，因为服务是“一问一答”模式，不需要共享所有权，直接修改传入的请求和响应对象即可</p><p>话题通信中将接收到的消息封装为 <code>boost::shared_ptr</code>（智能指针）传递给回调函数，目的是为了高效管理内存（避免拷贝）</p></blockquote><p>客户端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    服务器实现:</span></span><br><span class="line"><span class="comment">        1.包含头文件</span></span><br><span class="line"><span class="comment">        2.初始化 ROS 节点</span></span><br><span class="line"><span class="comment">        3.创建 ROS 句柄</span></span><br><span class="line"><span class="comment">        4.创建 客户端 对象</span></span><br><span class="line"><span class="comment">        5.请求服务，接收响应</span></span><br><span class="line"><span class="comment">    实现参数的动态提交：</span></span><br><span class="line"><span class="comment">        1. 格式 rosrun ..... (参数)</span></span><br><span class="line"><span class="comment">        2. 节点执行时，需要获取命令中的参数，并组织进 request</span></span><br><span class="line"><span class="comment">    问题：</span></span><br><span class="line"><span class="comment">        如果先启动客户端，会请求异常</span></span><br><span class="line"><span class="comment">    需求：</span></span><br><span class="line"><span class="comment">        先启动客户端，不直接抛出异常，挂起，等待服务器启动再请求</span></span><br><span class="line"><span class="comment">    解决：</span></span><br><span class="line"><span class="comment">        ROS中内置函数，可以让客户端启动后挂起等待</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;plumbing_server_client/AddInts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 优化实现，获取命令中的参数</span></span><br><span class="line">    <span class="comment">// 如果不传递任何ROS参数，argc 的值为 1（只有程序名本身）</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;提交的参数个数不对&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;AddInts_Client&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::ServiceClient client = nh.<span class="built_in">serviceClient</span>&lt;plumbing_server_client::AddInts&gt;(<span class="string">&quot;AddInts&quot;</span>);</span><br><span class="line">    <span class="comment">// 5.请求服务，接收响应</span></span><br><span class="line">    plumbing_server_client::AddInts ai;</span><br><span class="line">    <span class="comment">// 组织请求</span></span><br><span class="line">    ai.request.num1 = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    ai.request.num2 = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">    <span class="comment">// 函数1，等到服务启动后才继续</span></span><br><span class="line">    <span class="comment">// client.waitForExistence();</span></span><br><span class="line">    <span class="comment">// 函数2，需要传入具体的服务话题</span></span><br><span class="line">    ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;AddInts&quot;</span>); </span><br><span class="line">    <span class="type">bool</span> flag = client.<span class="built_in">call</span>(ai);</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;响应成功&quot;</span>);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;响应结果 = %d&quot;</span>,ai.response.sum);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;响应失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置CMakeLists</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add_executable(AddInts_Server src/AddInts_Server.cpp)</span><br><span class="line">add_executable(AddInts_Client src/AddInts_Client.cpp)</span><br><span class="line"></span><br><span class="line">add_dependencies(AddInts_Server $&#123;PROJECT_NAME&#125;_gencpp)</span><br><span class="line">add_dependencies(AddInts_Client $&#123;PROJECT_NAME&#125;_gencpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(AddInts_Server</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br><span class="line">target_link_libraries(AddInts_Client</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>python</strong></p><p>服务端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> plumbing_server_client.srv <span class="keyword">import</span> AddInts,AddIntsRequest,AddIntsResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doReq</span>(<span class="params">req</span>):</span><br><span class="line">    num1 = req.num1</span><br><span class="line">    num2 = req.num2</span><br><span class="line">    <span class="built_in">sum</span> = num1 + num2</span><br><span class="line">    resp = AddIntsResponse()</span><br><span class="line">    resp.<span class="built_in">sum</span> = <span class="built_in">sum</span></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;服务器解析结果:%d&quot;</span>,<span class="built_in">sum</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;AddInts_Server_p&quot;</span>)</span><br><span class="line">    server = rospy.Service(<span class="string">&quot;AddInts&quot;</span>,AddInts,doReq)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;服务器启动&quot;</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> plumbing_server_client.srv <span class="keyword">import</span> AddInts,AddIntsRequest,AddIntsResponse</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#优化实现</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        rospy.logerr(<span class="string">&quot;请正确提交参数&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    rospy.init_node(<span class="string">&quot;AddInts_Client_p&quot;</span>)</span><br><span class="line">    client = rospy.ServiceProxy(<span class="string">&quot;AddInts&quot;</span>,AddInts)</span><br><span class="line">    client.wait_for_service()</span><br><span class="line">    req = AddIntsRequest()</span><br><span class="line">    req.num1 = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    req.num2 = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    resp = client.call(req)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;响应结果:%d&quot;</span>,resp.<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><p>配置CMakeLists</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">catkin_install_python(PROGRAMS</span><br><span class="line">  scripts/demo01_server_p.py</span><br><span class="line">  scripts/demo02_client_p.py</span><br><span class="line">  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h3><p>以共享的方式实现不同节点之间数据交互的通信模式，存储一些多节点共享的数据，类似于全局变量。</p><p>案例：实现参数增删改查操作</p><p>ROS Master 作为一个公共容器保存参数，Talker 可以向容器中设置参数，Listener 可以获取参数</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/03ROS通信机制03_参数服务器.jpg" alt="03ROS通信机制03_参数服务器" style="zoom: 67%;" /><blockquote><p>注意：参数服务器不是为高性能而设计的，因此最好用于存储静态的非二进制的简单数据</p></blockquote><p><strong>c++</strong></p><ul><li>参数服务器新增(修改)参数</li></ul><p>实现参数服务器数据的增删改查，可以通过两套 API 实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment">ros::NodeHandle</span></span><br><span class="line"><span class="comment">        setParam(&quot;键&quot;,&quot;值&quot;)</span></span><br><span class="line"><span class="comment">    ros::param</span></span><br><span class="line"><span class="comment">        set(&quot;键&quot;,&quot;值&quot;)</span></span><br><span class="line"><span class="comment">*/</span>        </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;set_param_c&quot;</span>);</span><br><span class="line">    std::vector&lt;std::string&gt; stus;</span><br><span class="line">    stus.<span class="built_in">push_back</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    stus.<span class="built_in">push_back</span>(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::map&lt;std::string,std::string&gt; friends;</span><br><span class="line">    friends[<span class="string">&quot;guo&quot;</span>] = <span class="string">&quot;huang&quot;</span>;</span><br><span class="line">    friends[<span class="string">&quot;yuang&quot;</span>] = <span class="string">&quot;xiao&quot;</span>;</span><br><span class="line">    <span class="comment">//NodeHandle--------------------------------------------------------</span></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;nh_int&quot;</span>,<span class="number">10</span>); <span class="comment">//整型</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;nh_double&quot;</span>,<span class="number">3.14</span>); <span class="comment">//浮点型</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;nh_bool&quot;</span>,<span class="literal">true</span>); <span class="comment">//bool</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;nh_string&quot;</span>,<span class="string">&quot;hello NodeHandle&quot;</span>); <span class="comment">//字符串</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;nh_vector&quot;</span>,stus); <span class="comment">// vector</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;nh_map&quot;</span>,friends); <span class="comment">// map</span></span><br><span class="line">    <span class="comment">//param--------------------------------------------------------</span></span><br><span class="line">    ros::param::<span class="built_in">set</span>(<span class="string">&quot;param_int&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    ros::param::<span class="built_in">set</span>(<span class="string">&quot;param_double&quot;</span>,<span class="number">3.14</span>);</span><br><span class="line">    ros::param::<span class="built_in">set</span>(<span class="string">&quot;param_string&quot;</span>,<span class="string">&quot;Hello Param&quot;</span>);</span><br><span class="line">    ros::param::<span class="built_in">set</span>(<span class="string">&quot;param_bool&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">    ros::param::<span class="built_in">set</span>(<span class="string">&quot;param_vector&quot;</span>,stus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数服务器获取参数</li></ul><p>在 roscpp 中提供了两套 API 实现参数操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">ros::NodeHandle</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        param(键,默认值) </span></span><br><span class="line"><span class="comment">            存在，返回对应结果，否则返回默认值</span></span><br><span class="line"><span class="comment">int res1 = nh.param(&quot;nh_int&quot;,100); </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        getParam(键,存储结果的变量)</span></span><br><span class="line"><span class="comment">            存在,返回 true,且将值赋值给参数2</span></span><br><span class="line"><span class="comment">            如果键不存在，那么返回值为 false，且不为参数2赋值</span></span><br><span class="line"><span class="comment">nh.getParam(&quot;nh_int&quot;,nh_int_value);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        getParamCached(键,存储结果的变量)--提高变量获取效率</span></span><br><span class="line"><span class="comment">            存在,返回 true,且将值赋值给参数2</span></span><br><span class="line"><span class="comment">            如果键不存在，那么返回值为 false，且不为参数2赋值</span></span><br><span class="line"><span class="comment">    nh.getParamCached(&quot;nh_int&quot;,nh_int_value);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        getParamNames(std::vector&lt;std::string&gt;)</span></span><br><span class="line"><span class="comment">            获取所有的键,并存储在参数 vector 中 </span></span><br><span class="line"><span class="comment">                std::vector&lt;std::string&gt; param_names;</span></span><br><span class="line"><span class="comment">                nh.getParamNames(param_names);</span></span><br><span class="line"><span class="comment">                for (auto &amp;&amp;name : param_names)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    ROS_INFO(&quot;名称解析name = %s&quot;,name.c_str());   </span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        hasParam(键)</span></span><br><span class="line"><span class="comment">        是否包含某个键，存在返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">ROS_INFO(&quot;存在 nh_int 吗? %d&quot;,nh.hasParam(&quot;nh_int&quot;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        searchParam(参数1，参数2)</span></span><br><span class="line"><span class="comment">            搜索键，参数1是被搜索的键，参数2存储搜索结果的变量</span></span><br><span class="line"><span class="comment">                nh.searchParam(&quot;nh_int&quot;,key);</span></span><br><span class="line"><span class="comment">                ROS_INFO(&quot;搜索键:%s&quot;,key.c_str());</span></span><br><span class="line"><span class="comment">                -&gt; 搜索键:/nh_int</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">    ros::param ----- 与 NodeHandle 类似</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure><ul><li>参数服务器删除参数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    ros::NodeHandle</span></span><br><span class="line"><span class="comment">        deleteParam(&quot;键&quot;)</span></span><br><span class="line"><span class="comment">        根据键删除参数，删除成功，返回 true，否则(参数不存在)，返回 false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ros::param</span></span><br><span class="line"><span class="comment">        del(&quot;键&quot;)</span></span><br><span class="line"><span class="comment">        根据键删除参数，删除成功，返回 true，否则(参数不存在)，返回 false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>python</strong></p><ul><li>参数服务器新增(修改)参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;set_update_paramter_p&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置各种类型参数</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;p_int&quot;</span>,<span class="number">10</span>)</span><br><span class="line">    rospy.set_param(<span class="string">&quot;p_double&quot;</span>,<span class="number">3.14</span>)</span><br><span class="line">    rospy.set_param(<span class="string">&quot;p_bool&quot;</span>,<span class="literal">True</span>)</span><br><span class="line">    rospy.set_param(<span class="string">&quot;p_string&quot;</span>,<span class="string">&quot;hello python&quot;</span>)</span><br><span class="line">    rospy.set_param(<span class="string">&quot;p_list&quot;</span>,[<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;haha&quot;</span>,<span class="string">&quot;xixi&quot;</span>])</span><br><span class="line">    rospy.set_param(<span class="string">&quot;p_dict&quot;</span>,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;hulu&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">8</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;p_int&quot;</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><ul><li>参数服务器获取参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">rospy.init_node(&quot;get_param_p&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数服务器操作之查询_Python实现:    </span></span><br><span class="line"><span class="string">        get_param(键,默认值)</span></span><br><span class="line"><span class="string">            当键存在时，返回对应的值，如果不存在返回默认值</span></span><br><span class="line"><span class="string">            int_value = rospy.get_param(&quot;p_int&quot;,10000)</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        get_param_cached(键,默认值)--提高变量获取效率</span></span><br><span class="line"><span class="string">        int_cached = rospy.get_param_cached(&quot;p_int&quot;)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        get_param_names--获取所有的键</span></span><br><span class="line"><span class="string">            names = rospy.get_param_names()</span></span><br><span class="line"><span class="string">            for name in names:</span></span><br><span class="line"><span class="string">                rospy.loginfo(&quot;name = %s&quot;,name)</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">        has_param</span></span><br><span class="line"><span class="string">        是否包含某个键，存在返回 true，否则返回 false</span></span><br><span class="line"><span class="string">            flag = rospy.has_param(&quot;p_int&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        search_param--寻找某个键，并返回完整的路径</span></span><br><span class="line"><span class="string">        key = rospy.search_param(&quot;p_int&quot;)</span></span><br><span class="line"><span class="string">    rospy.loginfo(&quot;搜索的键 = %s&quot;,key)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>参数服务器删除参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    rospy.delete_param(&quot;键&quot;)</span></span><br><span class="line"><span class="string">    键存在时，可以删除成功，键不存在时，会抛出异常</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    rospy.init_node(&quot;delete_param_p&quot;)</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        rospy.delete_param(&quot;p_int&quot;)</span></span><br><span class="line"><span class="string">    except Exception as e:</span></span><br><span class="line"><span class="string">        rospy.loginfo(&quot;删除失败&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>和之前介绍的文件系统操作命令比较，文件操作命令是静态的，操作的是磁盘上的文件，而上述命令是动态的，在ROS程序启动后，可以动态的获取运行中的节点或参数的相关信息</p><p><a href="https://wiki.ros.org/ROS/CommandLineTools">ROS&#x2F;CommandLineTools - ROS Wiki</a></p><p><a href="https://wiki.ros.org/rosnode">rosnode - ROS Wiki</a>   用于获取节点信息的命令</p><ul><li>rosnode list        列出所有的活动节点</li><li>rosnode ping [node_name]        测试到节点的连接状态</li><li>rosnode info [node_name]         打印节点信息</li><li>rosnode machine [machine_name]        列出指定设备上的节点</li><li>rosnode kill [node_name]        杀死某个节点</li><li>rosnode cleanup        清除无用节点，比如小乌龟示例</li></ul><hr><p><a href="https://wiki.ros.org/rostopic">rostopic - ROS Wiki</a>   用于显示有关ROS话题的调试信息，包括发布者，订阅者，发布频率和ROS消息</p><ul><li><p>rostopic list        显示所有活动状态下的话题</p></li><li><p>rostpic echo [topic-name]        获取指定话题当前发布的消息</p></li><li><p>rostopic pub        直接调用命令向订阅者发布消息 [这类指令都需要先source 一下]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub -r [频率] /话题名称 消息类型 消息内容</span><br><span class="line">rostopic pub -r 10 chatter_person plumbing_pub_sub/Person [按两次Tab补齐]</span><br></pre></td></tr></table></figure></li><li><p>rostopic info [topic-name]        获取当前话题的相关信息</p></li><li><p>rostopic type [topic-name]       打印话题类型</p></li><li><p>rostopic hz [topic-name]         显示话题的发布频率</p></li></ul><hr><p><a href="https://wiki.ros.org/rosmsg">rosmsg - ROS Wiki</a>   用于显示有关 ROS消息类型的工具</p><ul><li><p>rosmsg list        列出所有消息</p></li><li><p>rosmsg list | grep -i [消息种类]      显示消息的具体路径</p></li><li><p>rosmsg show [消息种类]        显示消息描述</p></li><li><p>rosmsg info [消息种类]        作用与 rosmsg show 一样</p></li></ul><hr><p><a href="https://wiki.ros.org/rosservice">rosservice - ROS Wiki</a>   用于列出和查询ROS <a href="http://wiki.ros.org/Services">Services</a>的工具</p><ul><li>rosservice list         列出所有活动的服务</li><li>rosservice call [service-name]       使用提供的参数调用服务</li><li>rosservice info [service-name]       打印有关服务的信息</li><li>rosservice type [service-name]      打印服务类型</li></ul><p>rossrv是用于显示有关ROS服务类型的信息的命令行工具，与 rosmsg 使用语法高度一致</p><hr><p><a href="https://wiki.ros.org/rosparam">rosparam - ROS Wiki</a>  用于使用YAML编码文件在参数服务器上获取和设置ROS参数</p><ul><li><p>rosparam list        列出所有参数</p></li><li><p>rosparam set       设置参数 [参数名] [参数值]</p></li><li><p>rosparam get       获取参数</p></li><li><p>rosparam delete   删除参数</p></li><li><p>rosparam dump    将参数写出到外部文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam dump xxx.yaml</span><br></pre></td></tr></table></figure></li><li><p>rosparam load [yaml文件]  从外部文件加载参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam load xxx.yaml</span><br></pre></td></tr></table></figure></li></ul><h3 id="通信机制实操"><a href="#通信机制实操" class="headerlink" title="通信机制实操"></a>通信机制实操</h3><h4 id="实操1-话题发布"><a href="#实操1-话题发布" class="headerlink" title="实操1 话题发布"></a>实操1 话题发布</h4><p>需求描述：编码实现乌龟运动控制，让小乌龟做圆周运动</p><p>实现分析：</p><ol><li>乌龟运动控制实现，关键节点有两个，一个是乌龟运动显示节点 turtlesim_node，另一个是控制节点，二者是订阅发布模式实现通信的，乌龟运动显示节点直接调用即可，运动控制节点之前是使用的 turtle_teleop_key 通过键盘控制，现在需要自定义控制节点</li><li>控制节点自实现时，首先需要了解控制节点与显示节点通信使用的话题与消息，可以使用ros命令结合计算图来获取</li><li>了解了话题与消息之后，通过 C++ 或 Python 编写运动控制节点，通过指定的话题，按照一定的逻辑发布消息即可</li></ol><p>实现流程：</p><ol><li>通过计算图结合ros命令获取话题与消息信息</li><li>编码实现运动控制节点</li><li>启动 roscore、turtlesim_node 以及自定义的控制节点，查看运行结果</li></ol><p><strong>话题与消息获取</strong></p><p>先启动键盘控制乌龟运动案例</p><ol><li><p>话题获取</p><p>通过 rostopic 列出话题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic list</span><br></pre></td></tr></table></figure><p>或者通过计算图查看话题，启动计算图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_graph</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20250523203511067.png" alt="image-20250523203511067" style="zoom: 67%;" /><p>-&gt; &#x2F;turtle1&#x2F;cmd_vel 传递运动指令</p></li><li><p>消息获取</p><p>获取消息类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rostopic type /turtle1/cmd_vel</span><br><span class="line">// rostopic info /turtle1/cmd_vel</span><br></pre></td></tr></table></figure><p>info 命令下也显示type</p><p>type: geometry_msgs&#x2F;Twist</p></li><li><p>获取消息格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosmsg info geometry_msgs/Twist</span><br></pre></td></tr></table></figure><p>输出: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/Vector3 linear</span><br><span class="line">  float64 x</span><br><span class="line">  float64 y</span><br><span class="line">  float64 z</span><br><span class="line">geometry_msgs/Vector3 angular</span><br><span class="line">  float64 x</span><br><span class="line">  float64 y</span><br><span class="line">  float64 z</span><br></pre></td></tr></table></figure><p>inear(线速度) ：xyz分别对应在x、y和z方向上的速度(单位是 m&#x2F;s)</p><p>angular(角速度)：xyz分别对应x轴上的翻滚roll、y轴上pitch和z轴上偏航yaw的速度(单位是rad&#x2F;s)</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/欧拉角1.webp" alt="欧拉角1" style="zoom: 67%;" /><blockquote><p>弧度：单位弧度定义为圆弧长度等于半径时的圆心角</p><p>在ros中顺时针弧度为 - ，逆时针为 +，值的范围在[-π,π]</p></blockquote></li></ol><p>于是可以通过直接发布指令做到简单实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub -r 10 /turtle1/cmd_vel [TAB补齐]</span><br></pre></td></tr></table></figure><p><strong>实现发布节点</strong></p><p>创建功能包需要依赖的功能包: roscpp rospy std_msgs geometry_msgs(封装坐标)</p><p><strong>c++</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">topic(已知: /turtle1/cmd_vel)</span></span><br><span class="line"><span class="comment">    消息类型(已知: geometry_msgs/Twist)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    实现流程:</span></span><br><span class="line"><span class="comment">        1.包含头文件</span></span><br><span class="line"><span class="comment">        2.初始化 ROS 节点</span></span><br><span class="line"><span class="comment">        3.创建节点句柄</span></span><br><span class="line"><span class="comment">        4.创建发布者对象</span></span><br><span class="line"><span class="comment">        5.发布逻辑</span></span><br><span class="line"><span class="comment">        6.spinOnce()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/Twist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;circle_control&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">    geometry_msgs::Twist msg;</span><br><span class="line"></span><br><span class="line">    msg.linear.x = <span class="number">1.0</span>;</span><br><span class="line">    msg.linear.y = <span class="number">1.0</span>;</span><br><span class="line">    msg.linear.z = <span class="number">0.0</span>;</span><br><span class="line">    msg.angular.x = <span class="number">0.0</span>;</span><br><span class="line">    msg.angular.y = <span class="number">0.0</span>;</span><br><span class="line">    msg.angular.z = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> Twist</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    rospy.init_node(<span class="string">&quot;circle_control_p&quot;</span>)</span><br><span class="line">    pub = rospy.Publisher(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>,Twist,queue_size=<span class="number">1000</span>)</span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>)</span><br><span class="line">    msg = Twist()  // 注意这里要()</span><br><span class="line"></span><br><span class="line">    msg.linear.x = <span class="number">1.0</span></span><br><span class="line">    msg.linear.y = <span class="number">0.0</span></span><br><span class="line">    msg.linear.z = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    msg.angular.x = <span class="number">0.0</span></span><br><span class="line">    msg.angular.y = <span class="number">0.0</span></span><br><span class="line">    msg.angular.z = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        pub.publish(msg)</span><br><span class="line">        rate.sleep</span><br></pre></td></tr></table></figure><h4 id="实操2-话题订阅"><a href="#实操2-话题订阅" class="headerlink" title="实操2 话题订阅"></a>实操2 话题订阅</h4><p>需求描述：turtlesim中的乌龟显示节点，会发布当前乌龟的位姿(窗体中乌龟的坐标以及朝向)，要求控制乌龟运动，并时时打印当前乌龟的位姿</p><p>实现分析：</p><ol><li>首先，需要启动乌龟显示以及运动控制节点并控制乌龟运动</li><li>要通过ROS命令，来获取乌龟位姿发布的话题以及消息</li><li>编写订阅节点，订阅并打印乌龟的位姿</li></ol><p>实现流程:</p><ol><li>通过ros命令获取话题与消息信息</li><li>编码实现位姿获取节点</li><li>启动 roscore、turtlesim_node 、控制节点以及位姿订阅节点，控制乌龟运动并输出乌龟的位姿</li></ol><p><strong>话题与消息获取</strong></p><p>先启动键盘控制乌龟运动案例</p><ol><li><p>话题获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic list</span><br></pre></td></tr></table></figure><p>-&gt; &#x2F;turtle1&#x2F;pose  存储乌龟位置</p></li><li><p>获取消息类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic info  /turtle1/pose</span><br></pre></td></tr></table></figure><p>-&gt; type: turtlesim&#x2F;Pose</p></li><li><p>获取消息格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosmsg info turtlesim/Pose</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float32 x</span><br><span class="line">float32 y</span><br><span class="line">float32 theta</span><br><span class="line">float32 linear_velocity</span><br><span class="line">float32 angular_velocity</span><br></pre></td></tr></table></figure></li></ol><p><strong>实现订阅节点</strong></p><p>需要增添功能包turtlesim</p><p>在package.xml中增添</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>turtlesim<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>sturtlesim<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在CMakeLsit.txt中增添</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  turtlesim //增添包</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>c++</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    话题名称 /turtle1/pose</span></span><br><span class="line"><span class="comment">    消息类型 turtlesim/Pose</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    实现流程:</span></span><br><span class="line"><span class="comment">        1.包含头文件</span></span><br><span class="line"><span class="comment">        2.初始化 ROS 节点</span></span><br><span class="line"><span class="comment">        3.创建 ROS 句柄</span></span><br><span class="line"><span class="comment">        4.创建订阅者对象</span></span><br><span class="line"><span class="comment">        5.回调函数处理订阅的数据</span></span><br><span class="line"><span class="comment">        6.spin</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPose</span><span class="params">(<span class="type">const</span> turtlesim::Pose::ConstPtr &amp;pose)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;乌龟的位姿信息: \n坐标(%.2f,%.2f)\n朝向(%.2f)\n线速度:%.2f\n角速度:%.2f&quot;</span>,</span><br><span class="line">    pose-&gt;x,pose-&gt;y,pose-&gt;theta,pose-&gt;linear_velocity,pose-&gt;angular_velocity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;sub_pose&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;/turtle1/pose&quot;</span>,<span class="number">1000</span>,doPose);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> turtlesim.msg <span class="keyword">import</span> Pose</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doPose</span>(<span class="params">pose</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;乌龟的位姿信息: \n坐标(%.2f,%.2f)\n朝向(%.2f)\n线速度:%.2f\n角速度:%.2f&quot;</span>,</span><br><span class="line">                pose.x,pose.y,pose.theta,pose.linear_velocity,pose.angular_velocity)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;sub_pose_p&quot;</span>)</span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;/turtle1/pose&quot;</span>,Pose,doPose,queue_size=<span class="number">1000</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><p>代码中容易错误的地方：话题名是&#x2F;turtle1&#x2F;pose ，注意这个1</p><h4 id="实操3-服务调用"><a href="#实操3-服务调用" class="headerlink" title="实操3 服务调用"></a>实操3 服务调用</h4><p>需求描述：编码实现向 turtlesim 发送请求，在乌龟显示节点的窗体指定位置生成一乌龟，这是一个服务请求操作</p><p>实现分析:</p><ol><li>首先，需要启动乌龟显示节点</li><li>要通过ROS命令，来获取乌龟生成服务的服务名称以及服务消息类型</li><li>编写服务请求节点，生成新的乌龟</li></ol><p>实现流程:</p><ol><li>通过ros命令获取服务与服务消息信息</li><li>编码实现服务请求节点</li><li>启动 roscore、turtlesim_node 、乌龟生成节点，生成新的乌龟</li></ol><p><strong>服务名称与服务消息获取</strong></p><ol><li><p>获取话题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice list</span><br></pre></td></tr></table></figure><p>-&gt; &#x2F;spawn</p></li><li><p>获取服务消息类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice info /spawn</span><br></pre></td></tr></table></figure><p>type: turtlesim&#x2F;Spawn</p><p>Args: x y theta name</p></li><li><p>获取服务消息格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rossrv info turtlesim/Spawn</span><br></pre></td></tr></table></figure><p>响应结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float32 x</span><br><span class="line">float32 y</span><br><span class="line">float32 theta</span><br><span class="line">string name</span><br><span class="line">---</span><br><span class="line">string name</span><br></pre></td></tr></table></figure></li></ol><p>也可以简单实现增添乌龟</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /spawn [TAB补齐]</span><br></pre></td></tr></table></figure><p><strong>c++</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    服务话题 /spawn</span></span><br><span class="line"><span class="comment">    服务消息类型 turtlesim/Spawn</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现流程:</span></span><br><span class="line"><span class="comment">        1.包含头文件</span></span><br><span class="line"><span class="comment">          需要包含 turtlesim 包下资源，注意在 package.xml 配置</span></span><br><span class="line"><span class="comment">        2.初始化 ros 节点</span></span><br><span class="line"><span class="comment">        3.创建 ros 句柄</span></span><br><span class="line"><span class="comment">        4.创建 service 客户端</span></span><br><span class="line"><span class="comment">        5.等待服务启动</span></span><br><span class="line"><span class="comment">        6.发送请求</span></span><br><span class="line"><span class="comment">        7.处理响应</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/Spawn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;service_call&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::ServiceClient client = nh.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">    turtlesim::Spawn spawn;</span><br><span class="line">    spawn.request.x = <span class="number">1.0</span>;</span><br><span class="line">    spawn.request.y = <span class="number">4.0</span>;</span><br><span class="line">    spawn.request.theta = <span class="number">1.57</span>;</span><br><span class="line">    spawn.request.name = <span class="string">&quot;turtlec&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ros::service::waitForService(&quot;/spawn&quot;);</span></span><br><span class="line">    client.<span class="built_in">waitForExistence</span>();</span><br><span class="line">    <span class="type">bool</span> flag = client.<span class="built_in">call</span>(spawn);</span><br><span class="line">    <span class="comment">// 7.处理响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;新的乌龟生成,名字:%s&quot;</span>,spawn.response.name.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;乌龟生成失败！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> turtlesim.srv <span class="keyword">import</span> Spawn,SpawnRequest,SpawnResponse </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    rospy.init_node(<span class="string">&quot;service_call_p&quot;</span>)</span><br><span class="line">    client = rospy.ServiceProxy(<span class="string">&quot;/spawn&quot;</span>,Spawn)</span><br><span class="line">    request = SpawnRequest()</span><br><span class="line">    request.x = <span class="number">4.0</span></span><br><span class="line">    request.y = <span class="number">1.0</span></span><br><span class="line">    request.theta = <span class="number">1.57</span></span><br><span class="line">    request.name = <span class="string">&quot;turtlep&quot;</span></span><br><span class="line">    client.wait_for_service()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = client.call(request)</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;乌龟创建成功!，叫:%s&quot;</span>,response.name)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;服务调用失败&quot;</span>)</span><br></pre></td></tr></table></figure><p>可能会出现因为重复命名的异常</p><h4 id="实操4-参数设置"><a href="#实操4-参数设置" class="headerlink" title="实操4 参数设置"></a>实操4 参数设置</h4><p>需求描述: 修改turtlesim乌龟显示节点窗体的背景色，已知背景色是通过参数服务器的方式以 rgb 方式设置的</p><p>实现分析:</p><ol><li>首先，需要启动乌龟显示节点[注意这里不启动launch文件]</li><li>要通过ROS命令，来获取参数服务器中设置背景色的参数</li><li>编写参数设置节点，修改参数服务器中的参数值</li></ol><p>实现流程:</p><ol><li>通过ros命令获取参数</li><li>编码实现服参数设置节点</li><li>启动 roscore、turtlesim_node 与参数设置节点，查看运行结果</li></ol><p><strong>参数名获取</strong></p><p>获取参数列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam list</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/turtle1/background_b</span><br><span class="line">/turtle1/background_g</span><br><span class="line">/turtle1/background_r</span><br><span class="line">/turtlesim/background_b</span><br><span class="line">/turtlesim/background_g</span><br><span class="line">/turtlesim/background_r</span><br></pre></td></tr></table></figure><p>方式1：命令行实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosparam set /turtlesim/background_r 自定义数值</span><br><span class="line">rosparam set /turtlesim/background_g 自定义数值</span><br><span class="line">rosparam set /turtlesim/background_b 自定义数值</span><br></pre></td></tr></table></figure><p>修改相关参数后，重启 turtlesim_node 节点，背景色就会发生改变了</p><p>方式2：代码</p><p><strong>c++</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;color&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ros::NodeHandle nh(&quot;turtlesim&quot;); //加上命名空间</span></span><br><span class="line"><span class="comment">// nh.setParam(&quot;background_r&quot;,0);</span></span><br><span class="line">    <span class="comment">// nh.setParam(&quot;background_g&quot;,0);</span></span><br><span class="line">    <span class="comment">// nh.setParam(&quot;background_b&quot;,0);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;color_p&quot;</span>)</span><br><span class="line">    rospy.set_param(<span class="string">&quot;/turtlesim/background_r&quot;</span>,<span class="number">255</span>)</span><br><span class="line">    rospy.set_param(<span class="string">&quot;/turtlesim/background_g&quot;</span>,<span class="number">255</span>)</span><br><span class="line">    rospy.set_param(<span class="string">&quot;/turtlesim/background_b&quot;</span>,<span class="number">255</span>)</span><br></pre></td></tr></table></figure><h3 id="通信机制比较"><a href="#通信机制比较" class="headerlink" title="通信机制比较"></a>通信机制比较</h3><p>三种通信机制中</p><p>参数服务器是一种数据共享机制，可以在不同的节点之间共享数据</p><p>话题通信与服务通信是在不同的节点之间传递数据的</p><p>话题通信：Publisher→Subscriber [Topic] [msg]</p><p>服务通信：Client→Server [Service] [srv]</p><p>二者的实现流程相似，都是两个节点通过话题关联到一起，并使用某种类型的数据载体实现数据传输</p><table><thead><tr><th></th><th>Topic(话题)</th><th>Service(服务)</th></tr></thead><tbody><tr><td>通信模式</td><td>发布&#x2F;订阅</td><td>请求&#x2F;响应</td></tr><tr><td>同步性</td><td>异步(无序)</td><td>同步(有序)</td></tr><tr><td>底层协议</td><td>ROSTCP&#x2F;ROSUDP</td><td>ROSTCP&#x2F;ROSUDP</td></tr><tr><td>缓冲区</td><td>有(queue_size 队列)</td><td>无</td></tr><tr><td>时时性</td><td>弱</td><td>强</td></tr><tr><td>节点关系</td><td>多对多</td><td>一对多(一个 Server)</td></tr><tr><td>通信数据</td><td>msg</td><td>srv</td></tr><tr><td>使用场景</td><td>连续高频的数据发布与接收：雷达、里程计</td><td>偶尔调用或执行某一项特定功能：拍照、语音识别</td></tr></tbody></table><h2 id="ROS通信机制进阶"><a href="#ROS通信机制进阶" class="headerlink" title="ROS通信机制进阶"></a>ROS通信机制进阶</h2><p><a href="https://docs.ros.org/en/api/roscpp/html/">roscpp</a><a href="https://wiki.ros.org/rospy">rospy</a></p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>建议参考官方API文档或参考源码</p><p>在运行程序时rosrun 后接着写 _[参数名] &#x3D; [参数值] 可以给节点 </p><h4 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h4><p>ros::init(argc, argv, “name”, [options])</p><ol><li><p>argc — 封装实参的个数(n+1)</p></li><li><p>argv — 封装参数的数组</p></li><li><p>name — 为节点命名(唯一性)</p></li><li><p>options — 节点启动选项  ros::init_options::AnonymousName  </p><blockquote><p>给前面的节点命名后增加一个随机数，使得同一个节点能够重复启动</p><p>否则重名情况下，第二次启动时第一次会自动停止</p></blockquote></li></ol><p>返回值: void</p><p>rospy.init_node(name, argv&#x3D;None, anonymous&#x3D;False) </p><ol><li>name — 节点名称</li><li>argv — 封装节点调用时传递的参数</li><li>anonymous — 取值为 true 时，为节点名称后缀随机编号</li></ol><h4 id="话题与服务"><a href="#话题与服务" class="headerlink" title="话题与服务"></a>话题与服务</h4><p>在 roscpp 中，话题和服务的相关对象一般由 ros::NodeHandle nh 创建，python中不用专门创建NodeHandle  </p><p><strong>发布对象</strong></p><p>ros::Publisher pub &#x3D; nh.advertise&lt; type &gt;(“topic”, queue_size, [latch])</p><ol><li><p>type — 消息类型</p></li><li><p>topic — 话题名称</p></li><li><p>queue_size — 队列长度</p></li><li><p>latch — 设置为ture时，该话题发布的最后一条消息将被保存，并且当有订阅者连接时会将该消息发送给订阅者</p><p>以静态地图发送为例(短时间不变的数据)</p><p>方案1：可以使用固定频率发送地图数据，但是效率低</p><p>方案2：可以将地图发布对象的latch设置为true，并且发布方只发送一次数据，每当订阅者连接时，将地图数据发送给订阅者(只发送一次)，这样提高了数据的发送效率</p></li></ol><p>pub &#x3D; rospy.Publisher(“topic”, type, queue_size, [lathc])</p><p><strong>订阅对象</strong>  </p><p>ros::Subscriber sub &#x3D; nh.subscribe(“topic”, queue_size, callback);</p><blockquote><p>void callback(const std_msgs::String::ConstPtr &amp;msg)</p></blockquote><p>sub &#x3D; rospy.Subscriber(“topic”, type, callback, queue_size)</p><blockquote><p>def callback(msg):</p></blockquote><p><strong>服务对象</strong></p><p>ros::ServiceServer server &#x3D; nh.advertiseService(“service”, callback);</p><blockquote><p>bool callback(srv type::Request &amp;req, srv type::Response &amp;resp)</p></blockquote><p>server &#x3D; rospy.Service(“service”, srv type, callback)</p><blockquote><p>def callback(req):</p><p>return resp</p></blockquote><p><strong>客户端对象</strong></p><p>ros::ServiceClient client &#x3D; nh.serviceClient&lt; srv type &gt;(“service”);</p><p>等待服务函数1  ros::service::waitForService(“service”)</p><p>等待服务函数2  client.waitForExistence();</p><p>请求写入：srv type req; req.request.input1 &#x3D; atoi(argv[1]); (类推写完输入)</p><p>client &#x3D; rospy.ServiceProxy(“service”, srv type)</p><p>等待服务函数    client.wait_for_service()</p><p>请求写入：req &#x3D; srv typeRequets() req.input1 &#x3D; sys.argv[1] (类推写完输入)</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>spinOnce()  处理一轮回调，一般用于循环体内</p><p>spin() 进入循环去处理回调</p><p>不同点：在ros::spin() 后的语句不会执行到，而 ros::spinOnce() 后的语句可以执行</p><p>python 只有 rospy.spin()</p><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p><strong>时刻</strong> </p><p>获取时刻，或是设置指定时刻</p><p>ros::Time::now()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;hello_time&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">// 获取当前时刻：now 被调用执行的那一刻</span></span><br><span class="line">    <span class="comment">// 参考系：1970年01月01日 00:00:00</span></span><br><span class="line">    ros::Time current_time = ros::Time::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取距离 1970年01月01日 00:00:00 的秒数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;当前时刻:%.2f&quot;</span>,current_time.<span class="built_in">toSec</span>()); <span class="comment">// 浮点型</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;当前时刻:%d&quot;</span>,current_time.sec);  <span class="comment">// 整型    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化为年月日时分秒格式</span></span><br><span class="line">    std::<span class="type">time_t</span> raw_time = current_time.<span class="built_in">toSec</span>(); <span class="comment">// 转换为秒</span></span><br><span class="line">    std::tm* time_info = std::<span class="built_in">localtime</span>(&amp;raw_time); <span class="comment">// 转换为本地时间</span></span><br><span class="line">    <span class="comment">// 如果需要UTC时间使用 std::gmtime</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line">    std::<span class="built_in">strftime</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time_info); <span class="comment">// 格式化时间</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;当前时间: %s&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指定时刻</span></span><br><span class="line">    <span class="function">ros::Time <span class="title">t1</span><span class="params">(<span class="number">100</span>,<span class="number">100000000</span>)</span></span>; <span class="comment">// 参数1:秒数  参数2:纳秒</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;时刻:%.2f&quot;</span>,t<span class="number">1.</span><span class="built_in">toSec</span>()); </span><br><span class="line">    <span class="function">ros::Time <span class="title">t2</span><span class="params">(<span class="number">100.1</span>)</span></span>; <span class="comment">// 传入浮点型</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;时刻:%.2f&quot;</span>,t<span class="number">2.</span><span class="built_in">toSec</span>()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名增加时间戳方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">time_t</span> raw_time = ros::Time::<span class="built_in">now</span>().<span class="built_in">toSec</span>(); <span class="comment">// 转换为秒</span></span><br><span class="line">std::tm* time_info = std::<span class="built_in">localtime</span>(&amp;raw_time); <span class="comment">// 转换为本地时间</span></span><br><span class="line"><span class="comment">// 如果需要UTC时间使用 std::gmtime</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line">std::<span class="built_in">strftime</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;%Y%m%d_%H%M%S&quot;</span>, time_info); <span class="comment">// 格式化时间</span></span><br></pre></td></tr></table></figure><p>后续直接+buffer即可</p><p>rospy.Time.now()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">current_time = rospy.Time.now()</span><br><span class="line">rospy.loginfo(<span class="string">&quot;当前时刻:%.2f&quot;</span>,right_now.to_sec()) <span class="comment"># 浮点型</span></span><br><span class="line">rospy.loginfo(<span class="string">&quot;当前时刻:%.2f&quot;</span>,right_now.to_nsec()) <span class="comment"># 整型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置指定时刻</span></span><br><span class="line">time1 = rospy.Time(<span class="number">100</span>,<span class="number">100000000</span>)  <span class="comment"># 参数1:秒数  参数2:纳秒</span></span><br><span class="line">time2 = rospy.Time(<span class="number">100.1</span>)</span><br><span class="line">time3 = rospy.Time.from_sec(<span class="number">100.1</span>)</span><br><span class="line">rospy.loginfo(<span class="string">&quot;设置时刻1:%.2f&quot;</span>,time1.to_sec())</span><br><span class="line">rospy.loginfo(<span class="string">&quot;设置时刻2:%.2f&quot;</span>,time2.to_sec())</span><br><span class="line">rospy.loginfo(<span class="string">&quot;设置时刻2:%.2f&quot;</span>,time3.to_sec())</span><br></pre></td></tr></table></figure><p><strong>持续时间</strong></p><p>设置一个时间区间(间隔)</p><p>ros::Duration du()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;开始休眠:%.2f&quot;</span>,ros::Time::<span class="built_in">now</span>().<span class="built_in">toSec</span>());</span><br><span class="line"><span class="function">ros::Duration <span class="title">du</span><span class="params">(<span class="number">4.5</span>)</span></span>;<span class="comment">//持续4.5秒,double类型，以秒为单位</span></span><br><span class="line">du.<span class="built_in">sleep</span>();</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;结束休眠:%.2f&quot;</span>,ros::Time::<span class="built_in">now</span>().<span class="built_in">toSec</span>());</span><br></pre></td></tr></table></figure><p>du &#x3D; rospy.Duration()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rospy.loginfo(<span class="string">&quot;持续时间测试开始.....&quot;</span>)</span><br><span class="line">du = rospy.Duration(<span class="number">3.3</span>)</span><br><span class="line">rospy.sleep(du) <span class="comment">#休眠函数</span></span><br><span class="line">rospy.loginfo(<span class="string">&quot;持续时间测试结束.....&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>时刻运算</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros::Time begin = ros::Time::<span class="built_in">now</span>();</span><br><span class="line"><span class="function">ros::Duration <span class="title">du1</span><span class="params">(<span class="number">5</span>)</span></span>;     <span class="comment">// 模拟运行时间</span></span><br><span class="line">ros::Time stop = begin + du1;</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;开始时刻:%.2f&quot;</span>,begin.<span class="built_in">toSec</span>());</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;结束时刻:%.2f&quot;</span>,stop.<span class="built_in">toSec</span>());</span><br></pre></td></tr></table></figure><p>time 与 duration 可以+&#x2F;-，duration 之间也可以+&#x2F;-</p><p>但time 之间只可以 - ，不可以 + ，返回的是 ros::Duration 类型</p><p>python与c++相同</p><p><strong>设置运行频率</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//指定频率</span></span><br><span class="line">   <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       rate.<span class="built_in">sleep</span>(); <span class="comment">// 要放在循环里</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rate = rospy.Rate(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">    rate.sleep() <span class="comment">#休眠，要放在循环里</span></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;+++++++++++++++&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>定时器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb</span><span class="params">(<span class="type">const</span> ros::TimerEvent &amp;event)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;----&quot;</span>);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;调用时刻:%.2f&quot;</span>,event.current_real.<span class="built_in">toSec</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Timer createTimer(ros::Duration(period), // 时间间隔</span></span><br><span class="line"><span class="comment">        const TimerCallback&amp; callback,      // 回调函数</span></span><br><span class="line"><span class="comment">        bool oneshot = false,               // 是否一次性</span></span><br><span class="line"><span class="comment">        bool autostart = true ）            // 是否自动启动，设置为false时需要手动启动 time.start()</span></span><br><span class="line"><span class="comment">    定时器启动需要ros::spin() 因为有回调函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    ros::Timer timer = nh.<span class="built_in">createTimer</span>(ros::<span class="built_in">Duration</span>(<span class="number">1</span>),cb);</span><br><span class="line">    <span class="comment">// ros::Timer timer = nh.createTimer(ros::Duration(1),cb,false,false);</span></span><br><span class="line">    <span class="comment">// timer.start(); // 手动启动</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cb</span>(<span class="params">event</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;+++++++++++&quot;</span>)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;当前时刻:%.2f&quot;</span>,event.current_real.to_sec())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">rospy.Timer(rospy.Duration(period), // 时间间隔</span></span><br><span class="line"><span class="string">callback,// 回调函数</span></span><br><span class="line"><span class="string">oneshot=False,// 是否一次性</span></span><br><span class="line"><span class="string">                reset=False)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    rospy.Timer(rospy.Duration(<span class="number">1</span>),cb)</span><br><span class="line"><span class="comment"># rospy.Timer(rospy.Duration(1),cb,True) # 只执行一次</span></span><br><span class="line">rospy.spin()</span><br></pre></td></tr></table></figure><h4 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h4><p>在发布实现时，一般会循环发布消息，循环的判断条件一般由节点状态来控制</p><p>C++中可以通过 ros::ok() 来判断节点状态是否正常，而 python 中则通过 rospy.is_shutdown() 来实现判断，导致节点退出的原因主要有如下几种：</p><ul><li>节点接收到了关闭信息，比如常用的 ctrl + c(z) 快捷键就是关闭节点的信号</li><li>同名节点启动，导致现有节点退出</li><li>程序中的其他部分调用了节点关闭相关的API(C++中是ros::shutdown()，python中是rospy.signal_shutdown())</li></ul><p>日志函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;hello,DEBUG&quot;</span>); <span class="comment">//不会输出</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;hello,INFO&quot;</span>); <span class="comment">//默认白色字体</span></span><br><span class="line"><span class="built_in">ROS_WARN</span>(<span class="string">&quot;Hello,WARN&quot;</span>); <span class="comment">//默认黄色字体</span></span><br><span class="line"><span class="built_in">ROS_ERROR</span>(<span class="string">&quot;hello,ERROR&quot;</span>);<span class="comment">//默认红色字体</span></span><br><span class="line"><span class="built_in">ROS_FATAL</span>(<span class="string">&quot;hello,FATAL&quot;</span>);<span class="comment">//默认红色字体</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rospy.logdebug(<span class="string">&quot;hello,debug&quot;</span>)  <span class="comment">#不会输出</span></span><br><span class="line">rospy.loginfo(<span class="string">&quot;hello,info&quot;</span>)  <span class="comment">#默认白色字体</span></span><br><span class="line">rospy.logwarn(<span class="string">&quot;hello,warn&quot;</span>)  <span class="comment">#默认黄色字体</span></span><br><span class="line">rospy.logerr(<span class="string">&quot;hello,error&quot;</span>)  <span class="comment">#默认红色字体</span></span><br><span class="line">rospy.logfatal(<span class="string">&quot;hello,fatal&quot;</span>) <span class="comment">#默认红色字体</span></span><br></pre></td></tr></table></figure><h3 id="头文件与源文件"><a href="#头文件与源文件" class="headerlink" title="头文件与源文件"></a>头文件与源文件</h3><p>核心内容在于CMakeLists.txt文件的配置</p><h4 id="自定义头文件调用"><a href="#自定义头文件调用" class="headerlink" title="自定义头文件调用"></a>自定义头文件调用</h4><p>流程: </p><ol><li>编写头文件；</li><li>编写可执行文件(同时也是源文件)；</li><li>编辑配置文件并执行。</li></ol><p><strong>头文件</strong></p><p>在功能包下的<code>include/功能包名</code>目录下新建头文件: hello.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HELLO_H</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    声明namespace</span></span><br><span class="line"><span class="comment">        |-- class</span></span><br><span class="line"><span class="comment">            |- run</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hello_ns&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHello</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>为了后续包含头文件时不抛出异常，配置 .vscode 下 _cpp_properties.json 的 includepath属性（和之前配置服务srv文件生成的头文件过程相似）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">...</span><br><span class="line">        <span class="string">&quot;/home/ros/demo03_ws/src/plumbing_head/include/**&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><strong>源文件</strong></p><p>src目录下新建 hello.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;plumbing_head/hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hello_ns&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyHello::run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;run函数执行....&quot;</span>);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;hello_head&quot;</span>);</span><br><span class="line">    hello_ns::MyHello myhello;</span><br><span class="line">    myhello.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><p>与之前配置多一步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">include // 这里解除注释</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_executable(hello src/hello.cpp)</span><br><span class="line"></span><br><span class="line">add_dependencies(hello $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line"></span><br><span class="line">target_link_libraries(hello</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="自定义源文件调用"><a href="#自定义源文件调用" class="headerlink" title="自定义源文件调用"></a>自定义源文件调用</h4><p>流程:</p><ol><li>编写头文件；</li><li>编写源文件；</li><li>编写可执行文件；</li><li>编辑配置文件并执行。</li></ol><p><strong>可执行文件</strong></p><p>src目录下新建 use_head.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;plumbing_head/hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;hello_head_src&quot;</span>);</span><br><span class="line">    hello_ns::MyHello my;</span><br><span class="line">    my.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><p>头文件与源文件相关配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">include // 这里解除注释</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">## 声明C++库</span><br><span class="line">## Declare a C++ library</span><br><span class="line"># add_library($&#123;PROJECT_NAME&#125;</span><br><span class="line">#   src/$&#123;PROJECT_NAME&#125;/plumbing_pub_sub.cpp</span><br><span class="line"># )</span><br><span class="line">add_library(head_src</span><br><span class="line">  include/$&#123;PROJECT_NAME&#125;/hello.h</span><br><span class="line">  src/hello.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_dependencies(head_src $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line"></span><br><span class="line">target_link_libraries(head_src</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可执行文件配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_executable(use_hello src/use_hello.cpp)</span><br><span class="line"></span><br><span class="line">add_dependencies(use_hello $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line"></span><br><span class="line">#此处需要添加之前设置的库</span><br><span class="line">target_link_libraries(use_hello</span><br><span class="line">  head_src // 库声明</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Python模块导入"><a href="#Python模块导入" class="headerlink" title="Python模块导入"></a>Python模块导入</h3><p>实现:</p><ol><li>新建两个Python文件，使用 import 实现导入关系；</li><li>添加可执行权限、编辑配置文件并执行UseA</li></ol><p>tool.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line">num = <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>use_tool.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置临时环境变量</span></span><br><span class="line"><span class="comment"># sys.path.insert(0,&quot;/home/ros/demo03_ws/src/plumbing_pub_sub/scripts&quot;)</span></span><br><span class="line"><span class="comment"># 路径动态，保证移植可执行</span></span><br><span class="line">path = os.path.abspath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">sys.path.insert(<span class="number">0</span>,path + <span class="string">&quot;/src/plumbing_head/scripts&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tool</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;tool&quot;</span>)</span><br><span class="line">    <span class="comment"># 异常：ModuleNotFoundError:No module named&#x27;tools&#x27;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">        原因: rosrun 执行时，参考路径是工作空间的路径，在工作空间下无法查找依赖的模块 </span></span><br><span class="line"><span class="string">        解决：可以声明python的环境变量,当依赖某个模块时,先去指定环境变量中查找依赖</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;num=%d&quot;</span>,tool.num)</span><br></pre></td></tr></table></figure><h2 id="ROS运行管理"><a href="#ROS运行管理" class="headerlink" title="ROS运行管理"></a>ROS运行管理</h2><h3 id="元功能包"><a href="#元功能包" class="headerlink" title="元功能包"></a>元功能包</h3><p>完成ROS中一个系统性的功能，可能涉及到多个功能包，逐一安装功能包的效率低下，在ROS中，提供了一种方式可以将不同的功能包打包成一个功能包，当安装某个功能模块时，直接调用打包后的功能包即可，该包又称之为元功能包</p><p><code>MetaPackage</code>是Linux的一个文件管理系统的概念，是ROS中的一个虚包，里面没有实质性的内容，但是它依赖了其他的软件包，通过这种方法可以把其他包组合起来，可以认为它是一本书的目录索引，告诉我们这个包集合中有哪些子包，并且该去哪里下载</p><p>例如：sudo apt install ros-noetic-desktop-full 命令安装ros时就使用了元功能包</p><p><strong>实现</strong></p><p>新建一个功能包，不需要添加依赖，修改package.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加依赖的功能包名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>plumbing_pub_sub<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>plumbing_server_client<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>plumbing_param_server<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- The export tag contains other, unspecified, tags --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">metapackage</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改 CMakeLists.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0.2)</span><br><span class="line">project(plumbing_my)</span><br><span class="line">find_package(catkin REQUIRED)</span><br><span class="line">catkin_metapackage()</span><br></pre></td></tr></table></figure><p><font color='Violetred'>不能出现换行以及注释</font></p><p><a href="https://wiki.ros.org/catkin/package.xml#Metapackages">catkin&#x2F;package.xml - ROS Wiki</a></p><h3 id="launch文件-1"><a href="#launch文件-1" class="headerlink" title="launch文件"></a>launch文件</h3><p>在功能包下添加 launch目录, 目录下新建 xxxx.launch 文件，编辑 launch 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot;     name=&quot;myTurtle&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot;  name=&quot;myTurtleContro&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p>调用 launch 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch 包名 xxx.launch</span><br></pre></td></tr></table></figure><p>roslaunch 命令执行launch文件时，首先会判断是否启动了 roscore，如果启动了，则不再启动，否则，会自动调用 roscore</p><p><strong>launch标签</strong></p><p><code>&lt;launch&gt;</code>标签是所有 launch 文件的根标签，充当其他标签的容器</p><p>deprecated 告知用户当前 launch 文件已经弃用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch deprecated=&quot;此文件可能过时！&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>node标签</strong></p><p><code>&lt;node&gt;</code>标签用于指定 ROS 节点，是最常见的标签，但 roslaunch 命令不能保证按照 node 的声明顺序来启动节点(节点的启动是多进程的)</p><ul><li><p>pkg&#x3D;”包名”</p><p>节点所属的功能包</p></li><li><p>type&#x3D;”nodeType”  </p><p>节点类型，即与之相同名称的可执行文件，python文件需要带上<code>.py</code>，cpp文件不需要，类似CMakeList配置</p></li><li><p>name&#x3D;”nodeName”</p><p>节点名称，在 ROS 网络拓扑中节点的名称</p></li><li><p>machine&#x3D;”机器名”</p><p>在指定机器上启动节点</p></li><li><p>respawn&#x3D;”true | false” (可选)</p><p>如果节点退出，是否自动重启</p></li><li><p>respawn_delay&#x3D;” N” (可选)</p><p>如果 respawn 为 true，那么延迟 N 秒后启动节点</p></li><li><p>required&#x3D;”true | false” (可选)</p><p>如果为 true，那么该节点退出，将杀死整个 roslaunch，不能和respawn一起用，会报错</p></li><li><p>ns&#x3D;”xxx” (可选)</p><p>在指定命名空间 xxx 中启动节点 ，主要用来避免重名</p><p>node list -&gt;  &#x2F;命名空间&#x2F;name </p></li><li><p>output&#x3D;”log | screen” (可选)</p><p>默认log，但一般改成screen</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;myTurtle&quot; output=&quot;screen&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>include标签</strong></p><p>用于将另一个 xml 格式的 launch 文件导入到当前文件</p><p>file&#x3D;”$(find 包名)&#x2F;xxx&#x2F;xxx.launch”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;!-- 包含 --&gt;</span><br><span class="line">    &lt;include file = &quot;$(find launch01_basic)/launch/start_turtle.launch&quot;/&gt;</span><br><span class="line">    &lt;!-- 其他节点 --&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p>用于复用</p><p><strong>remap标签</strong></p><p>用于话题重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot;  name=&quot;myTurtle&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">    &lt;remap from=&quot;/turtle1/cmd_vel&quot; to = &quot;/cmd_vel&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br><span class="line">&lt;!-- 在launch中的语法是每个标签结束后才标斜杠，没结束还有子标签的话就不标 --&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>from &#x3D; “原始话题名称” to &#x3D; “目标话题名称”</p><p>此时原来的控制失效，因为turtle_teleop_key 是以&#x2F;turtle1&#x2F;cmd_vel 发布</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot;  name=&quot;myTurtleContro&quot; output=&quot;screen&quot; /&gt;</span><br></pre></td></tr></table></figure><p>这里需要下载一个控制包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-teleop-twist-keyboard</span><br></pre></td></tr></table></figure><p><strong>param标签</strong></p><p><code>&lt;param&gt;</code>标签主要用于在参数服务器上设置参数</p><p>在<code>&lt;node&gt;</code>标签中时，相当于私有参数</p><p>在<code>&lt;node&gt;</code>标签外时，相当于全局参数</p><ul><li><p>name&#x3D;”[命名空间]&#x2F;参数名”</p><p>参数名称，可以包含命名空间</p></li><li><p>value&#x3D;”xxx” (可选)</p><p>定义参数值，如果此处省略，必须指定外部文件作为参数源</p></li><li><p>type&#x3D;”str | int | double | bool | yaml” (可选)</p><p>指定参数类型，如果未指定，roslaunch 会尝试确定参数类型，规则如下:</p><ul><li>如果包含 ‘.’ 的数字解析未浮点型，否则为整型</li><li>“true” 和 “false” 是 bool 值(不区分大小写)</li><li>其他是字符串</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;param name=&quot;param_A&quot; type = &quot;int&quot; value =&quot;100&quot; /&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;myTurtle&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">    &lt;remap from=&quot;/turtle1/cmd_vel&quot; to = &quot;/cmd_vel&quot; /&gt;</span><br><span class="line">    &lt;param name=&quot;param_B&quot; type = &quot;double&quot; value =&quot;3.14&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br></pre></td></tr></table></figure><p><strong>rosparam标签</strong></p><p><code>&lt;rosparam&gt;</code>标签可以从 YAML 文件导入参数，或将参数导出到 YAML 文件，也可以用来删除参数</p><ul><li>command&#x3D;”load | dump | delete” (可选，默认 load)</li><li>file&#x3D;”$(find 功能包)&#x2F;xxx&#x2F;yyy….”</li><li>param&#x3D;”参数名称”</li><li>ns&#x3D;”命名空间” (可选)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入参数 --&gt;</span><br><span class="line">&lt;rosparam command = &quot;load&quot; file = &quot;$(find launch01_basic)/launch/param.yaml&quot;/&gt;</span><br></pre></td></tr></table></figure><p>由于launch文件也不是按顺序进行，导出虽然写在launch文件较后的位置也可能无法正常导出，所以最好分两个launch文件，在完成后再进行导出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;!-- 导出参数 --&gt;</span><br><span class="line">    &lt;rosparam command = &quot;dump&quot; file = &quot;$(find launch01_basic)/launch/param_out.yaml&quot;/&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p>删除操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rosparam command = &quot;delete&quot; param = &quot;bg_B&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>group标签</strong></p><p><code>&lt;group&gt;</code>标签可以对节点分组，具有 ns 属性，可以让节点归属某个命名空间</p><ul><li><p>clear_params&#x3D;”true | false” (可选)</p><p>启动前，是否删除组名称空间的所有参数(慎用….此功能危险)</p></li></ul><p>这个时候即使在node中name属性相同也不会报错，因为group使得前面加上前缀，不会产生相同的节点名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch &gt;</span><br><span class="line">    &lt;group ns = &quot;first&quot;&gt;</span><br><span class="line">        &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;myTurtle&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">        &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot;  name=&quot;myTurtleContro&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">    &lt;/group&gt; </span><br><span class="line">    &lt;group ns = &quot;second&quot;&gt;</span><br><span class="line">        &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;myTurtle&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">        &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot;  name=&quot;myTurtleContro&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">    &lt;/group&gt; </span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p><strong>arg标签</strong></p><p><code>&lt;arg&gt;</code>标签是用于动态传参，类似于函数的参数</p><ul><li><p>name&#x3D;”参数名称”</p></li><li><p>default&#x3D;”默认值” (可选)</p></li><li><p>value&#x3D;”数值” (可选)</p><p>不可以与 default 并存</p></li><li><p>doc&#x3D;”描述”</p></li></ul><p>命令行调用传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch hello.launch xxx:=值</span><br></pre></td></tr></table></figure><h3 id="工作空间覆盖"><a href="#工作空间覆盖" class="headerlink" title="工作空间覆盖"></a>工作空间覆盖</h3><p>所谓工作空间覆盖，是指不同工作空间中，存在重名的功能包的情形</p><p>比如：自定义工作空间A存在功能包 turtlesim，自定义工作空间B也存在功能包 turtlesim，当然系统内置空间也存在turtlesim，如果调用turtlesim包，会调用哪个工作空间中的呢</p><ol><li><p>新建工作空间A与工作空间B，两个工作空间中都创建功能包: turtlesim</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ros::init(argc,argv,&quot;hello_ws1&quot;);</span><br><span class="line">    ROS_INFO(&quot;demo01_ws&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了在任何工作空间下调用demo01_ws和demo02_ws，需要在根目录下的.bashrc文件中进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/noetic/setup.bash</span><br><span class="line"># 新增</span><br><span class="line">source /home/ros/demo01_ws/devel/setup.bash</span><br><span class="line">source /home/ros/demo02_ws/devel/setup.bash</span><br></pre></td></tr></table></figure></li><li><p>刷新环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim [TAB]</span><br></pre></td></tr></table></figure><p>会发现直接跳出hello_ws2 </p><p>是因为在.bashrc中后刷新的会覆盖前面的</p></li><li><p>查看ROS环境环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $ROS_PACKAGE_PATH</span><br></pre></td></tr></table></figure><p>ROS_PACKAGE_PATH 中的值，和 .bashrc 的配置顺序相反—&gt;后配置的优先级更高</p></li></ol><p>功能包重名时，会按照 ROS_PACKAGE_PATH 查找，配置在前的会优先执行</p><p><strong>隐患</strong></p><p>比如当前工作空间B优先级更高，意味着当程序调用 turtlesim 时，不会调用工作空间A也不会调用系统内置的 turtlesim，如果工作空间A在实现时有其他功能包依赖于自身的 turtlesim，而按照ROS工作空间覆盖的涉及原则，那么实际执行时将会调用工作空间B的turtlesim，从而导致执行异常，出现安全隐患</p><p>BUG 说明:</p><blockquote><p>在 .bashrc 文件中 source 多个工作空间后，可能出现在 ROS PACKAGE PATH 中只包含两个工作空间，可以删除自定义工作空间的 build 与 devel 目录，重新 catkin_make，然后重新载入 .bashrc 文件，问题解决</p></blockquote><p>目前没有特别的解决方案</p><h3 id="节点名称重名"><a href="#节点名称重名" class="headerlink" title="节点名称重名"></a>节点名称重名</h3><p>ros::init(argc,argv,””)   rospy.init_node(“”)  定义节点名称</p><p>在ROS的网络拓扑中，是不可以出现重名的节点的，也不可以启动重名节点或者同一个节点多次</p><p>在ROS中给出的解决策略是使用命名空间或名称重映射</p><p>命名空间就是为名称添加前缀，名称重映射是为名称起别名</p><h4 id="rosrun实现"><a href="#rosrun实现" class="headerlink" title="rosrun实现"></a>rosrun实现</h4><p><strong>rosrun设置命名空间</strong></p><p>语法: rosrun 包名 节点名 __ns:&#x3D;新名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node __ns:=t1</span><br><span class="line">rosrun turtlesim turtlesim_node __ns:=t2</span><br><span class="line"># 注意，这里=后面不可以有空格</span><br></pre></td></tr></table></figure><p>rosnode list </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/t1/turtlesim</span><br><span class="line">/t2/turtlesim</span><br></pre></td></tr></table></figure><p><strong>rosrun名称重映射</strong></p><p>语法: rosrun 包名 节点名 __name:&#x3D;新名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim  turtlesim_node __name:=t1</span><br><span class="line">rosrun turtlesim  turtlesim_node __name:=t2</span><br></pre></td></tr></table></figure><p><strong>设置命名空间同时名称重映射</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node __ns:=w1 __name:=t1</span><br></pre></td></tr></table></figure><p>使用环境变量也可以设置命名空间，启动节点前在终端键入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ROS_NAMESPACE=sw1</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><h4 id="launch实现"><a href="#launch实现" class="headerlink" title="launch实现"></a>launch实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch &gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;turtlesim&quot; output=&quot;screen&quot;/&gt;</span><br><span class="line">    &lt;!-- 名称重映射 --&gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot; output=&quot;screen&quot;/&gt;</span><br><span class="line">    &lt;!-- 命名空间 --&gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;turtlesim&quot; output=&quot;screen&quot; ns=&quot;p1&quot; /&gt;</span><br><span class="line">    &lt;!-- 命名空间 + 称重映射 --&gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t2&quot; output=&quot;screen&quot; ns=&quot;p2&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p>在 node 标签中，name 属性是必须的，ns 可选</p><p><code>rosnode list</code>查看节点信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/p1/turtlesim</span><br><span class="line">/p2/t2</span><br><span class="line">/rosout</span><br><span class="line">/t1</span><br><span class="line">/turtlesim</span><br></pre></td></tr></table></figure><h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p><strong>c++</strong></p><p>重映射：(设置别名)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc,argv,&quot;name&quot;,ros::init_options::AnonymousName)；</span><br></pre></td></tr></table></figure><p>在名称后面添加时间戳</p><p>命名空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::string&gt; map;</span><br><span class="line">map[&quot;__ns&quot;] = &quot;name&quot;;</span><br><span class="line">ros::init(map,&quot;&quot;);</span><br></pre></td></tr></table></figure><p><strong>python</strong></p><p>重映射：(设置别名)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospy.init_node(&quot;name&quot;,anonymous=True)</span><br></pre></td></tr></table></figure><h3 id="话题名称重名"><a href="#话题名称重名" class="headerlink" title="话题名称重名"></a>话题名称重名</h3><h4 id="rosrun实现-1"><a href="#rosrun实现-1" class="headerlink" title="rosrun实现"></a>rosrun实现</h4><p>语法: rorun 包名 节点名 话题名:&#x3D;新话题名称</p><p>实现teleop_twist_keyboard与乌龟显示节点通信方案</p><p>方案1：将 teleop_twist_keyboard 节点的话题设置为<code>/turtle1/cmd_vel</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun teleop_twist_keyboard teleop_twist_keyboard.py /cmd_vel:=/turtle1/cmd_vel</span><br></pre></td></tr></table></figure><p>这个时候<code>rosrun turtlesim turtle_teleop_key</code> 也能正常控制，相当于两个发布</p><p>方案2：将乌龟显示节点的话题设置为 <code>/cmd_vel</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node /turtle1/cmd_vel:=/cmd_vel</span><br></pre></td></tr></table></figure><h4 id="launch实现-1"><a href="#launch实现-1" class="headerlink" title="launch实现"></a>launch实现</h4><p>在之前launch文件标签那里讲过，这里就给个代码</p><p>语法<code>&lt;remap from=&quot;原话题&quot; to=&quot;新话题&quot; /&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot; /&gt;</span><br><span class="line">    &lt;node pkg=&quot;teleop_twist_keyboard&quot; type=&quot;teleop_twist_keyboard.py&quot; name=&quot;key&quot;&gt;</span><br><span class="line">        &lt;remap from=&quot;/cmd_vel&quot; to=&quot;/turtle1/cmd_vel&quot; /&gt;</span><br><span class="line">    &lt;/node&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;&gt;</span><br><span class="line">        &lt;remap from=&quot;/turtle1/cmd_vel&quot; to=&quot;/cmd_vel&quot; /&gt;</span><br><span class="line">    &lt;/node&gt;</span><br><span class="line">    &lt;node pkg=&quot;teleop_twist_keyboard&quot; type=&quot;teleop_twist_keyboard.py&quot; name=&quot;key&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><h4 id="编码实现-1"><a href="#编码实现-1" class="headerlink" title="编码实现"></a>编码实现</h4><p>话题的名称与节点的命名空间、节点的名称是有一定关系的，话题名称大致可以分为三种类型:</p><ul><li>全局(话题参考ROS系统，与节点命名空间平级)</li><li>相对(话题参考的是节点的命名空间，与节点名称平级)</li><li>私有(话题参考节点名称，是节点名称的子级)</li></ul><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-05-30_21-27-59.webp" alt="Snipaste_2025-05-30_21-27-59" style="zoom: 50%;" /><p><strong>c++</strong>：</p><p>全局名称：以<code>/</code>开头，和节点名称无关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;/chatter&quot;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>相对名称：非<code>/</code>开头，参考命名空间(与节点名称平级)来确定话题名称</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>__ns:&#x3D;设置命名空间后，则话题位于 &#x2F;name&#x2F;chatter</p><p>私有名称：以<code>~</code>开头的名称</p><p>需要在节点handle创建时候做出些改变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ros::NodeHandle <span class="title">nh</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line">ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>但如果话题以<code>/</code>开头则话题仍为全局(全局话题优先级更高)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ros::NodeHandle <span class="title">nh</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line">ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;/chatter&quot;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><strong>python</strong>：</p><p>全局名称：以<code>/</code>开头，和节点名称无关</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub = rospy.Publisher(<span class="string">&quot;/chatter&quot;</span>,String,queue_size=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>相对名称：非<code>/</code>开头，参考命名空间(与节点名称平级)来确定话题名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub = rospy.Publisher(<span class="string">&quot;chatter&quot;</span>,String,queue_size=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>私有名称：以<code>~</code>开头的名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub = rospy.Publisher(<span class="string">&quot;~chatter&quot;</span>,String,queue_size=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="参数名称重名"><a href="#参数名称重名" class="headerlink" title="参数名称重名"></a>参数名称重名</h3><p>在ROS中节点名称话题名称可能出现重名的情况，同理参数名称也可能重名</p><p>当参数名称重名时，那么就会产生覆盖</p><p>关于参数重名的处理，没有重映射实现，为了尽量的避免参数重名，都是使用为参数名添加前缀的方式，实现类似于话题名称，有全局、相对、和私有三种类型之分</p><h4 id="rosrun实现-2"><a href="#rosrun实现-2" class="headerlink" title="rosrun实现"></a>rosrun实现</h4><p>语法：rosrun 包名 节点名称 _参数名:&#x3D;参数值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node _A:=100</span><br></pre></td></tr></table></figure><p>rosparam list 查看节点信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/turtlesim/A</span><br></pre></td></tr></table></figure><p>这种方法创建出来的参数为私有模式</p><h4 id="launch实现-2"><a href="#launch实现-2" class="headerlink" title="launch实现"></a>launch实现</h4><p>在launch文件那部分细讲过了，不再赘述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;param name=&quot;radius&quot; value=&quot;0.2&quot; /&gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot; ns=&quot;xxx&quot;&gt;</span><br><span class="line">        &lt;param name=&quot;radius&quot; value=&quot;0.08&quot; /&gt;</span><br><span class="line">    &lt;/node&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><h4 id="编码实现-2"><a href="#编码实现-2" class="headerlink" title="编码实现"></a>编码实现</h4><p><strong>c++</strong></p><p>使用 ros::param 或者 ros::NodeHandle 来设置参数</p><p>具体内容查看 - ROS通信机制 -&gt; 参数服务器</p><p>ros::param::set，参数1传入参数名称，参数2传入参数值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/set_A&quot;</span>,<span class="number">100</span>); <span class="comment">//全局,和命名空间以及节点名称无关</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;set_B&quot;</span>,<span class="number">100</span>); <span class="comment">//相对,参考命名空间</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;~set_C&quot;</span>,<span class="number">100</span>); <span class="comment">//私有,参考命名空间与节点名称</span></span><br></pre></td></tr></table></figure><p>ros::NodeHandle，首先需要创建 NodeHandle 对象，然后调用该对象的 setParam 函数，该函数参数1为参数名，参数2为要设置的参数值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ros::NodeHandle nh;</span><br><span class="line">nh.<span class="built_in">setParam</span>(<span class="string">&quot;/nh_A&quot;</span>,<span class="number">100</span>); <span class="comment">//全局,和命名空间以及节点名称无关</span></span><br><span class="line"></span><br><span class="line">nh.<span class="built_in">setParam</span>(<span class="string">&quot;nh_B&quot;</span>,<span class="number">100</span>); <span class="comment">//相对,参考命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function">ros::NodeHandle <span class="title">nh_private</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line">nh_private.<span class="built_in">setParam</span>(<span class="string">&quot;nh_C&quot;</span>,<span class="number">100</span>);<span class="comment">//私有,参考命名空间与节点名称</span></span><br></pre></td></tr></table></figure><p><strong>python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rospy.set_param(<span class="string">&quot;/py_A&quot;</span>,<span class="number">100</span>)  <span class="comment">#全局,和命名空间以及节点名称无关</span></span><br><span class="line">rospy.set_param(<span class="string">&quot;py_B&quot;</span>,<span class="number">100</span>)  <span class="comment">#相对,参考命名空间</span></span><br><span class="line">rospy.set_param(<span class="string">&quot;~py_C&quot;</span>,<span class="number">100</span>)  <span class="comment">#私有,参考命名空间与节点名称</span></span><br></pre></td></tr></table></figure><h3 id="分布式通信"><a href="#分布式通信" class="headerlink" title="分布式通信"></a>分布式通信</h3><p>ROS是一个分布式计算环境，一个运行中的ROS系统可以包含分布在多台计算机上多个节点</p><p>ROS对网络配置有某些要求：</p><ul><li>所有端口上的所有机器之间必须有完整的双向连接</li><li>每台计算机必须通过所有其他计算机都可以解析的名称来公告自己</li></ul><p><strong>实现</strong></p><ol><li><p>准备</p><p>先要保证不同计算机处于同一网络中，最好分别设置固定IP，如果为虚拟机，需要将网络适配器改为桥接模式</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/Snipaste_2025-05-31_13-04-06.webp" alt="Snipaste_2025-05-31_13-04-06" style="zoom: 67%;" /><p>修改有线连接的IPv4</p><p>下载包 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>查看网络信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ros-VirtualBox (ROS1)</span><br><span class="line">inet 10.129.163.127 # ip地址</span><br><span class="line">netmask 255.255.248.0 # 子网掩码</span><br><span class="line"># ROS2</span><br><span class="line">inet 10.129.164.127 # ip地址</span><br><span class="line">netmask 255.255.248.0 # 子网掩码</span><br></pre></td></tr></table></figure><p>网关和地址一样，但是最后一组数只留1</p></li><li><p>配置文件修改</p><p>分别修改不同计算机的 &#x2F;etc&#x2F;hosts 文件，在该文件中加入对方的IP地址和计算机名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc</span><br><span class="line">sudo gedit hosts</span><br></pre></td></tr></table></figure><p>可以通过hostname查看计算机名</p><p>设置完毕，可以通过 ping 命令测试网络通信是否正常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 10.129.164.127 #地址 </span><br><span class="line">ping ROS2 #计算机名</span><br></pre></td></tr></table></figure></li><li><p>配置主机</p><p>~&#x2F;.bashrc 追加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># export ROS_MASTER_URI=http://主机IP:11311</span><br><span class="line"># export ROS_HOSTNAME=主机IP</span><br><span class="line"></span><br><span class="line">export ROS_MASTER_URI=http://10.129.163.127:11311</span><br><span class="line">export ROS_HOSTNAME=10.129.163.127</span><br></pre></td></tr></table></figure></li><li><p>配置从机</p><p>从机可以有多台，每台都做设置，~&#x2F;.bashrc 追加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># export ROS_MASTER_URI=http://主机IP:11311</span><br><span class="line"># export ROS_HOSTNAME=从机IP</span><br><span class="line"></span><br><span class="line">export ROS_MASTER_URI=http://10.129.163.127:11311</span><br><span class="line">export ROS_HOSTNAME=10.129.164.127</span><br></pre></td></tr></table></figure><p>source .bashrc  刷新环境变量</p></li></ol><p><strong>测试</strong></p><ol><li><p>主机启动 roscore(必须)</p></li><li><p>主机启动订阅节点，从机启动发布节点，测试通信是否正常</p></li><li><p>反向测试，主机启动发布节点，从机启动订阅节点，测试通信是否正常</p></li></ol><h2 id="ROS常用组件"><a href="#ROS常用组件" class="headerlink" title="ROS常用组件"></a>ROS常用组件</h2><p>章主要介绍ROS中内置的如下组件:</p><ul><li>TF坐标变换，实现不同类型的坐标系之间的转换；</li><li>rosbag 用于录制ROS节点的执行过程并可以重放该过程；</li><li>rqt 工具箱，集成了多款图形化的调试工具</li></ul><p>案例演示: 小乌龟跟随实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roslaunch turtle_tf2 turtle_tf2_demo_cpp.launch</span><br><span class="line">roslaunch turtle_tf2 turtle_tf2_demo.launch </span><br><span class="line"># 如果报错 sudo ln -s /usr/bin/python3 /usr/bin/python</span><br></pre></td></tr></table></figure><h3 id="TF坐标变换"><a href="#TF坐标变换" class="headerlink" title="TF坐标变换"></a>TF坐标变换</h3><p>机器人系统上有多个传感器，如激光雷达、摄像头等，有的是可以感知机器人周边的物体方位(坐标，横向、纵向、高度的距离信息)的，以协助机器人定位障碍物</p><p>但不可以直接将物体相对该传感器的方位信息，等价于物体相对于机器人系统或机器人其它组件的方位信息</p><p>ROS 中直接封装了相关的模块: 坐标变换(TransForm Frame，TF)</p><p>tf2常用功能包有：</p><ul><li><p>tf2_geometry_msgs：将ROS消息转换成tf2消息</p></li><li><p>tf2：封装了坐标变换的常用消息</p><ul><li>欧拉角转四元数：tf2&#x2F;LinearMath&#x2F;Quaternion.h (python：tf.transformations)</li></ul></li><li><p>tf2_ros：为tf2提供了roscpp和rospy绑定，封装了坐标变换常用的API(python比较简洁，直接import tf2_ros就行)，一般创建类对象</p><ul><li>静态变换广播器：tf2_ros&#x2F;static_transform_broadcaster.h</li><li>转换关系订阅器：tf2_ros&#x2F;transform_listener.h</li><li>缓存数据：tf2_ros&#x2F;buffer.h</li></ul></li></ul><p>可以借助于rviz显示坐标系关系</p><ul><li>新建窗口输入命令rviz</li><li>在启动的 rviz 中设置Fixed Frame 为 base_link;</li><li>点击左下的 add 按钮，在弹出的窗口中选择 TF 组件，即可显示坐标关系</li></ul><h4 id="坐标msg消息"><a href="#坐标msg消息" class="headerlink" title="坐标msg消息"></a>坐标msg消息</h4><p>在坐标转换实现中常用的 msg：</p><p><font color='Violetred'>geometry_msgs&#x2F;TransformStamped   传输坐标系相关位置信息</font></p><p><font color='Violetred'>geometry_msgs&#x2F;PointStamped 传输坐标系内坐标点的信息</font>     </p><blockquote><p>c++: 调用PointStamped需要调用tf2_geometry_msgs&#x2F;tf2_geometry_msgs.h</p><p>python: 需要from tf2_geometry_msgs import PointStamped调用</p></blockquote><p>命令行键入:<code>rosmsg info geometry_msgs/TransformStamped</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header                     #头信息</span><br><span class="line">  uint32 seq                                #|-- 序列号</span><br><span class="line">  time stamp                                #|-- 时间戳</span><br><span class="line">  string frame_id                           #|-- 坐标 ID</span><br><span class="line">string child_frame_id                    #子坐标系的 id</span><br><span class="line">geometry_msgs/Transform transform        #坐标信息</span><br><span class="line">  geometry_msgs/Vector3 translation        #偏移量</span><br><span class="line">    float64 x                                #|-- X 方向的偏移量</span><br><span class="line">    float64 y                                #|-- Y 方向的偏移量</span><br><span class="line">    float64 z                                #|-- Z 方向上的偏移量</span><br><span class="line">  geometry_msgs/Quaternion rotation        #四元数</span><br><span class="line">    float64 x                                </span><br><span class="line">    float64 y                                </span><br><span class="line">    float64 z                                </span><br><span class="line">    float64 w</span><br><span class="line"># 四元数用于表示坐标的相对姿态</span><br></pre></td></tr></table></figure><p>命令行键入:<code>rosmsg info geometry_msgs/PointStamped</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header                    #头</span><br><span class="line">  uint32 seq                                #|-- 序号</span><br><span class="line">  time stamp                                #|-- 时间戳</span><br><span class="line">  string frame_id                           #|-- 所属坐标系的 id</span><br><span class="line">geometry_msgs/Point point                #点坐标</span><br><span class="line">  float64 x                                 #|-- x y z 坐标</span><br><span class="line">  float64 y</span><br><span class="line">  float64 z</span><br></pre></td></tr></table></figure><h4 id="静态坐标变换"><a href="#静态坐标变换" class="headerlink" title="静态坐标变换"></a>静态坐标变换</h4><p>静态坐标变换，是指两个坐标系之间的相对位置是固定的</p><p><strong>需求</strong>：</p><p>现有一机器人模型，核心构成包含主体与雷达，各对应一坐标系，坐标系的原点分别位于主体与雷达的物理中心，已知雷达原点相对于主体原点位移关系如下: x 0.2 y0.0 z0.5。当前雷达检测到一障碍物，在雷达坐标系中障碍物的坐标为 (2.0 3.0 5.0),请问，该障碍物相对于主体的坐标是多少？</p><p>添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscpp rospy std_msgs geometry_msgs tf2 tf2_ros tf2_geometry_msgs </span><br></pre></td></tr></table></figure><p><strong>c++</strong></p><p>发布方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/static_transform_broadcaster.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/TransformStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2/LinearMath/Quaternion.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;static_pub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh; <span class="comment">// 非必需</span></span><br><span class="line">    <span class="comment">// 创建发布对象</span></span><br><span class="line">    tf2_ros::StaticTransformBroadcaster pub;</span><br><span class="line">    <span class="comment">// 组织发布消息 </span></span><br><span class="line">    geometry_msgs::TransformStamped tfs;</span><br><span class="line">    <span class="comment">// 设置头信息</span></span><br><span class="line">    tfs.header.stamp = ros::Time::<span class="built_in">now</span>(); <span class="comment">// 时间戳</span></span><br><span class="line">    tfs.header.frame_id = <span class="string">&quot;base_link&quot;</span>; <span class="comment">// 原点坐标系</span></span><br><span class="line">    <span class="comment">// 部件坐标系</span></span><br><span class="line">    tfs.child_frame_id = <span class="string">&quot;laser&quot;</span>; </span><br><span class="line">    <span class="comment">// 部件相对原点的位移</span></span><br><span class="line">    tfs.transform.translation.x = <span class="number">0.2</span>;</span><br><span class="line">    tfs.transform.translation.y = <span class="number">0.0</span>;</span><br><span class="line">    tfs.transform.translation.z = <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 设置四元数</span></span><br><span class="line">    tf2::Quaternion qtn; </span><br><span class="line">    <span class="comment">// 向该对象设置欧拉角,可以将欧拉角转化为四元数</span></span><br><span class="line">    qtn.<span class="built_in">setRPY</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// 翻滚roll,俯仰pitch,偏航yaw,值为弧度</span></span><br><span class="line">    tfs.transform.rotation.x = qtn.<span class="built_in">getX</span>();</span><br><span class="line">    tfs.transform.rotation.y = qtn.<span class="built_in">getY</span>();</span><br><span class="line">    tfs.transform.rotation.z = qtn.<span class="built_in">getZ</span>();</span><br><span class="line">    tfs.transform.rotation.w = qtn.<span class="built_in">getW</span>();  </span><br><span class="line">    <span class="comment">// 发布数据</span></span><br><span class="line">    pub.<span class="built_in">sendTransform</span>(tfs);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/欧拉角1.webp" alt="欧拉角1" style="zoom: 67%;" /><blockquote><p>欧拉角：翻滚roll,俯仰pitch,偏航yaw，对应绕xyz轴旋转多少度</p><p>转化为四元数是为了避免出现万向节死锁，当俯仰角达到90°时（机头垂直向下），此时横滚（X轴）和偏航（Z轴）<code>重合为同一旋转轴</code>，无法区分左右倾斜和水平转向</p><p>四元数：由1个实部 + 3个虚部组成，这个转化过程计算太复杂了，会用就行</p></blockquote><p>订阅方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/transform_listener.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/PointStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;static_sub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">// 创建TF订阅节点</span></span><br><span class="line">    <span class="comment">// 创建一个Buffer 缓存</span></span><br><span class="line">    tf2_ros::Buffer buffer;</span><br><span class="line">    <span class="comment">// 创建监听对象(可以将订阅数据放入buffer)</span></span><br><span class="line">    <span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buffer)</span></span>;</span><br><span class="line">    <span class="comment">// 正常雷达不断扫描坐标</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 组织一个部件坐标系</span></span><br><span class="line">        geometry_msgs::PointStamped point_laser;</span><br><span class="line">        <span class="comment">// 部件坐标系名称 与发布方的child_frame_id 相同</span></span><br><span class="line">        point_laser.header.frame_id = <span class="string">&quot;laser&quot;</span>; </span><br><span class="line">        point_laser.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        <span class="comment">// 检测物体信息(部件坐标系位置)</span></span><br><span class="line">        point_laser.point.x = <span class="number">2.0</span>;</span><br><span class="line">        point_laser.point.y = <span class="number">3.0</span>;</span><br><span class="line">        point_laser.point.z = <span class="number">5.0</span>;</span><br><span class="line">        <span class="comment">// 添加休眠,避免开始的时候没有找到发布的坐标系相对关系,导致异常</span></span><br><span class="line">        <span class="comment">// ros::Duration(2); 但是用try的方法更好</span></span><br><span class="line">        <span class="comment">// 转换坐标点(相对于原点坐标系)</span></span><br><span class="line">        <span class="comment">// 新建一个坐标点，用于接收转换结果 </span></span><br><span class="line">        <span class="comment">// 使用 try 语句或休眠，否则可能由于缓存接收延迟而导致坐标转换失败</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 核心代码,将部件坐标系坐标点转化为原点坐标系坐标点</span></span><br><span class="line">            geometry_msgs::PointStamped point_base;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                调用的是buffer的转换函数transform</span></span><br><span class="line"><span class="comment">                参数1是被转换的坐标点</span></span><br><span class="line"><span class="comment">                参数2是目标坐标系</span></span><br><span class="line"><span class="comment">                返回输出的坐标点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                PS:调用时需要加头文件 tf2_geometry_msgs/tf2_geometry_msgs.h</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            point_base = buffer.<span class="built_in">transform</span>(point_laser,<span class="string">&quot;base_link&quot;</span>); </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;转换后的坐标值:(%.2f,%.2f,%.2f),参考的坐标系:%s&quot;</span>,</span><br><span class="line">                point_base.point.x,</span><br><span class="line">                point_base.point.y,</span><br><span class="line">                point_base.point.z,</span><br><span class="line">                point_base.header.frame_id.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;程序异常.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r.<span class="built_in">sleep</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tos::NodeHandle nh 注册节点到ROS Master，提供访问ROS功能（如话题、服务、参数）的接口，如如果删除 ros::NodeHandle nh，<code>TransformListener</code> 的订阅失败，<code>buffer</code> 收不到TF数据</p><p><strong>python</strong></p><p>发布方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> tf.transformations</span><br><span class="line"><span class="keyword">import</span> tf2_ros</span><br><span class="line"><span class="keyword">import</span> tf</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> TransformStamped</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;static_pub_p&quot;</span>)</span><br><span class="line">    pub = tf2_ros.StaticTransformBroadcaster()</span><br><span class="line">    <span class="comment"># 组织发布的数据</span></span><br><span class="line">    tfs = TransformStamped()</span><br><span class="line">    <span class="comment"># 设置头信息</span></span><br><span class="line">    tfs.header.stamp = rospy.Time.now()  <span class="comment"># 时间戳信息</span></span><br><span class="line">    tfs.header.frame_id = <span class="string">&quot;base_link&quot;</span>  <span class="comment"># 原点坐标系id</span></span><br><span class="line">    <span class="comment"># 设置部件坐标系id</span></span><br><span class="line">    tfs.child_frame_id = <span class="string">&quot;laser&quot;</span></span><br><span class="line">    <span class="comment"># 部件相对原点的位移</span></span><br><span class="line">    tfs.transform.translation.x = <span class="number">0.2</span></span><br><span class="line">    tfs.transform.translation.y = <span class="number">0.0</span></span><br><span class="line">    tfs.transform.translation.z = <span class="number">0.5</span></span><br><span class="line">    <span class="comment"># 设置四元数</span></span><br><span class="line">    qtn = tf.transformations.quaternion_from_euler(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    tfs.transform.rotation.x = qtn[<span class="number">0</span>]</span><br><span class="line">    tfs.transform.rotation.y = qtn[<span class="number">1</span>]</span><br><span class="line">    tfs.transform.rotation.z = qtn[<span class="number">2</span>]</span><br><span class="line">    tfs.transform.rotation.w = qtn[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># 广播发送</span></span><br><span class="line">    pub.sendTransform(tfs)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><p>订阅方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> tf2_ros</span><br><span class="line"><span class="comment"># 不要使用 geometry_msgs,需要使用 tf2 内置的消息类型</span></span><br><span class="line"><span class="keyword">from</span> tf2_geometry_msgs <span class="keyword">import</span> PointStamped</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;static_sub_p&quot;</span>)</span><br><span class="line">    buffer = tf2_ros.Buffer()</span><br><span class="line">    listener = tf2_ros.TransformListener(buffer)</span><br><span class="line">    rate = rospy.Rate(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        <span class="comment"># 组织一个部件坐标系 </span></span><br><span class="line">        point_laser = PointStamped()</span><br><span class="line">        <span class="comment"># 部件坐标系名称</span></span><br><span class="line">        point_laser.header.frame_id = <span class="string">&quot;laser&quot;</span></span><br><span class="line">        <span class="comment"># 坐标点数据</span></span><br><span class="line">        point_laser.header.stamp = rospy.Time.now()</span><br><span class="line">        point_laser.point.x = <span class="number">2.0</span></span><br><span class="line">        point_laser.point.y = <span class="number">3.0</span></span><br><span class="line">        point_laser.point.z = <span class="number">5.0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 组织一个转换参考系</span></span><br><span class="line">            point_base = PointStamped()</span><br><span class="line">            <span class="comment"># 坐标转换</span></span><br><span class="line">            point_base = buffer.transform(point_laser,<span class="string">&quot;base_link&quot;</span>)</span><br><span class="line">            rospy.loginfo(<span class="string">&quot;转换后的坐标值:(%.2f,%.2f,%.2f),参考的坐标系:%s&quot;</span>,</span><br><span class="line">                point_base.point.x,</span><br><span class="line">                point_base.point.y,</span><br><span class="line">                point_base.point.z,</span><br><span class="line">                point_base.header.frame_id)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            rospy.logerr(<span class="string">&quot;异常:%s&quot;</span>,e)</span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><p>python 这里不写spin是因为python没有spinOnce，无法跳过循环</p><p>当坐标系之间的相对位置固定时，那么所需参数也是固定的，实现逻辑相同，参数不同，那么 ROS 系统就已经封装好了专门的节点，使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf2_ros static_transform_publisher x偏移量 y偏移量 z偏移量 z偏航角度 y俯仰角度 x翻滚角度 父级坐标系 子级坐标系</span><br></pre></td></tr></table></figure><p>其实父系就是代码中的原点坐标系，子级就是代码中的部件坐标系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf2_ros static_transform_publisher 0.2 0 0.5 0 0 0 /base_link /laser</span><br></pre></td></tr></table></figure><p><font color='Violetred'>建议使用该种方式直接实现静态坐标系相对信息发布</font></p><h4 id="动态坐标变换"><a href="#动态坐标变换" class="headerlink" title="动态坐标变换"></a>动态坐标变换</h4><p><strong>需求</strong>：</p><p>启动 turtlesim_node，该节点中窗体有一个世界坐标系(左下角为坐标系原点)，乌龟是另一个坐标系，键盘控制乌龟运动，将两个坐标系的相对位置动态发布</p><p>依赖同静态</p><p><strong>c++</strong></p><p>发布方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/transform_broadcaster.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/TransformStamped.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2/LinearMath/Quaternion.h&quot;</span> </span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    发布方：需要订阅乌龟的位姿信息，转换成相对于窗体的坐标关系，并发布</span></span><br><span class="line"><span class="comment">    准 备</span></span><br><span class="line"><span class="comment">        话题：/turtle1/pose</span></span><br><span class="line"><span class="comment">        消息：/turtlesim/Pose</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPose</span><span class="params">(<span class="type">const</span> turtlesim::Pose::ConstPtr&amp; pose)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取位姿信息，转换成坐标系相对关系(核心),并发布</span></span><br><span class="line">    <span class="comment">// 创建发布对象</span></span><br><span class="line">    <span class="comment">// tf2_ros::TransformBroadcaster pub; 如果这么写每次处理都要创建一个新的发布对象</span></span><br><span class="line">    <span class="type">static</span> tf2_ros::TransformBroadcaster pub; <span class="comment">// 静态发布对象</span></span><br><span class="line">    <span class="comment">// 处理发布数据</span></span><br><span class="line">    geometry_msgs::TransformStamped tfs;</span><br><span class="line">    tfs.header.frame_id = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    tfs.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    tfs.child_frame_id = <span class="string">&quot;turtle1&quot;</span>;</span><br><span class="line">    <span class="comment">// 从乌龟位姿信息获取坐标</span></span><br><span class="line">    tfs.transform.translation.x = pose-&gt;x;</span><br><span class="line">    tfs.transform.translation.y = pose-&gt;y;</span><br><span class="line">    tfs.transform.translation.z = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 坐标系四元数</span></span><br><span class="line">    <span class="comment">// pose 信息中只有偏航yaw -&gt; theta,二维没有翻滚roll,俯仰pitch</span></span><br><span class="line">    <span class="comment">// 欧拉角为 (0,0,theta)</span></span><br><span class="line">    tf2::Quaternion qtn;</span><br><span class="line">    qtn.<span class="built_in">setRPY</span>(<span class="number">0</span>,<span class="number">0</span>,pose-&gt;theta);</span><br><span class="line">    tfs.transform.rotation.x = qtn.<span class="built_in">getX</span>();</span><br><span class="line">    tfs.transform.rotation.y = qtn.<span class="built_in">getY</span>();</span><br><span class="line">    tfs.transform.rotation.z = qtn.<span class="built_in">getZ</span>();</span><br><span class="line">    tfs.transform.rotation.w = qtn.<span class="built_in">getW</span>();</span><br><span class="line">    <span class="comment">// 发布</span></span><br><span class="line">    pub.<span class="built_in">sendTransform</span>(tfs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;dynamic_pub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">// 创建订阅对象</span></span><br><span class="line">    ros::Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;turtle1/pose&quot;</span>,<span class="number">100</span>,doPose);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅方：</p><p>代码和静态的类似，可以直接复制粘贴改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/transform_listener.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/buffer.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/PointStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;dynamic_sub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">// 创建TF订阅节点 -&gt; 订阅相对关系</span></span><br><span class="line">    <span class="comment">// 创建一个Buffer 缓存</span></span><br><span class="line">    tf2_ros::Buffer buffer;</span><br><span class="line">    <span class="comment">// 创建监听对象(可以将订阅数据放入buffer)</span></span><br><span class="line">    <span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buffer)</span></span>;</span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 组织一个部件坐标系</span></span><br><span class="line">    geometry_msgs::PointStamped point_turtle;</span><br><span class="line">    point_turtle.header.frame_id = <span class="string">&quot;turtle1&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 try 语句或休眠，否则可能由于缓存接收延迟而导致坐标转换失败</span></span><br><span class="line">        point_turtle.header.stamp = ros::<span class="built_in">Time</span>(<span class="number">0.0</span>);</span><br><span class="line">        point_turtle.point.x = <span class="number">1</span>;</span><br><span class="line">        point_turtle.point.y = <span class="number">1</span>;</span><br><span class="line">        point_turtle.point.z = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 核心代码,将部件坐标系坐标点转化为原点坐标系坐标点</span></span><br><span class="line">            geometry_msgs::PointStamped point_world;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                调用的是buffer的转换函数transform</span></span><br><span class="line"><span class="comment">                参数1是被转换的坐标点</span></span><br><span class="line"><span class="comment">                参数2是目标坐标系</span></span><br><span class="line"><span class="comment">                返回输出的坐标点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                PS:调用时需要加头文件 tf2_geometry_msgs/tf2_geometry_msgs.h</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            point_world = buffer.<span class="built_in">transform</span>(point_turtle,<span class="string">&quot;world&quot;</span>); </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;转换后的坐标值:(%.2f,%.2f,%.2f),参考的坐标系:%s&quot;</span>,</span><br><span class="line">                point_world.point.x,</span><br><span class="line">                point_world.point.y,</span><br><span class="line">                point_world.point.z,</span><br><span class="line">                point_world.header.frame_id.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;程序异常.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r.<span class="built_in">sleep</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里<code>ros::Time</code>不可以用now 了，因为动态使得部件位置一直在发生变化，buffer接收有延迟，使得部件相对位置和检测物体位置的时间戳匹配不上，这个时候就会报错，设置ros::time(0.0)或者空数值就可以避免这个问题(不考虑时间戳继续转化)</p><p><strong>python</strong></p><p>订阅方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> turtlesim.msg <span class="keyword">import</span> Pose</span><br><span class="line"><span class="keyword">import</span> tf2_ros</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> TransformStamped</span><br><span class="line"><span class="keyword">import</span> tf.transformations</span><br><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    发布方：需要订阅乌龟的位姿信息，转换成相对于窗体的坐标关系，并发布</span></span><br><span class="line"><span class="string">    准 备</span></span><br><span class="line"><span class="string">        话题：/turtle1/pose</span></span><br><span class="line"><span class="string">        消息：/turtlesim/Pose</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doPose</span>(<span class="params">pose</span>):</span><br><span class="line"><span class="comment"># 1. 创建发布坐标系相对关系的对象</span></span><br><span class="line">    pub = tf2_ros.TransformBroadcaster()</span><br><span class="line">    <span class="comment"># 2. 将pose转换成坐标系相对关系消息</span></span><br><span class="line">    tfs = TransformStamped()</span><br><span class="line">    tfs.header.frame_id = <span class="string">&quot;world&quot;</span></span><br><span class="line">    tfs.header.stamp = rospy.Time.now()</span><br><span class="line">    tfs.child_frame_id = <span class="string">&quot;turtle1&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成部件坐标系相对于原点坐标系的偏移量</span></span><br><span class="line">    tfs.transform.translation.x = pose.x</span><br><span class="line">    tfs.transform.translation.y = pose.y</span><br><span class="line">    tfs.transform.translation.z = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 四元数,从欧拉角转换</span></span><br><span class="line">    qtn = tf.transformations.quaternion_from_euler(<span class="number">0</span>,<span class="number">0</span>,pose.theta)</span><br><span class="line">    tfs.transform.rotation.x = qtn[<span class="number">0</span>]</span><br><span class="line">    tfs.transform.rotation.y = qtn[<span class="number">1</span>]</span><br><span class="line">    tfs.transform.rotation.z = qtn[<span class="number">2</span>]</span><br><span class="line">    tfs.transform.rotation.w = qtn[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 发布</span></span><br><span class="line">    pub.sendTransform(tfs)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;dynamic_pub_p&quot;</span>)</span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;/turtle1/pose&quot;</span>,Pose,doPose,queue_size=<span class="number">100</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><p>订阅方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> tf2_ros</span><br><span class="line"><span class="comment"># 不要使用 geometry_msgs,需要使用 tf2 内置的消息类型</span></span><br><span class="line"><span class="keyword">from</span> tf2_geometry_msgs <span class="keyword">import</span> PointStamped</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;dynamic_sub_p&quot;</span>)</span><br><span class="line">    buffer = tf2_ros.Buffer()</span><br><span class="line">    listener = tf2_ros.TransformListener(buffer)</span><br><span class="line">    rate = rospy.Rate(<span class="number">1</span>)</span><br><span class="line">    point_turtle = PointStamped()</span><br><span class="line">    point_turtle.header.frame_id = <span class="string">&quot;turtle1&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        point_turtle.header.stamp = rospy.Time()</span><br><span class="line">        point_turtle.point.x = <span class="number">1</span></span><br><span class="line">        point_turtle.point.y = <span class="number">1</span> </span><br><span class="line">        point_turtle.point.z = <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            point_world = buffer.transform(point_turtle,<span class="string">&quot;world&quot;</span>)</span><br><span class="line">            rospy.loginfo(<span class="string">&quot;转换后的坐标值:(%.2f,%.2f,%.2f)&quot;</span>,</span><br><span class="line">                point_world.point.x,</span><br><span class="line">                point_world.point.y,</span><br><span class="line">                point_world.point.z,)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            rospy.loginfo(<span class="string">&quot;异常:%s&quot;</span>,e)</span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><h4 id="多坐标系变换"><a href="#多坐标系变换" class="headerlink" title="多坐标系变换"></a>多坐标系变换</h4><p><strong>需求</strong>：</p><p>现有坐标系统，父级坐标系统 world,下有两子级系统 son1，son2，son1 相对于 world，以及 son2 相对于 world 的关系是已知的，求 son1原点在 son2中的坐标，又已知在 son1中一点的坐标，要求求出该点在 son2 中的坐标</p><p>发布方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;son1&quot; args=&quot;5 1 0 0 0 0 /world /son1&quot; output=&quot;screen&quot;/&gt;</span><br><span class="line">    &lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;son2&quot; args=&quot;-5 -1 0 0 0 0 /world /son2&quot; output=&quot;screen&quot;/&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p>使用launch文件建立两个子坐标系</p><p>订阅方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/transform_listener.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/buffer.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/PointStamped.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/TransformStamped.h&quot;</span></span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    订阅方实现：</span></span><br><span class="line"><span class="comment">        1. 计算son1与son2的相对关系</span></span><br><span class="line"><span class="comment">        2. 计算son1中的某个点在son2中的坐标值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;tfs_sub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    tf2_ros::Buffer buffer;</span><br><span class="line">    <span class="function">tf2_ros::TransformListener <span class="title">sub</span><span class="params">(buffer)</span></span>;</span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 创建坐标点</span></span><br><span class="line">    geometry_msgs::PointStamped psAtSon1;</span><br><span class="line">    psAtSon<span class="number">1.</span>header.frame_id = <span class="string">&quot;son1&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line"></span><br><span class="line">        psAtSon<span class="number">1.</span>header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        psAtSon<span class="number">1.</span>point.x = <span class="number">1.0</span>;</span><br><span class="line">        psAtSon<span class="number">1.</span>point.y = <span class="number">2.0</span>;</span><br><span class="line">        psAtSon<span class="number">1.</span>point.z = <span class="number">3.0</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            geometry_msgs::PointStamped psAtSon2;</span><br><span class="line">            <span class="comment">// 计算son1 和son2 的坐标关系</span></span><br><span class="line">            <span class="comment">// lookupTransform:参数1父级坐标系,参数2子坐标系,参数3ros::Time(0) 取间隔最小的两个时间戳进行计算</span></span><br><span class="line">            geometry_msgs::TransformStamped son1Toson2 = buffer.<span class="built_in">lookupTransform</span>(<span class="string">&quot;son2&quot;</span>,<span class="string">&quot;son1&quot;</span>,ros::<span class="built_in">Time</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;son1 相对 son2 的信息: 父级:%s,子级:%s, 偏移量:(%.2f,%.2f,%.2f)&quot;</span>,</span><br><span class="line">                    son1Toson<span class="number">2.</span>header.frame_id.<span class="built_in">c_str</span>(),</span><br><span class="line">                    son1Toson<span class="number">2.</span>child_frame_id.<span class="built_in">c_str</span>(),</span><br><span class="line">                    son1Toson<span class="number">2.</span>transform.translation.x,</span><br><span class="line">                    son1Toson<span class="number">2.</span>transform.translation.y,</span><br><span class="line">                    son1Toson<span class="number">2.</span>transform.translation.z</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算son1中某个点在son2中的坐标值</span></span><br><span class="line">            psAtSon2 = buffer.<span class="built_in">transform</span>(psAtSon1,<span class="string">&quot;son2&quot;</span>);</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;坐标点在Son2中的值:(%.2f,%.2f,%.2f)&quot;</span>,</span><br><span class="line">                    psAtSon<span class="number">2.</span>point.x,</span><br><span class="line">                    psAtSon<span class="number">2.</span>point.y,</span><br><span class="line">                    psAtSon<span class="number">2.</span>point.z);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;错误提示:%s&quot;</span>,e.<span class="built_in">what</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.导包</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> tf2_ros</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> TransformStamped</span><br><span class="line"><span class="keyword">from</span> tf2_geometry_msgs <span class="keyword">import</span> PointStamped</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.初始化 ROS 节点</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;frames_sub_p&quot;</span>)</span><br><span class="line">    <span class="comment"># 3.创建 TF 订阅对象</span></span><br><span class="line">    buffer = tf2_ros.Buffer()</span><br><span class="line">    listener = tf2_ros.TransformListener(buffer)</span><br><span class="line"></span><br><span class="line">    rate = rospy.Rate(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 4.调用 API 求出 son1 相对于 son2 的坐标关系</span></span><br><span class="line">            <span class="comment">#lookup_transform(self, target_frame, source_frame, time, timeout=rospy.Duration(0.0)):</span></span><br><span class="line">            tfs = buffer.lookup_transform(<span class="string">&quot;son2&quot;</span>,<span class="string">&quot;son1&quot;</span>,rospy.Time(<span class="number">0</span>))</span><br><span class="line">            rospy.loginfo(<span class="string">&quot;son1 与 son2 相对关系:&quot;</span>)</span><br><span class="line">            rospy.loginfo(<span class="string">&quot;父级坐标系:%s&quot;</span>,tfs.header.frame_id)</span><br><span class="line">            rospy.loginfo(<span class="string">&quot;子级坐标系:%s&quot;</span>,tfs.child_frame_id)</span><br><span class="line">            rospy.loginfo(<span class="string">&quot;相对坐标:x=%.2f, y=%.2f, z=%.2f&quot;</span>,</span><br><span class="line">                        tfs.transform.translation.x,</span><br><span class="line">                        tfs.transform.translation.y,</span><br><span class="line">                        tfs.transform.translation.z,</span><br><span class="line">            )</span><br><span class="line">        <span class="comment"># 5.创建一依赖于 son1 的坐标点，调用 API 求出该点在 son2 中的坐标</span></span><br><span class="line">            point_source = PointStamped()</span><br><span class="line">            point_source.header.frame_id = <span class="string">&quot;son1&quot;</span></span><br><span class="line">            point_source.header.stamp = rospy.Time.now()</span><br><span class="line">            point_source.point.x = <span class="number">1</span></span><br><span class="line">            point_source.point.y = <span class="number">1</span></span><br><span class="line">            point_source.point.z = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            point_target = buffer.transform(point_source,<span class="string">&quot;son2&quot;</span>,rospy.Duration(<span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line">            rospy.loginfo(<span class="string">&quot;point_target 所属的坐标系:%s&quot;</span>,point_target.header.frame_id)</span><br><span class="line">            rospy.loginfo(<span class="string">&quot;坐标点相对于 son2 的坐标:(%.2f,%.2f,%.2f)&quot;</span>,</span><br><span class="line">                        point_target.point.x,</span><br><span class="line">                        point_target.point.y,</span><br><span class="line">                        point_target.point.z</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            rospy.logerr(<span class="string">&quot;错误提示:%s&quot;</span>,e)</span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><h4 id="坐标系关系查看"><a href="#坐标系关系查看" class="headerlink" title="坐标系关系查看"></a>坐标系关系查看</h4><p>在机器人系统中，涉及的坐标系有多个，为了方便查看，ros 提供了专门的工具，可以用于生成显示坐标系关系的 pdf 文件，该文件包含树形结构的坐标系图谱</p><p>安装指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-tf2-tools</span><br></pre></td></tr></table></figure><p>启动坐标系广播程序之后，运行如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf2_tools view_frames.py</span><br></pre></td></tr></table></figure><p>会产生类似于下面的日志信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [1592920556.827549]: Listening to tf data during 5 seconds...</span><br><span class="line">[INFO] [1592920561.841536]: Generating graph in frames.pdf file...</span><br></pre></td></tr></table></figure><p>查看当前目录会生成一个 frames.pdf 文件</p><p>可以直接进入目录打开文件，或者调用命令查看文件:<code>evince frames.pdf</code></p><h4 id="坐标变换实操"><a href="#坐标变换实操" class="headerlink" title="坐标变换实操"></a>坐标变换实操</h4><p>需求描述：程序启动之初产生两只乌龟，中间的乌龟(A) 和 左下乌龟(B)，B 会自动运行至A的位置，并且键盘控制时，只是控制 A 的运动，但是 B 可以跟随 A 运行</p><p>实现分析：</p><p>乌龟跟随实现的核心，是乌龟A和B都要发布相对世界坐标系的坐标信息，然后，订阅到该信息需要转换获取A相对于B坐标系的信息，最后，再生成速度信息，并控制B运动。</p><ol><li>启动乌龟显示节点</li><li>在乌龟显示窗体中生成一只新的乌龟(需要使用服务)</li><li>编写两只乌龟发布坐标信息的节点</li><li>编写订阅节点订阅坐标信息并生成新的相对关系生成速度信息</li></ol><p>实现流程：</p><ol><li>新建功能包，添加依赖</li><li>编写服务客户端，用于生成一只新的乌龟</li><li>编写发布方，发布两只乌龟的坐标信息</li><li>编写订阅方，订阅两只乌龟信息，生成速度信息并发布</li><li>运行</li></ol><p>创建第二只乌龟需要使用rosservice，话题使用的是 spawn</p><p>位置信息通过话题 &#x2F;乌龟名称&#x2F;pose 来获取的</p><p>创建功能包依赖于 tf2、tf2_ros、tf2_geometry_msgs、roscpp rospy std_msgs geometry_msgs、turtlesim</p><p><strong>服务客户端(生成乌龟)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/Spawn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;turtle_new&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    ros::ServiceClient client = nh.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">    <span class="comment">// 请求内容</span></span><br><span class="line">    turtlesim::Spawn spawn;</span><br><span class="line">    spawn.request.x = <span class="number">1</span>;</span><br><span class="line">    spawn.request.y = <span class="number">3</span>;</span><br><span class="line">    spawn.request.theta = <span class="number">1.57</span>;</span><br><span class="line">    spawn.request.name = <span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line">    <span class="comment">// 等待服务器启动</span></span><br><span class="line">    client.<span class="built_in">waitForExistence</span>();</span><br><span class="line">    <span class="comment">// call 发送请求,flag反应结果</span></span><br><span class="line">    <span class="type">bool</span> flag = client.<span class="built_in">call</span>(spawn);</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;新的乌龟生成,名称:%s&quot;</span>,spawn.response.name.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;乌龟生成失败！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发布方(发布两只乌龟的坐标信息)</strong></p><ul><li>该节点需要启动两次</li><li>每次启动时都需要传入乌龟节点名称(第一次是 turtle1 第二次是 turtle2)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/transform_broadcaster.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/TransformStamped.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2/LinearMath/Quaternion.h&quot;</span> </span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    发布方：需要订阅乌龟的位姿信息，转换成相对于窗体的坐标关系，并发布</span></span><br><span class="line"><span class="comment">    准 备</span></span><br><span class="line"><span class="comment">        话题：/turtle1/pose</span></span><br><span class="line"><span class="comment">        消息：/turtlesim/Pose</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明传入的变量</span></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPose</span><span class="params">(<span class="type">const</span> turtlesim::Pose::ConstPtr&amp; pose)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取位姿信息，转换成坐标系相对关系(核心),并发布</span></span><br><span class="line">    <span class="comment">// 创建发布对象</span></span><br><span class="line">    <span class="comment">// tf2_ros::TransformBroadcaster pub; 如果这么写每次处理都要创建一个新的发布对象</span></span><br><span class="line">    <span class="type">static</span> tf2_ros::TransformBroadcaster pub; <span class="comment">// 静态发布对象</span></span><br><span class="line">    <span class="comment">// 处理发布数据</span></span><br><span class="line">    geometry_msgs::TransformStamped tfs;</span><br><span class="line">    tfs.header.frame_id = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    tfs.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// tfs.child_frame_id 动态传入</span></span><br><span class="line">    tfs.child_frame_id = turtle_name;</span><br><span class="line">    <span class="comment">// 从乌龟位姿信息获取坐标</span></span><br><span class="line">    tfs.transform.translation.x = pose-&gt;x;</span><br><span class="line">    tfs.transform.translation.y = pose-&gt;y;</span><br><span class="line">    tfs.transform.translation.z = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 坐标系四元数</span></span><br><span class="line">    <span class="comment">// pose 信息中只有偏航yaw -&gt; theta,二维没有翻滚roll,俯仰pitch</span></span><br><span class="line">    <span class="comment">// 欧拉角为 (0,0,theta)</span></span><br><span class="line">    tf2::Quaternion qtn;</span><br><span class="line">    qtn.<span class="built_in">setRPY</span>(<span class="number">0</span>,<span class="number">0</span>,pose-&gt;theta);</span><br><span class="line">    tfs.transform.rotation.x = qtn.<span class="built_in">getX</span>();</span><br><span class="line">    tfs.transform.rotation.y = qtn.<span class="built_in">getY</span>();</span><br><span class="line">    tfs.transform.rotation.z = qtn.<span class="built_in">getZ</span>();</span><br><span class="line">    tfs.transform.rotation.w = qtn.<span class="built_in">getW</span>();</span><br><span class="line">    <span class="comment">// 发布</span></span><br><span class="line">    pub.<span class="built_in">sendTransform</span>(tfs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;dynamic_pub&quot;</span>);</span><br><span class="line">    <span class="comment">// 解析argc传入的参数</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;请传入一个参数&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        turtle_name = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;乌龟 %s 坐标发送启动&quot;</span>,turtle_name.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">// 创建订阅对象,订阅话题动态传入</span></span><br><span class="line">    ros::Subscriber sub = nh.<span class="built_in">subscribe</span>(turtle_name + <span class="string">&quot;/pose&quot;</span>,<span class="number">100</span>,doPose);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>订阅方(解析坐标信息并生成速度信息)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/transform_listener.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/PointStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/TransformStamped.h&quot;</span> <span class="comment">// buffer.lookupTransform 返回值类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/Twist.h&quot;</span> <span class="comment">//速度信息</span></span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    订阅方实现：</span></span><br><span class="line"><span class="comment">        1. 计算turtle1相对turtle2的关系</span></span><br><span class="line"><span class="comment">        2. 计算线速度和角速度发布</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;control&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    tf2_ros::Buffer buffer;</span><br><span class="line">    <span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buffer)</span></span>; <span class="comment">// 不能删监听器</span></span><br><span class="line">    <span class="comment">// 创建发布对象</span></span><br><span class="line">    ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle2/cmd_vel&quot;</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 参数1父级坐标系,参数2子坐标系,参数3ros::Time(0) 取间隔最小的两个时间戳进行计算</span></span><br><span class="line">            geometry_msgs::TransformStamped tfs = buffer.<span class="built_in">lookupTransform</span>(<span class="string">&quot;turtle2&quot;</span>,<span class="string">&quot;turtle1&quot;</span>,ros::<span class="built_in">Time</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// ROS_INFO(&quot;%s 相对 %s 的偏移量:(%.2f,%.2f,%.2f)&quot;,</span></span><br><span class="line">            <span class="comment">//         tfs.child_frame_id.c_str(),</span></span><br><span class="line">            <span class="comment">//         tfs.header.frame_id.c_str(),</span></span><br><span class="line">            <span class="comment">//         tfs.transform.translation.x,</span></span><br><span class="line">            <span class="comment">//         tfs.transform.translation.y,</span></span><br><span class="line">            <span class="comment">//         tfs.transform.translation.z</span></span><br><span class="line">            <span class="comment">//     );</span></span><br><span class="line">            geometry_msgs::Twist twist;</span><br><span class="line">            <span class="comment">// 2D只需要配置角速度z和线速度x</span></span><br><span class="line">            <span class="comment">// x = 系数*\sqrt&#123;(y^2+x^2)&#125;</span></span><br><span class="line">            <span class="comment">// z = 系数*arctan(y/x)</span></span><br><span class="line">            twist.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(tfs.transform.translation.x,<span class="number">2</span>)+<span class="built_in">pow</span>(tfs.transform.translation.y,<span class="number">2</span>));</span><br><span class="line">            twist.angular.z = <span class="number">0.5</span> * <span class="built_in">atan2</span>(tfs.transform.translation.y,tfs.transform.translation.x);</span><br><span class="line">            <span class="comment">// 发布</span></span><br><span class="line">            pub.<span class="built_in">publish</span>(twist);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;错误提示:%s&quot;</span>,e.<span class="built_in">what</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行</strong></p><p>使用launch文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 启动乌龟GUI节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;turtle1&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_teleop_key&quot;</span> <span class="attr">name</span>=<span class="string">&quot;key&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 生成新乌龟节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf04_test&quot;</span> <span class="attr">type</span>=<span class="string">&quot;new_turtle&quot;</span> <span class="attr">name</span>=<span class="string">&quot;turtle2&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3. 设置两个乌龟相对于世界坐标的发布 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf04_test&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dynamic_pub&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pub1&quot;</span> <span class="attr">args</span>=<span class="string">&quot;turtle1&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf04_test&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dynamic_pub&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pub2&quot;</span> <span class="attr">args</span>=<span class="string">&quot;turtle2&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4. 订阅两只乌龟相对于世界坐标系的信息,并转化为turtle1相对于turtle2的坐标关系</span></span><br><span class="line"><span class="comment">            再生成速度信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf04_test&quot;</span> <span class="attr">type</span>=<span class="string">&quot;control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;control&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h3><p>机器人传感器获取到的信息，有时我们可能需要时时处理，有时可能只是采集数据，事后分析</p><p>机器人导航实现中，可能需要绘制导航所需的全局地图，地图绘制实现，有两种方式</p><ul><li>方式1：控制机器人运动，将机器人传感器感知到的数据时时处理，生成地图信息</li><li>方式2：控制机器人运动，将机器人传感器感知到的数据留存，事后再重新读取数据，生成地图信息</li></ul><p>两种方式比较，显然方式2使用上更为灵活方便</p><p>在ROS中关于数据的留存以及读取实现，提供了专门的工具: rosbag</p><p>rosbag是用于录制和回放 ROS 主题的一个工具集</p><p>本质也是ros的节点，当录制时，rosbag是一个订阅节点，可以订阅话题消息并将订阅到的数据写入磁盘文件；当重放时，rosbag是一个发布节点，可以读取磁盘文件，发布文件中的话题消息</p><h4 id="通过命令行"><a href="#通过命令行" class="headerlink" title="通过命令行"></a>通过命令行</h4><p>创建目录保存录制的文件 比如根目录下创建bsgs文件夹</p><p>开始录制（-a指的是全部）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -a -O [bags/turtle.bag]</span><br></pre></td></tr></table></figure><p>操作小乌龟一段时间，结束录制使用 ctrl + c，在创建的目录中会生成bag文件</p><p>此时文件命名为turtle_[时间戳]</p><p>查看文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag info [bags/turtle TAB]</span><br></pre></td></tr></table></figure><p>回放文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play [bags/turtle TAB]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rosbag play [bags/turtle TAB]</span><br></pre></td></tr></table></figure><p>重启乌龟节点，会发现，乌龟按照录制时的轨迹运动</p><h4 id="通过编码"><a href="#通过编码" class="headerlink" title="通过编码"></a>通过编码</h4><p><strong>c++</strong></p><p>写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rosbag/bag.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;bag_write&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">// 创建rosbag对象</span></span><br><span class="line">    rosbag::Bag bag;</span><br><span class="line">    <span class="comment">// 打开文件流</span></span><br><span class="line">    bag.<span class="built_in">open</span>(<span class="string">&quot;hello.bag&quot;</span>,rosbag::BagMode::Write);</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    msg.data = <span class="string">&quot;hello xxx&quot;</span>;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        参数1:话题</span></span><br><span class="line"><span class="comment">        参数2:时间戳</span></span><br><span class="line"><span class="comment">        参数3:消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    bag.<span class="built_in">write</span>(<span class="string">&quot;/chatter&quot;</span>,ros::Time::<span class="built_in">now</span>(),msg);</span><br><span class="line">    <span class="comment">// 关闭文件流(养成习惯,打开写完就写关)</span></span><br><span class="line">    bag.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rosbag/bag.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rosbag/view.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/Int32.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;bag_read&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 bag 对象</span></span><br><span class="line">    rosbag::Bag bag;</span><br><span class="line">    <span class="comment">// 打开 bag 文件</span></span><br><span class="line">    bag.<span class="built_in">open</span>(<span class="string">&quot;hello.bag&quot;</span>,rosbag::BagMode::Read);</span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="comment">// 可以先获取消息的集合，再迭代取出消息的字段</span></span><br><span class="line">    <span class="comment">// forrange 增强for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;m : rosbag::<span class="built_in">View</span>(bag)) <span class="comment">// rosbag::View 解析信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 解析, 对应的函数类型可以看函数返回值</span></span><br><span class="line">        std::string topic =  m.<span class="built_in">getTopic</span>();</span><br><span class="line">        ros::Time time = m.<span class="built_in">getTime</span>();</span><br><span class="line">        std_msgs::StringPtr p = m.<span class="built_in">instantiate</span>&lt;std_msgs::String&gt;();</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;解析的数据为:话题:%s,时间戳:%.2f,消息:%s&quot;</span>,</span><br><span class="line">                topic.<span class="built_in">c_str</span>(),</span><br><span class="line">                time.<span class="built_in">toSec</span>(),</span><br><span class="line">                p-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件流</span></span><br><span class="line">    bag.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python</strong></p><p>写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> rosbag</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">rospy.init_node(<span class="string">&quot;write_bag_p&quot;</span>)</span><br><span class="line"><span class="comment"># 创建bag对象并打开数据流</span></span><br><span class="line">bag = rosbag.Bag(<span class="string">&quot;hello_p.bag&quot;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="comment"># 注意这里是&#x27;w&#x27;，不是双引号</span></span><br><span class="line"><span class="comment"># 写数据</span></span><br><span class="line">msg = String()</span><br><span class="line">msg.data = <span class="string">&quot;hello bag&quot;</span></span><br><span class="line">bag.write(<span class="string">&quot;/chatter&quot;</span>,msg)</span><br><span class="line">    <span class="comment"># 关闭数据流</span></span><br><span class="line">bag.close()</span><br></pre></td></tr></table></figure><p>读：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> rosbag</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">rospy.init_node(<span class="string">&quot;read_bag_p&quot;</span>)</span><br><span class="line"><span class="comment"># 创建bag对象并打开数据流</span></span><br><span class="line">bag = rosbag.Bag(<span class="string">&quot;hello_p.bag&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="comment"># 读数据</span></span><br><span class="line">msgs = bag.read_messages(topics=<span class="string">&quot;/chatter&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> topic,msg,time <span class="keyword">in</span> msgs: <span class="comment"># 将返回的topic, message, timestamp赋到topic,msg,time</span></span><br><span class="line">rospy.loginfo(<span class="string">&quot;话题:%s,消息:%s,时间:%s&quot;</span>,topic,msg,time)</span><br><span class="line">bag.close()</span><br></pre></td></tr></table></figure><h3 id="rqt工具箱"><a href="#rqt工具箱" class="headerlink" title="rqt工具箱"></a>rqt工具箱</h3><p>ROS基于 QT 框架，针对机器人开发提供了一系列可视化的工具，这些工具的集合就是rqt</p><p>rqt 工具箱组成有三大部分</p><ul><li>rqt——核心实现，开发人员无需关注</li><li>rqt_common_plugins——rqt 中常用的工具套件</li><li>rqt_robot_plugins——运行中和机器人交互的插件(比如: rviz)</li></ul><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>一般只要安装的是desktop-full版本就会自带工具箱</p><p>如果需要安装可以以如下方式安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-rqt</span><br><span class="line">sudo apt-get install ros-noetic-rqt-common-plugins</span><br></pre></td></tr></table></figure><p><code>rqt</code>的启动方式有两种：</p><ul><li>方式1：rqt</li><li>方式2：rosrun rqt_gui rqt_gui</li></ul><p>启动 rqt 之后，可以通过 plugins 添加所需的插件</p><h4 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h4><ul><li>rqt_graph：plugins&#x2F;introspection&#x2F;Node Graph or rqt_graph</li></ul><p>圆框是节点，方框是话题，箭头是数据的订阅发布方向</p><ul><li>rqt_console：plugins&#x2F;Logging&#x2F;Console or rqt_console</li></ul><p>ROS 中用于显示和过滤日志的图形化插件</p><p>编写 Node 节点输出各个级别的日志信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;log_demo&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">0.3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Debug message d&quot;</span>);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Info message oooo&quot;</span>);</span><br><span class="line">        <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Warn message wwww&quot;</span>);</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Erroe message EEEE&quot;</span>);</span><br><span class="line">        <span class="built_in">ROS_FATAL</span>(<span class="string">&quot;Fatal message FFFF&quot;</span>);</span><br><span class="line">        r.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/01_rqt_console插件.webp" alt="01_rqt_console插件" style="zoom: 67%;" /><ul><li>rqt_plot：plugins&#x2F;Visualization&#x2F;plot or rqt_plot</li></ul><p>图形绘制插件，可以以 2D 绘图的方式绘制发布在 topic 上的数据</p><ul><li>rqt_bag：plugins&#x2F;Logging&#x2F;Bag or rqt_bag</li></ul><p>录制和重放 bag 文件的图形化插件</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/14rqt_bag_录制.webp" alt="14rqt_bag_录制" style="zoom: 50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/15rqt_bag_回放.webp" alt="15rqt_bag_回放" style="zoom: 50%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 🤖ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenAI使用指南</title>
      <link href="/posts/4024736854.html"/>
      <url>/posts/4024736854.html</url>
      
        <content type="html"><![CDATA[<p>OpenAI随着模型的迭代已经越来越适用日常的各种场景，基本所有人都可以用得上（截止2024年10月模型最新知识库为2023年9月）</p><p>目前未付费用户可每日免费使用一定次数的GPT-4o模型，以及免费的GPT-4o mini模型</p><p>付费用户可无限使用GPT-4o、GPT-4o with canvas(测试版)[个人感觉目前最好用]、o1-preview、o1-mini，包括绘图</p><p>本文将介绍国内如何使用ChatGPT（官网）</p><blockquote><p><font color='DarkViolet'>前提需要魔法[或者叫科学上网]</font>，节点尽量不要选择台湾、香港</p></blockquote><h2 id="谷歌账号"><a href="#谷歌账号" class="headerlink" title="谷歌账号"></a>谷歌账号</h2><p>作为一个国外的网站，注册肯定避免不了谷歌账号，而且一个谷歌账号可以极大程度地提高国外资料检索的便捷度</p><p>进入谷歌账号注册页：<a href="https://www.google.com/intl/zh-CN/account/about/">Google 账号</a></p><p>按照要求填写想要的Gmail地址</p><p>但是目前国内手机号已经无法注册谷歌账号了</p><p>最便捷的方法是利用一些网站，接收国外手机号的短信【价格挺便宜的】</p><blockquote><p>这一步如果用的国外手机号注册，后面的OpenAI注册也可以免去手机号验证</p><p>因为以前是可以利用qq邮箱绕过手机号验证注册Gmail(我是这么干的)，所以注册OpenAI的时候要求再次验证手机号</p></blockquote><p>接收短信网站：<a href="https://sms-activate.guru/en">Receive SMS Online to Virtual Number for OTP | SMS-Activate</a></p><p>账户注册完成和登录后，要为账户充值，用于购买一次性海外手机号码。点击页面右上方的“余额(Balance)”下拉按钮，在出现的下拉列表中点击“充值”即可开始为账户充值。</p><p>一个手机号不贵，但是基本都有最低充值额度，这个额度基本可以注册四五个号了</p><p>这里不具体演示了</p><p>可以参考这篇的后半段：<a href="https://thetowerinfo.com/zh/use-chatgpt-china-method/">ChatGPT中国国内使用方法 – 访问、注册及使用详细步骤 – The Tower Info</a></p><h2 id="OpenAI"><a href="#OpenAI" class="headerlink" title="OpenAI"></a>OpenAI</h2><p>注册完Google账号后面的事情就很简单了，进入<a href="https://openai.com/">OpenAI</a>，点击ChatGPT</p><p>ChatGPT能做什么？</p><p>内容创作：内容创作可以涵盖起工作的很大一部分，包括论文写作、工作汇报、营销文案、产品文案、工作总结等等，Chatgpt都能大幅提高效率，可以将大量pdf导入，生成自己的知识库，每次问答它甚至会帮你指出参考的是哪篇论文的哪个位置的话</p><p>编程支持：不仅涉及编写代码示例、调试和解释程序功能等方面，甚至可以帮你自行写代码、修bug</p><p>多语言交流：模型的多语言能力亦是引人瞩目，支持语音和文本的多语言理解与生成</p><p>AI绘图：可以描述你需要的图片，包括画风，内容，色调等等，在几秒内生成一张html格式的图片，目前模型支持图片部分修改</p><p>进入登录页面：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241022154512351.png" alt="image-20241022154512351" style="zoom: 67%;" /><p>正常刚注册完浏览器会记住你的账号，之后就会直接跳转到GPT的开始页</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241022154410971.png" alt="image-20241022154410971" style="zoom:50%;" /><p>就可以开始愉快地使用了</p><p>免费模型一天只能绘制两次图片以及少量的GPT-4o，付费价格为 $20&#x2F;月 (加上税大约150RMB)，需要国外的信用卡支付</p><h2 id="信用卡支付"><a href="#信用卡支付" class="headerlink" title="信用卡支付"></a>信用卡支付</h2><p>虚拟信用卡注册可以使用WildCard <a href="https://bewildcard.com/">https://bewildcard.com</a> </p><p>可以使用b站up主的推荐码GPT365进行注册开通(便宜$1)</p><p>服务费为2年$11.99；3年 16.99[均可支付宝]</p><p>在GPT页面找到升级页面，将支付页面然后复制浏览器地址栏里的链接，<strong>一定要全部复制</strong></p><p>打开刚才注册的WildCard页面进入我的服务，点击进入 ChatGPT Plus&#x2F;Team一键升级</p><p>选择订阅类型：个人就选择Plus即可</p><p>粘贴刚刚从支付页面复制的链接，就是以 <a href="https://pay.openai.com/">https://pay.openai.com</a> 开头的内容，确认支付即可</p><blockquote><p>这样支付以后相当于开通了包月，如果不用的话及时在个人设置里面取消订阅，虚拟信用卡如果扣费失败几次之后就会封号</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 🛠️基础工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人性的弱点</title>
      <link href="/posts/278820309.html"/>
      <url>/posts/278820309.html</url>
      
        <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>人们会自然而然地谈论自己想说的事情而非对方想听的事情</p><p><font color='DarkViolet'>请不要听任自己的本能反应，因为第一反应往往是错的</font></p><p>可以每周回顾自己的错误</p><h2 id="人际关系的基本技巧"><a href="#人际关系的基本技巧" class="headerlink" title="人际关系的基本技巧"></a>人际关系的基本技巧</h2><p>人们会给自己的行为找借口，不管理由是否站得住脚</p><p>百分之九十九的情况下，不管犯下多严重的错误，人们都不会责备自己</p><p>改变自己远比改变他人令你受益更多，并且风险更小</p><p><font color='OrangeRed'>「原则 1：不要批评，不要指责，不要抱怨」</font></p><p>让对方心甘情愿地去做才能让对方为你效劳</p><p>为了博得同情和关注，人们有时会假装弱小，从而获得存在感</p><p>一个人在被赞许时会工作得更加尽力，而被批评时则截然相反</p><p>伴侣的付出也需要被称赞、被感激</p><p>每个人都是渴求认同的平凡人，每一颗心都会因他人的赞许而欢愉，真挚的赞美可以改变人的一生</p><p><font color='OrangeRed'>「原则 2：真心实意地感谢他人、赞美他人」</font></p><p>正常人只会在意自己想要的，找出对方的需求</p><p>说服别人的时候开口前先想想如何让对方自发去做这件事，而不是讲自己的需求</p><p>吵架是吵不出结果的，即使说服对方，对方也会碍于面子寸步不让</p><p>需要洞悉他人的立场，同时兼顾自己和他人</p><p>不要把对方最关心的部分放在最后，容易引起对方的不满，激发对方兴趣才好更好说服对方</p><p>先写出对对方不好的地方，然后提出请求并列出对对方的好处，强调对方需求</p><p><font color='OrangeRed'>「原则 3：激发他人的需求」</font></p><h2 id="赢得他人喜爱的六种方式"><a href="#赢得他人喜爱的六种方式" class="headerlink" title="赢得他人喜爱的六种方式"></a>赢得他人喜爱的六种方式</h2><h3 id="广受欢迎的奥秘"><a href="#广受欢迎的奥秘" class="headerlink" title="广受欢迎的奥秘"></a>广受欢迎的奥秘</h3><p>真正的朋友无法通过讨好来获得</p><p>表现个人魅力的同时也要对他人充满热诚</p><p>核心：真诚</p><p><font color='LightSkyBlue'>对这个世界时刻保持热爱与好奇哇~</font></p><p><font color='OrangeRed'>「原则 1：建立对他人的兴趣，真心诚意地关注他人」</font></p><h3 id="如何建立美好的第一印象"><a href="#如何建立美好的第一印象" class="headerlink" title="如何建立美好的第一印象"></a>如何建立美好的第一印象</h3><p>脸上的神情比身上的衣着要重要得多</p><p>人人都讨厌虚伪，假笑是无法骗过任何人的，只有真正发自内心的笑容才能够带来积极的影响</p><p>如果你希望人们乐于同你相处，那你自己要先乐于和对方相处</p><p>只要可以调整行为，就能间接调整情绪</p><p>事情没有好坏绝对，你的思想决定它的好坏</p><p><font color='OrangeRed'>「原则 2：微笑」</font></p><h3 id="记住他的名字"><a href="#记住他的名字" class="headerlink" title="记住他的名字"></a>记住他的名字</h3><p>能够熟悉叫出对方姓名本身就是有效且不着痕迹的赞美</p><p>只有尊重别人才能赢得别人的尊重</p><p><font color='DarkViolet'>所有事情都需要付出精力，好的习惯建立在日复一日的琐碎牺牲上</font></p><p>沟通中一旦道出对方姓名，我们所传递的信息或是请求就增添了一层特别的色彩</p><p><font color='OrangeRed'>「原则 3：无论对于何人，无论以何种语言，自己的名字都是世界上最甜蜜最重要的词汇」</font></p><h3 id="你想变得健谈吗"><a href="#你想变得健谈吗" class="headerlink" title="你想变得健谈吗"></a>你想变得健谈吗</h3><p><font color='LightSkyBlue'>倾听他人，表达重视与认可，可以让对方解除戒备</font></p><p><font color='LightSkyBlue'>如果对方处于情绪不稳定状态，先倾听，不要打断，等说完情绪稍微平复以后再进行沟通，并进行共情</font></p><p>他人倾述需要的不是建议，而是一个友好且体贴的听众，能够卸下心里的重担</p><p><font color='OrangeRed'>「原则 4：专注地倾听，鼓励他人谈论自己」</font></p><h3 id="如何引起他人的兴趣"><a href="#如何引起他人的兴趣" class="headerlink" title="如何引起他人的兴趣"></a>如何引起他人的兴趣</h3><p>谈论对方最在乎的事情，是直抵对方内心深处的捷径</p><p>尽可能一开始就找到了对方感兴趣的话题，借此拉近距离</p><p>沟通本身已经扩大了生命的边界</p><p><font color='OrangeRed'>「原则 5：谈论对方感兴趣的事情」</font></p><h3 id="让每个人都喜欢你"><a href="#让每个人都喜欢你" class="headerlink" title="让每个人都喜欢你"></a>让每个人都喜欢你</h3><p><font color='LightSkyBlue'>细致观察对方，找出对方的闪光点进行称赞，对方才会真的开心</font></p><p>不要付出一点小小的善意和一句真诚的称赞都索求回报，那么失败是注定应得的惩罚</p><p>希望他人怎样对待自己，也要怎样待人</p><p>要求别人前先表示尊重，礼貌用语也是一种教养</p><p>每个人心里都认为他在某一方面比你强，都自视甚高，都渴望被重视</p><p>不要滥用自己小小的权利，<font color='LightSkyBlue'>对于位高权重之人他们所缺乏的可能是感情</font></p><p><font color='DarkViolet'>为一件事投入的时间最重要，因为那是生命的组成部分</font></p><p>和对方谈谈他们自己，对方听上几个小时也不会厌倦</p><p><font color='OrangeRed'>「原则 6：真心实意地让对方知道他有多重要」</font></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>原则1 建立对他人的兴趣，真心诚意地关注他人</p><p>原则2 微笑</p><p>原则3 无论对于何人，无论以何种语言，自己的名字都是世界上最甜蜜最重要的词汇</p><p>原则4 专注地倾听，鼓励他人谈论自己</p><p>原则5 谈论对方感兴趣的事情</p><p>原则6 真心实意地让对方知道他有多重要</p><h2 id="如何让他人想你之所想"><a href="#如何让他人想你之所想" class="headerlink" title="如何让他人想你之所想"></a>如何让他人想你之所想</h2><h3 id="争论永无赢家"><a href="#争论永无赢家" class="headerlink" title="争论永无赢家"></a>争论永无赢家</h3><p>争论不会让双方和解，反而会让对方更加坚信自己言之有理，<font color='DarkViolet'>赢得争论的方法只有一个，那就是避免争论</font></p><p>不要着急反驳，先顺从对方，避免言语冲突，不要替对方决定，而是去引发对方思考</p><p>永远无法通过争论的胜利赢得对方的尊敬，驳倒对方也无法改变他的想法</p><p>质疑对方可能会让对方觉得自己没受到重视，激化矛盾，还有可能让自己受伤</p><p><font color='DarkViolet'>如果两个合作伙伴总是意见一致，那么其中一个人就没有存在的意义</font></p><p>先听，后说，给对方说话的机会，听他们把话说完，反驳和争辩只会徒增隔阂。建立沟通的桥梁，不要筑起误解的壁垒</p><p><font color='DarkViolet'>在能够让步的时候让步，在应该认错的时候认错</font></p><p>真心诚意地感谢对方的重视，对方愿意花时间和你争辩，是因为他和你对同一件事感兴趣</p><p>可以推迟讨论时间，将所有细节都考虑清楚</p><p><font color='OrangeRed'>「原则 1：赢得争论的方法只有一个，那就是避免争论」</font></p><h3 id="如何避免树敌"><a href="#如何避免树敌" class="headerlink" title="如何避免树敌"></a>如何避免树敌</h3><p>如果你不能保证自己是对的，那么有何底气断定是别人错了？</p><p>批评否定了他们的智慧和判断力，打击了他们的骄傲和自尊，哪怕你的逻辑没有问题，也无法扭转对方的观念，因为你已经伤害了他的感情<br><font color='DarkViolet'>在交谈过程中不要让自己的目的太过明显</font></p><p><font color='DarkViolet'>你可以比所有人都做的更好，但不要告诉他们</font></p><p>学会用：“估计是我错了，让我们一起弄清事实。”</p><p>对方的负面情绪疏导好了就好处理事情</p><p><font color='LightSkyBlue'>人在不知不觉中会改变一些想法，但被人指出错误时却选择拒绝改变，并不是对方的说法不对，只是人本能地会维护自己的自尊心</font></p><p><font color='LightSkyBlue'>当他人表达自己的价值观或是想法时，人总是先去对其进行评判，而不是去理解他的感受</font></p><p>犯错的人面对温和的态度也许会自己道出错误，但态度强硬只会引发争论，<font color='DarkViolet'>学会克制自己反驳的冲动</font></p><p><font color='OrangeRed'>「原则 2：尊重他人的观点，绝不要说“你错了”」</font></p><h3 id="坦率承认错误"><a href="#坦率承认错误" class="headerlink" title="坦率承认错误"></a>坦率承认错误</h3><p>坦率地积极认错，争端和平地解决，让双方都理解对方的立场</p><p>如果责骂在所难免，与其从对方口中听到攻击的言辞，不如抢先认错</p><p>勇于承认错误能够令人产生自豪感，认错不仅能够减轻自己的内疚和对方的防备，还能够弥补错误引发的后果</p><p>如果你是对的，请以婉转友善的方式赢得对方的赞同。如果你是错的——倘若你对自己诚实，那就果断诚恳地承认错误</p><p>在特定环境学会适当妥协</p><p><font color='OrangeRed'>「原则 3：如果你错了，请坚决果断地承认错误」</font></p><h3 id="一滴蜜糖"><a href="#一滴蜜糖" class="headerlink" title="一滴蜜糖"></a>一滴蜜糖</h3><p>如果对方心中充满了对你的怨言和猜忌，你用任何逻辑也无法说服他站在你这一边</p><p>没有人愿意改变自己的想法，你无法强迫他们认同你的观点，然而如果我们温和友好，也许他们终有一天会被感动</p><p><font color='DarkViolet'>用友善、感激而体谅对方的谈判方式进行博弈</font></p><p><font color='OrangeRed'>「原则 4：沟通始于友善」</font></p><h3 id="苏格拉底的秘密"><a href="#苏格拉底的秘密" class="headerlink" title="苏格拉底的秘密"></a>苏格拉底的秘密</h3><p>与人商谈时，请先强调你赞同的观点，不要急于挑明分歧</p><p>如果可能的话，请让对方了解，你们的差异在于方法而非目的</p><p>尽量不要让对方说“不“，因此交谈中最重要的是先抛出对方认同的观点</p><p>如果对方在一开始以“不”作答，那么你需要过人的智慧和耐心，才能变拒绝为肯定</p><p><font color='LightSkyBlue'>如果你确信你是对的，不要一开始和对方反驳，从基本道理入手，让对方肯定你的每一步推导，再让对方可以推导出结果</font></p><p>苏格拉底的谋略，温和地抛出问题——一个答案为“是”的问题。</p><p><font color='OrangeRed'>「原则 5：让对方点头称“是”」</font></p><h3 id="对待抱怨的安全方式"><a href="#对待抱怨的安全方式" class="headerlink" title="对待抱怨的安全方式"></a>对待抱怨的安全方式</h3><p>不是需要一个专断的家长，而是需要一个能够分担成长困惑的知心朋友，孩子不希望自己的倾诉淹没在喋喋不休之中</p><p><font color='DarkViolet'>若想树敌，就胜于你的朋友；若想交友，请让朋友胜于你。</font></p><p>如果朋友胜过我们，他们会觉得自己很重要；如果我们胜过他们，他们中的一部分人会对此感到自卑，甚至心生妒忌。</p><p>在谈话中开始注意多倾听，少开口</p><p><font color='OrangeRed'>「原则 6：让对方主导谈话」</font></p><h3 id="如何取得合作"><a href="#如何取得合作" class="headerlink" title="如何取得合作"></a>如何取得合作</h3><p>较之别人灌输的想法，人们更相信自己得出的结论</p><p>没有人喜欢强买强卖，也没有人愿意被迫完成任务，我们更喜欢自己做决定的感觉，喜欢被问及我们的心愿、我们的需求、我们的想法</p><p>主动询问对方的需求，不推销有时候就是最好的推销</p><p><font color='LightSkyBlue'>从利益无关的人口中说出的话更有影响力</font></p><p><font color='OrangeRed'>「原则 7：循循善诱，让对方自行得出结论」</font></p><h3 id="创造奇迹的妙方"><a href="#创造奇迹的妙方" class="headerlink" title="创造奇迹的妙方"></a>创造奇迹的妙方</h3><p>万事皆有因，任何想法和行为背后都有其缘由，一旦找出动机，对方的脾气秉性就尽在掌握之中。</p><p><font color='DarkViolet'>同理心是为人处世的制胜之道</font></p><p>设身处地地站在对方的角度思考问题，站在对方的角度问问你自己：“对方为什么要这样做？”</p><p>若想让交流变得顺畅，请像重视自己的感受一样重视对方，在开口之前先斟酌一下，如果你是对方，你愿不愿意听这些话</p><p><font color='DarkViolet'>以请求代替命令</font></p><p>面谈之前先想清楚我要说什么，对方感兴趣的是什么，动机，会如何回答，而不是贸然开始一段谈话</p><p><font color='DarkViolet'>「原则 8：抛开成见，将心比心」</font></p><h3 id="体谅他人"><a href="#体谅他人" class="headerlink" title="体谅他人"></a>体谅他人</h3><p>“我一点都不怪你这样想。如果我是你，我也会有完全相同的感受。”</p><p>你之所以成为你，并不完全是由你自己主观决定的</p><p>以友善作为对侮辱的回答，博得对方的好感比直接骂回去更有意思</p><p><font color='LightSkyBlue'>游说对方接受你的意见的时候可以抛出不听从建议可能导致的更坏的结果</font></p><p>无论这些不幸是现实还是假想，“自怜“都普遍存在于人类行为之中</p><p><font color='OrangeRed'>「原则 9 体谅他人的想法和愿望」</font></p><h3 id="没人会拒绝这样的请求"><a href="#没人会拒绝这样的请求" class="headerlink" title="没人会拒绝这样的请求"></a>没人会拒绝这样的请求</h3><p>周围的每个人都自视甚高，认为自己品行高尚、慷慨无私</p><p>人们知道自己真正的动机，但是每个人的内心都会把自己高尚化，因而也需要一个听起来更高尚的动机</p><p>“相信您是个言而有信的君子，不会轻易违约。无论如何，如何做人的决定权在于我们自己。”</p><p>把“我不喜欢那张照片，请把它撤换掉？” 变成 “我母亲不喜欢那张照片，请您把它撤换掉。”</p><p><font color='DarkViolet'>把自己的请求变成一个有理有据的事情</font></p><p>哪怕是存心欺骗的人，一旦知道你认为他真诚正直，他们也不想辜负你的信任。</p><p><font color='OrangeRed'>「原则 10：激发对方内心深处的高尚情操」</font></p><h3 id="电影电视都是这样做的"><a href="#电影电视都是这样做的" class="headerlink" title="电影电视都是这样做的"></a>电影电视都是这样做的</h3><p><font color='LightSkyBlue'>将你的想法用一种具体的举动表示出来，这种方法可以从视听上入手，放大人的感官</font></p><p><font color='OrangeRed'>「原则 11：戏剧化你的想法」</font></p><h3 id="任何方法都不奏效的时候，请使用杀手锏"><a href="#任何方法都不奏效的时候，请使用杀手锏" class="headerlink" title="任何方法都不奏效的时候，请使用杀手锏"></a>任何方法都不奏效的时候，请使用杀手锏</h3><p>竞争产生效率（竞争指产生超越他人的渴望）</p><p>但凡对方有一点好胜心，这个方法绝对有效</p><p><font color='OrangeRed'>「原则 12：激将法」</font></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>原则1 赢得争论的方法只有一个，那就是避免争论</p><p>原则2 尊重他人的观点，绝不要说“你错了”</p><p>原则3 如果你错了，请坚决果断地承认错误</p><p>原则4 沟通始于友善</p><p>原则5 让对方点头称“是”</p><p>原则6 让对方主导谈话</p><p>原则7 循循善诱，让对方自行得出结论</p><p>原则8 抛开成见，将心比心</p><p>原则9 体谅他人的想法和愿望</p><p>原则10 激发对方内心深处的高尚情操</p><p>原则11 戏剧化你的想法</p><p>原则12 激将法</p><h2 id="如何改变他人，成为领导者"><a href="#如何改变他人，成为领导者" class="headerlink" title="如何改变他人，成为领导者"></a>如何改变他人，成为领导者</h2><h3 id="挑错的时候，请用这种方式"><a href="#挑错的时候，请用这种方式" class="headerlink" title="挑错的时候，请用这种方式"></a>挑错的时候，请用这种方式</h3><p>在说出令人不快的事情之前先给对方一些肯定，就更容易让对方接受。</p><p>比如先肯定对方的工作，鼓励对方，再提出改进意见</p><p><font color='OrangeRed'>「原则 1：欲抑先扬」</font></p><h3 id="怎样批评不会触犯众怒"><a href="#怎样批评不会触犯众怒" class="headerlink" title="怎样批评不会触犯众怒"></a>怎样批评不会触犯众怒</h3><p>不要用“但是”，用“而且”代替“但是”</p><p>纠正他人错误最有效的方式是——</p><p><font color='OrangeRed'>「原则 2：间接地引起对方的注意」</font></p><h3 id="先承认自己的错误"><a href="#先承认自己的错误" class="headerlink" title="先承认自己的错误"></a>先承认自己的错误</h3><p>假如别人在批评你之前先承认自己也有诸多缺点，批评的话语就没有那么刺耳了</p><p><font color='OrangeRed'>「原则 3：批评对方之前，先谈谈你自己的过错」</font></p><h3 id="没有人喜欢听命于人"><a href="#没有人喜欢听命于人" class="headerlink" title="没有人喜欢听命于人"></a>没有人喜欢听命于人</h3><p>“你可能想把这一点考虑进去”或是“你觉得这样做能奏效吗”</p><p>“如果这样说或许更好一些”</p><p>给人们独立尝试的机会，让他们放手去做，从错误中汲取经验</p><p>即使出发点是好的，颐指气使的命令也会令人怀恨在心</p><p>将命令改为问句不仅听起来更悦耳，还能够激发创造力。如果对方参与了决策过程，他就更乐于付诸实施</p><p><font color='OrangeRed'>「原则 4：以引导代替命令」</font></p><h3 id="给对方留足面子"><a href="#给对方留足面子" class="headerlink" title="给对方留足面子"></a>给对方留足面子</h3><p>在他人面前训斥会对他们自尊心造成的伤害，而这些伤害原本只需要几分钟的思考或是几句贴心的话语就能够轻易化解</p><p>我没有权利做出任何让对方感到自卑的言行。我怎么看他并不重要，重要的是他如何看自己，伤害别人的自尊是一种罪过</p><p><font color='OrangeRed'>「原则 5：给对方留足面子」</font></p><h3 id="如何激励他人走向成功"><a href="#如何激励他人走向成功" class="headerlink" title="如何激励他人走向成功"></a>如何激励他人走向成功</h3><p>哪怕他人只取得了一点微不足道的进步，也请真诚地表达你的赞赏，这些话语会成为他们前进的动力</p><p>赞许就是其中一种你未尽其用的强大能力，你的赞许能够让他人发觉自身潜在的无限可能</p><p><font color='OrangeRed'>「原则 6：夸奖他人每一点微小的进步，“由衷地赞许，不吝啬赞美之词”」</font></p><h3 id="用美誉激励他人"><a href="#用美誉激励他人" class="headerlink" title="用美誉激励他人"></a>用美誉激励他人</h3><p>在不了解对方是主观还是客观原因令人不满的时候不要妄下结论，把对方推向对立面，试着站在对方角度探究问题，暗示对方</p><p>“我们一起找到改进的方法”</p><p><font color='DarkViolet'>如果你希望对方提高某方面的能力，就请装作他早已拥有这一品质，对方定会竭尽全力维护他在你心目中的形象</font></p><p>如果你身处低谷，就越要自信，你脑海中一定要有走出低谷的画面。其实生活中无论处在什么样的境地，我们都要始终相信自己，相信什么才会成为什么！相信自己是什么样的人，拥有什么样的能力，我们就会努力朝这个方向发展，这既是前进的动力，也是一个非常积极的心理暗示</p><p><font color='OrangeRed'>「原则 7：用美誉激励他人，他就会努力不辜负你的期望」·</font></p><h3 id="鼓励对方勇于改变"><a href="#鼓励对方勇于改变" class="headerlink" title="鼓励对方勇于改变"></a>鼓励对方勇于改变</h3><p>如果你对孩子、爱人或是员工说他在某件事上笨手笨脚、没有天赋、毫无可取之处，你会毁了他们进步的动力；</p><p>如果你采用相反的方式，充分鼓励他，指出这件事对他来说易如反掌，告诉他你充分相信他的能力或者说他一定有潜能做成这件事，那么他一定会为此竭尽全力</p><p><font color='OrangeRed'>「原则 8：鼓励对方勇于改变，让改正错误听起来轻而易」</font></p><h3 id="让对方乐于为你做事"><a href="#让对方乐于为你做事" class="headerlink" title="让对方乐于为你做事"></a>让对方乐于为你做事</h3><p>得人心的奖惩措施，让其他人心甘情愿做事</p><p>管理需要在不同的层面去做分析和对应方案的</p><p>如果想改变对方的态度或行为，有以下建议：</p><ol><li><p>实事求是，做不到的事情请不要承诺。忘记自己的私利，关注对方的利益；</p></li><li><p>目的明确，清楚知道你希望对方做什么；</p></li><li><p>有同理心，扪心自问什么是对方真正的需求；</p></li><li><p>换位思考，想一想对方帮你做事能得到哪些好处；</p></li><li><p>利益交换，找到上述好处与对方需求的结合点；</p></li><li><p>表明态度，提出请求的时候，向对方说明他如何能从中受益</p></li></ol><p><font color='OrangeRed'>「原则 9：让对方乐于为你做事」</font></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>原则1 欲抑先扬</p><p>原则2 间接地引起对方的注意</p><p>原则3 批评对方之前，先谈谈你自己的过错</p><p>原则4 以引导代替命令</p><p>原则5 给对方留足面子</p><p>原则6 夸奖他人每一点微小的进步，“由衷地赞许，不吝啬赞美之词”</p><p>原则7 用美誉激励他人，他就会努力不辜负你的期望</p><p>原则8 鼓励对方勇于改变，让改正错误听起来轻而易举</p><p>原则9 让对方乐于为你做事</p><p><font color='LightSkyBlue'>但请记住，在任何情况下改变别人都是一件极度困难的事情，需要考虑实际情况，是改变他人更有价值还是改变自己更直接，当然大部分人是不愿意改变自己的，改变的是他人明确的好的方面另做考虑</font></p><h2 id="创造奇迹的信"><a href="#创造奇迹的信" class="headerlink" title="创造奇迹的信"></a>创造奇迹的信</h2><p>人类思想史上的每一次进步，都来自那些怀疑者、质问者、挑战者，以及不轻信的大众</p><p>寻找对方最擅长的领域，并请求对方的帮助，认真倾听对方，给他以尊重，成就感</p><p>人们视欣赏和认同如瑰宝，弃虚伪与逢迎如尘灰</p><p>本书所述的原则只有发自内心才会行之有效</p>]]></content>
      
      
      
        <tags>
            
            <tag> 📘微信读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微纳米加工及应用</title>
      <link href="/posts/3769378865.html"/>
      <url>/posts/3769378865.html</url>
      
        <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>微纳加工的特点：</p><ul><li>微纳加工是在衬底表面通过薄膜材料沉积和图形化的方法实现的，平面工艺一般只能形成二维平面结构，准三维结构通过多层二维叠加形成</li><li>微细结构一般由曝光成像的方法形成，而不是加工工具与材料的直接相互作用</li><li>复杂微纳米系统是在平面加工过程中形成的，是一个逐层进行且不可逆过程</li></ul><p><font color='DarkViolet'>微纳加工的基本过程：薄膜沉积→图形成像→图形转移</font>【课后复习题】</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20240911200457063.png" alt="image-20240911200457063" style="zoom: 67%;" /><ul><li><p>图形成像：平面工艺；探针工艺；模型工艺</p></li><li><p>图形转移：刻蚀法；沉积法</p></li></ul><p>集成电路工艺主要包括4个主要方面：薄膜沉积；制图；掺杂；热处理</p><p><font color='OrangeRed'>广义的光刻包括</font>：光学曝光；电子束曝光；离子束曝光和X射线曝光，激光直写</p><p><strong>强酸中毒的应急处理方法</strong>：</p><p>①沾着皮肤时，用大量水冲洗15分钟 (稀释减少中和热伤害)，再用碳酸氢钠之类稀碱液或肥皂液进行洗涤</p><p>②当沾着草酸时，不宜使用碳酸氢钠，可以用镁盐和钙盐中和</p><blockquote><p>误食氢氟酸喝大量的水或牛奶，不能催吐</p></blockquote><p><strong>强碱中毒的应急处理方法</strong>：</p><p>①沾着皮肤时，尽快用水冲洗至皮肤不滑为止，接着用经水稀释的醋酸或柠檬汁等进行中和；</p><p>②沾着生石灰时，则用油之类东西，先除去生石灰</p><p><strong>呼吸道吸入刺激性或有毒气体应急处理办法</strong>：</p><p>①吸入氯气、氯化氢气体时，可吸入少量<u>酒精和乙醚</u>的混合蒸气使之解毒  </p><p>②吸入硫化氢或一氧化碳气体而感不适时，应立即到室外呼吸新鲜空气</p><p><font color='DarkViolet'>微纳米加工和传统机械加工有什么不同？</font>【课后复习题】</p><table><thead><tr><th>属性</th><th>微纳米加工</th><th>传统机械加工</th></tr></thead><tbody><tr><td>加工尺度</td><td>微米&#x2F;纳米级（10⁻⁶至10⁻⁹米）</td><td>毫米级及以上</td></tr><tr><td>精度</td><td>公差可达到纳米级别</td><td>公差在微米级别</td></tr><tr><td>加工方法</td><td>光刻、电子束刻蚀、聚焦离子束刻蚀、纳米压印等</td><td>切削、研磨、钻孔等物理加工</td></tr><tr><td>设备与环境</td><td>专业设备，高洁净环境（超净室）</td><td>通用机械设备，一般环境</td></tr><tr><td>材料选择</td><td>硅等半导体和功能材料</td><td>金属、塑料、木材等宏观材料</td></tr><tr><td>成本与效率</td><td>产量低、生产成本高</td><td>产量高、生产成本低</td></tr><tr><td>应用领域</td><td>半导体制造、MEMS传感器、纳米技术</td><td>机械设备、汽车制造、航空航天</td></tr></tbody></table><p><font color='DarkViolet'>在超净室工作有哪些日常行为规范？</font>【课后复习题】</p><ol><li>按顺序穿戴洁净服、帽子、口罩、手套，通过风淋室</li><li>规范操作，定期参加洁净室操作规程培训</li><li>及时清理垃圾，定期清洁设备和工作区</li></ol><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>微纳米加工的基本过程是什么？  </font></li><li><font color='OrangeRed'>微纳米加工和传统机械加工有什么不同？  </font></li><li><font color='OrangeRed'>在超净室工作有哪些日常行为规范？  </font></li></ol><h2 id="光学曝光技术"><a href="#光学曝光技术" class="headerlink" title="光学曝光技术"></a>光学曝光技术</h2><h3 id="光学曝光方式与原理"><a href="#光学曝光方式与原理" class="headerlink" title="光学曝光方式与原理"></a>光学曝光方式与原理</h3><p><font color='DarkViolet'>光学曝光的方式：掩模对准式曝光与投影式曝光</font>【课后复习题】</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20240918125306772.png" alt="image-20240918125306772" style="zoom:40%;" /><p>真空接触：使经过多道工序加工而翘曲的基片恢复平整，从而保证曝光时投射到胶表面的光强分布均匀；使掩膜与胶表面接触更加严密，从而获得更高的分辨率</p><p><font color='DarkViolet'>光学曝光方式各有什么优缺点？</font>【课后复习题】</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>掩膜对准式曝光</td><td>曝光分辨率较高；<br />工艺简单且设备成本较低；</td><td>光学分辨率有限，掩膜和衬底之间可能接触；<br />曝光过程较慢，不适合大规模生产；</td></tr><tr><td>投影式曝光</td><td>曝光分辨率最高（高NA，短波长）；<br />掩膜不接触衬底；<br />图像可缩放，适合大规模生产；</td><td>设备复杂且昂贵，需要精密的光学系统和高效的光源；<br />掩膜图案通常需要缩放，掩膜制作更加复杂</td></tr></tbody></table><p>工业主要采用投影式曝光，它的图像质量完全取决于光学成像系统，与掩模-基片之间的距离无关</p><h3 id="光学曝光工序"><a href="#光学曝光工序" class="headerlink" title="光学曝光工序"></a>光学曝光工序</h3><p><font color='DarkViolet'>光学曝光工序有哪些？</font>【课后复习题】</p><p><font color='OrangeRed'>基片表面处理、涂敷光刻胶、前烘、曝光、后烘、显影、清除残胶、坚膜、图形转移、去胶等</font></p><p><strong>前烘的目的</strong>：去除胶膜中残存的溶剂，使胶膜干燥，以增强胶膜与基片的粘附性和胶膜的耐磨性</p><p><strong>后烘的目的</strong>：部分消除驻波造成的影响，但是也会导致胶中光活性物质横向扩散，影响胶的图形质量</p><blockquote><p>光线照射到光刻胶与基片界面上会产生部分反射，反射光会使掩模不透光区下边的光刻胶进行曝光，反射光与入射光叠加会形成驻波，驻波会造成光刻胶边缘曝光结果出现螺纹状</p><p>如果涂胶前在基片上先涂覆一层抗反射层或涂胶后在胶表面施加抗反射剂则可以有效防止驻波效应</p></blockquote><p><strong>图形转移</strong>：通常通过 <u>干法刻蚀</u> 和 <u>湿法刻蚀</u></p><p><font color='DarkViolet'>光刻胶的评价指标有哪些？</font>【课后复习题】</p><p>灵敏度、对比度、抗刻蚀比、分辨能力、曝光宽容度、工艺宽容度、热流动性、膨胀效应、粘度、保质期限</p><blockquote><p>灵敏度是衡量曝光速度的指标，灵敏度越高，所需要的曝光剂量越小</p><p>对比度越高，曝光的线条边缘越陡</p><p>抗刻蚀比是衡量在刻蚀过程中保护下层材料的能力</p><p>分辨能力影响最小线宽</p></blockquote><p><font color='DarkViolet'>正胶和负胶的区别：</font>【课后复习题】</p><table><thead><tr><th align="center"></th><th align="center"><strong>曝光反应</strong></th><th align="center"><strong>显影结果</strong></th><th align="center"><strong>图案关系</strong></th><th align="center"><strong>灵敏度</strong></th><th align="center"><strong>对比度</strong></th><th align="center"><strong>分辨率</strong></th><th align="center">显影液</th><th align="center">残胶现象</th><th align="center">成本</th></tr></thead><tbody><tr><td align="center">正胶</td><td align="center">曝光后可溶解</td><td align="center">未曝光区域保留</td><td align="center">与掩膜一致</td><td align="center">较低</td><td align="center">高</td><td align="center">高</td><td align="center">水溶性</td><td align="center">少</td><td align="center">较高</td></tr><tr><td align="center">负胶</td><td align="center">曝光后不可溶解</td><td align="center">未曝光区域被去除</td><td align="center">与掩膜相反</td><td align="center">高</td><td align="center">低</td><td align="center">较低</td><td align="center">有机溶剂(污染环境)</td><td align="center">较普遍</td><td align="center">较低</td></tr></tbody></table><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>光学曝光的方式有哪些?各有什么优缺点?</font></li><li><font color='OrangeRed'>光学曝光的工序一般有哪些?</font></li><li><font color='OrangeRed'>光刻胶的性能指标有哪些?正胶和负胶有什么区别?</font></li></ol><h3 id="光学曝光的分辨率"><a href="#光学曝光的分辨率" class="headerlink" title="光学曝光的分辨率"></a>光学曝光的分辨率</h3><p>特征尺寸(CD)：掩膜设计的最小图形尺寸</p><p>最小线宽：$l_{CD}&#x3D;\sqrt {\lambda z}$，反映了制造工艺的分辨能力</p><blockquote><p>$\lambda $ 是曝光光源的波长，$z$ 是掩模版与基片间的间隙距离</p></blockquote><p><font color='DarkViolet'>数值孔径的定义：</font> 【课后复习题】</p><p>平行光通过透镜后聚焦成一直径有限的光点时，最外光线与光轴间夹角$\theta $的正弦值与透镜和基片之间介质的折射率$n$的乘积</p><p><font color='DarkViolet'>NA对光学曝光分辨率和焦深有什么影响？</font>【课后复习题】</p><p>数值孔径越大，分辨率越高，焦深越小</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241126212103608.png" alt="image-20241126212103608" style="zoom:50%;" /><p><font color='DarkViolet'>光学分辨率的定义： </font>【课后复习题】</p><p>能精确转移到晶片表面光刻胶图案的最小特征尺寸<br>$$<br>R&#x3D;k_{1} \frac{\lambda}{N A}<br>$$<br>分辨率可以通过减小曝光波长和增加数值孔径来实现</p><p><font color='DarkViolet'>焦深的定义： </font> 【课后复习题】</p><p>指能够满足光刻分辨率与特征尺寸<strong>均匀性</strong>的基片最大离焦范围<br>$$<br>D&#x3D;k_{2} \frac{\lambda}{(N A)^{2}}<br>$$</p><blockquote><p>$k_{1} ,k_{2}  $ 为与工艺相关的参数，<font color='OrangeRed'>$k_1$的理论极限是0.25</font></p></blockquote><p>焦深可以通过增大曝光波长和减小数值孔径实现</p><p><font color='OrangeRed'>单纯追求分辨率会使得焦深大大降低，分辨率只有在一定焦深范围才有意义</font></p><p>焦深太小，掩模成像只在很小的高度起伏范围内才能保证聚焦，超过这一范围就会散焦</p><p><font color='DarkViolet'>有哪些短波曝光技术？ </font>【课后复习题】</p><p>深紫外光刻(DUV)、极紫外光刻(EUV)、X射线曝光技术</p><p><font color='DarkViolet'>短波曝光技术面临的问题：</font> 【课后复习题】</p><table><thead><tr><th>技术</th><th>波长范围</th><th>主要挑战</th></tr></thead><tbody><tr><td>DUV</td><td>193 nm、248 nm</td><td>分辨率受限，面临光波长和数值孔径的物理限制；<br />为实现更小特征尺寸，需要通过多重曝光、多重图案化等方法提高分辨率，工艺复杂度高；</td></tr><tr><td>EUV</td><td>13.5 nm</td><td>光源输出功率较低且难提高，导致曝光效率低，生产速率缓慢；<br />光刻胶材料需要更高的灵敏度和分辨率；</td></tr><tr><td>X 射线</td><td>0.1–10 nm</td><td>光源技术尚不成熟，难以实现高功率；<br />掩模制造困难，需要有X射线的高透明性，且掩膜图样精细度高；<br />分辨率受限，难以获得与波长相对应的曝光分辨率 ；</td></tr></tbody></table><blockquote><p>193nm波长的深紫外光刻使用水作为浸没液体  </p></blockquote><p><font color='DarkViolet'>什么是大数值孔径和浸没式曝光技术?为什么要发展他们?</font>【课后复习题】</p><p>大数值孔径技术：通过增加光刻机镜头的数值孔径来提高分辨率</p><p>浸没式曝光技术：在光刻过程中，将镜头与基片之间的空气替换为高折射率的液体(通常是水)，增加光学系统中的折射率来提高数值孔径 NA，从而提升分辨率</p><p>发展它们是为了突破传统光刻的物理限制</p><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><p><font color='OrangeRed'>光学曝光的分辨率和焦深是什么意思?他们由什么决定?</font></p></li><li><p><font color='OrangeRed'>有哪些短波曝光技术?他们都面临什么样的问题?</font></p></li><li><p><font color='OrangeRed'>什么是数值孔径?它对光学曝光分辨率和焦深有什么影响?</font></p></li><li><p><font color='OrangeRed'>什么是大数值孔径和浸没式曝光技术?为什么要发展他们?</font></p></li></ol><h3 id="分辨率增强技术"><a href="#分辨率增强技术" class="headerlink" title="分辨率增强技术"></a>分辨率增强技术</h3><p>分为对光学系统的改进和对掩膜版的改进</p><p><font color='DarkViolet'>针对曝光光学系统和光刻掩膜，有哪些分辨率增强技术?</font> 【课后复习题】</p><table><thead><tr><th>光学曝光工艺环节</th><th>分辨率增强技术</th></tr></thead><tbody><tr><td>照明光学系统</td><td>离轴照明技术</td></tr><tr><td>成像光学系统</td><td>空间滤波技术</td></tr><tr><td>光学掩模</td><td>移相掩模技术，光学邻近效应校正技术</td></tr></tbody></table><p><strong>离轴照明技术</strong>：</p><p>传统曝光系统的光源是通过一个中心圆孔进入聚光透镜系统</p><p>离轴照明技术采用倾斜照明方式，照明光束以偏离主光轴方向$\theta &#x2F;2$入射，用从掩模透过的零级光和其中一个一级衍射光成像，让包含主要结构信息的低频分量和部分包含精细特征的高频分量都进人系统，因而可以提高分辨率，改善像质；由于是双光束对称成像，还可改善焦深</p><table><thead><tr><th>传统照明系统</th><th>离轴照明系统</th></tr></thead><tbody><tr><td>$\begin{aligned}R_{\text {传统 out }- \text { off }}&#x3D;\frac{\lambda}{2 N A(1+\sigma)} \end{aligned}$</td><td>$\begin{aligned}R_{\text {离轴 out }- \text { off }}&#x3D;\frac{\lambda}{2 N A(1+\sigma)+2 \theta_{i}} \end{aligned}$</td></tr></tbody></table><p>$\sigma  $ 为曝光系统的部分相干因子，$\theta_{i} $ 为离轴照明光束的入射角；与传统照明相比，离轴照明提高了分辨率</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20240918230341881.png" alt="image-20240918230341881" style="zoom: 43%;" />$$DOF_{离轴}/DOF_{传统}=\tan \theta' /\tan \frac{\theta '}{2}$$> 四极照明比环形照明的效果更明显，但仅适用于周期性图形<p><strong>空间滤波技术</strong>：</p><p>在透镜的光阑平面上通过加滤光片，滤波片的不同环区对入射光有不同的透射率和相位差，从而部分遏制低频分量，突出高频分量，使得图像清晰度增加</p><p><strong>移相掩膜技术</strong>：</p><p>通过移相掩模使两个紧邻清晰区域各自引入0°和180°的相位差，改变了电场的符号，减少了硅片上两个光孔之间黑暗区域的光强，以此来改进图像对比度，从而导致了更好的分辨率和焦深</p><p><font color='DarkViolet'>什么是光学临近效应？</font>【课后复习题】</p><p>光学临近效应是指在光刻过程中，由于光通过掩膜图案时发生的干涉和衍射，导致实际在衬底上形成的图形与设计图形存在偏差，这种效应会引起线宽变化、图形畸变和位置误差，比如方角图形变成圆角，或者线端变短，影响半导体器件的精度和性能。</p><p><font color='DarkViolet'>光学邻近效应的校正：</font>【课后复习题】</p><ol><li><p><font color='DarkViolet'>线条偏置法(形状调整法)：</font>对原设计增加或减少部分图形</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241127222743078.png" alt="image-20241127222743078" style="zoom:50%;" /></li><li><p><font color='DarkViolet'>加衬线法</font>：通过在掩模上添加亚分辨辅助线条，使孤立的空间像能和密集线条的空间像具有相同的线宽</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241127222953407.png" alt="image-20241127222953407" style="zoom: 67%;" /></li><li><p><font color='DarkViolet'>灰度掩膜法：</font>调整掩模图形的局部透光率；（类似剂量校正）</p><p>传统掩模上只有透光区与不透光区，而灰度掩模的透光率则是以灰度等级来表示，实现灰度的方法是改变掩模的透光点密度，一种是改变透光点的大小，一种是改变透光点的数目，也可以二者相结合</p></li></ol><p><font color='DarkViolet'>可以突破光学曝光分辨率的理论极限的方法</font>【课后复习题】</p><p>在没有任何技术优化的情况下，$k_1$的理论下限为0.61；使用了分辨率增强技术后接近于理论下限0.25；</p><p>多重曝光和加工技术是唯一可以进一步突破$k_1$理论极限的技术；</p><p>多重曝光：设计子图案掩膜，多次曝光；</p><p>多重加工：曝光刻蚀后再曝光再刻蚀； </p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241221233330836.png" alt="image-20241221233330836" style="zoom:50%;" /><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>针对曝光光学系统和光刻掩膜，有哪些分辨率增强技术?</font></li><li><font color='OrangeRed'>什么是光学临近效应?可以通过什么方法进行校准?</font></li><li><font color='OrangeRed'>有什么方法可以突破光学曝光分辨率的理论极限?具体是怎么实现的?</font></li></ol><h2 id="电子束曝光技术-EBL"><a href="#电子束曝光技术-EBL" class="headerlink" title="电子束曝光技术(EBL)"></a>电子束曝光技术(EBL)</h2><h3 id="电子束曝光系统"><a href="#电子束曝光系统" class="headerlink" title="电子束曝光系统"></a>电子束曝光系统</h3><p>电子束曝光(electron beam lithography)：利用某些高分子聚合物对电子敏感而形成曝光图形</p><p>光学曝光分辨率：<br>$$<br>R&#x3D;k_1\frac{\lambda }{NA}<br>$$<br>受光波长的限制：G线(436nm)→I线(365nm)→DUV(248,193nm)→EUV(13nm)</p><p>根据波粒二象性，电子波长<br>$$<br>\lambda_e&#x3D;\frac{1.226}{\sqrt V} \text{nm}<br>$$<br>电子光学像差：决定最小束斑直径</p><ul><li><p>一般像差：<font color='OrangeRed'>其中以球差和色差为主</font></p></li><li><p>偏转像差： 电子束离轴后形成的像差，如像散和场曲</p></li></ul><p>空间电荷效应像差： 空间电荷排斥效应会使电子束直径增大，破坏聚焦（小束斑需要小束流）</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20240923133228818.png" alt="image-20240923133228818" style="zoom: 43%;" /><h3 id="电子束抗蚀剂"><a href="#电子束抗蚀剂" class="headerlink" title="电子束抗蚀剂"></a>电子束抗蚀剂</h3><p>两种分类</p><table><thead><tr><th align="center">正型</th><th align="center">负型</th></tr></thead><tbody><tr><td align="center">显影后曝光区域溶解</td><td align="center">显影后未曝光区域溶解</td></tr><tr><td align="center">PMMA，ZEP-520</td><td align="center">HSQ</td></tr></tbody></table><p>PMMA过曝光时可从正胶转变为负胶特性，但抗刻蚀能力差(ZEP-520抗刻蚀能力强)</p><table><thead><tr><th align="center">传统型</th><th align="center">化学放大型</th></tr></thead><tbody><tr><td align="center">抗蚀剂中聚合物分解在曝光过程中完成</td><td align="center">抗蚀剂中聚合物分解在后烘过程中完成</td></tr></tbody></table><blockquote><p>和光刻胶的正负性质相同</p></blockquote><p>传统型：抗蚀剂中的聚合物分解或链接是在曝光过程中完成  </p><p>常见高分辨率电子束抗蚀剂：</p><blockquote><p>化学放大型优点：具有高灵敏度，兼有高分辨率；高对比度；高刻蚀比  </p><p>化学放大型缺点：后烘工艺条件要求高；存在延迟效应和表面污染</p></blockquote><p>实际曝光剂量的决定因素：</p><table><thead><tr><th>因素</th><th>剂量变化</th></tr></thead><tbody><tr><td>电子束能量 ↑</td><td>↑ <font color='DarkViolet'> 曝光主要靠低能量电子</font></td></tr><tr><td>抗蚀剂厚度 ↑</td><td>↓ 抗蚀剂越薄，其中电子能量沉积越少</td></tr><tr><td>图形密度 ↑</td><td>↓ 电子散射互相影响</td></tr><tr><td>衬底材料密度 ↑</td><td>↓ 高密度衬底会产生更多背散射电子</td></tr></tbody></table><p>and 抗蚀剂工艺条件：后烘温度、显影液温度和强度等</p><p><font color='OrangeRed'>多层胶工艺：从下到上灵敏度逐渐降低，形成undercut结构   </font></p><p><font color='DarkViolet'>影响电子束曝光分辨率的因素有哪些？</font>【课后复习题】</p><p>主要受电子像差和电子散射的影响，高分辨率需要小束斑，影响因素如下：</p><table><thead><tr><th>影响因素</th><th></th></tr></thead><tbody><tr><td>加速电压(电子束能量)</td><td>加速电压越大，电子能量高，可以减少散射角，获得更小的束斑与更高分辨率，但影响曝光深度，加速电压需适中</td></tr><tr><td>束流大小</td><td>束流强度决定单位时间照射到样品的电子数量，小束流空间电荷效应小，可以获得小束斑</td></tr><tr><td>抗蚀剂厚度</td><td>抗蚀剂越薄，电子在内部散射越少，有助于提高分辨率</td></tr><tr><td>抗蚀剂灵敏度</td><td>低灵敏度抗蚀剂具有更高的分辨率和对比度</td></tr><tr><td>图形密度</td><td>图形密度低，邻近效应小</td></tr><tr><td>衬底密度和导电性</td><td>衬底密度越低背散射越少，导电性强可以降低电荷积累效应</td></tr></tbody></table><p><font color='DarkViolet'>如何抑制电子束与抗蚀剂作用范围的扩展？ </font>【课后复习题】</p><p>即减少电子散射范围</p><ul><li>增大电子束的能量</li><li>降低束流大小</li><li>控制曝光剂量；</li><li>采用更薄的抗蚀剂层；</li><li>使用高分辨率抗蚀剂(快速反应，减少累计散射)</li></ul><p>针对高灵敏度和低灵敏度的问题举例：</p><ul><li>PMMA(聚甲基丙烯酸甲酯)：作为一种典型的低灵敏度抗蚀剂，PMMA在高剂量下表现出优异的分辨率，广泛应用于纳米级图形的制备。然而，其高剂量需求也可能导致较大的邻近效<br>应，需要通过优化曝光和显影工艺来控制</li><li>ZEP和其他高灵敏度抗蚀剂：这些抗蚀剂在较低的电子剂量下即可实现有效曝光，适用于需要快速曝光和抑制邻近效应的场景，但在分辨率上可能不及PMMA</li></ul><h3 id="电子束曝光成像质量"><a href="#电子束曝光成像质量" class="headerlink" title="电子束曝光成像质量"></a>电子束曝光成像质量</h3><p>电子束在抗蚀剂和基底材料中的散射：</p><table><thead><tr><th align="center"></th><th align="center">散射深度</th><th align="center">散射范围</th></tr></thead><tbody><tr><td align="center">电子能量 ↑</td><td align="center">↑</td><td align="center">↑</td></tr><tr><td align="center">衬底密度 ↑</td><td align="center">↓</td><td align="center">↓</td></tr></tbody></table><p>衬底密度越高导致背散射电子增加，  背散射造成的邻近效应可波及几个微米，造成密集图形变形失真  </p><p><font color='DarkViolet'>光学曝光邻近效应和电子束曝光邻近效应导致的原因有何不同?</font>【课后复习题】</p><ul><li><p>光学曝光：干涉和衍射；</p></li><li><p>电子束曝光：电子散射；</p></li></ul><p><font color='DarkViolet'>如何校准电子束曝光的临近效应?</font>【课后复习题】</p><p><strong>图形校正</strong>：对掩膜图形进行调整，避免过度曝光</p><p><strong>剂量校正</strong>：根据邻近效应模型，调整每个图案的曝光剂量，消除邻近区域的过度曝光</p><p><strong>背景曝光</strong>：第一次对曝光图形进行正常曝光，第二次将所有没有图形的地方以散焦的电子束和低剂量进行曝光，目的是补偿能量  </p><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>影响电子束曝光分辨率的因素有哪些?</font></li><li><font color='OrangeRed'>如何抑制电子束与抗蚀剂作用范围的扩展?</font></li><li><font color='OrangeRed'>导致光学曝光临近效应和电子束曝光临近效应导致的原因有何不同?如何校准电子束曝光的临近效应?</font></li></ol><h2 id="聚焦离子束曝光技术-FIB"><a href="#聚焦离子束曝光技术-FIB" class="headerlink" title="聚焦离子束曝光技术(FIB)"></a>聚焦离子束曝光技术(FIB)</h2><p>聚焦离子束(Focused Ion beam)成为一种用途广泛的微纳加工工具，因为具备4个特点&#x2F;功能：</p><p> (1) 材料表面加工；（2）注入掺杂，材料改性；（3）材料沉积；（4）高分辨能力</p><p>液态金属离子源(LMIS)：利用液态金属在强电场下形成场致离子发射离子源(液态金属Ga)  </p><p>离子在固体中会经历一系列散射，在散射中不断损失能量，最后停止并留在固体中  </p><p><font color='DarkViolet'>离子束和材料的相互作用与电子束和材料的相互作用有何不同?</font>【课后复习题】</p><p>最主要区别在于粒子的质量和电荷，离子束具有较大质量和多重电荷，电子束质量轻、电荷单一</p><p>离子束：通过直接的物理溅射和材料表面原子碰撞来移除材料，表面损伤较大</p><p>电子束：通过电子与材料的电荷相互作用来产生光刻效应，有电子散射，表面损伤较小</p><p><font color='DarkViolet'>比较离子束曝光技术与电子束曝光技术</font>【课后复习题】</p><table><thead><tr><th>特性</th><th>离子束曝光(FIB)</th><th>电子束曝光(EBL)</th></tr></thead><tbody><tr><td>工作原理</td><td>使用聚焦离子束直接轰击，使其发生化学或物理反应</td><td>电子与抗蚀剂相互作用引发化学反应</td></tr><tr><td>加工方式</td><td>既可以进行曝光，也可进行直接加工图形</td><td>通过抗蚀剂间接加工，需要后续刻蚀工艺</td></tr><tr><td>相互作用深度</td><td>离子相互作用集中在材料表面（几纳米至几十纳米）</td><td>电子在材料中穿透较深（几十纳米至几微米）</td></tr><tr><td>分辨率</td><td>分辨率更高，适用于亚纳米级加工</td><td>分辨率高，适用于纳米级图案加工</td></tr><tr><td>曝光速度</td><td>曝光速度较慢，适合小面积高精度加工</td><td>曝光速度较快，适合大面积图案加工</td></tr><tr><td>应用场景</td><td>高精度表面修饰、纳米结构直接雕刻</td><td>高分辨率曝光、纳米图案加工</td></tr></tbody></table><p><font color='DarkViolet'>离子束加工的原理有哪些？</font>【课后复习题】</p><ul><li><p>离子溅射：入射离子将能量传给靶材原子，使其获得足够能量而逃逸出固体表面的现象，是离子束加工的最主要功能</p></li><li><p>离子束辅助沉积：吸附在靶材表面的非活性气体分子在离子束的轰击下发生分解，生成固态物质沉积在材料表面</p></li></ul><p><font color='DarkViolet'>离子束加工技术的应用有哪些？</font>【课后复习题】</p><p>审查与修改集成电路芯片；修复光刻掩模缺陷 ；制作透射电镜样品；多用途微切割工具  </p><p><font color='DarkViolet'>什么是离子束注入技术？</font>【课后复习题】</p><p>离子束注入技术是一种利用高能离子束将离子注入材料表面的物理技术，控制离子掺杂和材料改性</p><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>离子束和材料的相互作用与电子束和材料的相互作用有何不同?</font></li><li><font color='OrangeRed'>离子束加工的原理有哪些?</font></li><li><font color='OrangeRed'>离子束加工技术有哪些应用?</font></li><li><font color='OrangeRed'>比较离子束曝光技术与电子束曝光技术</font></li><li><font color='OrangeRed'>什么是离子束注入技术?</font></li></ol><h2 id="扫描探针加工技术"><a href="#扫描探针加工技术" class="headerlink" title="扫描探针加工技术"></a>扫描探针加工技术</h2><p>扫描探针加工技术的优缺点：</p><ul><li>优点：简单易行  </li><li>缺点：加工精度有限；加工深度有限；加工速度极低；加工面积极小</li></ul><p>扫描探针显微镜：</p><ul><li><p>STM：扫描隧道显微镜</p></li><li><p>SFM：扫描力显微镜</p></li><li><p>NSOM：扫描近场光学显微镜</p></li></ul><h3 id="扫描隧道显微镜-STM"><a href="#扫描隧道显微镜-STM" class="headerlink" title="扫描隧道显微镜(STM)"></a>扫描隧道显微镜(STM)</h3><p><font color='DarkViolet'>STM的成像原理：</font>【课后复习题】</p><p>当探针与样品表面距离足够近时，电子发生隧穿效应，产生一个非常小的电流，距离越近，隧道电流越大；</p><p>STM通过精确的反馈系统控制探针的高度，使得隧道电流保持恒定，STM可以记录探针的位移，这个位移的变化反映了样品表面的高度变化，形成样品表面的高度图像。</p><h3 id="原子力显微镜-AFM"><a href="#原子力显微镜-AFM" class="headerlink" title="原子力显微镜(AFM)"></a>原子力显微镜(AFM)</h3><p><font color='DarkViolet'>AFM的成像原理：</font>【课后复习题】</p><p>将对微弱力极敏感的微悬臂一端固定，另一端有一个非常尖锐的探针(通常由硅或氮化硅制成)</p><p>当探针接近样品表面时，探针尖端和样品表面的原子之间会产生不同的相互作用力，如范德华力、电磁力等，扫描时控制力的恒定，通过使用光学系统（通常是激光反射装置）来检测悬臂的位移，从而获得样品的表面形貌信息。</p><p>在AFM中探针与样品原子之间有两种类型相互作用力</p><ul><li>短程力：在针尖与样品表面接触时相互作用力主要是短程的原子间斥力，如泡利斥力和离子斥力、磨擦力等</li><li>长程力：当针尖离开样品表面10nm~100nm或更大时，如象磁力、静电力和范德瓦尔斯力等</li></ul><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241014145405727.png" alt="image-20241014145405727" style="zoom:50%;" /><p>短程力的作用范围在0.1mm以下，把工作在这种模式下的AFM称为接触式AFM</p><p>最主要用的是Tapping mode</p><table><thead><tr><th>AFM的类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>接触式AFM (Contact Mode)</td><td>高扫描速度；<br />高分辨率（原子分辨率）；<br />可以扫描表面极端变化的样本；</td><td>横向力、摩擦力可能会扭曲图像中的特征；<br />探针与样品表面直接接触，可能导致样品的损坏；<br />接触导致探针磨损，进而影响成像精度和分辨率</td></tr><tr><td>轻敲式AFM(Tapping mode)</td><td>横向分辨率更高(1~5nm)；<br />几乎消除了侧向力；<br />减少了样品损伤；</td><td>扫描速度比接触式AFM较慢</td></tr><tr><td>非接触式AFM(Non-contact Mode)</td><td>样品表面不受力，避免样品损伤</td><td>横向分辨率较低，受针尖-样品分离影响；<br />扫描速度比接触与轻敲慢，以避免针尖被卡住；<br />只适用于疏水性极强的样品；</td></tr></tbody></table><p>分辨率的影响因素：</p><ul><li>针尖半径：探针尖端的半径越小，分辨率越高；</li><li>针尖侧面角：决定最高表面比率特征的探测能力</li><li>成像模式：接触、轻敲、非接触</li></ul><h3 id="扫描近场光学显微镜-SNOM"><a href="#扫描近场光学显微镜-SNOM" class="headerlink" title="扫描近场光学显微镜(SNOM)"></a>扫描近场光学显微镜(SNOM)</h3><p>SNOM与STM或AFM的基本区别是将固体扫描探针换成一个扫描光源，光源扫描由光纤探针实现</p><p>近场光学成像分辨率与入射光波长无关， 只与光探针的大小(数值孔径)有关    </p><p>优点：突破衍射极限；非破坏性分析；多维信号获取</p><p>SNOM通常有两种工作模式：</p><ul><li>透射模式：光通过样品，然后被探针采集，这种模式适用于透明样品</li><li>反射模式：光反射回样品表面并被探针捕获，适用于不透明样品</li></ul><h3 id="扫描探针加工技术-1"><a href="#扫描探针加工技术-1" class="headerlink" title="扫描探针加工技术"></a>扫描探针加工技术</h3><p><strong>抗蚀剂曝光加工</strong>（一般不咋用）</p><p>包括STM曝光、SNOM曝光</p><p>STM曝光的一些问题：</p><table><thead><tr><th>问题</th><th>具体解释</th></tr></thead><tbody><tr><td>抗蚀剂层必须很薄</td><td>由于探针的针尖必须非常靠近作为阳极的衬底材料表面才能产生足够高的场致发射电流，用STM曝光的抗蚀剂一般不超过50nm厚</td></tr><tr><td>曝光分辨率≤成像分辨率</td><td>相比于电子束曝光利用聚焦电子束，STM针尖发射的电子束是<font color='OrangeRed'>发散束</font>，发散程度取决于施加的偏压和探针与抗蚀剂表面的距离</td></tr><tr><td>曝光所需剂量大</td><td>STM曝光的特点是低能电子束曝光，曝光同样尺寸图形时，STM曝光的剂量是传统曝光的30倍</td></tr></tbody></table><p><strong>局部氧化加工</strong></p><p>STM或AFM针尖处的强电场使得空气中的水分子在针尖附近被电离成离子态，然后将衬底材料氧化，扫描针尖形成加工图形</p><p>反应影响因素：偏压、探针在某一点的停留时间，环境空气湿度等</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241014140951548.png" alt="image-20241014140951548" style="zoom:50%;" /><p>环境湿度对局部氧化层起着重要作用：</p><ul><li>湿度越大，供给局部氧化的水分子越多，氧化越快；</li><li>湿度会影响针尖局部电场的分布；</li><li>湿度较大时，会在针尖和样品之间形成一层水膜，使局部电场发散和局部氧化范围增加，造成氧化线条变宽</li></ul><p>STM不能反馈氧化层的变化，氧化层的生长导致隧道电流和针尖表面距离的减小，但STM反馈系统会增大探针偏压，且不会同步抬起探针，易导致探针受损</p><p>AFM的偏压独立于探针高度的反馈控制系统，可以很好地适应氧化物的生长；且氧化层的厚度可以原位实时监测    </p><p><font color='Orangered'>AFM更适合扫描探针局部氧化加工  </font></p><p><strong>添加式纳米加工</strong></p><p>包括：场致沉积加工、蘸笔纳米探针加工</p><p><strong>抽减式纳米加工</strong></p><p>包括：电化学刻蚀加工、场致分解加工、热力压痕加工、机械划痕加工</p><p><font color='DarkViolet'>扫描探针加工技术有哪些方式？</font>【课后复习题】</p><p>抗蚀剂曝光加工；局部氧化加工；添加式纳米加工；抽减式纳米加工；高产出率扫描探针加工</p><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>STM和AFM的成像原理是什么?</font></li><li><font color='OrangeRed'>扫描探针加工技术有哪些方式?</font></li></ol><h2 id="复制加工技术"><a href="#复制加工技术" class="headerlink" title="复制加工技术"></a>复制加工技术</h2><p>纳米压印是一种全新的纳米图形复制技术</p><p><font color='DarkViolet'>纳米压印技术的特点是什么?</font>【课后复习题】</p><p>超高分辨率、高产量、低成本</p><blockquote><p>高分辨率：没有光学曝光中的衍射现象和电子束曝光中的散射现象</p><p>高产量：可以像光学曝光那样并行处理，同时制作成百上千个器件</p><p>低成本：不像光学曝光机那样需要复杂的光学系统或像电子東曝光机那样需要复杂的电磁聚焦系统</p></blockquote><h3 id="热压纳米压印技术"><a href="#热压纳米压印技术" class="headerlink" title="热压纳米压印技术"></a>热压纳米压印技术</h3><p><font color='DarkViolet'>纳米压印过程包括的主要步骤：  </font>【课后复习题】</p><ol><li>涂覆聚合物涂层（如PMMA）；【PMMA是最早用来作为压印层的聚合物】</li><li>（在一定温度下）模具对准与压印；</li><li>聚合物固化，然后从基底上移除模具；</li><li>反应离子刻蚀去残胶，后续可进行图形转移</li></ol><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241016103235535.png" alt="image-20241016103235535" style="zoom:50%;" /><p>实现高质量纳米压印取决于印模、压印涂层材料、脱模技术、对准精度  </p><p>热压纳米压印最适合于制作<u>均匀的、小尺寸的、阵列式</u>的图形</p><table><thead><tr><th></th><th>印模</th><th>压印材料</th></tr></thead><tbody><tr><td>要求</td><td>印模和印模图形必须是硬质材料，如硅、氧化硅、氮化硅、金属等；<br />印模图形由电子束&#x2F;光学曝光技术&#x2F;激光直写加工；<br />最经久耐用的印模材料是<font color='OrangeRed'>金属镍  </font></td><td>较低的玻璃化转变温度$T_g$，降低压印温度；<br />较低的粘塑性，保证聚合物材料的流动性和印模空腔的充分填充；<br />较小的收缩性，保证冷却后压印结构不变；<br />较好的抗刻蚀性，保证压印图形完整转移</td></tr></tbody></table><p><strong>脱模</strong>：</p><p>有三种情况脱模会对压印图形造成破坏：  </p><ol><li><p>压印材料黏附在印模上</p></li><li><p>印模图形侧壁表面粗糙，当印模拔出时在印模和压印图形之间形成较大摩擦力</p></li><li><p>印模浮雕结构的侧壁坡度不合理，当拔出印模时连带将压印材料拔出</p></li></ol><p>希望是正坡度或零坡度边壁，但一般难以获得深宽比高的压印图形    </p><p>采用双层压印材料涂层可实现高深宽比图形结构的压印</p><h3 id="紫外固化纳米压印技术"><a href="#紫外固化纳米压印技术" class="headerlink" title="紫外固化纳米压印技术"></a>紫外固化纳米压印技术</h3><p>与热压纳米压印的基本区别：</p><ol><li><p><font color='OrangeRed'>采用了透明印模</font></p></li><li><p>采用可以经紫外固化的液体压印材料，其室温下黏度低  </p><p>没有固化的有机聚合物可以像未被曝光的负型光刻胶一样通过显影清洗掉</p></li></ol><p>如果衬底是透明的，则用非透明印模也可以实现紫外固化印模  </p><p><strong>闪光压印</strong>：因为光敏剂涂层很薄，只需要极短的紫外光照射即可固化  </p><p>曝光-压印混合光刻可以同时获得尺寸差异巨大的图形结构  </p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241016113015006.png" alt="image-20241016113015006" style="zoom: 67%;" /><h3 id="纳米转印技术"><a href="#纳米转印技术" class="headerlink" title="纳米转印技术"></a>纳米转印技术</h3><p><font color='OrangeRed'>也称为反向纳米压印</font></p><p>纳米转印是先将有机聚合物材料涂覆到印模上，待压印材料均匀填充印模浮雕图形表面后，再将印模压到一个平面衬底上，最后移开印模，使印模上的压印结构转移到平面衬底上</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241016113131906.png" alt="image-20241016113131906" style="zoom: 50%;" /><p>纳米转印成功的关键是衬底材料的表面能大于印模材料的表面能  </p><p>与纳米压印相比的优点：</p><ol><li>即使衬底表面已有图形也能进行转印，可加工多层结构</li><li>由于压印材料是注入而非挤压入印模空腔中，纳米转印较容易实现高深宽比图形结构的制作</li></ol><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>纳米压印技术的特点是什么?</font></li><li><font color='OrangeRed'>纳米压印过程包括的主要步骤?</font></li></ol><h2 id="镀膜技术"><a href="#镀膜技术" class="headerlink" title="镀膜技术"></a>镀膜技术</h2><p>薄膜生长技术：化学工艺(CVD、电镀等)、物理工艺(PVD)</p><p>沉积过程中若沉积粒子来源于化合物的气相分解反应，则称为化学气相沉积(CVD)，否则称为物理气相沉淀(PVD)</p><p>气相沉积基本过程包括三个步骤：</p><ol><li>靶材的气化</li><li>蒸镀材料向所镀制的基片输送</li><li>蒸镀材料沉积在基片上构成膜层</li></ol><h3 id="物理气相沉淀PVD"><a href="#物理气相沉淀PVD" class="headerlink" title="物理气相沉淀PVD"></a>物理气相沉淀PVD</h3><p>气相物质的产生：</p><ul><li>蒸发镀膜：镀料加热蒸发</li><li>溅射镀膜：用具有一定能量的离子轰击靶材(镀料)，从靶材上击出镀料原子</li></ul><p>PVD所需实验条件：高真空 (HV)；高纯材料；清洁和光滑的衬底表面；提供能量的能源</p><blockquote><p><font color='DarkViolet'>1标准大气压 &#x3D; 760mmHg &#x3D; 760 (Torr)  </font></p><p>1Torr&#x3D;133.3Pa  </p></blockquote><p>低真空($10^{-1}$Pa) ：机械泵；较高真空($10^{-3}\sim 10^{-4}$Pa)：扩散泵；更高真空：分子泵  </p><p>真空度的影响：对高功函数金属影响相对小；对低功函数金属影响非常大(真空度低会氧化)</p><p><strong>蒸发镀膜的缺点</strong>：</p><ul><li><font color='OrangeRed'>最大缺点是不能产生均匀的台阶覆盖  </font></li><li>不同材料的蒸气压不同，使得沉积任意精度的合金组分难以实现</li></ul><table><thead><tr><th></th><th>热蒸发镀膜</th><th>电子束(热)蒸发</th></tr></thead><tbody><tr><td>原理</td><td>利用欧姆加热或电磁感应加热材料</td><td>利用高能聚焦电子束溶解蒸发材料</td></tr><tr><td>特点</td><td>无法蒸发难溶材料，蒸发率低，易污染</td><td>适用于高纯和高熔点物质的蒸发，避免与坩埚材料发生反应</td></tr></tbody></table><p>注意：高熔点靶材一般不适合使用lift-off工艺，其沉积过程往往需要在高温环境下进行，这会使光刻胶发生软化、分解甚至失效，从而影响图案的精度和lift-off效果。<font color='OrangeRed'>对于高熔点靶材，刻蚀工艺通常是更合适的选择</font></p><p><strong>溅射镀膜的优点</strong>：</p><ul><li>具有淀积并保持复杂合金原组分的能力</li><li>能够淀积高温熔化和难熔金属</li><li>能够在直径为200毫米或者更大的硅片上淀积均匀薄膜</li><li>能够在淀积金属前清除硅片表面沾污和本身的氧化物（被称为原位溅射）</li></ul><p><strong>磁控溅射</strong>：</p><p>附加磁场的优点：</p><ul><li>限制溅射离子的轨道</li><li>增加离子在气体中停留的时间</li><li>增强等离子体和电离过程</li><li>减少从靶材到衬底路程中的碰撞</li><li>高磁场附近的产值比较高</li></ul><p>磁场的存在将延长电子在等离子体中的运动轨迹， 提高了它参与原子碰撞和电离过程的几率  </p><p><font color='DarkViolet'>对比热蒸发&#x2F;电子束蒸发镀膜和磁控溅射镀膜工作原理差别和成膜特点</font>【课后复习题】  </p><p><strong>工作原理</strong>：</p><table><thead><tr><th>热蒸发&#x2F;电子束蒸发镀膜</th><th>磁控溅射镀膜</th></tr></thead><tbody><tr><td>通过加热靶材，使其从固态转化为气态，在基底表面凝结沉积薄膜</td><td>利用惰性气体在靶材表面形成等离子体，在电场作用下轰击靶材表面，溅射出靶材原子，使其沉积在基底上</td></tr></tbody></table><p><strong>成膜特点</strong>：</p><table><thead><tr><th></th><th>热蒸发&#x2F;电子束蒸发镀膜</th><th>磁控溅射镀膜</th></tr></thead><tbody><tr><td><strong>薄膜质量</strong></td><td>平坦基底上均匀性好，复杂基底上均匀性差<br />致密性差，可能存在孔隙</td><td>均匀性、致密性好<br />对复杂基底形状适应性好</td></tr><tr><td><strong>薄膜附着力</strong></td><td>较低</td><td>较高</td></tr><tr><td><strong>沉积速率</strong></td><td>较快</td><td>较慢</td></tr><tr><td><strong>适用材料</strong></td><td>低熔点材料</td><td>广泛，尤其高熔点材料</td></tr><tr><td><strong>膜厚控制</strong></td><td>简单，精度高</td><td>复杂，精度一般</td></tr></tbody></table><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>对比热蒸发&#x2F;电子束蒸发镀膜和磁控溅射镀膜工作原理差别和成膜特点？  </font></li></ol><h4 id="薄膜沉积技术"><a href="#薄膜沉积技术" class="headerlink" title="薄膜沉积技术"></a>薄膜沉积技术</h4><p><font color='DarkViolet'>什么是PLD和MBE沉积技术？各自的优缺点是什么？</font>【课后复习题】</p><table><thead><tr><th></th><th>PLD脉冲激光沉积(Pulsed Laser Deposition)</th><th>MBE分子束外延(Molecular beam epitaxy)</th></tr></thead><tbody><tr><td>定义</td><td>通过高能激光束照射靶材表面，使其局部蒸发或激发成等离子体，并使这些蒸发的物质飞向基底的薄膜沉积技术</td><td>在极高真空下，通过精确控制分子束的流量、能量和方向，将原子层级的材料沉积到基底上的薄膜生长技术</td></tr><tr><td>优点</td><td>1. 无污染又易于控制；<br />2. 靶膜成分接近一致，适合制备具有复杂成分和高熔点的薄膜；<br />3. 多靶材组件变换灵便，容易制备多层膜及异质结</td><td>1. 精确的原子层厚度控制；<br />2. 能生长高质量的单晶薄膜，适用于复杂半导体器件；<br />3. 可实现原位观察、实时监测；<br />4. 非热平衡生长，可实现低温生长</td></tr><tr><td>缺点</td><td>1. 不易于制备大面积的膜；<br />2. 薄膜均匀性较差；<br />3. 仅适用于实验室</td><td>1. 沉积速率慢；<br />2. 设备复杂且昂贵</td></tr></tbody></table><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>什么是PLD和MBE沉积技术?各自的优缺点是什么?</font></li><li><font color='OrangeRed'>金属CVD的特点和优势</font></li></ol><h3 id="原子层沉积ALD"><a href="#原子层沉积ALD" class="headerlink" title="原子层沉积ALD"></a>原子层沉积ALD</h3><p><font color='DarkViolet'>金属CVD的特点和优势：  </font> 【课后复习题】</p><p>优良的台阶覆盖、通孔无间隙式填充、高深宽比接触、适应性广泛</p><p>原子层沉积(ALD, atomic layer deposition)是一种基于有序、表面自限制反应的CVD技术</p><p>虽然它与PVD有相似之处，但ALD的特点在于其通过交替引入反应物气体，以实现非常精确的薄膜生长</p><p><font color='DarkViolet'>ALD生长薄膜的基本过程：</font>【课后复习题】</p><ol><li>准备：真空，各点温度，阀门状态，气压等</li><li>脉冲通入前驱体1</li><li>抽气</li><li>脉冲通入前驱体2</li><li>抽气</li><li>回到步骤2，循环</li><li>结束：关阀门，降温，检查等</li></ol><p><font color='DarkViolet'>为什么ALD可以实现单原子层的薄膜生长？</font>【课后复习题】</p><p>主要得益于其表面自限制反应；</p><p>在每个ALD循环中，前驱体分子只能在基底表面形成单原子层结构，随后另一种前驱体分子与其反应，继续沉积另一个单原子层</p><p><font color='DarkViolet'>ALD和CVD生长薄膜的过程有什么不同？</font>【课后复习题】</p><table><thead><tr><th></th><th>ALD</th><th>CVD</th></tr></thead><tbody><tr><td>前驱体</td><td>前驱体交替进入反应室；<br />在工艺温度中不能分解；</td><td>前驱体通常是同时引入的；<br />通常需要高温来促进反应；</td></tr><tr><td>厚度控制</td><td>通过反应的循环次数，精确控制</td><td>通过工艺参数控制，精度较低</td></tr><tr><td>薄膜质量</td><td>高均匀性和致密性，缺陷少</td><td>薄膜质量高，但可能存在微量缺陷</td></tr><tr><td>沉积速率</td><td>较慢，每次仅沉积单原子层</td><td>较高，适合大规模沉积</td></tr><tr><td>工艺温度</td><td>温度较低（有利于热敏材料沉积）</td><td>温度较高（通常 500℃ ~ 1000℃）</td></tr></tbody></table><p><font color='DarkViolet'>如何避免在ALD过程中可能会出现CVD的过程：</font>【课后复习题】</p><ul><li><p>在引入下一种前驱体之前，彻底清除反应室中多余的前驱体和副产物</p></li><li><p>将反应温度保持在适当范围内，避免高温导致的CVD现象</p></li><li><p>控制前驱体的流量和暴露时间，防止过量反应</p></li></ul><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>ALD生长薄膜的基本过程是什么?为什么ALD可以实现单原子层的薄膜生长?</font></li><li><font color='OrangeRed'>ALD和CVD生长薄膜的过程有何不同?如何避免在ALD过程中可能会出现CVD的过程?</font></li></ol><h3 id="化学气相沉淀CVD"><a href="#化学气相沉淀CVD" class="headerlink" title="化学气相沉淀CVD"></a>化学气相沉淀CVD</h3><p>CVD的传输和反应过程：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241030114423556.png" alt="image-20241030114423556" style="zoom:50%;" /><p>CVD的反应条件：</p><ol><li>必须达到足够的沉积温度(高温CVD：&gt;900度，中温CVD：700~900度)</li><li>在沉积温度下，参加反应的各种物质必须有足够的蒸气压</li><li>参加反应的各种物质必须是气态(也可由液态蒸发或固态升华成气态)，而反应的生成物除了所需材料为固态外，其余也必须为气态</li><li>在沉积温度下，沉积物和基底材料本身的蒸气压要足够低</li></ol><p>CVD产物质量的影响因素：</p><ol><li><p>沉积温度：一般来说，温度越高，CVD化学反应速度加快</p><p>沉积温度过高，会造成晶粒粗大；沉积温度过低，反应不完全，产生不稳定结构和中间产物</p></li><li><p>沉积室压强</p><p>压强会影响沉积室内热量、质量及动量传输</p></li><li><p>反应气体分压(配比)</p><p>直接影响成核、生长、沉积速率、组织结构和成分</p></li></ol><p>CVD的优缺点：</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>薄膜质量高，致密性好；<br />膜厚均匀，适合大面积沉积；<br />可沉积多种材料；<br />沉积速度可以大范围调节</td><td>前驱体气体具有腐蚀性和毒性；<br />很难控制多组分的材料沉积；<br />工艺温度较高，热敏材料受限；</td></tr></tbody></table><h2 id="沉积图像转移"><a href="#沉积图像转移" class="headerlink" title="沉积图像转移"></a>沉积图像转移</h2><h3 id="溶脱剥离法lift-off"><a href="#溶脱剥离法lift-off" class="headerlink" title="溶脱剥离法lift-off"></a>溶脱剥离法lift-off</h3><p>蒸发和等离子溅射是适用于溶脱剥离法的常用薄膜沉积技术</p><p>溶脱剥离法是制作金属薄膜图形的主要方法， 因为许多金属材料都无法或者难以用刻蚀法形成图形  </p><p><font color='DarkViolet'>溶脱剥离法的过程：</font>【课后复习题】</p><ol><li>根据需要去除的涂层材料特性选择合适的溶剂</li><li>将溶剂均匀涂覆在材料表面，或将材料浸泡于溶剂中，使溶剂与涂层充分接触</li><li>保持溶剂与涂层接触一定时间，溶解或软化涂层，直至可以剥离</li><li>用水或其他适当的清洗剂去除材料表面残留的溶剂和涂层，再将材料干燥以恢复其表面状态</li></ol><p><font color='DarkViolet'>成功实现溶脱剥离的关键：</font>【课后复习题】</p><p>关键是保证沉积在光刻胶上与沉积在衬底上的金属薄膜不连续</p><ul><li>沉积金属薄膜厚度远小于光刻胶层厚度  </li><li>薄膜只沿垂直方向沉积</li></ul><p><font color='DarkViolet'>溶脱剥离的局限性：</font>【课后复习题】</p><ul><li>图形结构的高度受限：沉积的金属膜的厚度必须小于抗蚀剂或者光刻胶厚度的1&#x2F;3，因此无法获得高深宽比图像；</li><li>溶剂选择受限：部分材料不易被常规溶剂溶解</li><li>操作效率较低：较厚或结构复杂的涂层可能需要更长的时间才能溶解</li><li>表面损伤风险：溶剂的侵蚀作用可能会破坏基材表面或导致表面粗糙度改变</li></ul><p>改进方法：改进溶剂配方，改进曝光和光刻工艺，引入保护层</p><h3 id="热蒸发镀膜"><a href="#热蒸发镀膜" class="headerlink" title="热蒸发镀膜"></a>热蒸发镀膜</h3><p><font color='DarkViolet'>热蒸发镀膜特点：</font>【课后复习题】</p><p>具有较好的方向性，但<font color='OrangeRed'>沉积速率取决于蒸发源与衬底的距离及相对位置</font></p><p>在非垂直于蒸发源的位置，薄膜沉积的方向性会受到影响，进而会影响剥离转移的成功率</p><blockquote><p>可把样品放置于球面支架上，可获得均匀膜厚和改善方向性</p></blockquote><h3 id="溅射镀膜"><a href="#溅射镀膜" class="headerlink" title="溅射镀膜"></a>溅射镀膜</h3><p><font color='DarkViolet'>溅射镀膜特点：</font>【课后复习题】</p><p>溅射成膜的质量好，且衬底温升低，在需要高质量薄膜图形情况下多采用溅射沉积，但<font color='OrangeRed'>溅射法沉积的方向性不如热蒸发沉积法  </font></p><p>溅射沉积方向性差的主要原因：溅射靶原子在达到样品之前会经历空间气体原子的频繁碰撞散射，导致靶原子沉积的方向性降低，且溅射靶的尺寸要远远大于热蒸发沉积系统的蒸发源尺寸</p><p>改善溅射沉积方向性的两项措施：</p><ul><li><p>增加电极间距  </p><p>增加电极间距后，大角度发射的靶原子沉积到样品表面概率降低，也提高方向性，但缺点是靶材料的利用效率降低  </p></li><li><p>安装准直管</p><p>准直管只允许垂直或接近垂直飞行的溅射靶原子达到样品表面，大角度发射的靶原子均落在准直管的侧壁</p></li></ul><p><font color='OrangeRed'>沉积合金薄膜时，溅射法更优于热蒸发法，因为不同组分的热蒸发温度不同，导致膜的组分可能不同于靶的组分  </font></p><p><font color='DarkViolet'>为什么说热蒸发镀膜和溅射镀膜是适用于溶脱剥离法的薄膜沉积技术</font>【课后复习题】</p><p>热蒸发镀膜和溅射镀膜都具备良好的薄膜厚度控制、适中的附着力以及材料多样性，能够形成适合溶脱剥离法的薄膜结构。这些特点使得溶剂能够有效地渗透、溶解或剥离这些薄膜，从而实现高效的溶脱剥离过程。</p><h3 id="下切截面-undercut"><a href="#下切截面-undercut" class="headerlink" title="下切截面(undercut)"></a>下切截面(undercut)</h3><p>光学曝光形成的光刻胶截面一般都是上切(overcut)截面  </p><p><font color='DarkViolet'>什么是下切截面？</font>【课后复习题】</p><p>下切截面通常是指在材料加工过程中，沿着特定深度或角度对材料的表面进行部分削减或刻蚀，使其在垂直于加工方向的截面上呈现出“下切”或“凹陷”的特征</p><p><font color='DarkViolet'>为什么要下切截面？</font>【课后复习题】</p><ul><li>如果光刻胶图案的侧壁是垂直的或向上倾斜的，薄膜材料在沉积过程中容易在光刻胶的侧壁上连续覆盖，形成“桥梁”结构</li><li>下切截面确保了薄膜在光刻胶和基底之间有一个明显的分离区域，提高脱离效率</li></ul><p><font color='DarkViolet'>有什么方法可以实现下切截面？</font>【课后复习题】</p><p>多层光刻胶工艺；湿法刻蚀；倾斜曝光：</p><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>溶脱剥离法的过程是什么?成功实现溶脱剥离的关键是什么?溶脱剥离法有何局限性，如何解决?</font></li><li><font color='OrangeRed'>比较一下热蒸发镀膜和溅射镀膜的特点。为什么说它们是适用于溶脱剥离法的薄膜沉积技术?</font></li><li><font color='OrangeRed'>什么是下切截面?为什么要下切截面?有什么方法可以实现下切截面?</font></li></ol><h2 id="刻蚀技术"><a href="#刻蚀技术" class="headerlink" title="刻蚀技术"></a>刻蚀技术</h2><p><font color='DarkViolet'>刻蚀技术的重要参数：</font>【课后复习题】</p><p><font color='OrangeRed'>刻蚀速率、刻蚀方向、刻蚀均匀性、抗刻蚀比、精细度</font></p><blockquote><p>抗刻蚀比：描述刻蚀剂对不同材料刻蚀速率的比值，抗刻蚀比&#x3D;目标材料的刻蚀速度&#x2F;掩膜材料的刻蚀速度，高抗刻蚀比好</p></blockquote><p>主要分为湿法刻蚀和干法刻蚀</p><ul><li>湿法刻蚀：通常为各向同性刻蚀，具有高选择性，图形尺寸可控性差</li><li>干法刻蚀：单纯的物理刻蚀为各向异性刻蚀，无选择性，图形尺寸可控性高，适于小图形制作，对于离子增强或反应离子刻蚀既包含物理刻蚀也包含化学刻蚀作用</li></ul><h3 id="湿法刻蚀"><a href="#湿法刻蚀" class="headerlink" title="湿法刻蚀"></a>湿法刻蚀</h3><p>湿法腐蚀包含三个主要步骤：</p><ol><li>反应物通过扩散方式到达反应表面</li><li>化学反应在表面发生</li><li>反应生成物通过扩散离开表面</li></ol><p><font color='DarkViolet'>湿法刻蚀的特点：</font>【课后复习题】</p><p>一般为各向同性；高选择性；图形尺寸可控性差；</p><p><font color='DarkViolet'>湿法刻蚀的速度与什么有关？</font>【课后复习题】</p><p>刻蚀剂的浓度、刻蚀温度、材料的性质、搅拌速度</p><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>考察刻蚀技术的重要参数是什么?</font></li><li><font color='OrangeRed'>湿法刻蚀的特点是什么?</font></li><li><font color='OrangeRed'>湿法刻蚀的速度与什么相关?</font></li></ol><h3 id="干法刻蚀"><a href="#干法刻蚀" class="headerlink" title="干法刻蚀"></a>干法刻蚀</h3><p>干法刻蚀技术：广义上指所有不涉及化学腐蚀液体的刻蚀技术，狭义上的干法刻蚀主要指利用等离子体放电产生的物理和化学的刻蚀过程  </p><p><strong>反应离子刻蚀RIE</strong>：</p><p>反应离子刻蚀可简单归纳为离子轰击辅助的化学反应过程  </p><p>需满足两个必要条件：</p><ul><li>具有离子与化学活性气体的参与</li><li>刻蚀反应物必须为挥发性物，能够被真空系统及时抽走</li></ul><p><font color='DarkViolet'>反应离子刻蚀的微观过程有哪些：</font>【课后复习题】</p><p>物理溅射、离子反应、产生自由基、自由基反应</p><p>刻蚀气体的选择：</p><ul><li>一般硅及其硅化物的刻蚀气体主要以<u>氟化物</u>为主</li><li>III-V族元素化合物材料如GaAs和铝及其化合物的刻蚀气体以<u>氯化物</u>为主</li><li>某些III-V族元素化合物半导体材料(GaAs、InP)用氢或烷基气体刻蚀更有效  </li><li>选择刻蚀气体时应选择生成物沸腾温度低的气体，以便生成物能及时被抽走，有时需对样品台加温</li></ul><p>考察反应离子刻蚀性能的主要技术指标：  </p><ol><li>掩模材料对衬底材料的抗刻蚀比</li><li>各向异性度  </li><li>刻蚀速率  </li><li>刻蚀均匀性</li></ol><p>反应离子刻蚀的工艺参数：</p><ul><li><p>反应气体流量：流速太快将导致反应气体分子在反应室停留时间缩短，或如果流速太低， 被消耗的反应气体得不到及时供给，都会导致刻蚀速率下降；  </p></li><li><p>放电功率：增加放电功率一般会增加刻蚀速度；但是使得离子对处于阴极表面的样品表面的轰击增加，降低掩模的抗刻蚀比，<font color='OrangeRed'>刻蚀速度和抗刻蚀比不可兼得  </font></p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241106103857007.png" alt="image-20241106103857007" style="zoom:50%;" /></li><li><p>反应室气压：低气压下离子轰击刻蚀占主导；高气压时化学反应刻蚀占主导地位</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241106103926446.png" alt="image-20241106103926446" style="zoom:50%;" /></li><li><p>被刻蚀样品表面温度：刻蚀速率随温度增加，温度升高的另一个效应是横向刻蚀速率增加，使刻蚀的各向异性度变差，因为化学反应是各项同性的</p></li><li><p>电极材料：要求阴极材料是化学惰性的，否则阴极本身也会与样品一样被刻蚀</p></li><li><p>辅助气体：卤素气体中加入少量氧气或氩气会不同程度改进刻蚀效果</p></li></ul><p><font color='DarkViolet'>如何实现反应离子深刻蚀？</font>【课后复习题】</p><p>两个条件：</p><ul><li><p>高刻蚀速度和高抗刻蚀比——<font color='OrangeRed'>电感耦合等离子体刻蚀ICP</font></p><p>通过感应线圈将射频功率从外部耦合进入等离子体发生腔体，<font color='OrangeRed'>等离子体产生区与刻蚀区分开</font>，满足了高刻蚀速度和高抗刻蚀比两个矛盾的要求</p></li><li><p>极好的各向异性——Bosch工艺</p><p>通过交替转换刻蚀气体与钝化气体，在反应离子刻蚀的过程中不断在边壁上沉积抗蚀层或钝化层，从而增加刻蚀的各向异性</p></li></ul><blockquote><p>在Bosch工艺中由于刻蚀与钝化相互转换，而每一步刻蚀都是各向同性的，因此造成刻蚀边壁表面成波纹状（波纹效应）</p></blockquote><p>反应离子深刻蚀中存在的问题：</p><ul><li><p>负载效应： 局部刻蚀气体的消耗大于供给引起的刻蚀速度下降或分布不均匀的效应</p></li><li><p>微沟槽效应： 刻蚀过程中边角的刻蚀深度大于中心部分刻蚀深度的现象  </p></li><li><p>缺口效应：刻蚀到绝缘层后不停止，继续沿绝缘层表面横向刻蚀的现象</p></li><li><p>离子损伤效应：对刻蚀表面的载流子分布和晶体结构造成损伤  </p><p>对于单晶材料， 离子损伤一般可以通过高温退火工艺消除，但最效的降低离子损伤的办法是降低离子能量</p></li></ul><p><strong>等离子体刻蚀</strong>：纯粹的等离子刻蚀主要是化学刻蚀</p><p>主要是作为表面干法清洗工艺，各向同性的刻蚀性质使得它被广泛用来清除牺牲层  </p><p><strong>离子溅射刻蚀</strong>：纯粹的物理刻蚀过程，通过惰性气体(通常是氩气)离子的加速撞击，直接将表面原子溅射出去</p><p><font color='DarkViolet'>说明反应离子刻蚀、等离子刻蚀和离子溅射刻蚀的区别  </font>【课后复习题】</p><table><thead><tr><th>属性</th><th>反应离子刻蚀</th><th>等离子刻蚀</th><th>离子溅射刻蚀</th></tr></thead><tbody><tr><td>刻蚀机制</td><td>物理撞击 + 化学反应</td><td>化学反应</td><td>物理撞击</td></tr><tr><td>方向性</td><td>各向异性</td><td>各向同性</td><td>各向异性</td></tr><tr><td>刻蚀速度</td><td>中等</td><td>较慢</td><td>较慢</td></tr><tr><td>刻蚀选择性</td><td>较好</td><td>较差</td><td>差</td></tr><tr><td>物理损伤</td><td>中等</td><td>较少</td><td>较大</td></tr><tr><td>侧壁形貌</td><td>侧壁垂直，适合精细结构</td><td>侧壁较为圆滑</td><td>侧壁不定</td></tr><tr><td>适用材料</td><td>半导体材料</td><td>各种材料</td><td>金属、耐腐蚀材料</td></tr><tr><td>典型应用</td><td>微电子器件光刻后处理</td><td>表面清洁、薄膜去除</td><td>一般作为薄膜沉积工具</td></tr></tbody></table><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>反应离子刻蚀的微观过程有哪些?</font></li><li><font color='OrangeRed'>如何实现反应离子深刻蚀?</font></li><li><font color='OrangeRed'>说明反应离子刻蚀、等离子体刻蚀和离子溅射刻蚀的区别?</font></li></ol><h2 id="真空技术"><a href="#真空技术" class="headerlink" title="真空技术"></a>真空技术</h2><p>真空：气体分子数量低于大气压状态的空间，但不是完全没有  </p><p>标准大气压：0度时，760mm 水银柱产生的压强1atm&#x3D;1.033$\mathrm {kg&#x2F;cm^2}$&#x3D;760 Torr</p><p>工业大气压：1am&#x3D;1$\mathrm {kg&#x2F;cm^2}$&#x3D;735.56 Torr</p><p>起始压强：真空泵开始工作的允许压强，泵的工作原理决定</p><blockquote><p><font color='OrangeRed'>有些需要真空下开始工作，因此前级泵是必须的   </font> </p></blockquote><p>真空泵的分类：</p><table><thead><tr><th>抽气式</th><th>吸气式</th></tr></thead><tbody><tr><td>旋片式真空泵<br />扩散泵<br />涡轮分子泵<br />分子拖拽泵</td><td>冷凝泵<br />离子泵<br />升华泵</td></tr></tbody></table><p><font color='DarkViolet'>常见的几类真空泵的工作原理：</font>【课后复习题】</p><table><thead><tr><th>真空泵类型</th><th>工作原理</th></tr></thead><tbody><tr><td>旋片式机械泵</td><td>通过偏心转子上的旋片与泵腔壁之间的滑动，形成多个不断变化的密封腔室，逐步吸入气体并压缩排出，从而实现真空抽取，广泛应用于粗真空的产生</td></tr><tr><td>油扩散泵</td><td>通过加热液体（通常是油）蒸发形成蒸汽，蒸汽流带动气体分子向排气口移动，实现气体的抽取，蒸汽则被冷凝回泵内，适用于超高真空环境</td></tr><tr><td>钛升华泵</td><td>通过加热钛使其直接从固态升华为气态，在升华和沉积过程中与活性气体结合形成稳定化合物(TiO,TiN)，达到抽气的目的</td></tr><tr><td>离子泵</td><td>电子碰撞气体分子发生电离，离子注入撞击钛阴极，钛阴极发生磁控溅射，在阳极上沉积钛膜，气体分子在钛表面被吸附，然后被掩埋</td></tr><tr><td>冷凝泵</td><td>通过将气体分子引导至冷却表面，利用低温使气体凝结为液态或固态，从而实现抽气并维持真空</td></tr></tbody></table><p><font color='DarkViolet'>机械类、热传导类、电离真空计的工作原理：</font>【课后复习题】</p><p><font color='OrangeRed'>真空度越高，压力越小</font></p><table><thead><tr><th>类型</th><th>工作原理</th></tr></thead><tbody><tr><td>机械类真空计</td><td>通过读取气压对弹性元件的变形量来计算真空度</td></tr><tr><td>热传导类真空计</td><td>气体的热传导能力和气压相关，通过监测加热元件的温度变化来计算真空度</td></tr><tr><td>电离真空计</td><td>气体分子在高能电子作用下被电离，产生的电流大小与气压成正比，通过测量电流大小来计算真空度</td></tr></tbody></table><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>常见的几类真空泵的工作原理</font></li><li><font color='OrangeRed'>机械类、热传导类、电离真空计的工作原理  </font></li></ol><h2 id="洁净技术"><a href="#洁净技术" class="headerlink" title="洁净技术"></a>洁净技术</h2><p><font color='DarkViolet'>微纳器件的主要污染来源：</font>【课后复习题】</p><ul><li>空气中的颗粒物</li><li>人体</li><li>房间</li><li>水</li><li>工艺用化学物质</li><li>工艺用气体</li><li>工艺设备</li><li>静电</li></ul><p><font color='DarkViolet'>什么是RCA衬底清洗方法？</font>【课后复习题】</p><p><strong>RCA-1清洗 (标准清洗1，SC-1)</strong></p><p>目的： 去除有机污染物和部分颗粒</p><p>清洗液组成：$ \mathrm {NH_4 OH-H_2 O_2-H_2 O } $ (1: 1: 5)</p><p>反应原理：氨水使颗粒松散脱离表面，而过氧化氢提供氧化能力，分解有机物</p><p><strong>RCA-2清洗 (标准清洗2，SC-2)</strong></p><p>目的：去除金属离子污染</p><p>清洗液组成：$\mathrm{ HCl-H_2 O_2 -H_2 O }$ (1: 1: 6)</p><p>反应原理： 盐酸通过络合反应有效去除金属离子，过氧化氢增强氧化能力</p><p>清洗流程：</p><ol><li>硅片预处理（如去除颗粒）</li><li>进行SC-1清洗，去除有机污染</li><li>用去离子水冲洗，去除残留SC-1</li><li>HF处理，去除氧化层</li><li>用去离子水冲洗，去除残留HF</li><li>进行SC-2清洗，去除金属污染</li><li>用去离子水冲洗干净并干燥</li></ol><p><font color='DarkViolet'>课后复习题：  </font></p><ol><li><p><font color='OrangeRed'>微纳器件的污染来源有哪些？  </font></p></li><li><p><font color='OrangeRed'>什么是RCA衬底清洗方法？  </font></p></li></ol><h2 id="电学测量"><a href="#电学测量" class="headerlink" title="电学测量"></a>电学测量</h2><p>电学测量的两个目的：</p><ul><li>表征纳米材料和器件的电学性能  </li><li>探索新的物理现象和知识</li></ul><p>重要概念：在导体中，低温低偏压下，只有能量接近费米能量的电子对电导有贡献  </p><p>常用的电学测量三种方式 </p><ul><li>半导体参数分析仪  </li><li>基于数据采集卡的测量系统  </li><li>基于GPIB的测量系统</li></ul><p><font color='DarkViolet'>在测量弱电流和小电压时，哪些影响因素会带来测量误差？</font>【课后复习题】</p><p>热噪声（Johnson噪声）；电磁干扰（EMI）；地回路；接触电阻和引线电阻</p><p><font color='DarkViolet'>在测量小电阻时如何避免引线电阻的影响？</font>【课后复习题】</p><ol><li><p>四端法（Kelvin连接）</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/image-20241221204527692.png" alt="image-20241221204527692" style="zoom:67%;" /><p>两根导线用于提供测量电流，另两根导线用于测量电阻两端的电压</p><p>由于测量电压的导线没有电流流过，因此引线的电阻不会影响测量结果。</p></li><li><p>校准和补偿：在测量前，通过短路测量法测量引线的总电阻，将引线电阻值从测量结果中减去</p></li><li><p>温度控制：引线电阻随温度变化，因此控制测量环境的温度稳定性可以减少测量误差</p></li></ol><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>在测量弱电流和小电压时，哪些影响因素会带来测量误差？</font></li><li><font color='OrangeRed'>在测量小电阻时如何避免引线电阻的影响？  </font></li></ol><h2 id="膜厚度测量"><a href="#膜厚度测量" class="headerlink" title="膜厚度测量"></a>膜厚度测量</h2><p><font color='DarkViolet'>椭偏仪的工作原理：</font>【课后复习题】</p><p>椭偏仪通过分析光的偏振状态变化来测量材料的光学性质，其核心原理是利用光学偏振和菲涅耳公式，主要测量参数是$ \Psi $ (振幅比变化)和$ \Delta $ (相位差变化)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">光源 --&gt; 偏振器 --&gt; 入射偏振光 --&gt; 样品 --&gt; 反射光 --&gt; 分析器 --&gt; 探测器 --&gt; 数据处理</span><br></pre></td></tr></table></figure><p><font color='DarkViolet'>椭偏法测量能够获取哪些材料信息？</font></p><p>薄膜厚度d、折射率n、消光系数k</p><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>椭偏仪的工作原理是什么？ 椭偏法测量能够获取哪些材料信息？</font></li></ol><h2 id="光学测量"><a href="#光学测量" class="headerlink" title="光学测量"></a>光学测量</h2><p><strong>为什么要用光学检测？</strong></p><p>高精度、非接触、无损检，灵敏度高</p><p>光散射的能量变化与其分类：</p><table><thead><tr><th>散射名称</th><th>能量改变范围</th><th>散射性质</th></tr></thead><tbody><tr><td>瑞利散射</td><td>$&lt;10 ^{-5} \mathrm{cm^{-1}} $</td><td>弹性</td></tr><tr><td>布里渊散射</td><td>$10^{-5}\sim 1\mathrm{cm^{-1}} $</td><td>非弹性</td></tr><tr><td>拉曼散射</td><td>$&gt;1 \mathrm{cm^{-1}}$</td><td>非弹性</td></tr></tbody></table><p>光散射研究中，能量通常以波数 $ \tilde \nu $ (波长的倒数) 表示，单位为 $ \color{red} \mathrm { cm^ { -1 } } &#x3D;0.000124 eV $ </p><blockquote><p>拉曼位移表示的是波数变化</p></blockquote><p>$$<br>E&#x3D;h\nu&#x3D;hc\tilde \nu<br>$$</p><p>为什么常用斯托克斯线Stokes line？</p><ul><li><p>斯托克斯散射比反斯托克斯散射的信号强度通常更高</p></li><li><p>斯托克斯信号在低频端，受热噪声影响较小，信噪比更高</p></li><li><p>斯托克斯线和反斯托克斯线关于激光频率对称，测量斯托克斯线已足以获取完整的振动信息</p></li></ul><p><font color='DarkViolet'>拉曼光谱测量的原理：</font>【课后复习题】</p><p>拉曼光谱基于拉曼散射效应，当入射光照射到样品表面，大部分光子发生弹性散射(瑞利散射)，少部分光子与样品分子的振动能级发生相互作用，发生非弹性散射(拉曼散射)，通过测量这些频移，可以获得分子的振动信息</p><p><font color='DarkViolet'>拉曼光谱的特征：</font>【课后复习题】</p><p>(1)改变入射光频率，散射光相对入射光的拉曼频移总是不变；</p><p>(2)斯托克斯和反斯托克斯频移的绝对值相等；</p><p>(3)谱峰的形状和强度取决于分子的类型和浓度，每个峰像指纹一样独特；</p><p>(4)激发光波长影响光谱质量，短波长激光可能导致样品荧光干扰，较长波长激光可能会提供更清晰的拉曼信号；</p><p><font color='DarkViolet'>荧光光谱测量的原理：</font>【课后复习题】</p><p>使用紫外光或可见光等激发光源照射样品，样品吸收光子后，电子跃迁至激发态，当这些激发态电子返回基态时，会以光子的形式释放能量，产生荧光。通过光谱仪对发射光进行分光分析，可以获取样品结构、浓度、环境等信息</p><p><font color='DarkViolet'>阴极荧光光谱(CL)测量的原理：</font>【课后复习题】</p><p>将高能电子束聚焦并照射到样品表面，激发材料中电子跃迁至激发态，当这些激发态电子返回基态时，会以光子的形式释放能量，产生荧光。通过光谱仪对发射光进行分光分析，从而获取材料的电子结构、缺陷和杂质信息</p><p>二者的区别：</p><table><thead><tr><th></th><th>荧光光谱</th><th>阴极荧光光谱</th></tr></thead><tbody><tr><td>激发源</td><td>光子(紫外光、可见光)</td><td>电子束</td></tr><tr><td>样品影响</td><td>无损伤，可以多次测量</td><td>可能对样品表面造成影响</td></tr><tr><td>空间分辨率</td><td>受限于光学衍射，通常在 $ \mu m $ 级别</td><td>作为扫描电子显微镜的附件，可以实现 $nm$ 级别</td></tr><tr><td>样品要求</td><td>常用于液体、气体、固体样品</td><td>通常为固体，最好导电</td></tr><tr><td>应用场景</td><td>化学、生命科学<br />分析分子或离子浓度、生物标记</td><td>材料科学、半导体研究</td></tr></tbody></table><p><font color='DarkViolet'>课后复习题：</font></p><ol><li><font color='OrangeRed'>Raman光谱的原理和特征是什么？  </font></li><li><font color='OrangeRed'>荧光光谱， 阴极荧光光谱测量方法的原理和应用特点  </font></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 🥼半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>昌平出行指南</title>
      <link href="/posts/128735050.html"/>
      <url>/posts/128735050.html</url>
      
        <content type="html"><![CDATA[<p>迫于新燕园的地理位置以及交通，刚入学一周就开始研究在不坐校车的情况下如何实现通勤（要是有个地铁站修到新燕园门口就好了）</p><p>从时效和经济手段上来看，校车的性价比肯定是最高的</p><h2 id="校历"><a href="#校历" class="headerlink" title="校历"></a>校历</h2><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/YJS1/bc3356fe24686f1646913bd3554a2639.webp" alt="bc3356fe24686f1646913bd3554a2639" style="zoom: 50%;" /><h2 id="班车时间"><a href="#班车时间" class="headerlink" title="班车时间"></a>班车时间</h2><p><strong>工作日：</strong></p><table><thead><tr><th>燕园出发</th><th>时间</th></tr></thead><tbody><tr><td>燕园校区→肖家河→西二旗→新燕园校区→200号校园</td><td>7:00</td></tr><tr><td>燕园校区→新燕园校区→200号校园</td><td>7:40</td></tr><tr><td>燕园校区→新燕园校区→200号校园</td><td>8:30</td></tr><tr><td>燕园校区→新燕园校区</td><td>10:10</td></tr><tr><td>燕园校区→新燕园校区</td><td>13:30</td></tr><tr><td>燕园校区→新燕园校区</td><td>16:00</td></tr><tr><td>燕园校区→新燕园校区</td><td>18:30</td></tr><tr><td>燕园校区→新燕园校区</td><td>20:40</td></tr><tr><td>燕园校区→新燕园校区</td><td>22:00</td></tr></tbody></table><table><thead><tr><th>新燕园出发</th><th>时间</th></tr></thead><tbody><tr><td>新燕园校区→燕园校区</td><td>6:30</td></tr><tr><td>新燕园校区→燕园校区</td><td>7:40</td></tr><tr><td>新燕园校区→燕园校区</td><td>8:30</td></tr><tr><td>新燕园校区→燕园校区</td><td>11:20</td></tr><tr><td>新燕园校区→燕园校区</td><td>13:00</td></tr><tr><td>新燕园校区→燕园校区</td><td>16:30</td></tr><tr><td>200号校园→新燕园校区→西二旗→肖家河→燕园校区</td><td>16:50</td></tr><tr><td>200号校园→新燕园校区→燕园校区</td><td>19:20</td></tr><tr><td>新燕园校区→燕园校区</td><td>21:45</td></tr></tbody></table><p><strong>非工作日：</strong></p><table><thead><tr><th>燕园出发</th><th>时间</th></tr></thead><tbody><tr><td>燕园校区→新燕园校区</td><td>7:00</td></tr><tr><td>燕园校区→新燕园校区</td><td>15:00</td></tr><tr><td>燕园校区→新燕园校区</td><td>19:00</td></tr><tr><td>燕园校区→新燕园校区</td><td>22:00</td></tr></tbody></table><table><thead><tr><th>新燕园出发</th><th>时间</th></tr></thead><tbody><tr><td>新燕园校区→燕园校区</td><td>8:00</td></tr><tr><td>新燕园校区→燕园校区</td><td>9:00</td></tr><tr><td>新燕园校区→燕园校区</td><td>11:00</td></tr><tr><td>新燕园校区→燕园校区</td><td>16:30</td></tr><tr><td>新燕园校区→燕园校区</td><td>21:45</td></tr></tbody></table><h2 id="地铁打车混合"><a href="#地铁打车混合" class="headerlink" title="地铁打车混合"></a>地铁打车混合</h2><p>离燕园最近的两个地铁口：沙河高教园(地铁昌平线) and 温阳路(16号线)</p><p>此外还有一个城际铁路站 昌平站，但是仅有开往清河站和北京北的列车，且班次不是很多，从时间上来看不是很方便</p><p><strong>打车前往地铁站</strong></p><table><thead><tr><th></th><th>时间</th><th>价格</th><th>备注</th></tr></thead><tbody><tr><td>沙河高教园</td><td>19min 左右</td><td>24~26</td><td>可能会没坐</td></tr><tr><td>温阳路</td><td>22min 左右</td><td>24~26</td><td>基本上地铁有位置</td></tr></tbody></table><p><strong>两个地铁站前往学校、高铁站以及机场</strong></p><table><thead><tr><th></th><th>沙河高教园</th><th>温阳路</th></tr></thead><tbody><tr><td>北京大学东门</td><td>58min &#x2F; 6r</td><td>42min &#x2F; 5r</td></tr><tr><td>北京西</td><td>74min &#x2F; 7r</td><td>61min &#x2F; 6r</td></tr><tr><td>北京丰台</td><td>80min &#x2F; 7r</td><td>67min &#x2F; 7r</td></tr><tr><td>北京南</td><td>76min &#x2F; 7r</td><td>74min &#x2F; 7r</td></tr><tr><td>大兴机场</td><td>94min &#x2F; 42r</td><td>96min &#x2F; 42r</td></tr><tr><td>首都机场T3</td><td>90min &#x2F; 32r</td><td>92min &#x2F; 32r</td></tr></tbody></table><p>综上对比从温阳路出发最优</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🏫校园生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业旅行之云南</title>
      <link href="/posts/503147929.html"/>
      <url>/posts/503147929.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在开始"><a href="#写在开始" class="headerlink" title="写在开始"></a>写在开始</h2><p>这场旅行期待很久了，准备工作其实还是蛮多的，主要参考来自b站各个up的旅游视频</p><p>云南我觉得大理≥昆明&gt;&gt;&gt;丽江，因此本来安排给泸沽湖的时间给了大理</p><p>旅行是我们漫漫人生中暂时离开既有生活的闪亮间隙，在旅行中经历另一种生活形态，与这辈子可能不会再见的人与事共同创造难忘的人生记忆</p><p>喜欢大理，在那里有睡到自然醒的松弛，有走哪算哪的随意，有抚平心灵的归属感，有些记忆最后封存在洱海就好</p><p><a href="https://guinness.autonavi.com/activity/2020CommonLanding/index.html?id=default&local=1&logId=&logParams=&gd_from=jinisi&schema=amapuri://ajx_favorites/folder?data=%257B%2522ugcId%2522%253A%252215389456410139424257%2522%252C%2522forceCustom%2522%253Atrue%252C%2522pathId%2522%253A6%252C%2522isCreatorShare%2522%253Atrue%257D">高德地图链接</a></p><h2 id="昆明"><a href="#昆明" class="headerlink" title="昆明"></a>昆明</h2><h3 id="day1-5-19"><a href="#day1-5-19" class="headerlink" title="day1(5.19)"></a>day1(5.19)</h3><p>✈️MU5853 成都天府T2→昆明长水 10:00</p><p>7:00左右出发 打车到火车南站换乘18号线</p><blockquote><p>我们出门太慢了，而且行李箱大，路上耽误了很久，差两分钟就值不上机了，最好提前一点走</p></blockquote><p>📍行程：机场→住宿点1→董家湾→西南联大旧址(需要提前预约)→云南陆军讲武堂→翠湖公园→黄公东街→南屏步行街→住宿点1</p><p>🏨住宿点1 春天印象写字楼内</p><p>🍲午饭：<u>三胖边境小食堂</u></p><blockquote><p>这两没吃上：</p><p>住宿点1附近  🍲<u>刀敬小锅米线(永善路店)</u></p><p>云南陆军讲武堂附近  🍲<u>茴香云南盛·过桥米线</u></p></blockquote><p>云南陆军讲武堂：周二到周日开放，下午四点半禁止入场，军人提枪表演时间：9点、10点、11点，下午14点、15点、16点</p><blockquote><p>我们在西南联大旧址呆太久了，没来得及进场，西南联大那边有章可以盖</p></blockquote><p>翠湖公园：最近应该没有海鸥了，但是还是有松鼠，西门进，南门出</p><p>🚩黄公东街一个比较火的拍照点，导航到朝茶暮酒</p><p>对月楼：已经变成一个酒店了，旁边和人民英雄纪念碑紧挨，也叫纸片楼</p><p>🍲晚饭：<u>西双曼傣·傣味野生菌手抓饭</u></p><p>去南屏街和大妈们一块跳了会舞就回了</p><h4 id="账务"><a href="#账务" class="headerlink" title="账务"></a>账务</h4><p>✈️机票 成都天府→昆明长水 282.75</p><p>🏨住宿 287.28&#x2F;4 &#x3D; 71.82</p><p>🚕打车 51.92&#x2F;4 &#x3D; 12.98</p><p>🍲吃饭 65+228+12(西瓜) &#x3D; 305&#x2F;4 &#x3D; 76.25</p><p>合计 282.75+71.82+12.98+76.25 &#x3D; 443.8</p><h2 id="大理"><a href="#大理" class="headerlink" title="大理"></a>大理</h2><h3 id="day1-5-20"><a href="#day1-5-20" class="headerlink" title="day1(5.20)"></a>day1(5.20)</h3><p>🚅昆明→大理，动车D8688，住的地方离昆明站就几分钟，下午1:05到达大理站</p><p>📍行程：住宿点1→昆明站→大理站→住宿点2→大理古城(洱海门→人民路→大理天主教堂→五华楼)→住宿点2</p><p>🏨住宿点2 才村小邑庄，近才村码头</p><p>下了高铁直接打车去住宿点，四个人基本全程打车了</p><p>午饭直接在民宿楼下吃的，老板手艺很好，还给我们送菜了</p><p>🍲午饭：<u>漫时光艺术花园餐厅</u>，我们住宿就在它楼上</p><blockquote><p>老板做饭真的绝杀，太好吃了</p></blockquote><p>运气非常好，到大理的时候还在哗啦哗啦下大雨，等到四点多我们出门已经基本没雨了，这时候的大理古城有一种别样的美</p><p>ℹ️大理天主教堂：建筑风格相当混血，具有本地特色</p><p>ℹ️大元帅府：每天晚上8:00-9:00门口有篝火晚会，没有篝火就是嬢嬢们跳广场舞了</p><p>ℹ️五华楼：到城墙上可以稍微俯看古城</p><p>ℹ️广武路：比较多小饰品店</p><p>ℹ️人民路：算是大理流浪文化的发源地吧，晚上九点以后比较热闹</p><p>ℹ️床单艺术中心：买的都是手作小物品，但是只有周末才有(近南门)</p><p>🍲晚饭：<u>德胜桥（大理古城店）</u></p><p>味道还可以，性价比适中</p><p>吃完回民宿已经快12点了，大理古城还是相对商业化的，往北边的北门菜市场走走也挺好</p><h4 id="账务-1"><a href="#账务-1" class="headerlink" title="账务"></a>账务</h4><p>🚅昆明→大理 145</p><p>🏨住宿 5天合计 954.89+540 &#x3D; 1494.89&#x2F;4 &#x3D; 373.72</p><p>🚕打车 5.49+38.97+10.34+19.4 &#x3D; 74.2&#x2F;4 &#x3D; 18.55 </p><p>🍲吃饭 (44+88)&#x2F;4 + 36.9&#x2F;2 &#x3D; 51.45</p><p> 合计 145+373.7225+18.55+51.45 &#x3D; 588.72</p><h3 id="day2-5-21"><a href="#day2-5-21" class="headerlink" title="day2(5.21)"></a>day2(5.21)</h3><p>时间这样就很充沛了，于是今天只沿海西线逛了逛，也没去喜洲古镇</p><p>📍行程：住宿点2→日出→生态廊道骑行(住宿点2→才村码头→观海庭→下波棚→潘溪村S弯→廊桥)</p><p>🌅日出地点导航大理屿月民宿，那里人少，感觉日出效果挺好，但是要注意别踩水里了(别问我为什么这么说π_π)</p><blockquote><p>在大理看了三天的日出，真的日出不看白来，每次都有巨大的心灵震撼</p></blockquote><p>🍲早饭是在民宿吃的，老板整的包子和小米粥，因为我们住了三天以上早餐是免费的</p><p>在洱海生态廊道可以找电动车，双人的60&#x2F;h，可以连蓝牙放音乐，注意找电够的</p><p>自行车是预付30，前15分钟2r，后面15分钟1.5r</p><p>直接跳过午饭，晚饭在民宿楼下吃的，吃完在生态廊道散步，这种感觉很棒</p><h4 id="账务-2"><a href="#账务-2" class="headerlink" title="账务"></a>账务</h4><p>🛵洱海电动车 60</p><p>🍲吃饭 48&#x2F;2 &#x3D; 24</p><p>合计 60+24 &#x3D; 88</p><h3 id="day3-5-22"><a href="#day3-5-22" class="headerlink" title="day3(5.22)"></a>day3(5.22)</h3><p>📍行程：住宿点2→喜洲古镇(喜洲菜市场→严家大院→蓝州扎染体验店→转角楼→禾田里(大树的位置))→住宿点2</p><p>在喜洲菜市场体验了一下生猪肉，感觉需要一点勇气</p><p>在严家大院刚好碰见旅游团，直接听了他们的讲解，感觉12r的门票很值</p><p>扎染需要预留2h及以上时间，那天和甜呀一起缝绘裙子差不多花了四个小时才结束，感觉效果还是很好的</p><p>这个时候天已经都黑了，秉持着来都来了的想法，摸黑去看了下麦田和刘亦菲同款大树，晚上去看这树倒也挺奇特</p><h4 id="账务-3"><a href="#账务-3" class="headerlink" title="账务"></a>账务</h4><p>🚕打车 1+50.2+44.14 &#x3D; 95.34&#x2F;4 &#x3D; 23.84</p><p>🎫严家大院 12</p><p>🥻扎染 90</p><p>🍲吃饭 97&#x2F;4 &#x3D; 24.25 +3+10 &#x3D; 37.25</p><p>合计 23.835+12+37.25+90 &#x3D; 163.09 </p><h3 id="day4-5-23"><a href="#day4-5-23" class="headerlink" title="day4(5.23)"></a>day4(5.23)</h3><p>📍行程：住宿点2→三月街→苍洱大道→岛七白族菜→住宿点2→洱海散步</p><p>刚好碰上农历16，三月街有赶集活动，于是去体验了一波，感觉物价还是可以的，没有很贵，很实惠</p><p>ℹ️去苍洱大道导航财校路口(公交站)，不然要爬坡</p><p>🍲<u>岛七白族菜</u>  这家店还是很不错的，位置有点偏，特色菜都好吃，性价比高</p><p>领悟了大理旅行的真谛就是沿着洱海散步发呆，坐在海边可以呆一天，这也就是为什么day5在这没有再写的原因了</p><p>在大理的5天看了三场日出，每场都让我很震撼，来大理一定要看一场日出！！！</p><h4 id="账务-4"><a href="#账务-4" class="headerlink" title="账务"></a>账务</h4><p>🍢零食 (10.5+10)&#x2F;2 &#x3D; 10.25</p><p>🚕打车 16.06+6.49+8.04+7.29 &#x3D; 37.88&#x2F;4 &#x3D; 9.47</p><p>🍲吃饭 15+170 &#x3D; 185&#x2F;4 &#x3D; 46.25</p><p>合计 10.25+9.47+46.25 &#x3D; 65.97</p><h3 id="day5-5-24"><a href="#day5-5-24" class="headerlink" title="day5(5.24)"></a>day5(5.24)</h3><p>不太想去苍山，爬山有点小累</p><p>没想着再到处跑了，就在洱海边再骑了骑车，很喜欢洱海给我的感觉</p><h4 id="账务-5"><a href="#账务-5" class="headerlink" title="账务"></a>账务</h4><p>🍲吃饭 68&#x2F;2+250&#x2F;5 &#x3D; 84</p><p>🚲️共享自行车 10</p><h3 id="海东线-未走"><a href="#海东线-未走" class="headerlink" title="海东线(未走)"></a>海东线(未走)</h3><p>📍行程：住宿点2→双廊古镇→(鹿卧山→)挖色镇→小普陀→文笔村→圣托里尼理想邦(到时候可以考虑不去)→兴盛大桥→下关→住宿点2</p><p>海东线可以包车，还还价300左右还可以接受，小红书上次问了一下包车时间是在9:00~18:00</p><p>打车路线：大理古镇到双廊古镇110左右，双廊古镇到鹿卧山那块25左右，鹿卧山到小普陀那块10左右；小普陀到文笔村22左右（日落）；小普陀到圣托里尼理想邦40左右；圣托里尼到下关48左右；下关到大理古镇30左右</p><p>合计也在300左右，但更自由一些，而且可以到时候叠加各种打车券</p><p>午饭在双廊古镇解决</p><p>ℹ️鹿卧山：废弃窗户，洱海之窗，山洞悬崖，风评不一</p><p>ℹ️小普陀上岛要花钱，没啥必要</p><p>ℹ️文笔村可以看日落</p><p>东线没啥太多特色</p><p>下关🍲<u>云龙黑山羊野生菌火锅(嘉士伯大道店)</u> 不点套餐，他家羊肉不错，搞一点炒菜</p><h3 id="巍山线-未走"><a href="#巍山线-未走" class="headerlink" title="巍山线(未走)"></a>巍山线(未走)</h3><p>住宿点2→洱海月湿地公园→下关吃午饭→大理站→巍山古城</p><p>下关那边到大理站就十来分钟打车，高铁到巍山站约22分钟，可以考虑体验一下一等座34r，二等座22r</p><p>大理过去的最好可以坐，巍山回的最后一班高铁是18:47的</p><h2 id="丽江"><a href="#丽江" class="headerlink" title="丽江"></a>丽江</h2><p>由于去年刚去的川西，对雪山有些审美疲劳，因此没把玉龙雪山列入我们的行程</p><h3 id="day1-5-25"><a href="#day1-5-25" class="headerlink" title="day1(5.25)"></a>day1(5.25)</h3><p>📍行程：住宿点2→三月街口(公交站)→丽江古城南门→住宿点3→白沙古镇→清溪公园→九婆餐饮店→住宿点3</p><p>🏨住宿点3在丽江古城西边，因为我们不咋去丽江古城在这边还便宜</p><p>🍲午饭 <u>纳西纯杂锅菜(白沙古镇店)</u>  便宜好吃，点了一个中锅+一份炸凉粉</p><p>白沙古镇可以走完，差不多两个小时，白沙壁画我们没来得及去</p><p>不想去丽江古城于是去了一个居民公园——清溪公园，但是这里的日落和湖却特别的好看</p><p>🍲晚饭 <u>九婆餐饮店</u>  腊排骨，味道还不错</p><h4 id="账务-6"><a href="#账务-6" class="headerlink" title="账务"></a>账务</h4><p>🏨住宿 407.8&#x2F;4 &#x3D; 101.95</p><p>🚌大巴 29.5</p><p>🚕打车 14.58+5.54+26.1+7.8+14.8 &#x3D; 68.82&#x2F;4 &#x3D; 17.21</p><p>🍲吃饭 98+98+10 &#x3D; 206&#x2F;4 &#x3D;51.5</p><p>合计 101.95+29.5+17.205+51.5 &#x3D; 200.16</p><h3 id="day2-5-26"><a href="#day2-5-26" class="headerlink" title="day2(5.26)"></a>day2(5.26)</h3><p>出了一些意外今天没出门</p><p>🍲晚饭 <u>老建水胖子烧烤</u>    可以避雷了，不是很好吃，上菜慢的想死</p><h4 id="账务-7"><a href="#账务-7" class="headerlink" title="账务"></a>账务</h4><p>✈️机票 丽江三义→成都双流 460</p><p>🍲吃饭 252&#x2F;4 &#x3D; 63</p><p>合计 460+63 &#x3D; 523</p><h3 id="泸沽湖线-未走"><a href="#泸沽湖线-未走" class="headerlink" title="泸沽湖线(未走)"></a>泸沽湖线(未走)</h3><p>📍行程：住宿点2→泸沽湖住宿点3(约4h)→大洛水村→云南情人滩</p><p>🏨住宿点3考虑在大洛水村，可以离湖近一点，而且车可以给送到住宿的地方</p><p>泸沽湖景区门票35r(学生票)，包车一天200r，可以找民宿老板或者当天送我们过去的司机问下</p><p>泸沽湖最有名的就是石锅蒸汽鱼  🍲<a href="https://m.dianping.com/shopshare/H5dFhDXZPQFH4eWI?msource=Appshare2021&utm_source=shop_share&issilencelogin=2&shoptype=10&shopcategoryid=34280&cityid=3623&isoversea=0">菌香小院·蒸汽石锅鱼</a> </p><p>📍行程：住宿点3→绕湖半日游(5h左右)→白沙古镇(约4h)住宿点4</p><p>顺时针：大洛水→云南情人滩→里格半岛→女神湾→走婚桥→草海</p><p>逆时针：大洛水→草海→走婚桥→女神湾→里格半岛→云南情人滩</p><p>女神山到时候看情况再看看要不要上索道上山顶看</p><p>ℹ️里格半岛：可以看半全景</p><p>ℹ️女神山：上索道可以看到全景，缆车比较刺激()，不是那种封闭小车</p><p>ℹ️走婚桥：是不能走回头路的，不然会找不到对象😿</p><blockquote><p>回可以坐进来时候一家公司的车，大概80&#x2F;人</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>⚠️大理算半个高原，需要及时做好防晒，可以带墨镜+帽子，防晒霜和芦荟胶最好都带上</p><p>📖可以带着盖章册，旅游城市的邮局肯定有章，不细找了，碰到就盖</p><p>👚云南嘛，四季如春，要稍微带些长袖和外套，昼夜温差巨大</p><h2 id="最终账单合计"><a href="#最终账单合计" class="headerlink" title="最终账单合计"></a>最终账单合计</h2><p>昆明合计 282.75+71.82+12.98+76.25 &#x3D; 443.8</p><p>大理合计 588.72+88+163.09+65.97+84 &#x3D; 989.78</p><p>丽江合计 200.16+523 &#x3D; 723.16</p><p>总合计    443.8+989.78+723.16 &#x3D; 2156.74</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🧳旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云贵川跑遍计划之贵州</title>
      <link href="/posts/4008641560.html"/>
      <url>/posts/4008641560.html</url>
      
        <content type="html"><![CDATA[<p>刚好假期前看见微帮上的帖子拼人自驾去贵州，第一次体验与陌生人一块旅行</p><blockquote><p>其实就是一个人＋有人摊住宿和饭钱的旅行，碰到的人不一定和你合得来</p></blockquote><p>由于清明节期间高速免费以及贵州景点的免票政策，这方面省下了一大笔钱</p><p>全程约3天3夜，<a href="https://guinness.autonavi.com/activity/2020CommonLanding/index.html?id=default&local=1&logId=&logParams=&gd_from=jinisi&schema=amapuri://ajx_favorites/folder?data=%257B%2522ugcId%2522%253A%252215389456410132960631%2522%252C%2522forceCustom%2522%253Atrue%252C%2522pathId%2522%253A6%252C%2522isCreatorShare%2522%253Atrue%257D">地图戳这里👈</a></p><h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><p><strong>day1</strong>：到达贵阳—黔灵山公园—入住小七孔附近</p><p>3.3 19:30 检查完车从成都大源地铁站附近驾车出发，加上中间休息差不多凌晨4点到贵阳</p><p><strong><font color='OrangeRed'>第一晚住宿：</font></strong></p><a href="http://dpurl.cn/RoBnvRYz" title=", https:&#x2F;&#x2F;www.meituan.com&#x2F;favicon.ico" target="">荣和酒店(贵阳师大店),</a><p>标间人均109.86&#x2F;2&#x3D;54.93 房间整体不错，性价比高</p><p>睡到11点起床洗漱收拾，<strong><font color='LightSkyBlue'>午饭：</font></strong></p><a href="http://dpurl.cn/b15ydVhz," title="https:&#x2F;&#x2F;www.meituan.com&#x2F;favicon.ico" target="">贵厨酸汤牛肉(小十字店),</a><p>点了一个四人餐，酸汤锅也没那么酸，如果平常吃的惯冬阴功这个肯定没问题，味道还可以，价格224&#x2F;5&#x3D;44.8</p><p>看小红书也点了一个去茶山的手打草莓生椰水仙抹茶顶，狠狠避雷，这店都不好喝，不如蜜雪冰城</p><p>下午去的黔灵山公园（免票，但是要用美团预约），据说是贵阳人的后花园，公园环境很好，就是爬山费腿，这里面的猴哥没有峨眉山的恶劣，只会对着游客叫，耍它也不会挠你，但还是注意点</p><p>建议东门进爬到山顶坐索道到南门出公园，索道15&#x2F;人，山顶导航弘福寺即可</p><p><strong><font color='Darkviolet'>晚饭：</font></strong></p><a href="http://dpurl.cn/9mgoWPBz," title="https:&#x2F;&#x2F;www.meituan.com&#x2F;favicon.ico" target="">丫头烧烤,</a><p>烤完了一堆拿上来自选，拿多了不退，签子有点油，1.2&#x2F;根，吃起来还不错，比较多人去的，人均191&#x2F;5&#x3D;38.2</p><p><strong><font color='OrangeRed'>第二晚住宿：</font></strong></p><a href="http://dpurl.cn/woSJeOhz" title=", https:&#x2F;&#x2F;www.meituan.com&#x2F;favicon.ico" target="">澜颜·美宿,</a><p>怎么说呢，狠狠地被照骗了，毕竟在景区旁边，只能说干净，住宿条件不咋地，标间人均215.08&#x2F;2&#x3D;107.54 景区旁边价格虚高理解</p><hr><p><strong>day2</strong>：小七孔—入住千户苗寨内—拍苗寨夜景</p><p>早上八点半前出门，小七孔逛完少说4-5h</p><p>小七孔看政策，最近是学生免门票，但是需要到票务中心买票，付40元的观光车（景区不可能走完的，大到会死）</p><p>可以不要10块钱的保险，需要购票的时候和票务人员说明</p><p>观光车路线图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/freecompress-202404072046251.webp" alt="freecompress-202404072046251" style="zoom:50%;" /><p>选择东进东出（前一晚的住宿在东门旁边），进景区后坐观光车到古桥站下，古桥站就是一般小红书给小七孔配图的地方，沿着路一直走到石上森林站坐车，可以不去水上森林站（如果不玩水可以直接去翠谷瀑布站），鸳鸯湖可以划船 30&#x2F;人，不划船的话去鸳鸯湖也没意思，卧龙潭比较好看（但是不如亚丁的牛奶海doge），最后可以直接坐回东门，东进东出就是全程上坡，需要一点体力，如果省力就先坐到卧龙潭再往回走</p><p>在鸳鸯湖划船玩了太久，但是真的很有意思，30块钱挺值</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/freecompress-2024040720550912.webp" alt="freecompress-2024040720550912" style="zoom: 15%;" /><p><strong><font color='LightSkyBlue'>午饭：</font></strong></p><a href="http://dpurl.cn/9mgoWPBz," title="https:&#x2F;&#x2F;www.meituan.com&#x2F;favicon.ico" target="">瑶厨(小七孔店),</a><p>虾酸牛肉是贵州那边的本地菜，但是外地人一般吃不习惯，那个味太冲了，臭豆腐都干不过，其它菜都还OK，但是价格偏贵</p><p>人均387&#x2F;5&#x3D;77.4</p><p><strong><font color='OrangeRed'>第三晚住宿：</font></strong></p><a href="http://dpurl.cn/l069hL8z" title=", https:&#x2F;&#x2F;www.meituan.com&#x2F;favicon.ico" target="">沐兮汤屋民宿,</a><p>这三天最满意的住宿，标间人均198&#x2F;2&#x3D;99，内含两个人的瑶浴，泡起来太爽了</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/freecompress-freecompress-20240407210738.jpg" alt="freecompress-freecompress-20240407210738" style="zoom: 33%;" /><p>千户苗寨导航到“西江千户苗寨北门游客服务中心”，如北门停车场没有车位可根据指示停往“长荣停车场”，有免费的摆渡车摆渡至大北门</p><p>同样学生免票，观光车5&#x2F;次，可以不用在票务中心买，上车前买就行</p><blockquote><p>如果这景区要票我感觉没必要去，太商业化了，真的苗族人现在已经很少了</p></blockquote><p><strong><font color='Darkviolet'>晚饭：</font></strong></p><a href="http://dpurl.cn/7sMmIiSz" title=", https:&#x2F;&#x2F;www.meituan.com&#x2F;favicon.ico" target="">望月美食坊粉面馆,</a><p>原汤面就很不错，桌上有蒜可以剥个一块吃，吃面不吃蒜乐趣少一半</p><p>吃完先是走到了官方的观景台拍夜景（摆渡车在一号风雨桥那里坐），没带相机可能拍不出来那个效果，手机拍出来肯定太亮了，好一些的观景台其实基本都变成了饭店，因为我们急着回去泡瑶浴就没呆太久，12点前供应</p><hr><p><strong>day3：</strong></p><p>早上起来再逛逛白天的苗寨，邮局和纪念品店有章可以盖，茅台奶茶不好喝</p><p>东引1号和东引2号观景台不太好找，但是那边风景其实比官方的观景台好多了，旁边就是梯田，真的就是原生的苗族生活，我一个人爬上去的，感觉很有意义</p><p>十点多就准备启程回成都了，开回来本身就要7h加上节假日最后一天高速堵车，最后9点多才到成都这边还车的地方</p><h2 id="总开销"><a href="#总开销" class="headerlink" title="总开销"></a>总开销</h2><p>车费＋油钱＋停车费 393.2</p><p>鸡排15零食16.5烤肠5</p><p>绵阳米粉13</p><p>贵厨 224&#x2F;5&#x3D;44.8</p><p>去茶山 22.9（不好喝）</p><p>黔灵山索道15</p><p>丫头烧烤191&#x2F;5&#x3D;38.2 橙汁13&#x2F;5</p><p>小七孔观光车40  划船30</p><p>瑶厨387&#x2F;5&#x3D;77.4</p><p>望月美食坊 原汤面15</p><p>好一多酸奶 16&#x2F;5＝3</p><p>苗寨观光车25  山花×2 14</p><p>住宿261</p><p>合计 1031.6</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🧳旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电动力学</title>
      <link href="/posts/3699162249.html"/>
      <url>/posts/3699162249.html</url>
      
        <content type="html"><![CDATA[<p>继电磁学之后又再学习了电动力学，对整个电磁理论的理解确实更加深入了</p><p>相比大二时学的电磁场，麦克斯韦方程组显现给我的远不止那些</p><p>复旦大学的周磊老师讲的很有深度也很有趣，视频虽然已经过去了十来年但课程的质量很好</p><p>在此完结撒花，附带上b站视频链接以及老师的讲义还有我自己的笔记</p><blockquote><p>自己的笔记后期可能翻读还需要再修改，毕竟电动力学不是一门一遍就能吃透的课</p></blockquote><p><a href="https://www.bilibili.com/video/BV1j4411t7KH?vd_source=f3394c34030fde78299a7d7a5bef0d1e">电动力学 周磊 复旦大学-HD</a></p><p><a href="https://pan.baidu.com/s/1O8MznlEso4NWoDKqPnrjug?pwd=m4yg">电动力学讲义</a></p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/电动力学.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐山一日特种兵</title>
      <link href="/posts/1317525552.html"/>
      <url>/posts/1317525552.html</url>
      
        <content type="html"><![CDATA[<p>一刻也没有为深圳之旅的结束哀悼，立刻赶到战场的是乐山一日游</p><blockquote><p><font color='DarkViolet'>如果你的12306积分足够你甚至可以免费兑换来回的车票(前提是你得有1w分)</font></p></blockquote><p>8:00从西门出发前往成都东，09:28成都东—乐山，17:31乐山—成都东</p><p>时间可以调整，改签就行</p><p>先附上<a href="https://guinness.autonavi.com/activity/2020CommonLanding/index.html?id=default&local=1&logId=&logParams=&gd_from=jinisi&schema=amapuri://ajx_favorites/folder?data=%257B%2522ugcId%2522%253A%252215389456410126792850%2522%252C%2522forceCustom%2522%253Atrue%252C%2522pathId%2522%253A6%252C%2522isCreatorShare%2522%253Atrue%257D">大地图</a></p><p>出了高铁站直接过街下楼，打车在底下的停车场，或者找个电动车开，公交车属于是有点慢了，我们三个人打车挺便宜的</p><p>直接打到<strong>冯四嬢跷脚牛肉(嘉兴路)</strong>，一个中锅+一份粉蒸肉+一份牛脊髓，味道比成都的好</p><p>店对面就是<strong>小豆海棠</strong>，点了蛋烘糕和蛋冲鸳鸯</p><p>吃饱了往乐山广场走，我们去的时候没有鸽子，被鸽子鸽了()</p><p>路上遇到了一家<strong>鞠婆婆绵绵冰</strong>，直接开炫，喜欢杨枝甘露所以就点了一份杨枝甘露，她家的绵绵冰没有冰渣子的感觉，很nice</p><p>出于消食直接走到了<strong>棣爸油炸(张公桥店)</strong>，有点像烧烤，但是感觉没有多少油，蘸碟一份3块钱，如果不是很需要可以不用</p><p>而后一路沿江边走，乐山的生活还是很安逸的，很适合散步</p><p>最后走到冬泳广场那个角那边能看见大佛（天气好的话视角更好，我们去的那天不是晴天不咋能看见大佛）</p><p>在乐山铁牛门那个位置据说视角更好</p><p>往回走去**海汇源(老烧麦店)**点了三份烧麦，我们点的应该是销量前三的三个（蟹黄和鲜虾加一个肉馅的）</p><p>最后在<strong>叶婆婆钵钵鸡</strong>那里吃了一顿，都不是很辣</p><p>没有专门去找甜皮鸭，但是没吃上咔饼比较可惜</p><p>最后附一下图片：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/freecompress-Collage_20240226_160819.webp" style="zoom: 33%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 🧳旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深圳中转之旅</title>
      <link href="/posts/1895378745.html"/>
      <url>/posts/1895378745.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开学但福州长乐飞成都的机票太贵了，鼠鼠只能去深圳坐飞机（它便宜的实在太多了）</p><p>七个人都是福建的，所以可以列车上碰头</p><p>21号福建出发，动车D3249，下午15:05到达深圳北&#x2F;动车D2361，下午15:11到达深圳北</p><p>住宿：福田区清风·荣盛创投大厦（loft）[在华强北附近]</p><p>loft是三房四床，除了只有一个卫生间其它都还不错，人均每晚71，这个价格在深圳还算ok</p><p>loft附近吃的：(没安排时间去吃)</p><p>阿叔牛杂（园岭地铁站）[步行20min左右]</p><p>老味道粉面店[很近，有点网红的感觉]</p><h2 id="行程安排"><a href="#行程安排" class="headerlink" title="行程安排"></a>行程安排</h2><p><strong>21号：</strong></p><p>到深圳北后坐地铁到民宿入住，低估了深圳北的人流量，最后到民宿休整后五点才出门</p><p>出门坐地铁去深圳湾公园，但是不巧那天天气不咋地，没有看见日落</p><p>时间充足可以全程浏览，天气好应该景色很好</p><p>深圳湾公园路线：</p><p>深圳湾公园地铁站D2口→（[左转]竹林小道→椰子林[会绕一圈]）→[右转]海边步道→白鹭坡书吧→keep集合点→小沙山→火炬广场→无忧广场→人才公园西北门→深圳湾万象城</p><p>From  <a href="https://www.xiaohongshu.com/explore/65b5bcd900000000110026d0?source=webshare">小时攻略6 | 深圳湾公园看海鸥，地铁出行！</a></p><p><a href="https://guinness.autonavi.com/activity/2020CommonLanding/index.html?id=default&local=1&logId=&logParams=&gd_from=jinisi&schema=amapuri://ajx_favorites/folder?data=%257B%2522ugcId%2522%253A%252215389456410125062733%2522%252C%2522forceCustom%2522%253Atrue%252C%2522pathId%2522%253A6%252C%2522isCreatorShare%2522%253Atrue%257D">地图</a></p><p>中间建议骑行，有点小远，我们是在海边走了一会就打车去深圳湾万象城那边了，吃完饭再去逛的人才公园</p><p>晚饭：米仓食堂（深圳湾万象城B139D）</p><p>招牌金枪鱼牛油果拌饭(偏单人份)；寿喜烧；</p><blockquote><p>我们去太晚了，金枪有牛油果拌饭已经没了，就点了些其他的，感觉偏贵</p></blockquote><p>人才公园我们从西北门进的，逛了一大圈最后地铁回loft</p><p><strong>22号：</strong></p><p>由于第一天走太多了，第二天就把行程一删再删，结果就是太少了；</p><p>直接早午饭合并去吃早茶，<font color='DarkViolet'>工作日11点前有8.8折</font>，如果要去吃要早点排队，11点前付款都有优惠</p><p>我们去的繁楼(华强北店)，味道不错，人均80左右，没有雷点，虾饺皇太好吃了</p><p>但是加菜可能会很慢，因为后面人会越来越多</p><p>吃完后直接步行去华强北，2F 3F还可以逛逛，东西也没有太便宜，得靠自己掂量一下，我们在那买了60块钱的卡拉OK，感觉性价比很好</p><p>下午直接去逛蛇口老街，有点决策失误了，刚吃完早茶吃不下小吃，太早往那边走了，导致直接大中午走海边</p><p>个人觉得合适的修正路线：</p><p>早茶后去南头古城附近逛逛，然后</p><p>plan1 导航去海上世界，那边是商业区，穿过去到海上世界艺术中心，在那里可以看海和日落(前提是天气好)，看完日落去蛇口老街那边吃晚饭</p><p>晚饭：蛇口德记烧腊饭店(烧鹅)</p><p>味道还可以，我们点少了，最后靠吃炒粉吃饱的</p><p>plan 2(未走过) 导航去前海石公园&#x2F;欢乐港湾(这里有摩天轮)，这边日落应该也不错</p><p><strong>23号：</strong></p><p>订的下午四点半的机票，但是loft 12:00就要退房了，所以很早就出门了，但是碰上了飞机晚点QAQ</p><p>最后11点才到学校，鼠鼠第二天还要去乐山</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>深圳这个地方去看看就好，不是一个旅游城市，去吃早茶和粤菜可以去潮汕或者广州，看的玩的也是广州多一些，去深圳一般是去香港顺便逛逛的，但是这次没有时间安排去香港，只是路过，下次有机会再去吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🧳旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电磁学</title>
      <link href="/posts/2211441552.html"/>
      <url>/posts/2211441552.html</url>
      
        <content type="html"><![CDATA[<p>寒假在家速通了一次，看的是b站北京大学王稼军老师的电磁学</p><p><a href="https://www.bilibili.com/video/BV1Dx411f7bi/?share_source=copy_web&vd_source=f3394c34030fde78299a7d7a5bef0d1e">电磁学 北京大学 王稼军教授</a></p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/电磁学.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微积分</title>
      <link href="/posts/2542312489.html"/>
      <url>/posts/2542312489.html</url>
      
        <content type="html"><![CDATA[<p>大四老东西写的，没带多少例题</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/微积分.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西安之约</title>
      <link href="/posts/817673269.html"/>
      <url>/posts/817673269.html</url>
      
        <content type="html"><![CDATA[<p>2024年的第一趟远门</p><p>拖了两年终于补上西安这座城市了</p><p>附上<a href="https://guinness.autonavi.com/activity/2020CommonLanding/index.html?id=default&local=1&logId=&logParams=&gd_from=jinisi&schema=amapuri://ajx_favorites/folder?data=%257B%2522ugcId%2522%253A%252215389456410040346590%2522%252C%2522forceCustom%2522%253Atrue%252C%2522pathId%2522%253A6%252C%2522isCreatorShare%2522%253Atrue%257D">地图</a></p><p><strong><font color='DarkViolet'>day1 1.13</font></strong></p><p>早上10:22 G388成都东→西安北 14:05到达</p><p>地铁2号线33分钟左右到达钟楼，去订好的民宿放行李，民宿就在钟楼地铁站附近</p><blockquote><p>民宿在钟楼A口出门后左手边咖姆酒店同楼栋，位置挺好，由于订的早价格和房间都还合适</p><p>建议第一次去住钟楼附近，去哪都方便，但是房间基本会旧一些，毕竟老城区</p></blockquote><p>行程安排：</p><p>民宿→子午路张记→永宁门(南门)→西安城墙→[钟楼→鼓楼→回民街→洒金桥] (city walk and enjoy food)</p><p>在子午路张记吃了三合一裤带面+肉夹馍</p><blockquote><p>西安面食还有肉夹馍量都很大，肉夹馍可以切对半，如果是两个女生的话一人一份面感觉吃不完</p></blockquote><p>城墙门票27(学生)，双人自行车90元&#x2F;180分钟，永宁门西侧100米可以打卡建筑群，往西走300米就可以到租自行车的地方租车开始骑行</p><p>快日落的时候上去，碰上好天气可以看见晚霞还有落日</p><p>城墙上有个30块钱的发簪真好看，但是最后没买(没人送是这样的)</p><p>因为下午吃太饱了所以晚饭没着急吃，在城墙下面点了杯茶话弄(桂花引热的味道不错)</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/20240117111336.webp" alt="20240117111336" style="zoom:15%;" /><p>晚饭去吃了个王婆大虾，然后就往回民街洒金桥方向走了</p><blockquote><p>其实这两地方可以不用去，没啥好看的，还要绕一大圈</p></blockquote><p>账单(单人)：打车12.3&#x2F;2+高铁票197+地铁4+民宿423.22&#x2F;2+自行车45+饭(47+59)&#x2F;2+城墙门票27+茶话弄15+矿泉水4&#x3D;562.76</p><p><strong><font color='DarkViolet'>day2 1.14</font></strong></p><p>行程安排：</p><p>民宿→小南门早市→小雁塔(西安博物馆)→大兴善寺→陕西历史博物馆→赛格→大雁塔→大唐不夜城</p><p>小南门早市8点半前到，再晚点没吃的了</p><p>早餐吃：肘子夹馍+优质牛肉饼+韭菜盒子+豆花泡馍(太能吃了，胃口少就点少一点)</p><p>吃完直接出城墙，小雁塔没去成(忘记提前约了，然后卡时间直接跳过)</p><p>大兴善寺里的动物很有灵性，和北京雍和宫一样进去可以领香火，但是不用门票</p><p><font color='DarkViolet'>陕西历史博物馆每天10点、11点、18点、19点放票，提前三天预约</font> </p><p>晚上两场的好抢一些，严格按照预约时间段进馆（最多只能提前或迟1个小时）</p><blockquote><p>按我们的安排打算约12:30~14:30进馆</p></blockquote><p><strong>讲解移步b站</strong>：<a href="https://www.bilibili.com/video/BV1Rv4y1p7vP/?share_source=copy_web&vd_source=f3394c34030fde78299a7d7a5bef0d1e">陕西历史博物馆全程参观讲解</a></p><blockquote><p>讲解视频有部分文物偏差，但是也是可以听的，少的蹭下旅游团就行</p></blockquote><p>从地铁站小寨出来到陕西历史博物馆路上会碰到一家全部10元的店，里面买点小纪念品也不错</p><p>看完可以去赛格里面吃点东西，赛格虽然是大商场但是负二楼小吃也没有很贵，我们吃的卷凉皮+臊子面</p><blockquote><p>赛格是西安最大的商场，里面有一个“瀑布”</p></blockquote><p>大唐不夜城节目单如下：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/202401171041.webp" alt="202401171041" style="zoom:50%;" /><p>主要的就是大雁塔北广场的灯光秀还有不倒翁小姐姐<a href="http://xhslink.com/cGa4zz">不倒翁小姐姐的位置</a></p><blockquote><p>如果要近距离接触要提前半小时去排队的</p></blockquote><p>盖章：大雁塔北广场西安市民游客服务中心(多章合一，盖章要带大本子去，小本子盖不下)</p><p>账单(单人)：优质牛肉饼10&#x2F;2+肘子夹馍10&#x2F;2+韭菜盒子7&#x2F;2+纪念币×2 10+卷凉皮13.8(美团)+臊子面15+辛拉面22&#x2F;2+茶话弄15+地铁4+骑行卡4.3+矿泉水5&#x3D;91.6</p><blockquote><p>不要去什么特产品商店里买水😿</p></blockquote><p><strong><font color='DarkViolet'>day3 1.15(周一)</font></strong></p><p><font color='OrangeRed'>喜报，这天西安开始下雪了</font></p><p>行程安排：</p><p>民宿→兵马俑→(书院门步行街→易俗文化街区)→永兴坊</p><blockquote><p>我两对长恨歌不咋感兴趣就直接没去了，考虑自己的实际情况再做选择</p></blockquote><p>城际铁路：西安站到临潼站9元，然后打个车过去差不多人均10元</p><blockquote><p>快且便宜，缺点就是时间卡的比较死，适合的时间只有8:06 9:08 9:55 这三班</p></blockquote><p>我们买的是9:55 K84到临潼，14:29 K2045回西安，时间很紧凑，如果逛的慢不建议这样，回去可以打车到地铁站回去</p><p>兵马俑淡季检票时间：8:30~16:30</p><p>游览顺序：1号坑➡️3号坑➡️2号坑</p><p><strong>讲解移步b站</strong>：<a href="https://www.bilibili.com/video/BV1y54y1f7nJ/?share_source=copy_web&vd_source=f3394c34030fde78299a7d7a5bef0d1e">秦始皇陵兵马俑讲解介绍</a>BV1y54y1f7nJ</p><p>第40分钟左右开始3号坑，第49分钟左右开始2号坑，第56分钟开始讲解唯一一座完整幸运兵马俑</p><p>也可以去b站看看别的，这个是直播录播</p><p><font color='DarkViolet'>兵马俑(×) 堆雪人(√)</font></p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/20240117110033.webp" alt="20240117110033" style="zoom: 15%;" /><p>刚好今天给和我一起去的人过生日，回去歇会直接去拿蛋糕😋</p><p>然后由于蛋糕店在东边，就没去吃坤坤菠菜面了</p><p>爱骅裤带面(总店)吃个晚饭，旁边就是秦豫肉夹馍</p><blockquote><p>秦豫肉夹馍这店很有个性，开到下午两点就不开了，导致我们没吃上</p></blockquote><p>吃完走去永兴坊消食，又吃了两份颜色奇异的面皮(菠菜and火龙果)</p><p>从永兴坊回钟楼可以直接公交车，这里点名表扬西安的公交车，才1块钱而且车上没有晕车味</p><p>西安之旅到此也差不多告一段落了</p><p>账单(单人)：高铁票来回9×2+打车20+门票60+蛋菜夹馍8+爱骅裤带面三合一20+面皮27&#x2F;2+饮料12+公交车1&#x3D;152.8</p><p><strong><font color='DarkViolet'>day4 1.16</font></strong></p><p>睡到自然醒，收拾东西撤，脆皮大学生要回家了</p><p>吃个午饭，还是子午路张记(有始有终了属于是)</p><p>三合一+丸子汤 62&#x2F;2</p><p>地铁to机场&#x2F;高铁站</p><p>钟楼出发去机场要75分钟左右，高铁站30分钟左右</p><hr><p>可以忽略以下部分，这个是之前没去成时候写的，留作纪念</p><p>2022年国庆版本</p><blockquote><p>带有时代眼泪的气息，当时的安排甚至还在考虑做核酸</p></blockquote><p><strong>前话：景区内邀请拍照的不要（收费）；优选地铁（西安容易堵车）；西安北站二号线直达钟楼</strong></p><p>西安的面量很大，饭量不是很大不要一人一大份；</p><p>西安绿码：西安市民一码通地铁：zfb长安通电子卡</p><p>观光车：小程序 西安城市观光，买个晚上的观光车两个小时去欣赏大唐灯具城（绕曲江）价格49.9</p><table><thead><tr><th>景点名字</th><th>门票</th><th>开放时间</th><th>游玩时间</th><th>注意事项</th></tr></thead><tbody><tr><td><u><strong>陕西历史博物馆</strong></u></td><td>免费入场</td><td>8:30~18:00</td><td>2~4h</td><td><strong>周一闭馆</strong>，最好请解说，提前两天抢票</td></tr><tr><td><u><strong>西安碑林博物馆</strong></u></td><td>学生票32</td><td>8:00~18:30，17:45停止入场</td><td></td><td>主要是碑石，墓志为主，对书法有理解一点去合适（或者请讲解）</td></tr><tr><td><u><strong>西安城墙</strong></u></td><td>学生票27</td><td>8:00~22:00</td><td>3h</td><td>永宁门是正南门，可<strong>租山地车</strong>绕骑一圈（可在任意还车点还车）<br />晚上六点以后，就只能从南门上城墙，最好傍晚去<br />自行车租赁价格：双人自行车三小时90元（骑行一圈大概两个小时）</td></tr><tr><td>书院门</td><td>免费</td><td></td><td></td><td>主要是纪念品</td></tr><tr><td><strong>钟楼</strong></td><td>免费</td><td>8:30~22:30</td><td></td><td>门票30但没必要</td></tr><tr><td><strong>鼓楼</strong></td><td>免费</td><td>8:30~21:00</td><td></td><td>有免费的编钟表演，但时间不长</td></tr><tr><td>大雁塔，<u>小雁塔</u></td><td>免费入场</td><td></td><td></td><td><strong>北广场音乐喷泉</strong><br />（国家法定节假日每天五场演出12:00,15:00,16:00,18:00,21:00）</td></tr><tr><td><strong><u>长安十二时辰主题街区(new)</u></strong></td><td>学生票38</td><td>10:00~21:00，20:30停止入场</td><td></td><td></td></tr><tr><td><u><strong>大唐芙蓉园</strong></u></td><td>免费入场</td><td>9:00~22:00,21:30停止入场</td><td>3h</td><td>大雁塔附近，<strong>白天晚上都可去</strong>，不一样的景色，有湖，可赏花<br />留意演出时间（另外购票），晚上去更合适</td></tr><tr><td><u><strong>大唐不夜城</strong></u></td><td>免费入场</td><td>全天开放</td><td>1~3h</td><td><strong>仅可晚上去</strong>，主要目的是拍照，氛围</td></tr><tr><td><strong><u>回民街</u></strong></td><td>免费入场</td><td>全天</td><td></td><td>吃的多但性价比低，不卫生，容易吃了拉稀（可抛弃）</td></tr><tr><td><u><strong>洒金桥</strong></u></td><td>免费入场</td><td>全天</td><td></td><td><strong>取代回民街的存在</strong>，性价比高（另外有<strong>北广济桥</strong>，西羊市，大皮院</td></tr><tr><td><strong><u>小赛赛格</u></strong></td><td>免费入场</td><td>10:00~22:00</td><td></td><td>西安最大的商场，内有“瀑布”</td></tr><tr><td><strong><u>陕西考古博物馆</u></strong></td><td>免费入场</td><td>9:00~17:00，16:00停止检票</td><td></td><td><strong>周三闭馆</strong>，今年新开发的，目前未通知开放时间</td></tr><tr><td>下面两个偏远</td><td>可花一天去</td><td></td><td></td><td></td></tr><tr><td><u><strong>兵马俑</strong></u>（秦始皇陵博物馆）</td><td>学生票60</td><td>8:30~17:00</td><td>1.5h</td><td>由兵马俑博物馆、秦始皇陵遗址公园（目前似乎没开发完）组成<br />有免费摆渡车，在出口至东门秦始皇雕像前方，往返两处<br />美团69含讲解，无线耳麦以及馆内下行电动车（性价比我觉得够了）<br />景区内有电子解说，但感觉不差那9块钱</td></tr><tr><td><u><strong>华清宫</strong></u></td><td>学生票60</td><td>7:30<del>19:00,18:00停止入场<br />长恨歌20:10</del>21:20&#x2F;21:40 ~ 22:50<br />19:30检票&#x2F;21:00检票(西门)</td><td></td><td>评价是是贵妃洗澡的池子，可以逛一逛，性价比不高，和兵马俑相连<br />长恨歌在华清宫里面表演，演出票价最低268(中B东西区)，358(中B区)<br />演出门票不含华清宫门票（评价给的都很高）<br /><u>骊山</u>在华清宫内（缆车上山30，往返60）</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 🧳旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学生特种兵之剑门关</title>
      <link href="/posts/3719896378.html"/>
      <url>/posts/3719896378.html</url>
      
        <content type="html"><![CDATA[<p>迟了半个月补上这段路程</p><p>门票：背《蜀道难》免票</p><p>全程7h，步行2w左右</p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><p>成都到剑门关早上最早的一班是9:33的，从你电出发，回程买的18:45的，一开始以为来不及，我们走的比较快其实还好</p><p>西门→百草路(打车)→成都东(2号线)</p><p>打车总价10，耗时50分钟</p><p>到剑门关高铁站出站以后坐7路公交车(按指引走就行)</p><blockquote><p>是直接微信收款，用不了优惠券的</p></blockquote><p>到南大门差不多40分钟，路线选择南进南出(纯步行路线，猿猱道和鸟道二选一，几乎把剑门关整个景区走了)</p><h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><p>上山：南门→关楼→雷鸣桥→绝壁廊→一线天→石笋峰→观光车道→仙女廊→鸟道&#x2F;猿猱道→梁山寺</p><p>下山：→大穿洞→小穿洞→梁山亭→天梯峡栈道→仙云桥→关楼→南门</p><p>地图如下：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/20231219173150.jpg" alt="20231219173150" style="zoom:33%;" /><blockquote><p>一线天主要是想看一下，这一段路不好走；</p><p>观光车道那一段路不长，而且感觉风景挺好的，可以走过去</p></blockquote><p>走到后面累趴，里面东西都不贵，可以买点吃的，最良心的一集</p><p>关楼还送了一张小照片，这个我觉得很有意义，如果想要大照片一张好像是20(记得不是很清楚)</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/20231219174045.jpg" alt="20231219174045" style="zoom:33%;" /><p>路上风景很好，晴天和剑门关更配</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/jmg20231219174351.webp" alt="jmg20231219174351" style="zoom: 50%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 🧳旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>川西之旅</title>
      <link href="/posts/20231110.html"/>
      <url>/posts/20231110.html</url>
      
        <content type="html"><![CDATA[<p>11.10出发，11.14返，五天四夜</p><p>我们是五个人自己找司机（两男三女）</p><p>去亚丁不建议自驾，下来以后太累了</p><p><font color='OrangeRed'>运气很好，碰到了五天大太阳</font>☀️</p><p>包车5500，包含车的所有费用，师傅说行李箱不超过24寸</p><h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><p>第一天：成都—折多山—鱼子西—住新都桥(藏缘康巴酒店)</p><p>第二天：新都桥—理塘—兔儿山—海子山—冰川石海—住宿香格里拉镇(象牙山假日酒店)</p><p>第三天：香格里拉镇—亚丁景区长线(络绒牛场—牛奶海—五色海)—住宿香格里拉镇(象牙山假日酒店)</p><blockquote><p>香格里拉镇的酒店是司机帮我们找的性价比极高的酒店</p><p>香格里拉镇的酒店基本都有免费登山杖提供，不用另外买</p></blockquote><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/20231101.webp" alt="20231101" style="zoom: 26%;" /><p>第四天：亚丁景区短线—住宿理塘(吐蕃大酒店)</p><p>第五天：理塘—机场路—红海子—回学校</p><p>正常环线需要六天时间，第四天走完短线赶去新都桥，第五天去丹巴，第六天去四姑娘山然后再回成都</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/川西路线图.webp" alt="川西路线图" style="zoom: 33%;" /><h2 id="物资"><a href="#物资" class="headerlink" title="物资"></a>物资</h2><p>买东西的时候恰逢双十一打折，所以可能便宜一些</p><table><thead><tr><th>物品</th><th align="left">备注</th></tr></thead><tbody><tr><td>药物(价格 数量)【购买渠道】</td><td align="left">茶苯海明片(晕车)(9.3 20片)【美团√】<br />布洛芬(20.9 24粒)【淘宝√】<br />晕车贴(19.5 12贴)【淘宝√】<br />艾润氧气瓶(137 1000ml×12瓶)【京东√】<br />西洋参片(33.3 250g)【淘宝√】<br />999感冒灵(29.81 10g×9包×2)【淘宝√】<br />葡萄糖(及天瑞)(24 20ml×20)【淘宝√】<br />健胃消食片(江中)(16 0.8g×64)【淘宝√】<br />肠炎宁(18.8 0.42g×12片×5)【美团√】<br />牙线(牦牛肉容易卡牙缝)；</td></tr><tr><td>衣物</td><td align="left"><strong>冲锋衣；羽绒服(厚外套)</strong>； <br />打底衫(厚)；长裤；长袖睡衣<br /><strong>墨镜，遮阳帽&#x2F;毛绒帽，围巾</strong><br />maybe 可以带个拖鞋(据说酒店的有点臭)<br />鞋子：要防滑，穿的舒服就行<br />剩下的看自己穿搭带吧</td></tr><tr><td>日用品</td><td align="left">牙膏牙刷；洗脸巾&#x2F;毛巾；<br />抽纸；纸巾；雨伞；<br />垃圾袋(怕晕车吐了)；<br />充电宝，充电线，<strong>保温杯</strong>(基本都能接热水)；<br />暖宝宝丽悦(11.8 30贴)【淘宝√】<br />u型枕(路上靠着舒服)</td></tr><tr><td>证件</td><td align="left"><strong>身份证，学生证</strong>（100%不能忘记）</td></tr><tr><td>干粮</td><td align="left">面包，饼干，能量饮料(高糖，如可乐)<br />士力架(27.5 23根)【淘宝√】</td></tr><tr><td>护肤品</td><td align="left"><strong>防晒霜</strong>，护手霜，唇膏，水乳<br />湿的东西放化妆包里就行</td></tr><tr><td>摄影设备</td><td align="left">司机那里有无人机；相机有的带上吧</td></tr></tbody></table><p>物资开销：</p><p>暖宝宝(11.8)+感冒灵(24.3)+健胃消食片(13)+西洋参片(25.78)+葡萄糖(19)+晕车贴(19.5)+士力架(27.5)+布洛芬(21)+肠炎宁(18.8)+晕车药(9.3)+氧气(117)+橘子(7.23)+给司机大哥递了包烟(24)+零食包(158.74)+补充氧气(60)</p><blockquote><p>11.8+24.3+13+25.78+19+19.5+27.5+21+18.8+9.3+117+7.23+24+158.74+60&#x3D;556.95</p><p>人均111.4</p></blockquote><h2 id="账单-人均"><a href="#账单-人均" class="headerlink" title="账单(人均)"></a>账单(人均)</h2><p>房间是一个标间一个三人间</p><ul><li><p>11.10</p><p>新都桥住宿藏缘康巴酒店；</p><p>早饭4.8；午饭65.6；晚饭62；</p><p>鱼子西清洁费20，司机摆渡费80</p><p>男生90；女生93.3</p><p>男生合计322.4；女生合计325.7</p></li><li><p>11.11</p><p>香格里拉镇住宿象牙山假日酒店；</p><p>早饭15；午饭75.2；晚饭38；</p><p>男生50×2；女生40×2；（两天住宿）</p><p>男生合计228.2；女生合计208.2</p></li><li><p>11.12</p><p>早饭12.2；稻城亚丁门票73+观光车120；电瓶车票70(长线需要坐)</p><p>合计275.2；</p></li><li><p>11.13</p><p>理塘住宿吐蕃大酒店；</p><p>早饭15；午饭31.2；晚饭52.8；</p><p>二进亚丁不需要门票，补观光车票60</p><p>男生110，女生100</p><p>男生合计269；女生合计259</p></li><li><p>11.14</p><p>午饭50.8</p></li><li><p>总开销</p><p>男生：1100+111.4+322.4+228.2+275.2+269+50.8&#x3D;2357</p><p>女生：1100+111.4+325.7+208.2+275.2+259+50.8&#x3D;2330.3</p></li></ul><h2 id="行李"><a href="#行李" class="headerlink" title="行李"></a>行李</h2><ul><li><p>行李箱(衣服)</p></li><li><p>医药包</p></li><li><p>零食包</p></li><li><p>洗护包</p></li><li><p>扑克牌，德国心脏病，uno等桌游</p><blockquote><p>晚上比较闲可以在酒店里面玩</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 🧳旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研专栏</title>
      <link href="/posts/4013913837.html"/>
      <url>/posts/4013913837.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="91f96c15482c758aadd46710035f9b6a46fd7e659f193747cd7764fde8f49ce0">54731dc3b4ebad01c4eeb61f3fe4ba23462d840a9803c3f631905ffed989d6d9cca139831cf8479633857500ce11b6fc6d02e4e18066b41b7ecee0e2172da221c3b0399c83bf927da9f6f2a13369989a494f1a53594c4bd7e216bdb4ff22ae0189630ccde96e6569e4ad950a804bb081747679ef863fa0f8e056a987101e0cc2b1eb01371c84b15eb8286a86c9edf41aa4af363d1351bc01e6300ec1043713197a0bb5fbe31146a7246b097c6bbf1508eaea5ee8de1363903552331a1f976e9d261a87cef37a4a2a69a5743c9dd09cd212478007bf6955a24a3069cc64c41ec1aba7084efb1385ef5dd8c1e6477ee5aa58cdd4fc4297cab32d2870bb110d609c22b146e0126dcce0886d806b33c2a513edc2bd10044c5a81503f0b7c6a19f75e1fa6f54dbfc7408f974dd55f27d0def5b79a6f74985c5d356eb177834b6ff2a6ac5dceb28201899c85f1595abe7a0fbc7e0bba57798f76f9331d79ca1e045d0c810e985a5f59ade18e759e88d49b6785de237dc2db91a647f16580ae2014f68e9a2e9b0b47dd807777c9bc34ae24250f2a1784859c7c874531de49c9da74eb390d0f3be9b7a48dd36c4fd8c35aa2cd9f5e4c6c3ecae8f41a241c84ac5b088864e47704e1cc7cffa2b588998b52c8d1738dd25f363a353f2fab281d549794e6163bcd0b9fad07399a6909e5943bed17983af73a7b192097d2bc35bf37e3dc2691d23b265ea09dba4978f6dabfce3a74ba75de3d1f4d47291b7272e7ff50a94e1623bd6658db44953544b67943add34a189021d78cd9738e7d1294fc86b0054adf8baacea679cd118932a5f88aea3797cfb897267f5b922e6d6e004f8332f9b4051b5f55131ba442ce77965fafca2dc39eb7276fa0ec98502d81f3ca86d19335bb82471c62c2345798427255f2141516aa08ae80c4ab2b350f5c077d7f1cd5fce467b59b9aa0263fb32734d7d38e2a07e9e61d6a2580a16f7b0f83a7360bd4dac52b52f17d6a513931bf74687fa5b708f2b3eb921c4c005877653471491fbc50c026c42ffc26da89fb8932613a12eee339912b248a9e635ae7b0e1e1928b214b7f9a8674bf22fad0ebb56731c6e5f9a074767e419ee2798e6cf9a174893ab61dd1353b61e578f45c1686a7088a475fb447a31231e7bef301efd9e08f59c52d19d423af4ec7e32ac16a2cc1c9007b063ee82b138b33d8ee7a52e753068e591b70be5c44127f3b144e5ac63ca7e7910462410fc2efa7838c525d77c69c2e241aa6d6a51f21293976e363aebc767f0a617243ff9a6c742d211e22aa22d83ee0900513b5f649e4ddf1a7d6c930ad0a1634cb068c217496a385b8fca872d3420d435e8e2ca8c879f42cce09f96b9e0a55477a34aa96561a8a4eaca4ed33af6c9124f10a301f64ac572022abc207c5f7416eadc21d02582b75a8e3c24f975262f57cce4919b0168fcf27811446e271cbada11640f4126abb2387e06935895999528e13df892e7a693aa561422a26c43a91848eddc43f62ef28cdec43bb251f7d92a89e4c46bd9ffa3711696af66cb407a2dc76a23ab5ef2b358c6d49c4c8998109bc22919994a1e0d6f110965244ceb0b8d35d77aa2f0cf3d8b17514e2be7f8041f411fc7c5c182d85a49107e1065ae46925e11415afa6948e4f7a2cc14c871cb4c1eebde41bbd1225a991a2a91fdb5f37beb08a9493c500f36fe70f8ae1dc992af164e06e37816334123e8e9eb18c01ba63fd0171220f37cc1c5f67f2478abbd9433174a6ac1b01014fa98c033a22cf9c7e14cd9c6e078dc91b8a5ec156a32bc166d2f404327486fa433f4d59fe6df69a0bad8d3254ef3249d3463021bc99a1f29ec33ad1c2b522a9780f72e603d597424da07b9b1ab5e30604c33460cc95cee147dc1ac8c167beff935834e14ff1f6c2fa4860d3b7ec2ee1a590aea8ade8ff93128a1f02acc2756bf72719624c81199dcb668345357946975d7115be16720b59f41e7d30660d37f45f247c5c663f98d25233de3f83500289b572365e808dc24eda4d45fe4916e2597758a78dfcb69c9da028ecee60bd5b5830708463233da0b1300acc029fb4bf3f6c0bb578719baf0f5fb7a5984caa766d9fc176006149d56ded43bf017a1f153d949060c71f1838b1721835f89a830d0538ab2059abddb8c7ec15424a57ccefac48e6c6e8273f312df4048239d1445265060d340a4bf1a68375e9f9695d0a44aedc2183a1c9fcd61e25cb9380dd7e24484c7a4df3a423a38130e98601d1b045bd5b4836355d2f284f99ef4c5a41b3fd065e4e05f3aa88d6368857ae5932b9035389718de8e1deed71af4b9a8b091e172cb9c41985ef88c58eff84d0b17d4956d69e1acd7e2e8bf33a1c0297b82d0d3d0eae35227e3a0a5a62d96b30832ba16c220b23ff3730c84e90b1dcf391db08184c501c10b2b61bd92c52b97844491ed8320b011fb3b19695ee63a1cb0615c9fc050f3b2aeb7ea236491e891edcc49c9fcbef76e10a19c01fefe2d5eb55b2a0cd22a593110fc7a514b700ed5e164bf2e3b7390832530f6b01011c037d7751777b55a320dcee4880de9fcf9770f540aac6d6b9e0e0a988890d9b7be4317d5f7e2f4788f9c427d000edb5e16e1ab41b059b4efa703e9e3339b57ae298b95caced83986ad34bc5a0b4956786386a4b1f15f8addc2b9f183b62a9de1c4553ef6bb88b6e2164d7f56e62a2d85a5cf743b5c43129e2d683404b5cb781384a6547b857a0511aae8f934d5acfb471b4bf16643e091a5abda508ccf3d947a88d079258628d58415cdf94986d5974c566485e32e6c9f927b1fb7fcef255aad8dc5e1d49bd6c1d41c149ea2ff39a1ddb64b3ce9d7102f6a80b7d6fe3efbf09bfb583e71d782eeeb774106ece84b4c9cf11d45648780155a7c1e73797741d00cd48e69f413ff4809344b0ff9b368e4b1f7faca49c14900cdd1fe5f703564d411fa5720ae3ddeaf0ef620ed57a5fbb943754c17292e6aab85e941e6dda42a0c4c46917810c0d8de888c05abe44b99e2a4724d2390fd679649a66b53d39fedfd01db292fde9929665e4155c6f2342793e43ffe13fdc0b177eccf54c7398fc8c8edb79f5a992218775384e0dab6544f126546c3914ed09648eb23b55bdecd4fc12623da28ae2276b421cacd2e2439fb6619510023c8e0eaeb3a7519707b8284776c8e48ff277180ac22476f588d13aa404238ea68b149d0a182b99fa5f904269ddf59b0acf2b010834e44a1a97bb32ceee2b675885dcff7cfbed07639ccea9ccf9e9a520b40c3e1f900112821077bd6c82efe4ff07c89d018135d22a77a445fad99c7deb7adf4bb7b8b63385ee5258a690f0e0a005f2757ec9092914fa60b157f0117c75d6d3aa8c03be40a9d1ba4ff4f42cf66deeb14e3ddc2df4cfab2d0d9788feacb90bf1d105e06ec533e64e2c934711dda455e96d1ec13bea27029ff9d59c4080ccb436615574217aed5d877936d5dde32f89b984529f4c00af8e7d714e69d0e9273f6fbbff51bdf74536a6ba37a7aa76ade4ec15fc37d672d99122ed8511ab2f05adbe6941f7d9587aec5a24d55916c1463120868c25836cc1ea5fbbaa5f02dc17d9965ba664ce78ccecd2ae044827fa92ebf98e1a2820f36b7ffa158dd1e205c026ddc987b6f0ec7bfd3068b664ff300df2f8a1fee53b0ac1f7458eccf9ff09e9d693e140d6794b3efb701bf6984340c7adbce0ec786b5659ead51497e17a51d937fbc8c3b0a77444d28ae384dd93d825c9a9be0455c4a39efca3b9350f5bda118c53106c0d7b355a213b1fd84fae6ee3c5a6c18585ad1c8c56c795456d10fe3ef81cdc1a8ae3d79e9ca32ad9308363821f5cdd06ca3bad1675dd385210dc1764613725ade7d3351d7d3ba242d17acc2f701fda27bc960ed5a4c91d106c81dea2e40bfca735f4a5229e7edce2fbf3533392944e4a85310113c3dbebbb5fd72200e470fab9e2029161508f9fa95304bfbae221db3ae898db6ee4842345bbaabbb65fb3d8627fccdb5b07dc6936e987c1838f54e29faf85af0790e0cd1dbbdd9519b430d2a509d3b8975d60ecbd07e0baaf1795e61ff4941ab2e68262cd674696ae3f461cfcd657c7a8ed5f9ab0ed71ee9035a03f5b5b5452729d61f59e88a863cf0bba8d8a73472819cb4d0b918810e4238aa51d78305b72c4bf4ec6459375b5b9a0820f615858ff3e00fe38cbfa3099ffa932920f6472d2d94f3f41dc29bb1ead8fb7b340bd7c87544dfcfd374e3f9cd07b3d6e535a46b964b8568128bbd75a17461196c587ce45fbe968ea4333b5d7277b96ae59a17656496dffcdc750d9da23d22225da2482d6af9720e01ff995acf03f2f1ed274b30a6c23c8e794ee9dc6043ce3fa1d92c1cbb68dc1e773cb3d3214791965e5b1b55683f3d8d2fa560f7d0144dd330d08d7d8eddecd335be2ba933bbd67f29cf0ecb5e7488b1a0ad8911cfdf36c28370ae473a37fb89c3a54f74a66c095cff1f3543e7c7bd254533b2d8fe6b2decc0842c693878af2c60450ecb093d4c88dd8a7bf674c66e24f9cbc023cf2b60edff62f20f3a841ec1d3d7de66815359782f19f942b549dbbcc8792daea8aa3c4cafc461a89faff1f86140e5d2dd9c28be9c289c9047f59af9fc7a94ab53a75c70619365285cf48701b076412d2b6f24b0cc4d4d888d44f22ffd02b79cf65c897a7e438238df698a2747e99dc6e7112045bb1c45c233ba619a30de13fad4ba62704a868164ac25c5239f64cfc3d2137e1dd49d32bea80aa3cb5512238c3a77b03c2affaa906d2a23e99a5f85557fa23cc2de96eeac5a79fec78806d82539b439a1f11f4e13b4a6eea173f9cc3aa3c8adf16fb88533f9f3b6831d3622c74247e7a102c08ba55bd18a1758d356e32318dc215ad1a9ab641e70d0ec9e79e9b25a31a7350d84a198de1e9fde412c0b07b048ee5b6c268ae6f4731aeda0796f1b4694bfc05a966161728b7d3623b2b3225a4cd6d56ac410ccf11d0d0dbff48ecb71c2ba9400d344011ec93f90320b3fdf43f98f02955223aca2acef1a60e0edf8852791353cdc3944c69f73a3a8a9e82a9101953719547ad20d94377813c658db6d561343bb179b118b6329fe87b3affe53ff8e902654259ffc9b6386787f9143617d85dd428e52e1072d9366579996342994b10e5272eece62e66e9e39c1ebcceeca3dbd05b01e8c534a958bdbac9d42e52d524f0fec53b148b5ac9ddec6ed46c2af4fd450f5c11d1a67482b03a4a5af4b9718379e36da129e630f84d6d05b4a215e445a0a30965c9cf68cf42770122c08f7ee8e0ef967d800b3a72f239adb761af02a9c3c45f1cf21c8c7ca7d56058b5aa9b74a54ae3b85749746d3531c6a051b3cd8965f865995a94ebe0bda77e63ba96af6287be85074864b2d03daf4b7803edb0c9b6ad371d31220dd6216a5c2ed5c9d8dfd25a9e6ec375531588b2a756ec25df91facfc3c361216580aeff5417925f007fdf434e9689bd8c74fb4b9a5a8fe2f2e76fd27db7a1b079be641890e4dda5527e07b907b9e0ece473208bcdbf68ae258c8f8d4f0e754631aa1b1890b65147ea70842aa50f2dc21e813a54f0ca278b697f9a71e1c038fa64a27153b2508d0c78c8598c538e9de0f4b508f1d6d4865a635822d1a40c193b382a92f5f48bd326e0700f65f595f253066f0ee0cd7f65da9a7cd213247c4d15746a46010476c710d377317c9d4f8d8e07f45e10df3d5ad5f95637bbe8f6a6ce9f7dee3aa88e01f83187dfdff32fdb68cc6f2aa4c1fa9cc2732db412915d9ed095cbf7dbbc7f788b48657857410af4c6599fe32308cae42a20017d1f9ca66aa313cbec53966b18ece4d7b165e78038f915b30aa60ffba3bbb7fe3c0a861b44109c42ab875e3917b2cc7121be1d562cac07c224acd64a4b358676b97e83a4d76e22e0a4cbd718ff770fbab06d26a79e6a164f303a4f7fa36b9796172aad68069ad827b677b006579e984af7453ecf7cc2f207a00d85180e6f01631763e6dad78542ba3da42c4e7cee88c2d147b060e40b882c5ed08e89bd1e21069e3bcf436f5b5fb6b160cdc40afcefa94cb8ced1be8186afe97199090e908270698a314a855b099d94c345d77cc0588c21b6b3d5f2a717d48e9dc4a819726eda27489d09cdea160b5a24cdd1de8696cbd1ca20d1e89ed83d68e8ac75b92ae02e866e75c6ac1ab105c7b0c31aed703f30f2b3455c5ede587b545c91e4bc594dafcf4b8baa05e8bc7d9b16fac1f836db077b4ab6edecfb9cd0ef0a98ef5fdef20c1410faa8b8da5de19cfa9df5fa81bd88a8d0fbb7badbb8d9b905a88c118bdaa28e094759be8a64e98d5a24236140164621b8b2715a30ab900135997db77b37ba24326fddf00ac1265893741284d25d688ee57564f1f623c253bb234ea714d8882e30874059d953d6da37ba9694c4c0bd4054ccb8bfd37f0aa30a6caca5972beb65c3f9c5a33f48f4e32cb27f8c436ec291defc3c30ed90dea64a86a38a0efdc5d757113b15150bb418e5feab96afddd599ed3d4909c3dd5c9ea4d8faa4cc39bef911014cb791aae324b1fb585723801d5740c5be99e94ac69067270c5de1c6d3e9371ebcacd74248841267c0aac5184819e50de55d96c6292c90549e9d4b34a04f682c70c824be2abb75b1327c0d6ab672e087a92ec015f4a05cfde8d6c562c34cc9068859ba15059dd5064fe4052a62176e070fd54b69b2807a597f1af139921c1773f59f3695a1e7c52a2615fda2d92392d105bb09ffb3386d84e9c7b5ccd46068a9f425c1393cedad6f5a13a932f631c308fd849ecd1016803b42caca843336667858915eec11585bc7c693442e08006681cd6d3200b8fc43da50204b1a62a8dd7f89e32a300956ac0a1ecce2b82b684e8c1d81b91d70d065f6e7581edf0418e8dbbc952628b17461249020d316f9ab41a890c1222c0065ba3f1cac6ba705c1b1d2c8c602ef5d39569b1550dc271117e56e50bb31e0d8367c70f720ab15f5f2a63614faea264cb7da9f2652ae47e9a97b83604d448150b61319c35e03cf95d3dbf8a5886a7bba39d59a4f14e3cb8eeb41bd7942aa957aebbe82af02bfa510f4d629f4545711b0b521cd5b05399fcdfbfb39e6732410d6d0f6348c744afa8094f5f95622d5cb80fa7511cd289554205452286126cccd50ddac41d27135857839f203d281d85238be47738e0d4d686406fd884fdf761f0d097d638aabe3a5e75b9460c78c145f30adf82fa853618eb897f3a9e88f862ad81a1a5b169c760e5a96b95bcaec4d2dcf12fc73b87e0eaef3b6ad0a59a6ba92df901510bfbfc89653814f77dab8b545f7c66583d388f425a4393e0c5be4e986cb68ffc5b0299494c969f7ead593f757f0de3e060b687574b1b92b25fc04daf77c7d81df92befdf18d87dc52ce557f780e0d18c15b41573f16172fc91c671f53a8bca58429f1dc1d9797064f14f74db4117585d424849eb865e3d61ff65c8309b314435ffdb8d816bc23566edcd4ae34a28c5c0a07b15b86c9b6d16b47ea4bef37f9d72cfb5a5dc8a4086969b107c4f064541dd4f370c1029e5a8d783ff67709c3beffbefd31c781b5e832e51734bd8392b53c389df3786a13ee3ba78db9d965dbfce243ff467a9b20f31c6b965e6f1320a8eb66a6f76042e2eb82c7567d54506f5a7a8646b41006804c7fecb5e9859ff746f3ea14b9e31ba6cbcba793ce3ca6cf75b81d8be1a20b4f74c8d37ffef3eea6f2ad106213306f0240a50638981e4c763f870668e7ff7424198248704136099d78123ef968af1ff3dde0d6eed3eb85dbf203160cc9f4910649d468c753d80b02e4662bdd7ee1a92e80e11404d0ac38af50c629b82c1a9fbe44ad291e947efb60ab12e08f7ab35faad6bc5500dfd33dceb736acd4a5e4c9699681ae9811f7ddbdf9feaa7eb6c15782a02e03be7b85e4475ecc7ac6f32027c87b2413a6332fe61b6829e4e5e608120849873980eed5ed4f04337b420469c83bc27c73b3a98a42b1adb430392df47f4ec4d1de049b4bcb3831b9881f4879a638e5ebf48ef7b510a712c5a388fb2aeaf20e04732619beb90182f0a631269e89370f21028a8562bba727ff91ea0e41140f7b922c89ba9a309e6ee0a69911c61302372d211ca668d9199fe4a7080981c5c97b402a6450b4e215f27b5f312bbe0eaa216168787380dcc78dee4504ce9e4d8105e8cc2cb66036c8506ddd6ebbf620dbfe17d50c0189aed8089322a34f0baa29431669d1b3f4ade3be8cedb7f343bf0419f1285653ecc4fbafb40ca4754050e33ba5ccfed838cccaee62b3b22effb8d2adc03dbd7dbf2ffb27b7019777db2ea2d54652fa8852e87a60a32fd555291958043fe4830b0b2194d13289e207b4c036dfa97a1d5a311d44be79efad04197d439efbbfc6e69042654361e281a2e09abf52aa45d2af943a25d13eb212af20d0ac2a0776829c403356dcf436d5ed1faf12bc14b264b5f4de8f419036db1e6f51a1264dc2e764677586b05d315375825430209d1efb434ec931009c3ac29f403ebe4598da62cf0c8654cf06629ab725e1575f23b1019bba6e600c6ff7b28f3f2a07ce03f3ebc016be0a184725b4d100cab26403637f2198a3f5caada33e65f51e87edd087e359487ee3fdc6c4f29e89f862edf1286f5fe03488d6aa3c2a49d6681208ac216c19223c1c776044637f7a9e9b1b326b87da8f0aee97a06782f65651e90e9dc507784258460314aede17ab9e07b4c9a063d0a5069a48db8a4aeec9fce04301e30cbf92876c4770942752ba005466de5b4332f66344943e6ae3b4bb0c544740eb034a8b4285f9c65c6794a71a2961c159155531beb43e74a33faf88e25559bc43aba10333ebda0544b1182246c005c5f280d758bccedf58809391f8b6e39c83cde09464c80d0e6d9662f5f31a834beee1ddab77f7d0cbf9d0592d0d77fc387e2e0438c006ac7bacbc1d5e2d967093992a30f619e35e14092f91c2616c909d7422b4e11559b9d0ce98ec9bfa046c232dc871fa0a663682a69d7d3f57ed7645316b1b45eb1eb4b4f3cc650983127108242e5ae9cda4c5bdbc201bc8b48b9ac1f96e508c75a71f8062894b68a7eb4b41b019561c643350589798ec8bf6a95d5c91c7598741215ed161882de793c37037ccbb352e82fff79df7a78e14c5b09088f2efc4550693f9af87bbdf1a7ec631645ed9fb1448884ff34a6f55d6f271f0dff2293b99a8783b351733ddd7bad8c07db216c0685c63f8482c8e114e883952a42673a3fa4c9fe32a423db6c5b68cf937ba506a2bf45bb8ecf1e2d9ec1403d5e56e631df981534e858947c937c93e532f808f29ac4e7a908f037971c1363831c6117da73e88dc26b762dee23852917cee31e962f5136cb92fdb99e69a3e0164dc2a5b67f57be701e759b22f5ba6ff42747a1b8c5729c0cc067f88ac019a162b77fdaa57469cdab60e57451662086390103393054bfaf8de22a55967e8329361966656caaf3af2bd5cfc66eb81697ce7385a17ea6ff734c5a178137529b0a59d92c447471701819173cf6a34c4e79e25db356ea68637236f97b06828e7644f3400cbb5c55de890daa0cf8f4f416867077b9d7f773c8367125b52b1e0481c642be488d3d942ca8aeed6715305d7256c7e288a55db2cd0bccb0886266a913416506d929a746a78dc56cb1268963f3b8d6a1f601265aab5b44a7464182be99ce33885a96314d2efce1413c58b0adf11e4e4806ad7578bd03f64d1e8fe0db62f7b946a4cc43a07a64a75d65a10973e9d07feafb6087cc1805c7a976db46aec2e6a0140374edd56306733098f6722918594bc3b2080abff752326d90fdb4bdd8a919d0baffed51b6f7abbb3bf63df7f430db9adb206b6024589030f68a9fdc0271bd8a4242d333edb28aad2782f499d46196a36cdf929482cf45b6a6f9a1e7d31c5d5cfb9f242af39c48920c7131dec89e34416410baba98afd2b54f9908d4cad50e4c3bfcab31d47149fdc33c63b10a36ee78fc06883c4a270fd21be74e09e3fc565f1efb39c544745f7d90f607ca7a15540909ed169d9c1434661a8675621555076144417523fa8195f18996ca1341ca58f50269479092f8d66998271c3d19a6f49cef44953b129b4b8f3233d875d208f66757f04d9a866cb39706cd15f4917145afc1cfae505c4d5ca4ed7c52d055de3aaf1934f6cac8c04410bec8f74ef87f6e6d6a72e0d3768937749ece63d897a53e8d645fb49406b137910c75e522bc7ea74c9057946b2a3219c7188519dcd51ee90f1044d461d2af83d3b31dd6ee0071b03ed0d00982e14eb68ba08394b24a399c964e00d49b9a2e9ae02a150b49ae9f5ff6166ad936a34d146147da64affdacd973ecf03567350ea65876d4a7750f7f99ab897646f2dbf6f07ba154bf749ff7ee5612ac1508a4d4efefb93f2a1070fbc05286c0257ec7897d75825fc86b36b4d20d3e8bbcda3a38fdf43e5bf4df48542a1e4f983c867653f8bee14372b86930090fc6acf60d80fafb050ffe9096ee517cf28fa5330ed45dcb90be75c2906421a3f74433c8b0cb9cccd22bb9934ce66dc7cbba8e123c3d0ddfd143b1e7550ab12844b91011caea336e22190356e1d075538b8a873075f137bd3401ce548b7e573f44fb521038f152cbad3bb575c3e3d06099849ce2c4cda4d2d419898a6f631c8e5c9dd18c9fffa894bb323c5a1053b33bea912fec7622181d5deb77d825c7fe52136d410b04a7fda765dda8712d7db1838fb88a3353bc58fc0cc50607b3174ad2c609b2ad36beac294322ae0c4e048ceaa49219368f1e7bdd9f00ff305828133190606beab58d53aa227cae7b91aab0d6a92f82f400c148615d7d45bd18af0251cffd25ef4bfa731d35d03a2fe04b73ed9c3212b59109e8209529ace85e86bb0887b439b4a794d72063fe277ebc24a9987a9a9582bd101bac273190cb496cc270cc5be568d097c09df99251e2a02701bc5728ea1ea883fd93a53a685dd25970edcfaad4e0f38967804386d8f83133fce0d7124187b44105449320f207a90b1b10248c4d3a90b16b533a4384db17fa627c225d38a8c6426e842e0413ba08cbdb9b4cbfe2282b00c3b6de69f53132f5cdc1d2918cc4e743efd118d80b654cb5f8d7631130a6c09019ad476b202880556b25cf73e3110e4278d6af3edc9437c188f91fb1b0bb991d17b8cbc6de13825aa3da02302ea129afb70327e4e051d05f8ab13ff408188c07fe88221e51dc61e5f7619f47be8eff55639158488bf714aceec2fc9f2fddc89e847018f2abbfa735e39249e06ac0e8428535af25d5685291d439a6c21cb2505bf03cb24fff770efdc824a703a2d0103f7cea8f200113d5fe0a8403179f5242d4c5f94abbe12c981c056461bf4253db1257f7f2b48603bde419cee1bf8dcc910422d009079486fe583a631597e4d9ba29846ea4d60dc203822924ad96fea151ba06c1ee5ee237d4ca6330863fc3001f616b23d5470d17e1dfe9814d66a0779a8ed6c3e4a0ad77880ca8cd7e9d9c733c84d59acc8b6bd73e980a17689f36ba8aa43bb345e6ee10f6e5439ec2d861daaaa6a7a8d84c9d38b0efc3086f2ec04c279bc56fc989c490f13e041e370e9d574ac46d2d9846037b23cad596271830c18aba3f48fe493ec38a6eebbaddba26746b0fe3c72b9adca17849be6d994c39c172555238c94c610d81b0b9f5239f20b24a0326901f53562a17a4b072d44b52aa789b5bd9f9242fcab59dc810929349c8005092cdc47b98ce114ddea817197526609ae9b40fdd4d924497ec790fddcd145b5e15a3064d2948bf2e7504d3884ac5f22d3a4e64d7bcaff9757f7d3788aa734e9cc49ba3b8fecefb0585ad7c1be4a90486e82bcba25715e891656efb9c5bb3a8d88705138e4518d15dba401aacef033fb5e2db7e7cf0e8bd1d2126dc805675b66bc617fb81d4b7a14f4e74033872b354106b4e7c5588ea818a0193fdc26253cde2544e4b0a31547edf5c1d1166b407a22206b13999431ea8c5fc6e83b8453be49e30004104b482b277b7b18fe23b1c32a86ceb347b766528ba71b30339e4cf6cfcfb2049ba22990fe43e4cc0352e736e7201389e43c09c4cf2f6f8e696d844c5856e195307812ac541b77d87fb8d81cf64c9a4dc7d06110ce6883209d54d74c94b0a26417aad1f0d4f49c0f7bbf6c75feb31323853aa2599f5a6a071503d75896f8a1a4f4f23e30612881dacd36b97b65741e8e5500c9bad51196e17da359c87cd9f82c83d4ddf618fee55543f2ac8e7d66334c268856942f7f131f31e9e10a344a087aeee6108b3969c1d3a5043d82a38211893435c9c0c926c762391337cd94cf3001f4de220e384716940417cb473ec290d1ef06f97c49f0c6924b6d1e0eb941b03e27cab475f6bce7c36e47e93b6582162a7e42adddccfed4ead4c5eb4e7ba18164e5a4e90ad04d207d71a826779d41aadf0271133f4ebdbdafe475a278f31291d2263748eea2e605b830c7889eaaf5ec38f5de80bcb8f8fbd153a7f8cf20e464250b73c5974ec7d6da7b6e39f82540051f60f8b6072d96b1b57c3db3874cb812e2c2baf8ccec3b9d4501ade7b188adbf2edf0e3956db94a29a5e8245b1d449fcddfa6a05d911ec8f92edacd37deea4b20c7b306f61dda7f7cb40e3d6fa5d5996bb8ba3aadf94aefdf9dab5d15496972515c80a04992d48ba962f37aa12ce872e092f9bd788105ba5f4f458712c6d28b369e1171d4d48f8b3aea0dc8e823b9dbbbbb5ae5c5b789a7dc1e4f399e18713ca4902f187b56c41544785778d622d1c02aceecb669c5ab2c99abadb4e432d79070db792a1d68ab33995f470b127b8b904bcf05d91e9afc9f6f4a8a140fa1de321cdc2a15bce8bc1a7d054751218a037e1a854159fa64319a8e25a24268f731ec6540084717334ea89e476a5d54a2952da27d3ec965251405364f023ebdc454f679d63e051da094d655e0a240fec846c92faf014a0fc91e9dd3baae3d054d1649ec601f77ba7c2af674eade08f8952dd2daf78f26f26c82493b8c499ea62295fc54967918716944f53f7a67f1dfe115299da5d65e9bb2cea62fbdfcdec9a31bd35560e7c7143a87df5f23ec2da009b2a1d8ce7df2f0c507b12844a3ce13f2e50f5d3425ebbc9866826df61261c6afd7d4805a4ef759d960b1cdcd4332ef6882aea4157cd78d8798c44f74d4b3051e7df2560e444db3ea68239b4b2d7920c1974e786c3118575fd1afe601da68f679fe386d18e8384beaeb0e471c1c0399465e4ce66dbcce38cf545b26c6ea53080dceea176607bdd0fc6b6ebdccd5eb37e93a007aacde3d119ec58b7e5818b988e0f9a53c5ff67e60612b96a290098f69cd714e14493702d38956e40b1bba8accb2c3592c36e5e4cea2991115865496dcfbd2c9631044f8574314d98246c66c2ff434b257d7541533d943ec38c4349c9ad314cb730446e5cdb64fc070bf04217f9aa5c88b87f34de01f1df0df83f77814c4d24246f35313701dcf97a0d7934d556556a94e82bbb6e8d92aa349cb6578365e6540106fb2955ef7efdc9fccc42936265f9b02dea7f760dc201663c3f218d3e6d2bde7ea70b179104546a4c29873f1a53d1cbb8d9fb85f5d713cfad0f7c7134c68179094651f4dfb9cfc1f19fb3b74f8ebe6d7a236e21c3ea87761584dcce0af79cc8563e9c9a8adcc4d40477b77a1f5b403704dbdcec5b7cc1f80b03e488b0c7f28e1b49ed0ddb269fa65e669ec7e7cde40452654937d9a632f7829145025368a581ceab656d347db25c9071d3bb0e507a6a673f280941862029c32914cdc6a7d81de6a2c99dd778b57c5eeb8413d568b71224244511a2f077be777c9cb037d806de0e77b793443de98be0c4ea8753bce92c6a45354f5de65c32f3ab61b2b46b8a5fa965fe8d6b177fb73bccf9209bd224c83d2f323cf76155eba6e82f54011684d0d9e722f8a6fb45116a094f0cc9f2edec32a1f7419d0b90143e735232131b9be485133ccdef64a138123b2c6a57927e52566a6015857b766675bcb710a0075bf5a53c639e9ffb05b47f895bca444f4f97d79ea4e1bdde54a816e4ea5d90f5157cb57dd111f1d1cc52b1ffd46d105a347f4f39a1b1c75a06131900169fe09cd7fa21eadb65cb0f72738db2be8fa206e0120c50574e9ec644fd99699dbf3403efed8e7475c8d8cde7ec5cdd10dffdb584dc7dc0b51e149c35e3a7a7c6900104b0bf8eaedfb63f5fbb9959c340760b6848c4fa0490c9ab5994771d09db818b8a060f5b87abea4462f8c6cb3b0635e23089ce9aa00e1314747a0328c18807856fef0c68f2727a45b805cac47e7c3fb79ae1dc274930add66c4ae0b2d88c633ccd671fb6a0b821cf6dd60fcdc768b00a7897414bdf15aace93fc22509ebb49bdcd7021c5fd36708ca9d8bd62438033dce8fb5e659835b4e968c51ea55280ee19e33428280093152df53393f7d06a8c3ee8e1d971e02073988d2499abea20902c0b7c62f69147693e36c9d8c1508e666ced78ddb3d476343ab384bce96a40c6505edb9d6e862e375150018f65690690e715f47c0ac46800ed9f494c3bb60271f5a5a6bfd4ddf7f85ecb04ce0c29e36c7e147ebaf6ccb3e83f0d571c715957ad340b48454fcb226ab3cdd78e73ab12e5e9d6b902da6e60585086b87b3a71cdc2dd79a50396d1dc8a5c7754fe441423d5f9c7dc6a0c109351ff5a28aeed0d259cd12653af3fe3eb740f867b17933a893f5efe16a54bac8923b6bdaf18a2a80718080bbae09a2dc27aa938b986b43887459ddf367193a2a60bc85c4235dab70e0bbf98f2ff27bc2dc1c774c499b5f9e52dd7f78b9485db7a4c029c73d6f1ea18275d78e54405e10f68cd78631c92804b769839e77406523c05d77666721e17c18d4de5d284a41947cbdb929633a4d6f3b03c697a024b8e8423e35280d37c57719a2ec1724d2c8fbbf3d4186b7c684d74e204d82957004028f204230ef8dc004a496cbc4858d93527fabfc7e6e827f03fbd10b302f82513e71e5cd1dfda064867de121c0f65479fd0081f4070bcf957424e409966e41481553647ebe6038259e73deff720b4ad033d64e4c90697841dbeaeb0c776a4c9f8b3df0d8e7522f1f940b6b722a79636a68b0456607c12c063d7ae7c850bf1d957134e7bb866d9d1c6b0893e6216689b71a89f3aa299f89982bb98a400167c68ea9de8e72a4b685552303618735bfc33698096c3fd878e614c659a5d95280e15056e7ea5badd4ee66e90796f7b571bc91b8da50e9783f7cb6ef20724af6393dc09765fd0ef46608f1e23676888cd3c5963a8055105ccc31d03e444afdce42d88dacc62c4baadb66e821e028834405c0fa03f6e773079ac2951720e8177002b0cea2ceec59499f4dd2e0266972de7197dbc0583906d9af7f53d49baaba22d42b9f7c974ab744ec80d6b6eecad74d83c616c0c149007d437434929d8322131cb4d26965e83745cecaf96f87725627bf378b96abde4867d0647d922a840a01fec0bb08908300dde549fcdc531185ce576a7a0bb95912696130e755dd4eae9a15bdabdbff683c50116b648a38f80e59b2026d1ed05ba5b082a4a1457b3bd4263f6c5e791a312b2e51e222005db1dcc0a119f71402401c7155f52c4d066e97b1461af15efc5717ee3697759bc6af7e63fd78dbd882e5efe9d629e852d76de4d888b0a2aee05da3f566745678624df481e2080e790e980820efe30cdd0597c6606660858553076d5c2a3cfe290183f92e1cdd3001cac845559eac35c3145e7eb031b259497496b4cdbd7acd96c953a6304c3318e2404adc725b0be0e79a94fd6b6f738023600cd454fdbff948bea0e58c1fb8c60f1e9211c34dec73022a1d86f54e7f18f9cd938bcfb1f6791e6b068f4c5b37ee6f1c4fcaabbb8d1af072748b3eb97bc14f3f2ef7c6ba88092d7a0051bf33f5c929cef58ccef07d1cf421d21f4f0284d86c7d7c86245532c1678ac3467357002ee03414fa1514f50371df4b2a38e536d67d0728c81088d91e14f676e6027b7f72268fbb626452f8a8a4d0da941e15e550bf271337b270c3ce0440ccbc030bb65102bc32f4b9f9a37f009604d4793ca045baeb1c4359c36dcad9f6e8a7de713334e3c301d422496c9f187cab77bf6d679aa65f7721947ec3e11fff3dfec66f1c22a745d00c2319c8f2c44c9081192d8fc804c48f4096aedc8d451ff2b01517718f9a7287e99693022fec9550b7b89e295a2e91b1e469cac11c266bf79a83b9b41048508d68351face9fdc0f3cd2f5921e6ac28e0f73e4dddb59d6c732c0bcf2fc79a901f3727afcf028ba1996ceaa7a11add9a272062c53cfb1abf6d61e6b0c59d5a8f4421abf541cc2d3a8708426a62b82053168b5838acad8e78045e49e5dac1b39eab129df0f0c50fd4969d528c30bb332da2886e28a1f7779619413ef8e4f5d3a0395c285fae3d298ea9914672647c8201fac1ce3fed9da76fb52f6d0a7a23c8e9081294e32489daf4500141593e6adb1e370fbde1de61460c3ee4c8e49f43f7037d683046036e330da935e3fda11e4cc3774b0f5eb7648413998521d7a1bca37c596317198cacd0c1dbc273d5333f5a21b151894c7ed2c0ed19661ffd1f7d5c7d0fc2a01fa9f9e215df449f5f42b5f4eee07ea79960ddeff889402b8b45c025bfd190143bac5691e7e7cfe076b140982475a12b3a3339c641da0c54f0b548cf3e70f3d36b1da61076cde11e9b5d0cb22c2a2b60230ace21e8d23b175083d2e7ab19e672b15ee2b6ec79341932fab9f6b410c7d1e94822a70314881d76b038b90a17aed2e1dce726e5cfce635b02881ebc00c3dadb3c166bd539169b031c1ba30804a9af303331abd61daa1ec7eb72f78c55239a4449ddcec0a879e3a29dfd67e31cb1d8ee01b2c0d356c337424a8d6cb8d2cf89adac27901e767ed0a233606707d8e652e8c53e45ce1bc0c0cbc0b1df43c8195ee8d65f5faf2ee156486f1504aa3496a2f99addf1b3d4b2f8f28f65b67d28547c90c42c1e7b9357fb7d6a9d94cac66a62bbe475b7ff48db02144c0932894aef0c04f0d578c4f08593132f9205ecba41e6e2d4dae23724e2d78d1aa78bb726b840ce22d12b5bfa53ef9ff03ca1e8778ca6aaaf04dc2d6f715c1981302a92daae363e8a6dd85f7aa7711ab10d3e72f5479ad68c63ca30260485f3bc0fdd68c19dbc776b63baf251b8b341041f3b07648d5691da1f00d51523c03f1b278d471fda151f3306a6ebda7498d178f654a32b0da82289e7fdfc0308e553467ae8c231270cf2cb8e06809ea535a56620dc667bc7a6796b4719786c80ecb87866ce3131aaf1771a2de148a15ea625bb96b5b5325247a9f9d9970deacb141266554d19ddff66ffcbc5ac6e37d1a0849db43927069830c9ad39885bac272b25c7b3bfa241555d4ae274136e66958701de84ec5d6913141d645b0590293acdecfb2950c7beaa16296275d5e51fdccee3a5c6cab858bfd890af3689087714aa1fddf60d5be949074086c9fe2badde581c802caa7c0519ec716cc9582a33fabf38925697ce96e761c1beee450e2d6ce37bc69dfb142f22bad3240c390db9e7e6f745654f1f7acb69e3d8b91d6664733d6c1f75dda746feb32cd7214fbbd272db308259218cf4208082116f09abeafa08a7ed00d5e7003f3d86df095925637fd763e3fd4c7d11161162a5dcf1343284678cb2b6e70babf737e826c79b4170dbeff90dacbc38b3001699c7bbca7d0372a6b8c6d85cd52ee050211d69384e2003dd3eaab5c5ee9cd663b2b1058981ab7e077bfe9d18e83583d8193ffc9edd005a70fb56210790862eb5b0a202a068c5678dcaf07c62550a02b781fba7d0607e7b99faadeffd05661d654b42388e51a56e63fd9929458b736d871d5f2ae46a07dc9475b64f52c90feaa56041e65512f91b0072ba0aeb7c814ae825454b05a8a3fe4e04a780cd2f825e7704ab5f2300d32031864eee7e8e2271a8ebc9210381d646e7c2d751550f1a4d0078f6b38698183c455148ecaffa969074c11735d28ac1df1d69353d722776c0eedfb9cff64bc125109d4d9a228dea3482c2d0ad8e583c281040ecfdf90ab000cbcaf6cb478c2790cf9c2f61dea83f9f41c921cc9de3f5f43c99f92163c2f22840bc2379efc2843ceb58b86fc0903922963525364712a3e92f4c885408445c198d8f1ad1667d18566898a6e94ff1147dfc6bc15bb086bc0206aed9a7b9870ac9c72f6b8fe498f1c928c14230448cdd621cb115f534543776a98e5e0bcd29b88be4c0efb3a03d8f095f1f06f5699ee59e33245864cc4633d08f2b455fccbe01a304ee64ee9b47048e54ff1ef3eac0d058720ca2475b2445d3e32c3a33f46337068db6f24aac941094a085e88312554b1046cb583961882ce7bcfdedc6d82974a63a0ca6a478dea39f3e7273d39f89d1b2f657c74212ecf1e94604e345446f2ef5831f0ca8d21e7d8565b089854bcc8712e814056630eab928e99c274488c0e327302a13c175758bdf4844b8c749abb82a4c6f0cd17e7eae4c2cd0180a2f67f31c951e367d663f81c96ec60765c9e48c191e59479a6e9d6b0aa1e5fdee804d2f701fe5e59d97ab75e4d7b524291744a0b266be5c1ba93713c9a847bdeb25d7a4203c19bf141c98a83057fee9ea2da68eebd8167003641a0fa5c7c563ce1a5b7573f33c9c5724cdf20f86b3da196cdc193da19c6957d51867ec0390526332d38b92ceff30603c197ae8bd25bb296a6766abaf3db9355abfe42c04ff05c3be0b454d3d803be89f3c205738259405ac5a904c648b7472e6c390aa87d64b691eecde11ac8f02e4a9b8f04ec4cb560428c90cab6e068096f49d11c88146885ab3d54dd2efc4de627ca1fe1cdbdbe69c15eee5a2dcc42e23bf921dcac1926a3db84fa89cb8fd428e7d1bd353f1805875f0df5845fcb2e7ef207955606c867c19bedba619cd1a0e09c15faeb375f0ea4146473928b732eb35932fbff1d3894c34012ec6c938367f949693cea6c0e1c40bb77f06c95a97b9004776f55ba98ac90b21920689f5cb8dc5c0ac29615b4343ce16f5f99d301cb0a64702f8867d60157937c3f30ad710551d618e5016c9b330d15fd8933630656a234d86fd225bd968f2424ffcbee16d87f04686ce048ee842ab7bfb2d58f9ddb692914df4b7dea0d01accbbe8b548368703b22fdc1e74c5b8fddd5737b026f366b4093b547affd6edb0c346885de6f61ac40f3664b7abaad6ca478f39aa016dbb5fc75935d1df1cdf8ca46e8ebc202e55536c00eb7a0253a86b339abb0aa7c2c5d40d8cbf7bc64d6b0f27853ff48480cf52ac8209fc72931b4970150af53d68be55e68d129f1e56950850afc6e16b95df52a89a707ee4ae068a69d17dcb2d52ca72c17cc00d51fabb394727cc2d3e47b43a38f57044369056bfa8770d6b28f5b4db88423b5a8a872eab60e30b131fe0a5bd568dca892604c88ca7157594c81f11f8ee3018c1e190301005c6f9698ad36f3121950063d202334bb54106d785b6031cdaa45b9d2ceca1f7a50231a31bd1e8495db8a2f7c291c701f1a0a61284f70c23482cbeb58690c5f2634c99b3c06252f56142ab929ae73353b535eb532aabd0b4687ff09f98d211c8ce85aa13041f5f8bce9c5e638c0b7f87df607349a1b50ccc039d2c209239711bc289dd59ca50e614108a1de1f315dfbb2bbcd3f064f8b0ab717179625497bc655bf64caeedd5f9063b7d946d0ae0f739398902aebb956fb3fbfa069d1fcf5e955fcce4a8d5f00c901077cfdf7b21527f7144fc1a617da0b623914e32c34a67cac7a63cc339589d613de4ec2bd3e5302d7272c2110138f02bcdd3c9a5f79962722315156ece8fcc9c59dab4c110e3a2a3548297f71aa899289330a548734cd171eefd5c001134e75c2d37858b300bd7ad949c6d643dfaa3887c76999303fd4c663e583f00104e881cbcd3350d258e44cc943c266ba8cc22996b083d8cb76e08949d95a068c847447ababd8bca9436d9288473fbfe9cb5ac714d662144853337e2e9fef68834fc31aa53dca0810066ab6d86f2ee49cf7cffad762de8ccd90c84b945fd9b828b67f040bcfb6ef8b6043c512c9edf40c01b5f36af96d47f93f31eee4d81004cbe5184d85a3bb9064173ed36f2b6691c2f0a9ce622139e1b059b26b09e0fffaf074e22a8b5835dde29866917d7a791c7774300097261c615a1abd6978cfa7c7e96212137ba60f7f6b555ff37caa3d049b4dba4afb932954bbccee6d85fc414869a2d89ac9c324d9304b1215a3b32042e61aff5649c9ce9d7bda5db43569434554084ab1197e133d77d6554e09e4b07b3d8a88a81eed08426a488ffebafa6edb697a45e81fe804b5627c4faa832583f0db8e2027db186649181190333d2845630c00c418b5f7de7615ffd43dcbffcfc8114e899b96d9f1d623d250d33c46e841c6ec9efc6081f06822bf12d22718afc95c179bd1ae6fc86ad4d06a7e4d181d57026515d42f2d6ee7359bf6cf1b4ee1875b763e536e3f5a1d46eb2744953152bf2417d7ee54a8951f2f8d841a3efe8601e919df5eb28757b175e9fc999ec9c890ff9dc68d98c2319240b2145cecc5916060ce7ea9d60391865f78de0f5eff9a7af7e25642a90888fba9c109b2a07472a6fb3759a016283082d3b7c17b120dc6111e8fd08e1c85e24478f5eed344e57a6cebff7dd17f55e42e567c1371be371eed372d5fef5bef45ce3f694eabfe82038b6999646a5fcb8602f66a562b36e4fc1f9425e373827d98661448ef7dbbcef34898927662e8d9423104b4b76219df86926bb0a2eb3a00d0f5ae09292cc7c4f55fb030fc377024b70dadd6a1affc6e7c2248c0c682275f65e5b93415e89397a78ca981b2f8073591f849552bfdb949b174258788ffa488e078fcfdcee1594acb939d8cf28c22b769075f78f7201284c3a46c8a220196b87a04ddc44f0f8b16a686157c39cbd5cc92253db31e68525dee8aba266233b92f8b2e0957a4d66f33c18cb739c7fc23068d5d236ab44945894dc7dbd9c718de2cb8594f1d8ee210383ae616f8b83e837d18ca6220c830ec98e681022b874f190ac9fbca404e19d9ee4831c6cca0926967cfbdd02b7205e934364de125969a4a0917028aeca27bfa37686c784d693ce4343658cce01651f2011015c2677c24feebbd00652f19c2e09dd874f63d46527e90d043534a8ad6954744770b4889764da300d5afe532453c260cf560d8a9b65b55f5e8ffcaa16b2ada8e972f18d2221c75c54a88c62b6b932d3fa4cffedffad92ea4ede8b54059f6598296ea45b6e28a422332d9b170617d6adbce4054d8d0c8854b97087779d9e4b1e18124098f966db5d1ca578f7274db17daac9fcb6293577a4becc5c14cafada79a41a1f881c4915c85015c7aab41b510fc30c924bef0758702760be7fd49285b72150f915b6e53ab2aba91d12a2a3f4eb032403b6bbe23963ded44736fe644bc0065d174543e0c989a18e7daa7aebb7636d8ce7c3eeb06e4eab049826f068193f327cbf9af720da6b236ebe157e8ff0ff19dd03182a8d88637c6e26479f8207261872c123909e5443ef4404c894afb42e95b1e3157b151ce991105efadfab6f38cf34c1a7d12a6603d943fd8665974e7312484bc8a4ee4b1fb6d0ceb36d1bd51db789f03b49101c891a9e45903a2230bc45f0f077411b40926379f8955ae865f6889c48c309ce8fbffd91c214fad9d59114897abd8855836c4bad4afd8924622a8f7d2a7a1d176541987cd83dc51ee9b00a408b043c450ca70b021fca6d3e0eaa4ba08c39bee8e06ff49ef152759eb92e8efbd88fec96622bca4950b84b3fd3a2011fcc9222760624904eff2ba5e4d38e08b0157691bdb3ede3cfbb6f3b41ce578bffbe75e7de36ced8d6f4313a477c6ef77d1b74feee2c4b7ed0f426828437cff1d307120507da6389f1a3f6c4fda064120972db57f97908e07d281b860f6a8a5d47aad629a15e33028cde4c0d856a32e630d9b28e9b8fe4a408cec9ffe13fe4ff042549536795cf2fb7790a6c362f44e44f9136950a7794902252578f40b1dc01ce3744eb4d6c2b62685b109a5a8fb92820e17fe52a1944286762982c44fb775261723b24adeb38a9ba7545f5c602a75a2b3038535fd738dcaac8a7b355c585eb86f29bbc5a89eef7cfb4fecf57bb4bb86b4c72d10a5b3ae32ebc9fad978fba17a3d7d910fdcd48b7ab875c1e901e14683dd24dd3c99877248370090023ce6f54de2ad4ab89a8492b854c9966b59d87eefa521f12d408cdbfbe2f584cda69d90102a866b3701630ca9ddaf4418fdc6bd0e0b34734125dc7a8e828e31a77de1c54aad52c983587521828c6c08261de82a05e57957adbb939edf717c02be3406effa85d6e731c81e75a258ec5b2f237451856562d389c7796464a3bb7f6f05d96c662002b9dfcacfbb321d8d36ab8485775ca7206bdf1374fd96a090f8a5d5fcf243d7ae339654cfdd3c1078cc0e3c8cc418c85b0be05820ec79ff9854d9ac66954e2b565a8ff63d7554d54f73a1c01a66d8e4448c54737f8f6de7c50a59ee74380c4706e81ab09321b5995ab1bcb93438e3559727a70397c184e9ee04638dd47741d56be2f9cbbebc50a577462d6ac8ad397bb3cfb965508f3cb3d298b416211b2bf0a2cd32b27781bfa64c87fc114098640591d9dbf1df9de8d835128034183ff8626643ac129b878d7f6de1767398ca11e42d9516745029791a385d516856a5ec214129c42a950033b656ff6f061e2db9c1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 🎓个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>固体半导体器件</title>
      <link href="/posts/1820986107.html"/>
      <url>/posts/1820986107.html</url>
      
        <content type="html"><![CDATA[<p>保研期间简单学习写的，没有很全面</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/固体半导体器件.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爱在三部曲有感</title>
      <link href="/posts/3504288178.html"/>
      <url>/posts/3504288178.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="708df44f22aec286641e58ab78fd4db852c112453cdfe46bbd65b54a30b5b9bb">4eb73ec749794c3eeeaf8ac2ee365566154f16239f4bfbc4d5cb9651f5f78cce290249400e97d3782851cbcea855882382c2568cc726852397c25f4e09ab813498312ffb8bac9456ecf6f71ecc8f625ce990e58b933fc4ed0613d7f87bdcbab9c7d1222a27a0ac29d764f6b8934f436c0c2f2ee84fc75892c85e603fdc07bf7e04b2876aeff792d1f7f9944a19970246a1adccad11f509b61912952740f1591a9faae961b38e907cbe8094375a5bd48bb1a5cd592dd6506797702cccc1c9aa5c317cf958e986a118ed19b1441bf1e26c55ebb3a7b96a8187c4fc6c3ccc476396b95a8ea3c7a632777221cd849fc8fcc970aaff4833da08e07c6b64e6fe4f03ac426bcc5e79c181cad68e2144cf91c6330fbe4863caeac54708341cf830ca35c68ce3256915341d5ea30a03bac05dbda6fb02f50ba6093fc700ea1866ab5993598324b49fa558833fd36baf28bece76e01d13ed2e00c43f0e5ac703d7b3739219e874ac347c06cb3a216ce79803cb29fdc96c36f9853000b5b6b94050a9879129dc086cd7421d0f42a66267762ecdb3f1be39d1506baf2a6c71e4cffedff56f4209649013cf9155b3c9566d4dc59b3f32ed41c2324f88cb7b6b3b8fcc23b1e95a520befeafd63eb089690b9684e7f06f7552f8ede22a527ccaa576442f230bbe20b2bb31ae17ef68ebf0d8d2ed5cd2c6bb165c10e0a7d524c31513d785fb585f38a50417b82d98fbcde1cca4b7847cead5df490b6320a22024bd092f33728797f5ebc4c69a38f7e11e3e4debfee3983b628c757a075c73bd041b733fcb0034a4b8eab2258b677e296e4ed41c6ec091e1dac354b8e120e5f5bc2389f28be1e6cc7bdda88e8a6495492551b5df2aaa347421fcfb4e5ff6839b55b383aee1a5a7e98b67a8989451c08e23702ff68190af168b60b5d234e46bb0d1ddfb16933d2f36d0f23006d3496dee3e7392dd887159874b081147c828e61193ac6ead5be57cac5ab6c7af2d7411e3212605ad205f370660cc91abdbca09efd5670ed99b34bc4f97dd36f2cdd4fb6fb04eb44737cfe8272d028ba837aa1374d08e8d5a4df9b7d3ee3e571faf5f56f210e8d29e62ef378db4e359afc009a54db1f4eb61ec1c797a58030a15ab2f603e865dddee990391a69cd42416d28a2e6e018168ebd23a25e0fd338bbd03029865407b02f4e70d2f85aa7ae8f6288881831680e6de57adeb9363e5d467841492e4f3df96727ae345fe4290c0ba5bd59a6a9e9181b29e30a2b7708956a706dd75b05c68b1eecd55f64502ea78cbb1c52cf6e77bdf4db1913d6add789589ce4e0eff5e02a4432f5d1fb637767031592b723687281329b0854197d8be77982ffca8fdabd96aeae2fa835b39292b20b3beaee3d20c88c11561df6cdc74a11e1d0b4664ca24b27450bfd24ed926a6c9e95433eba4f13d602a9fe0c9a2cf5e3e1f07cdbc7123e2065d499172a1f4e6d9cb2e2835cdf8c089d8f4454ce6bd9b15ff5672b521b5d0674764589bccc1e02be468a2ceae890814d801bb39fb40160aeea51fa26abd8e4b8206a791d79322087e12f11e4891db3970b7ca69ac721ee55b779b13a3ca90d9b09da245a992f5adabb4f99285b0ec128fc8aba714616f6a0cc537c4f1b063546e5a648a769a21dfc8dcdf8ec18b0c59830aed42a1294e5ac148314b6ef0824351b1e73e388a663e4910c545979aad60a0cccd0971d31ab1648760b01daf75071f83286197d40f7ea32c5e73dfeaa92e4e198675d91f5c3f4bba170e984e0197ba5d8e53d20c795074c6622de2d43acb43efb20c3eac84f295ce80a352df317d801e607a0775c6fe5645511f67fcbe070d8a7a656ab74ea8a22ae302cfab44f9852daaf7c89c77815e65939c7206bef5e463605a6694ed48659a5c03ee974aab3720d541b3471683faa1a56b1e32818a14695803ff7a20ad54356b25da7392838788b86ca65f966f0c79a3413531aba4e79953921bb283a49796831d41af4c3efe2697a66ede54e3936beb99ddcb339900cbb94c94cc73c00721608be3280577cabc57c58484687573f9920edea513215792f63c22256e9bf7d388b3874e698a1d412b72c4ce264b3c6835744511e8db900614c9608cc44894e5aae1bb13f87472fae2ece853a1f932681dbe7d72cba705d1bdeb21db3b8f29a6f5d6cf57c8b14756821c79d83185582a5fc9c344f2da7d4ebe1594faa9b3352c7bd994db0bbb7d98419c1407ac684316107d198584e2ad483c6451ca7f4ac95b67ab9797357221478df06f8aa4dfcbea7cd8ce0f821e7db3dec0af4255712614bd4522ce058887be19a5517e66e7972b2f512bf71714f0b65b263b9684163ab627b4adfe0c9f48841abf42ec20de23179eb49b15fc4325be0ca41541465b7f7cd1368fca891b88497fb7c17487909ad8cf46b98518822eeef49d017fc7b8e30589e7a6fcb0e20019567c39af54bdbad1eacf37bc7b7bd577bc4d11bd2a18eb13a5a3d102973d10fdf84419470c4d51823f81cefca3d3cc58f33a8ec2e5aa4f505c42b3f605cb19cef98728a1e9bbcc36c51497394ee11ae986c634d7812602d33e41860e4ee96461c8249b0bb2cccc2e40b0c7916230cb88740c9f96f72c1ca34d4ec3e5c0ff2c3f7a2fdd39894a752e4a152c1010fae650315021df74c3fd83a048c425efa938bc9640aef69864caa088eef1c8e5312dc05e85ab933afe21e69088634f85fb03a20ed5ce624ddce792c62db136eb3f0c95545f3c170cc5b450d7b25729013bf93b9242be99274733e4aa8458c635709f7bd78957d36ca73ca87289f014ec84ca7e07273348d13a7ed992a0332a6e3a6098ec33cefb9558bb7aee8c58b85fa1930185b95ffc0401f34770b8b64c20e4438a08faf765894af49cd8263553d839bf5ebb4d3fb5a2258cd8abfe2ab1857a527a03d3432b713341cf1dfed1fa919c83f4eb22ac7b48cfb8ec18c7ae3cd402ca47ce9a0218c300e4591f99daff5fec5bd905eb466a58b83532e85d375401882a3c29602cc2134e4bb3be28475aa2789f696c95caf5faf1620002a53be5d5d0c9c91c99337c3adfba675bd9348b1c9ef1f9545c0867d158ea3f45bf63d285b5163ae5cfb443040a31415f2da9cc40c31aeeb68f891f1bb766041487177b6f82380522ce903d11c103167a551f702503307d8cb4ec7f0a9998c12bb8a54be5556446848325fae1c47f597bc24f454ed8132e6857ea5bbd2c8e96ced3f059138a427827272f2c55c35c0aa664a97d565b10ab4b89b9c291dda48c4d2467fe7185730db943a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">私人文章，不对外开放，请理解</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件集</title>
      <link href="/posts/2037495952.html"/>
      <url>/posts/2037495952.html</url>
      
        <content type="html"><![CDATA[<p>心血来潮，新生刚拿到电脑肯定要装软件的，这里给出一些自己平常用的舒服的小软件</p><h2 id="桌面类"><a href="#桌面类" class="headerlink" title="桌面类"></a>桌面类</h2><p><strong>壁纸</strong></p><p>博客的壁纸大多来自于<a href="https://wallhaven.cc/">Awesome Wallpapers - wallhaven.cc</a> 这个网站，但是这个网站是外网的，建议科学上网</p><p>条件允许还是steam上买个wallpaper，省时省力，壁纸好看</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogwebp/Snipaste_2023-08-15_17-12-54 (2).webp" style="zoom:33%;" /><p><strong>TranslucentTB</strong></p><p>底部的透明用的是以下这个软件</p><p>可在微软商城里搜索下载，下黑色的不用下汉化版，汉化版目前和window11最新的beta版还有点不兼容</p><p>可能下载后不透明，这个需要移步百度找解决方案了（这个软件被微软恶心坏了）</p><p>附个之前自己解决的链接：<a href="https://zhuanlan.zhihu.com/p/607154745">win11 透明任务栏软件失效解决办法 - 知乎 (zhihu.com)</a></p><p><strong>Wetab</strong></p><blockquote><p>在chrome 或 Microsoft Edge浏览器的拓展商城下载，本人现在已经弃坑chrome入Microsoft Edge了</p></blockquote><p>浏览器不想打开就是空白页或者什么导航页面的可以试试这个插件</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/Fuxi/image-20230815173719842.png" alt="image-20230815173719842" style="zoom:33%;" /><p>可以弄很多快捷浏览点，一些主页上的插件也好用</p><h2 id="空间管理类"><a href="#空间管理类" class="headerlink" title="空间管理类"></a>空间管理类</h2><p><strong>geek</strong></p><p>卸载工具的扛把子，一般的卸载肯定有残留，有了它以后再也不用自己费脑子去清理注册表那些了（记得以管理员身份启动它）</p><p>官网链接：<a href="https://geekuninstaller.com/">Geek Uninstaller - the best FREE uninstaller</a></p><p><strong>SpaceSniffer</strong></p><p>空间管理神器，可以把各个盘的内存占用情况一览无余，虽然从16年以后似乎没再更新了，但是用起来还行，扫描速度有点慢</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/Fuxi/image-20230815172733901.png" alt="image-20230815172733901" style="zoom:50%;" /><p>可以看到我的c盘被一堆系统文件挤着了（难绷），但c盘里的东西还是不要乱删，删掉一些东西可能电脑就g了</p><p>下载链接：<a href="http://www.uderzo.it/main_products/space_sniffer/download_alt.html">SpaceSniffer download (uderzo.it)</a></p><p><strong>TrafficMonitor</strong></p><p>电脑的网速、CPU和内存等指标的检测器，如桌面类图片右下角的小框（我选的皮肤比较朴素）</p><p>具体可以查看知乎这篇文章：<a href="https://zhuanlan.zhihu.com/p/39542454">TrafficMonitor：最好用的网速&#x2F;内存&#x2F;CPU监控软件 - 知乎 (zhihu.com)</a></p><p>能科学上网的尽量还是去github下载</p><p><strong>everything</strong></p><p>可以快速搜索电脑上的某个文件，比window资源管理器自带的搜索快多了</p><p>下载链接：<a href="https://www.voidtools.com/zh-cn/downloads/">voidtools</a></p><h2 id="文档类"><a href="#文档类" class="headerlink" title="文档类"></a>文档类</h2><p><strong>office</strong></p><p>看个人喜好，我喜欢用offic，WPS没咋用过，虽然office是付费软件，但是可以破解啊</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/Fuxi/image-20230815175135028.png" alt="image-20230815175135028" style="zoom:50%;" /><p>通过这个软件可以下载安装office全家桶，Word，Excel，PowerPoint(就是PPT)</p><p>然后安装完激活就行，版本可能不是最新的，我破解完的是2016，但这个版本高低其实差别也不太大</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/Fuxi/image-20230815175239946.png" alt="image-20230815175239946" style="zoom: 50%;" /><p><strong>福昕pdf</strong></p><p>完全舍弃wps以后肯定要遇到pdf的打开问题，福昕pdf是目前大部分人认为的最好用的pdf编译器</p><p><strong>Nanazip</strong></p><p>压缩包其实用啥都差不多，WinRAR、7z等也行，但我还是喜欢window商店下的这个 </p><p><strong>typora</strong></p><p>markdown的一个很好用的编译器，但是正版要收费，目前我还是用的破解版</p><p>这个编译器集成了多种语言，包括latex，html等，兼容代码块等功能，适合写笔记</p><p>你目前所看到的网页也是用这个编译器写的(.md文件)</p><p><strong>vscode + latex</strong></p><p>把它归到文档这一类是因为我的vscode只给配了latex，所以我平常用它也只是写比较规范的东西，比如数模论文</p><p>这个环境的配置还是移步百度吧，比较复杂，如果你不想这么玩，简单点的话直接移步下面的overleaf</p><p><strong>overleaf</strong></p><p>网页版latex，还可以支持共享合作写论文(目前没用过)，而且它的latex版本还是比较高的，用vscode配的话可能以后会碰到一些版本问题</p><p><a href="https://www.overleaf.com/">Overleaf, Online LaTeX Editor</a></p><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p><strong>snipaste</strong></p><p>目前来说用过的最好的截屏工具，比微信，QQ什么自带的好用多了，可以很容易加上文字等标注</p><p>甚至还可以实现贴图，方便你对照</p><p>下载链接：<a href="https://zh.snipaste.com/">Snipaste - 截图 + 贴图</a></p><p><strong>Quicklook</strong></p><p>有些时候不想打开一些文件但是想看一下它的内容，用上这个就很方便了，下载了它以后点击一个文件按上空格就有它的简单信息，图片一类的还有缩略图查看</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/Fuxi/image-20230911110813547.png" alt="image-20230911110813547" style="zoom: 67%;" /><p>这个是在微软商城Microsoft Store里搜索下载</p><p><strong>mathtype</strong></p><p>写数学公式的必要工具，虽然office有内置的数学公式编译器，但是写出来的公式感觉还是不太好看</p><p>这个软件里面也集成了latex语言，所以可以一举两得</p><p>我用的还是6版本的，7版本我电脑打开有些卡顿</p><blockquote><p>这个安装过程可能会有一些bug，如果你的office和mathtype都安装在默认c盘位置应该不容易出错</p><p>不然你需要花点时间去处理文件位置</p></blockquote><p>下载完以后每个月删除注册表就可以无限使用了</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/Fuxi/image-20230911104759082.png" alt="image-20230911104759082" style="zoom:50%;" /><p><strong>deepl</strong></p><p>科研翻译大部分人认为最准确的软件，也有copytranslator的监听功能，但我使用体验不是很好，感觉没copytranslator便捷</p><p>一般都是一起使用，对照翻译</p><p><a href="https://www.deepl.com/zh/translator">DeepL翻译：全世界最准确的翻译</a></p><p><strong>TopMost</strong></p><p>一个置顶窗口的软件，可以下一个时钟软件，然后把它置顶，主要用在抢票等环节，读秒</p><p>下载链接：<a href="https://www.sordum.org/9182/window-topmost-control-v1-3/">Window TopMost Control v1.3 (sordum.org)</a></p><h2 id="插件类"><a href="#插件类" class="headerlink" title="插件类"></a>插件类</h2><p>插件下载在<a href="https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home?hl=zh-CN">Microsoft Edge 加载项</a></p><blockquote><p>我已经抛弃谷歌浏览器了</p></blockquote><p><strong>Tampermonkey油猴插件</strong></p><p>插件的扛把子，在其基础上你可以找到大部分你要的插件</p><p><a href="https://zhuanlan.zhihu.com/p/128453110">Tampermonkey油猴插件——安装与使用教程 - 知乎 (zhihu.com)</a></p><blockquote><p>别人写的很细我就不写了（不是我懒）</p></blockquote><p>目前油猴里百度网盘下载比较好使，可以不用冲会员高速下载，需要配合idm使用</p><p><strong>一些别的插件</strong></p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/Fuxi/image-20230911103628725.png" alt="image-20230911103628725" style="zoom: 67%;" /><p>Super Vedio Speed Controller 可以实现网课的16倍速播放</p><p><strong>docmooc解压直用版</strong></p><p>下载链接：<a href="https://domooc.top/domoocinstall">中国大学慕课mooc答题&#x2F;自动播放脚本(domooc)</a></p><p><strong>IDM</strong></p><p><a href="https://zhuanlan.zhihu.com/p/370232716">IDM全网公认最强的下载工具！ - 知乎 (zhihu.com)</a></p><p>可以简单先看看介绍，大部分浏览器上的东西它都可以下，只要有个直链就行</p><p>找破解版就ok了，学生可以不用正版</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 🛠️基础工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马原笔记</title>
      <link href="/posts/1754089648.html"/>
      <url>/posts/1754089648.html</url>
      
        <content type="html"><![CDATA[<p>2023.6.16 马原考试真题</p><p>1.唯物辩证法的否定观<br>2.交往对社会生活的影响<br>3.马克思的劳动价值论的理论和实践意义<br>材料<br>1.坚持人民至上的哲学依据<br>2.文化对引领社会发展的意义</p><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>马克思一生最重要的理论发现：<font color='OrangeRed'>唯物史观和剩余价值理论</font>；由此社会主义由空想变为科学</p><p><strong>什么是马克思主义？</strong></p><p>1、是由马克思、恩格斯创立并为后继者所不断发展的科学理论体系；</p><p>2、是关于自然、社会和人类思维发展一般规律的学说，是关于社会主义必然代替资本主义、最终实现共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由全面发展的学说；</p><p>3、是无产阶级政党和社会主义国家的指导思想，是指引人民创造美好生活的行动指南。</p><blockquote><p>广义的马克思主义包括继承者对它的发展，狭义上只有马克思和恩格斯创立的</p></blockquote><p><strong>马克思主义的三个基本组成部分</strong>：<font color='DarkViolet'>马克思主义哲学、马克思主义政治经济学和科学社会主义</font>【背】</p><ul><li>马克思主义哲学：世界观和方法论的基础；</li><li>马克思主义政治经济学：对资本主义的理论剖析；</li><li>科学社会主义：马克思主义的结论和归宿，是最核心的内容；</li></ul><p><strong>马克思主义基本原理</strong>：<font color='DarkViolet'>马克思主义原理是对马克思主义的立场、观点、方法的集中概括</font>【背】</p><p>马克思主义基本立场：全人类的立场；</p><p>马克思主义基本方法：实事求是、辩证分析、社会基本矛盾和主要矛盾分析、历史分析、阶级分析、群众路线；</p><p>★<strong>马克思主义产生背景</strong>：【选择】</p><ul><li><p>社会根源：资本主义经济的发展导致社会两级分化，周期性经济危机频繁爆发；</p></li><li><p>阶级基础：无产阶级在反抗资产阶级剥削和压迫的斗争中，逐渐走向自觉，并迫切渴望科学理论的指导</p></li><li><p>直接的理论来源：德国古典哲学；英国古典政治经济学；英国空想社会主义的合理成分</p><p>自然科学前提：19世纪的三大科学发现，即细胞学说，能量守恒与转化定律、生物进化论</p></li></ul><blockquote><p>1844年《德法年鉴》：完成从唯心主义向唯物主义、从革命民主主义向共产主义的转变，为创立马克思主义奠定了思想前提</p><p><font color='SeaGreenBlue'>《德意志意识形态》：首次系统阐述了历史唯物主义的基本观点</font></p><p><font color='DarkViolet'>1848年世界上第一个无产阶级政党的党纲——《共产者宣言》的发表，标志着马克思主义的公开问世</font></p></blockquote><p>★<strong>马克思主义基本特征</strong>：<font color='DarkViolet'>科学性、人民性、实践性、发展性</font>【背】<font color='DarkViolet'>科学性与革命性的统一</font></p><p>马克思主义彻底的评判精神和鲜明的无产阶级立场是其革命性的表现；</p><ul><li><p>科学性：具有科学的世界观和方法论基础，即<strong>辩证唯物主义和历史唯物主义</strong>（科学性的重要体现）</p></li><li><p>人民性**：人民性是马克思主义的本质属性**，<font color='OrangeRed'>人民至上是马克思主义的政治立场</font>；以阶级性为深刻基础</p></li><li><p>实践性：从实践中来，到实践中去，在实践中接受检验，随实践而不断发展；<font color='OrangeRed'>实践观点是马克思主义首要的和基本的观点</font></p></li><li><p>发展性：不断发展的开放的学说，<font color='SeaGreenBlue'>具有与时俱进的理论品质</font>。</p></li></ul><p><strong>马克思主义的当代价值</strong>：【背】</p><p>1、观察当代世界变化的认识工具；</p><p>2、指引当代中国发展的行动指南；</p><p>3、引领人类社会进步的科学真理。</p><p><strong>自觉学习和运用马克思主义</strong>：</p><p>1、努力学习和掌握马克思主义的基本立场、观点、方法；</p><p>2、努力学习和掌握马克思主义中国化的理论成果；</p><p>3、坚持理论联系实际的马克思主义学风；</p><p>4、自觉将马克思主义内化于心，外化于行。</p><h2 id="世界的物质性及发展规律"><a href="#世界的物质性及发展规律" class="headerlink" title="世界的物质性及发展规律"></a>世界的物质性及发展规律</h2><p>世界观：人们对世界的总的看法和根本观点</p><p>方法论：人们认识世界和改造世界的根本原则和根本方法</p><p>在马克思主义世界观和方法论中，<font color='OrangeRed'>唯物辩证法是其核心内容</font></p><p>唯物辩证法是认识世界和改造世界的根本方法</p><h3 id="第一节-世界的多样性与物质统一性"><a href="#第一节-世界的多样性与物质统一性" class="headerlink" title="第一节 世界的多样性与物质统一性"></a>第一节 世界的多样性与物质统一性</h3><h4 id="一、哲学"><a href="#一、哲学" class="headerlink" title="一、哲学"></a>一、哲学</h4><p><strong>哲学</strong>：系统化、理论化的世界观</p><p>在马克思主义哲学产生以前不曾存在唯物史观和唯心史观的斗争</p><p><strong>哲学的基本问题</strong>：<font color='DarkViolet'>存在和思维</font>的关系问题，又称<font color='DarkViolet'>物质和意识</font>的关系问题</p><p><strong>哲学基本问题的内容</strong>：：</p><p>1、<font color='OrangeRed'>物质和意识谁为本原</font>：唯物主义、唯心主义</p><p>2、<font color='OrangeRed'>物质和意识是否具有同一性</font>：可知论、不可知论</p><p>唯物主义者和彻底的唯心主义者都是可知论者；二元论者是不可知论者；</p><p>二元论是不彻底的唯心主义；</p><p><strong>哲学的重要问题</strong>：世界是怎样存在？</p><p>辩证法：世界是运动的；形而上学：世界是孤立的，静止的</p><table><thead><tr><th>辩证法</th><th>形而上学</th></tr></thead><tbody><tr><td>坚持用<font color='SeaGreenBlue'>联系的、发展的、全面的</font>观点看世界</td><td>坚持用<font color='SeaGreenBlue'>孤立的、静止的、片面的</font>观点看问题</td></tr><tr><td>认为<font color='OrangeRed'>发展的根本原因在于事物的内部矛盾</font></td><td>否认事物内部矛盾的存在和作用</td></tr><tr><td>人不能两次踏进同一条河流——承认物质是运动的<br />是辩证唯物主义</td><td>人一次也不能踏进同一条河流——否认相对静止<br />是诡辩论，是形而上学</td></tr></tbody></table><blockquote><p>唯物辩证法是认识世界和改造世界的根本方法</p></blockquote><p>唯物辩证法是客观辩证法和主观辩证法的统一</p><ul><li><p>客观辩证法：指客观事物或客观存在的辩证法；</p></li><li><p>主观辩证法：指人类认识和思维运动的辩证法</p></li></ul><p><font color='SeaGreenBlue'>关系：主观辩证法是客观辩证法在人的思维中的反映。</font></p><h4 id="二、物质与意识的辩证关系"><a href="#二、物质与意识的辩证关系" class="headerlink" title="二、物质与意识的辩证关系"></a>二、物质与意识的辩证关系</h4><p><strong>物质</strong></p><ul><li><input disabled="" type="checkbox"> 2020-2021 第一学期：简述马克思主义物质范畴及其科学意义</li><li><input disabled="" type="checkbox"> 2019-2020 第一学期：简述列宁的物质定义及其意义</li><li><input disabled="" type="checkbox"> 2019-2020 第二学期：简述马克思主义物质范畴的理论意义</li></ul><p>★<strong>列宁对物质的定义</strong>：物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，<font color='OrangeRed'>它不依赖于我们的感觉而存在</font>，为我们的感觉所复写、摄影、反映。【背】</p><blockquote><p>最重要的是红字部分，物质就是不管你愿不愿意，想还是不想，它都在那里</p><p>生产关系是物质，如果说人与人的一切关系，那就不属于物质范畴</p><p>不是物质：爱情；人与人的部分关系；</p></blockquote><p><font color='DarkViolet'>物质范畴的共同特性：客观实在性</font>【背】</p><p><strong>物质范畴的理论意义</strong>：【背】</p><p>1、坚持了唯物主义一元论，同唯心主义一元论和二元论划清了界限；</p><p>2、坚持了能动的反映论和可知论，批判了不可知论；</p><p>3、体现了唯物论和辩证法的统一，克服了形而上学唯物主义的缺陷</p><p>4、体现了唯物主义自然观与唯物主义历史观的统一，为彻底的唯物主义奠定了基础；</p><p><strong>物质的根本属性</strong>：<font color='DarkViolet'>物质的根本属性是运动</font>；绝对运动与相对静止对立统一</p><p><strong>物质运动的基本存在形式</strong>：时间和空间时间一维，空间三维</p><p><font color='OrangeRed'>物质、运动、时间、空间具有内在统一性</font></p><p><strong>物质世界的二重化</strong>：一方面，世界分化为自然界与人类社会；另一方面，世界分化为客观世界和主观世界；</p><p>从哲学上来看，元宇宙依然是人的实践活动的产物，而不是一个完全不同于现实世界的“第三世界”；</p><hr><p><strong>意识</strong></p><p>一切物质的反映特性→低等动物的刺激感应性→高等动物的感觉和感知→人类的意识  <strong>(意识是人独有的)</strong></p><p><strong>意识起源</strong>：</p><p>1、自然界长期发展的产物</p><p>2、社会历史发展的产物；</p><p>★<strong>意识的本质</strong>：意识是物质世界长期发展的产物，是人脑的机能和属性，是客观世界的主观映象；【背】</p><p>意识在内容上是客观的，在形式上是主观的，是客观内容与主观形式的统一</p><p>★<strong>物质与意识的辩证关系</strong>：【背】</p><p><font color='DarkViolet'>物质决定意识；意识对物质具有反作用；这种反作用就是意识的能动作用</font></p><ul><li><input disabled="" type="checkbox"> 2018-2019 第二学期 意识的能动作用主要表现在？</li></ul><p>★<strong>意识的能动作用表现在</strong>：【背】</p><p>1、意识具有目的性和计划性；</p><p>2、意识具有创造性；</p><p>3、意识具有指导实践改造客观世界的作用；</p><p>4、意识具有调控人的行为和生理活动的作用。</p><hr><p>★<strong>主观能动性和客观规律的辩证统一</strong></p><p>1、尊重客观规律是正确发挥主观能动性的前提。</p><p>2、只有充分发挥主观能动性才能正确认识和利用客观规律（<font color='OrangeRed'>实践是客观规律性与主观能动性统一的基础</font>）</p><p><strong>正确发挥人的主观能动性的前提和条件</strong>：【选择】</p><p>1、<font color='SeaGreenBlue'>从实际出发</font>是正确发挥主观能动性的<font color='SeaGreenBlue'>前提</font>；</p><p>2、<font color='SeaGreenBlue'>实践</font>是正确发挥主观能动性的<font color='SeaGreenBlue'>根本途径</font>；</p><p>3、正确发挥主观能动性，还要<font color='SeaGreenBlue'>依赖于一定的物质条件和物质手段</font>；</p><hr><p>人工智能是人的意识能动性的一种特殊表现，不可能取代或超越人类智能；</p><p><strong>人工智能为何不能取代或超越人类智能</strong>？</p><p>1、人工智能只是对人类理性智能的模拟和扩展，不具备情感、信念、意志等人类意识形式；</p><p>2、社会性是人的意识所固有的本质属性，而人工智能不可能真正具备人类的社会属性；</p><p>3、人类的自然语言是思维的物质外壳和意识的现实形式，而人工智能难以完全具备理解自然语言真实意义的能力；</p><p>4、人工智能能够获得人类意识中可以约化成数字信号的内容，但人脑中总有许多东西是无法被约化的。</p><h4 id="★三、世界的物质统一性"><a href="#★三、世界的物质统一性" class="headerlink" title="★三、世界的物质统一性"></a>★三、世界的物质统一性</h4><p>世界的统一性在于它的物质性，世界统一于物质，世界的物质统一性是多样性的统一</p><p><strong>世界的物质统一性原理</strong>：</p><p>1、自然界是物质的，具有客观实在性；</p><p>2、人类社会本质上是生产实践基础上形成的物质体系；</p><p>3、人的意识统一于物质</p><p>意义：<font color='OrangeRed'>世界的物质统一性原理是辩证唯物主义最基本、最核心的观点，是马克思主义的基石</font></p><blockquote><p>“世界上除了运动着的物质之外，什么都没有”——主张世界统一于物质的辩证唯物主义；</p></blockquote><h3 id="第二节-事物的普遍联系和变化发展"><a href="#第二节-事物的普遍联系和变化发展" class="headerlink" title="第二节 事物的普遍联系和变化发展"></a>第二节 事物的普遍联系和变化发展</h3><h4 id="一、联系与发展"><a href="#一、联系与发展" class="headerlink" title="一、联系与发展"></a>一、联系与发展</h4><p><font color='DarkViolet'>联系和发展的观点是唯物辩证法的总观点，集中体现了唯物辩证法的总特征</font></p><p><strong>联系</strong>：事物内部各要素之间和事物之间相互影响、制约、作用的关系</p><p><strong>联系的特点</strong>：1、客观性；2、普遍性；3、多样性；4、条件性</p><p>★<strong>发展</strong>：事物变化中前进的、上升的运动；发展的实质是新事物的产生和旧事物的灭亡；</p><p>事物发展是前进性与曲折性相统一</p><p>在事物相互联系与发展的过程中，内容与形式的关系是：内容决定形式</p><p><strong>在发展过程中，为什么新事物是不可战胜的？</strong></p><p>1、就新事物与环境的关系而言，它适应已经变化了的环境和条件；</p><p>2、就新事物与旧事物的关系而言，它是对旧事物的批判继承，是扬弃；</p><h4 id="★二、三大规律"><a href="#★二、三大规律" class="headerlink" title="★二、三大规律"></a>★二、三大规律</h4><p>★<font color='DarkViolet'>事物变化发展的一般规律：对立统一规律、量变质变规律、否定之否定规律</font></p><p><strong>其中对立统一规律是根本规律</strong></p><p><strong>（一）对立统一规律</strong></p><p>矛盾是反映事物内部和事物之间对立统关系的哲学范畴</p><p><font color='DarkViolet'>对立统一规律是是辩证唯物法的实质和核心</font>揭示了<font color='OrangeRed'>事物变化发展的源泉和动力</font></p><p>矛盾分析法是对立统一规律在方法论上的体现，在唯物辩证法的方法论体系中居于核心地位，是我们认识事物的根本方法</p><p><strong>矛盾的两种基本属性</strong>：对立和统一</p><p>矛盾的对立属性又称斗争性，矛盾的统一属性又称同一性</p><ul><li><input disabled="" type="checkbox"> “白马非马”错误在于割裂了矛盾的普遍性和特殊性的关系</li></ul><table><thead><tr><th>矛盾的同一性和斗争性</th><th>矛盾的普遍性和特殊性</th></tr></thead><tbody><tr><td>同一性：矛盾着的对立面相互依存、相互贯通的性质和趋势；</td><td>矛盾的普遍性：矛盾无处不在，矛盾无时不有。</td></tr><tr><td>斗争性：矛盾着的对立面相互排斥、相互分离的性质和趋势；</td><td>矛盾的特殊性：各个具体事物的矛盾、每个矛盾的各个方面<br />在发展的不同阶段上各有其特点</td></tr><tr><td><strong>辩证关系</strong>：<br />1、矛盾的同一性和斗争性<font color='OrangeRed'>相互联结、相辅相成</font><br />2、斗争性寓于同一性之中，同一性通过斗争性来体现</td><td><strong>辩证关系</strong>：<br />1、矛盾的普遍性即矛盾的共性，矛盾的特殊性即矛盾的个性。<br />2、任何现实存在的事物的矛盾都是共性和个性的有机统一，<br />共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性；</td></tr></tbody></table><p><strong>矛盾的同一性的作用</strong>：</p><p>1、同一性是事物存在和发展的前提。</p><p>2、同一性使矛盾双方相互吸收有利于自己的因素。</p><p>3、同一性规定着事物转化的可能和发展的趋势。</p><p><strong>矛盾的斗争性的作用</strong>：</p><p>1、矛盾双方的斗争促使双方的力量发生变化，造成双方力量发展的不平衡，为对立面转化、事物的质变创造条件。</p><p>2、矛盾双方的斗争是一种矛盾统一体向另一种矛盾统一体过渡的决定性力量。</p><p>★<strong>坚持“两点论”和“重点论”的统一</strong></p><p>两点论：不仅看对立还要看统一，不仅看主要还要看次要；</p><p>重点论：着重把握主要矛盾、矛盾的主要方面，作为出发点</p><p><strong>（二）量变质变规律</strong></p><p>揭示了事物的变化是一个渐进性与飞跃性、前进性与曲折性相统一的过程；</p><p>事物包括 质、量、度 三方面的规定性</p><p>质：一事物区别于其他事物的内在规定性；</p><p>量：事物的规模、程度、速度等可以用数量关系表示的规定性；</p><p>度：保持事物的质的稳定性的数量界限（限度、幅度、范围）</p><p>事物的量和质是统一的，量和质的统一在度中得到体现</p><ul><li><input disabled="" type="checkbox"> 质和事物的存在是直接同一的</li></ul><p><strong>量变和质变的辩证关系</strong>：</p><p>1、量变是质变的必要准备；</p><p>2、质变是量变的必然结果；</p><p>3、量变和质变是相互渗透的。</p><p><strong>方法论</strong>：①重视量的积累；②当质变来临时，要果断抓住时机，促成质变；③坚持适度原则</p><p><strong>（三）否定之否定规律</strong></p><ul><li><input disabled="" type="checkbox"> 2020-2021 第二学期 简述辩证否定观的基本内容</li></ul><p><strong>辩证否定观的基本内容</strong>：【背】</p><p>1、否定是事物的自我否定、自我发展，是事物内部矛盾运动的结果；</p><p>2、否定是事物发展的环节，是旧事物向新事物的转变和飞跃；</p><p>3、否定是新旧事物联系的环节；</p><p>4、辩证否定的实质是“扬弃”，即新事物对旧事物既批判又继承。</p><p>否定之否定规律<strong>揭示了</strong>事物发展的<font color='OrangeRed'>前进性和曲折性的统一</font>【背】</p><p>事物的发展不是直线式前进，而是螺旋式上升的</p><p>实例：失败是成功之母</p><p><strong>六大思维能力</strong>：</p><p>1、辩证；2、历史；3、系统；4、战略；5、底线；6、创新</p><h2 id="实践与认识及其发展规律"><a href="#实践与认识及其发展规律" class="headerlink" title="实践与认识及其发展规律"></a>实践与认识及其发展规律</h2><h3 id="第一节-实践与认识"><a href="#第一节-实践与认识" class="headerlink" title="第一节 实践与认识"></a>第一节 实践与认识</h3><table><thead><tr><th>马克思主义的</th><th>是</th></tr></thead><tbody><tr><td>根本特征</td><td>实践性</td></tr><tr><td>基本观点</td><td>实践的观点</td></tr><tr><td>重要内容</td><td>以实践为基础从整体把握人与自然的关系</td></tr></tbody></table><p>在《关于费尔巴哈的提纲》中系统论述了实践的观点，揭示了科学实践观的基本内容。</p><ul><li><input disabled="" type="checkbox"> 2022-2023 第一学期 马克思科学实践观创立和发展的意义</li></ul><p><strong><font color='DarkViolet'>科学实践观创立和发展的意义：</font></strong>【背】 </p><p>1、克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的理论基础；</p><p>2、建立了科学的、能动的、革命的反映论，实现了人类认识史上的变革；</p><p>3、第一次揭示了社会生活的实践本质，为唯物史观的创立奠定了科学的理论基础；</p><p>4、为人们能动地认识世界和改造世界提供了基本思想方法和工作方法。</p><h4 id="一、实践"><a href="#一、实践" class="headerlink" title="一、实践"></a>一、实践</h4><p><strong>实践的本质</strong>：实践是<font color='DarkViolet'>人类</font>能动地改造世界的社会性的<font color='OrangeRed'>物质活动</font>【背】</p><blockquote><p>实践的主体只能是人类；实践是联系物质和意识的桥梁，但实践属于物质</p></blockquote><p>实践既是使物质世界分化为自然界和人类社会的历史前提，也是使自然界和人类社会统一起来的现实基础；</p><p>★<strong>实践的特征</strong>：<font color='DarkViolet'>客观实在性、自觉能动性、社会历史性</font>【背】</p><table><thead><tr><th>客观实在性</th><th>自觉能动性</th><th>社会历史性</th></tr></thead><tbody><tr><td>把脑中的物变成现实的物</td><td>受意识的指导</td><td>不同时期的人的实践方式不同</td></tr></tbody></table><p><strong>实践的基本结构</strong>：【选】</p><p>实践的<font color='OrangeRed'>主体、客体和中介</font>是实践活动的三项基本要素，三者的有机统一构成实践的基本结构；</p><blockquote><p>实践主体：具有一定主体能力、从事现实社会实践活动的<font color='DarkViolet'>人</font>；</p><p>实践客体：实践活动所指向的对象；进入主体的认识和实践范围的客观事物</p><p>实践中介：各种形式的工具、手段及其应用、操作这些工具、手段的程序和方法；</p></blockquote><p><strong>主体和客体相互作用的关系</strong>：<font color='OrangeRed'>实践关系、认识关系和价值关系</font>，其中<font color='DarkViolet'>实践关系是最根本关系</font></p><p>实践的基本结构也是历史地变化发展的，这种变化主要表现为<font color='OrangeRed'>主体客体化与客体主体化的双向运动</font></p><p>★<strong>实践形式</strong>：【背】</p><p>实践的形式可分为三种基本类型：</p><p>1、物质生产实践；【劳动】<font color='DarkViolet'>人类最基本的实践活动</font></p><p>2、社会政治实践；【搞关系】(两会)</p><p>3、科学文化实践；【未知领域的探索】</p><blockquote><p>另外两个实践在物质生产实践基础上产生和发展，受其制约并对其产生能动的反作用</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D3/image-20230612145929592.png" alt="image-20230612145929592" style="zoom:50%;" /></blockquote><p>4、虚拟实践：主体与客体之间通过<font color='OrangeRed'>数字化中介系统</font>在虚拟空间进行的双向对象化的活动，具有<u>交互性、开放性、间接性</u>等特点。</p><ul><li><p><input disabled="" type="checkbox"> 2018-2019 第一学期 毛泽东同志说“实践的观点是辩证唯物论的认识论之第一的和基本的观点”，请谈谈对这句话的理解：</p><p>注意挑出重点词，实践与认识，也就是实践对认识的重要性</p></li><li><p><input disabled="" type="checkbox"> 2018-2019 第二学期 实践在认识活动中的决定作用有哪些？</p></li></ul><p>★<strong>实践对认识的决定作用</strong>：【背】</p><p>1、实践是认识的来源；</p><p>2、实践是认识发展的动力；</p><p>3、实践是认识的目的；</p><p>4、实践是检验认识真理性的唯一标准；</p><ul><li><input disabled="" type="checkbox"> 2019-2020 第二学期 为什么说“实践是检验真理的唯一性标准”</li></ul><p><strong>★为什么实践是检验真理的唯一标准</strong>【背】</p><p><font color='OrangeRed'>实践是检验真理的唯一标准</font>，这是由<font color='Darkviolet'>由<u>真理的本性</u>和<u>实践的特点</u>决定的</font></p><p>1、真理的本性在于主客观相符合，检验真理就是检验人的主观认识同客观实际是否相符合以及符合的程度；</p><p>2、实践具有直接现实性的特点，实践的直接现实性是它的客观实在性的具体表现</p><p>在实践检验真理的过程中，逻辑证明可以起到重要的补充作用。</p><h4 id="二、认识"><a href="#二、认识" class="headerlink" title="二、认识"></a>二、认识</h4><p>唯物主义反映论和唯心主义先验论的对立</p><p>★<strong>唯物主义认识论——认识的本质</strong>：<font color='DarkViolet'>主体在实践基础上对客体的能动反映</font>【背】</p><p><strong>旧唯物主义认识论的缺陷</strong>：</p><p>1、离开实践考察认识问题，因而不了解<font color='OrangeRed'>实践对认识的决定性作用(主要区别)</font></p><p>2、不了解认识的<font color='SeaGreenBlue'>辩证本性</font>，离开辩证法来考察认识问题</p><p><strong>近代的机械唯物主义理论基础</strong>：1、牛顿力学；2、道尔顿的原子论</p><blockquote><p>承认必然 否认偶然性 的哲学学说 机械决定论(形而上学决定论)</p></blockquote><table><thead><tr><th>古代朴素唯物主义</th><th>近代形而上学唯物主义<br />(机械唯物主义)</th><th>辩证唯物主义</th></tr></thead><tbody><tr><td>世界本原是某一种或几种具体的物质形态</td><td>把物质等同于原子</td><td>强调矛盾的普遍性和同一性<br />强调对事物的全面认识和长远眼光的考虑</td></tr><tr><td>世界是一团永恒燃烧的活火。<br />——赫拉克利特</td><td>万物的基础是原始物质，是基本元素。<br />——培根</td><td>人们首先必须吃、喝、住、穿，然后才能从事政治、科学、艺术、宗教等活动。<br />——恩格斯</td></tr><tr><td>水者，何也，万物之本也</td><td>自然界由数目无穷、性质不同的异质元素构成。<br />——狄德罗</td><td>金银不是天然的货币，但货币天然是金银 。<br />——马克思</td></tr></tbody></table><p><font color='SeaGreenBlue'>唯心主义的思想认识根源：夸大意识的能动作用</font></p><p>唯心主义的两种基本形式：</p><table><thead><tr><th>主观唯心主义</th><th>客观唯心主义</th></tr></thead><tbody><tr><td>把人的主观精神（如人的意志、感觉等）当做本原</td><td>把客观精神（如上帝、理念、绝对精神等）看作世界的主宰和本原</td></tr><tr><td>我思故我在——笛卡尔</td><td>世界是“理念”的影子——柏拉图</td></tr><tr><td>不是风动，不是幡动，仁者心动</td><td>世界的本质是独立存在的“绝对精神”——黑格尔</td></tr><tr><td></td><td>天行有常，不为尧存，不为桀亡</td></tr></tbody></table><p><strong>辩证唯物主义认识论的突出特点</strong>：</p><p>1、把实践的观点引入认识论；</p><p>2、把辩证法应用于反映论考察认识的发展过程。</p><hr><p>★<strong>认识过程</strong></p><p><strong>从实践到认识(第一次飞跃)</strong>：</p><p>感性认识和理性认识是人对客观世界的两种不同水平的反映形式，狭义上讲是认识过程的两个不同阶段</p><table><thead><tr><th></th><th>感性认识</th><th>理性认识</th></tr></thead><tbody><tr><td>定义</td><td>认识的低级阶段，通过感官对事物<font color='SeaGreenBlue'>外部形态</font>的反映</td><td>认识的高级阶段，通过思维对事物<font color='SeaGreenBlue'>内在联系</font>的反映</td></tr><tr><td>形式</td><td><font color='DarkViolet'>感觉、知觉、表象</font>三种形式(从低到高)</td><td><font color='DarkViolet'>概念、判断、推理</font>三种形式(从低到高)</td></tr><tr><td>特点</td><td><font color='DarkViolet'>具体性，直接性</font></td><td><font color='DarkViolet'>抽象性、间接性</font></td></tr><tr><td>理解</td><td><strong>感觉</strong>：视觉，听觉，触觉，整个认识过程的起始环节<br /><strong>知觉</strong>：整体的反映，将苹果的色、香、味等方面的感觉结合起来，就形成苹果的知觉<br /><strong>表象</strong>：人脑对过去的感觉和知觉的回忆，是曾经的重现</td><td><strong>概念</strong>：同类事物的概括和反映，如家庭、社会、国家、民族等<br /><strong>判断</strong>：展开的概念，对事物是否具有某种属性的判定<br /><strong>推理</strong>：判断与判断间的联系</td></tr></tbody></table><ul><li><input disabled="" type="checkbox"> 2020-2021 第二学期 简述感性认识和理性认识的辩证统一关系</li></ul><p>★<strong>感性认识和理性认识的辩证关系</strong>：【背】</p><p>1、理性认识依赖于感性认识；</p><p>2、感性认识有待于发展和深化为理性认识；</p><p>3、感性认识和理性认识相互渗透、相互包含；</p><p>感性认识和理性认识的辩证统一关系是在<font color='OrangeRed'>实践的基础</font>上形成的，也需要在实践中发展；</p><p>如果割裂两者辩证统一关系，就会走向唯理论和经验论，在实践中就会犯教条主义和验主义的错误</p><p><strong>从感性认识上升到理性认识必须具备两个基本条件</strong>：</p><p>1、投身实践，深入调查，获取十分丰富和合乎实际的感性材料（基础）；</p><p>2、经过思考的作用，运用理论思维和科学抽象，将丰富的感性材料加以处理加工，形成概念和理论的系统。</p><p><strong>从认识到实践(第二次飞跃)</strong></p><p><strong>必要想和重要性</strong>：</p><p>1、认识世界的目的是为了改造世界；</p><p>2、认识的真理性只有在实践中才能得到检验和发展。</p><p>实现由认识向实践的飞跃，需要经过一定的中介环节</p><h4 id="三、实践与认识的辩证运动及其规律"><a href="#三、实践与认识的辩证运动及其规律" class="headerlink" title="三、实践与认识的辩证运动及其规律"></a>三、实践与认识的辩证运动及其规律</h4><p>认识运动总规律：由感性认识到理性认识，又由理性认识到实践的飞跃，是实践、认识、再实践、再认识，循环往复以至无穷的辩证发展过程。</p><p>经历两次飞跃，实践与认识的运动算完成了吗？<font color='DarkViolet'>既完成了又没完成</font></p><p>1、完成了：针对具体事物的认识而言的。</p><p>2、没完成：针对实践和认识运动过程的向前推移、向前发展而言的。</p><p>在实践和认识的辩证运动中，主观必须统一于客观，认识必须统一于实践。</p><p>这种统一是认识和实践的矛盾在发展中的统一，是具体的、历史的统一。</p><h3 id="第二节-真理与价值"><a href="#第二节-真理与价值" class="headerlink" title="第二节 真理与价值"></a>第二节 真理与价值</h3><h4 id="一、真理"><a href="#一、真理" class="headerlink" title="一、真理"></a>一、真理</h4><p>定义：真理是标志主观与客观相符合的哲学范畴，是对客观事物及其规律的正确反映</p><p><font color='DarkViolet'>真理的特性：客观性、绝对性和相对性</font></p><p>★<strong>真理的客观性</strong>：真理的内容是对客观事物及其规律的正确反映，真理中包含着不依赖于人和人的意识的客观内容</p><p>真理的客观性决定了真理的一元性，真理是内容上的一元性与形式上的多样性的统一</p><blockquote><p>真理的一元性指在同一条件下对于特定的认识客体的真理性认识只有一个，而不可能有多个。认识是多元的，但真理是一元的。</p></blockquote><p><strong>真理的绝对性</strong>：是指真理主客观统一的确定性和发展的无限性；</p><p><strong>真理的相对性</strong>：是指人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的、不完善的。</p><p>★<strong>真理的绝对性和相对性的辩证关系</strong>：【背】</p><p>1、二者相互依存，又是相互包含的；</p><p>2、任何真理性的认识都是由真理的相对性向绝对性转化过程中的一个环节；</p><p>3、真理的绝对性和相对性根源于人类认识世界能力的无限性与有限性、绝对性与相对性的矛盾；</p><p>4、割裂真理的二者的辩证关系，就会走向形而上学的真理观，即绝对主义与相对主义；</p><p><strong>★真理与谬误的对立统一关系</strong>【背】</p><p>1、真理与谬误相互对立；</p><p>2、真理与谬误的对立是相对的，在一定条件下能相互转化；</p><p>3、真理与谬误的对立统一表明，真理总是同谬误相比较而存在、相斗争而发展的。</p><p><strong>★为什么实践是检验真理的唯一标准</strong>【背】</p><p><font color='OrangeRed'>实践是检验真理的唯一标准</font>，这是由<font color='Darkviolet'>由真理的本性和实践的特点决定的</font></p><p>1、真理的本性在于主客观相符合，检验真理就是检验人的主观认识同客观实际是否相符合以及符合的程度；</p><p>2、实践具有直接现实性的特点，实践的直接现实性是它的客观实在性的具体表现</p><p>在实践检验真理的过程中，逻辑证明可以起到重要的补充作用。</p><p><strong>实践标准的确定性与不确定性</strong></p><p>确定性：实践标准的确定性即绝对性，是指实践作为检验真理标准的唯一性。实践标准的确定性和绝对性由其客观性和唯一性决定。</p><p>不确定性：实践标准的不确定性即相对性，是指实践作为检验真理标准的条件性。</p><h4 id="二、价值"><a href="#二、价值" class="headerlink" title="二、价值"></a>二、价值</h4><p><strong>定义</strong>：价值是反映主体和客体之间意义关系的哲学范畴，是客体对个人、群体乃至整个社会的生活和活动所具有的意义；【价值即意义】</p><p><strong>★价值的基本特性</strong>：<font color='DarkViolet'>主体性、客观性、多维性、社会历史性</font></p><blockquote><p>主体性：指价值直接与主体相联系，始终以主体为中心；</p><p>客观性：客体对于主体的意义不依赖于主体的主观意识而存在；</p><p>多维性：同一客体对于主体的不同需求产生不同的价值，比如钻石对主体来说有审美价值、经济价值、科学研究价值等等</p><p>社会历史性：随着历史发展客体价值判断发生变化，比如石油、核能等等</p></blockquote><p><strong>价值评价</strong>：是主体对客体的价值以及价值大小所作的评判或判断</p><p><strong>价值评价的特点</strong>：</p><p>1、评价以主客体之间的价值关系为认识对象；</p><p>2、评价结果与评价主体直接相关；【评价结果受到主体意志的影响】</p><p>3、评价结果的正确与否依赖于对客体状况和主体需要的认识；</p><p>4、价值评价有科学与非科学之别；</p><p>价值评价要以真理为根据，要有利于人类主体的生存与发展，与社会历史发展的客观规律相一致，推动社会历史进步，以最广大人们的需要和利益为根本。</p><p><strong>价值观与核心价值观</strong></p><p><strong>价值观</strong>：是人们关于价值本质的认识以及对人和事物的评价标准、评价原则和评价方法的观点的体系。它与世界观和人生观是一致的。</p><p><strong>核心价值观</strong>：对民族与国家来说，最持久、最深层的力量是全社会共同认可的核心价值观。</p><h4 id="★三、真理与价值的辩证统一"><a href="#★三、真理与价值的辩证统一" class="headerlink" title="★三、真理与价值的辩证统一"></a>★三、真理与价值的辩证统一</h4><p>1、二者是紧密联系、不可分割的辩证统一关系</p><p>2、价值尺度必须以真理为前提；</p><p>3、人类自身需要的内在尺度，推动着人们不断发现新真理。</p><p>4、真理尺度与价值尺度的统一必须通过实践来验证。</p><h3 id="第三节-认识世界和改造世界"><a href="#第三节-认识世界和改造世界" class="headerlink" title="第三节 认识世界和改造世界"></a>第三节 认识世界和改造世界</h3><p>认识世界和改造世界的根本方法——<font color='OrangeRed'>唯物辩证法</font></p><p><strong>认识世界</strong>：主体能动地反映客体，探索和掌握真理；</p><p><strong>改造世界</strong>：改变事物的现存形式，创造自己的理想世界和生活方式。</p><p><strong>认识世界和改造世界的辩证关系</strong>：【背】</p><p>认识世界和改造世界是相互依赖、相互制约的辩证统一关系</p><p>1、认识世界有助于改造世界，正确认识世界是有效改造世界的必要前提；</p><p>2、只有在实践中才能不断深化、拓展对世界的正确认识。</p><p>二者统一的基础是实践；</p><p><strong>客观世界</strong>：物质的，可以感知的世界；</p><p><strong>主观世界</strong>：人的意识，观念世界；</p><p>主观和客观的矛盾是人类认识和实践活动中的基本矛盾，也是人类认识世界和改造世界的根本动力</p><p><strong>改造客观世界和改造主观世界的辩证关系</strong></p><p>改造客观世界和改造主观世界是辩证统一的关系</p><p>1、只有在改造客观世界的实践中才能深入改造主观世界；</p><p>2、只有认真改造主观世界，才能更好地改造客观世界；</p><p>3、二者相辅相成，相互促进，缺一不可；</p><p><strong>一切从实际出发，实事求是</strong></p><p>1、一切从实际出发是马克思主义认识论的根本要求</p><p>2、实事求是是中国共产党思想路线的核心</p><p>3、在当代中国，一切从实际出发，就是一切要从中国特色社会主义进入了新时代这个我国发展新的历史方位出发</p><p>4、解放思想与实事求是是辩证统一的</p><p><strong>实现理论创新和实践创新的良性互动</strong></p><p>1、实践创新为理论创新提供不竭的动力源泉；</p><p>2、理论创新为实践创新提供科学的行动指南；</p><p>3、努力实现理论创新与实践创新的良性互动；</p><h2 id="人类社会及其发展规律"><a href="#人类社会及其发展规律" class="headerlink" title="人类社会及其发展规律"></a>人类社会及其发展规律</h2><p>人类历史是一部生产劳动发展史</p><h3 id="第一节-人类社会的存在与发展"><a href="#第一节-人类社会的存在与发展" class="headerlink" title="第一节 人类社会的存在与发展"></a>第一节 人类社会的存在与发展</h3><h4 id="一、社会存在与社会意识"><a href="#一、社会存在与社会意识" class="headerlink" title="一、社会存在与社会意识"></a>一、社会存在与社会意识</h4><p><strong>社会存在与社会意识的关系问题是社会历史观的基本问题</strong></p><p>在马克思主义产生之前，唯心史观一直占据统治地位；唯心主义只看到个人在历史上的作用，忽略了人民群众创造历史的决定作用</p><p>唯心史观：社会意识具有第一性；</p><p>唯物史观：社会存在具有第一性；</p><p><strong>社会存在</strong>：社会生活的物质方面，主要包括<font color='DarkViolet'>自然地理环境、人口因素、物质生产方式</font></p><blockquote><p>自然地理环境是人类社会生存和发展永恒的、必要的条件，是人们生活和生产的自然基础</p><p>人口因素是重要的社会物质生活条件，对社会发展具有影响和制约作用</p><p>物质生产方式是社会存在和发展的基础及决定力量 生产力+生产关系 </p><p>物质生产方式起决定作用</p></blockquote><p><strong>社会意识</strong>：社会意识是社会存在的反映，是社会生活的精神方面。</p><ul><li>根据不同主体分：个人意识，群体意识；</li><li>根据不同层次分：社会心理，社会意识形式；</li></ul><table><thead><tr><th>社会心理</th><th>社会意识形式</th></tr></thead><tbody><tr><td>低层次的社会意识<br /><font color='OrangeRed'>以感性认识为主</font>(情绪，情感，习俗)</td><td>高层次的社会意识<br /><font color='OrangeRed'>以理性认识为主</font>(政治法律思想、道德、艺术、宗教、科学等)</td></tr></tbody></table><p>社会意识形式分为：意识形态、非意识形态；</p><table><thead><tr><th>意识形态</th><th>非意识形态</th></tr></thead><tbody><tr><td>政治法律思想、道德、艺术、宗教、哲学等等<br /><font color='SeaGreenBlue'>反映一定阶级或社会集团利益</font></td><td><font color='OrangeRed'>自然科学</font>和语言学、形式逻辑等；<br /><font color='SeaGreenBlue'>不服务于特定阶级</font></td></tr></tbody></table><p>★<strong>社会存在与社会意识的辩证关系</strong>【背】</p><p>1、社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在</p><p>2、社会意识是具体的、历史的，它依赖于社会存在，又有其相对独立性</p><blockquote><p>社会意识的能动作用是通过指导人们的实践活动实现的</p><p><font color='DarkViolet'>社会实践的主体是人民群众</font></p></blockquote><p><strong>社会意识具有相对独立性表现在</strong>：</p><p>1、社会意识和社会存在的发展具有不完全同步性和不平衡性。</p><p>2、社会意识的内部各种形式之间存在相互影响且各自具有历史继承性。</p><p>3、<font color='SeaGreenBlue'>社会意识对社会存在具有能动的反作用，这是社会意识相对独立性的突出表现。</font></p><h4 id="★二、社会基本矛盾及其运动规律"><a href="#★二、社会基本矛盾及其运动规律" class="headerlink" title="★二、社会基本矛盾及其运动规律"></a>★二、社会基本矛盾及其运动规律</h4><p><strong>社会基本矛盾</strong>：生产力与生产关系、经济基础与上层建筑之间的矛盾</p><p><strong>人类社会发展的基本规律</strong>：生产力与生产关系矛盾运动的规律、经济基础与上层建筑矛盾运动的规律。</p><hr><p><strong>生产力与生产关系</strong></p><p><strong>生产力的基本要素</strong>：<font color='DarkViolet'>劳动资料、劳动对象、劳动者</font></p><p><strong>科学技术是生产力的重要因素</strong>，是先进生产力的集中体现和主要标志，是第一生产力</p><p>【选】</p><blockquote><p>劳动资料：也称劳动手段，运用的物资资料或物质条件，其中最重要的是<strong>生产工具</strong>；</p><p>劳动对象：一切自然物质都是可能的劳动对象，是现实生产的必要前提；</p><p>劳动者：能够运用一定劳动资料作用于劳动对象，从事生产实践活动的人，是生产力中最活跃的因素；</p></blockquote><p><strong>生产关系</strong>：人们在物质生产过程中形成的不以人的意志为转移的<font color='DarkViolet'>经济关系</font></p><p>包括<font color='DarkViolet'>生产资料所有制关系</font>（最基本的关系）、生产中人与人的关系和产品分配关系；</p><p>依据生产资料所有制的性质，生产关系分为两种基本类型：</p><p>1、以生产资料公有制为基础的生产关系；</p><p>2、生产资料私有制为基础的生产关系。</p><p>★<strong>生产力与生产关系的辩证关系</strong>：</p><p>1、生产力决定生产关系；</p><p>2、生产关系对生产力具有能动的反作用。</p><p>3、生产力与生产关系的相互作用是一个过程，表现为二者的矛盾运动；</p><p>4、生产关系一定要适合生产力状况的规律是社会形态发展的普遍规律。</p><hr><p><strong>经济基础与上层建筑</strong></p><p><strong>经济基础</strong>：社会一定发展阶段的生产力所决定的生产关系的总和。</p><blockquote><p>1、决定一个社会性质的是其中占支配地位的生产关系；</p><p>2、经济基础与经济体制具有内在联系</p></blockquote><p><strong>上层建筑</strong>：建立在一定经济基础之上的<font color='OrangeRed'>意识形态</font>以及与之相适应的制度、组织和设施。</p><p>上层建筑由两部分构成：<font color='DarkViolet'>意识形态(观念上层建筑)以及政治法律制度及设施和政治组织(政治上层建筑)</font>；【背】</p><p>★<font color='OrangeRed'>在整个上层建筑中，政治上层建筑居主导地位，国家政权是核心</font></p><p><strong>国家的实质</strong>：是社会发展到一定阶段的产物，是一个阶级统治另一个阶级的工具</p><p>依据国家性质和政权组织形式，将国家分为两方面：<font color='DarkViolet'>国体、政体</font>；</p><p><strong>国体</strong>：是指社会各阶级在国家中的地位，表明<u>国家政权掌握在哪个阶级手里</u>；</p><p><strong>政体</strong>：是指统治阶级实现其阶级统治的<u>具体组织形式</u>，<u>即政权构成形式</u>。</p><p>我国的国体是人民民主专政，政体是人民代表大会制度；</p><p><strong>二者关系</strong>：</p><p>国体决定政体，政体服从于国体；政体为国体服务，并对保证国家性质起重要作用；</p><p>但同一国体也可能采取不同的政体，不同国体也可能采取同一政体。</p><p>★<strong>经济基础与上层建筑的辩证关系</strong>：【背】</p><p>1、经济基础决定上层建筑；</p><p>2、上层建筑对经济基础具有反作用；</p><p>3、经济基础与上层建筑的相互作用构成二者的矛盾运动；</p><p>4、经济基础和上层建筑之间的内在联系构成了上层建筑一定要适合经济基础状况的规律。</p><p>世界历史的基本特征：普遍交往；</p><h4 id="三、社会形态"><a href="#三、社会形态" class="headerlink" title="三、社会形态"></a>三、社会形态</h4><p>社会形态是同生产力发展一定阶段相适应的经济基础与上层建筑的统一体</p><p>社会形态包括<font color='OrangeRed'>社会的经济形态【基础】</font>、政治形态、意识形态，是三者具体的、历史的统一。</p><blockquote><p>一定的社会形态总要以一定的社会制度形式呈现，社会制度能集中体现社会形态的性质，所以人们在日常生活中往往用社会制度来指代社会形态</p></blockquote><p><strong>社会形态更替的统一性和多样性</strong></p><p>统一性：原始社会、奴隶社会、封建社会、资本主义社会、共产主义社会五种社会形态的依次更替</p><p>多样性：发展历程情况复杂，更替跳跃或反复。</p><p>社会形态更替的统一性和多样性，根源于社会发展的必然性与人们的历史选择性相统一的过程。</p><p><strong>社会形态更替的必然性与选择性</strong></p><p>必然性：主要是指社会形态依次更替的过程和规律是客观的，其发展的基本趋势是确定不移的</p><p>历史选择性：规律的客观性并不否定人们历史活动的能动性</p><p><strong>人们的历史选择性包含三层意思</strong>：</p><p>1、社会发展的必然性造成了一定历史阶段社会发展的基本趋势，为人们的历史选择提供了基础、范围和可能性空间；</p><p>2、社会形态更替的过程也是一个主观能动性与客观规律性相统一的过程；</p><p>3、人们的历史选择性归根结底是人民群众的选择性。【人民史观】</p><p><strong>社会形态更替的前进性与曲折性</strong>：</p><p>前进性：五种社会形态依次演进的基本趋势</p><p>曲折性：社会形态更替的反复、跨越甚至倒退现象</p><h3 id="★第二节-社会历史发展的动力"><a href="#★第二节-社会历史发展的动力" class="headerlink" title="★第二节 社会历史发展的动力"></a>★第二节 社会历史发展的动力</h3><ul><li><input disabled="" type="checkbox"> 人类历史发展的决定因素是生产方式；</li></ul><p><strong>社会基本矛盾</strong></p><p><font color='DarkViolet'>生产力与生产关系、经济基础与上层建筑的矛盾 </font>【背】</p><p><font color='OrangeRed'>生产力与生产关系的矛盾是更为基本的矛盾</font></p><p>★<strong>社会基本矛盾在历史发展中的作用</strong>：【背】</p><p>1、生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量</p><p>2、生产力是社会进步的根本内容，是衡量社会进步的根本尺度</p><p>3、社会基本矛盾特别是生产力与生产关系的矛盾，决定着社会中其他矛盾的存在和发展</p><p>4、社会基本矛盾具有不同的表现形式和解决方式，并从根本上影响和促进社会形态的变化和发展。</p><hr><p><strong>社会主要矛盾</strong>：社会主要矛盾是处于支配地位，在社会发展过程一定阶段上起主导作用的矛盾</p><p>社会历史发展的决定性力量是社会主要矛盾</p><p>★<strong>社会主要矛盾在历史发展中的作用</strong>：【背】</p><p>1、社会主要矛盾的存在和发展，规定或影响着社会非主要矛盾的存在和发展；</p><p>2、社会主要矛盾和非主要矛盾相互作用，在一定条件下相互转化。</p><p><font color='OrangeRed'>十八大以来我国社会主要矛盾：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾</font></p><hr><p><strong>阶级斗争</strong></p><p>阶级斗争根源于不同阶级在经济利益</p><p>无产阶级专政，最终阶级消亡；</p><p><strong>阶级斗争的作用</strong>：</p><p>1、阶级斗争是社会基本矛盾在阶级社会中的表现；</p><p>2、<font color='DarkViolet'>阶级斗争是阶级社会发展的直接动力</font>；</p><p>3、阶级斗争对阶级社会发展的推动作用突出表现在社会形态的更替中；</p><blockquote><p>阶级斗争及其作用受到一定社会历史条件的制约</p></blockquote><hr><p><strong>社会革命</strong></p><p>广义的社会革命是指在社会基本矛盾运动基础上的社会生活的全面变革；</p><p>狭义的社会革命主要是指社会形态的变更，即新的社会形态取代旧的社会形态</p><p><strong>社会革命爆发的根本原因</strong>：生产力的发展和旧的生产关系，经济基础的发展和旧的上层建筑之间出现矛盾冲突</p><p><strong>社会革命的实质</strong>：革命阶级推翻反动阶级的统治，用新的社会制度代替旧的社会制度，解放生产力，推动社会发展</p><p>★<strong>社会革命的作用</strong>：【背】</p><p>1、社会革命是实现社会形态更替的重要手段和决定性环节；</p><p>2、社会革命能充分发挥人民群众创造历史的积极性和伟大作用；</p><p>3、革命斗争还能够极大地教育和锻炼包括革命阶级在内的广大人民群众；</p><p>马克思主义不拒绝改良，但反对改良主义</p><hr><p><strong>改革</strong>：改革是同一种社会形态发展过程中的量变和部分质变，是推动社会发展的又一重要动力</p><p><strong>改革的重要作用</strong>：改革是解决社会基本矛盾、促进生产力发展、推动社会进步的有效途径和手段。</p><p>改革适用于解决现存的社会体制存在的问题，在不改变社会基本制度的前提下，对生产关系和上层建筑的某些环节进行变革，从而促进生产力发展和社会的进步</p><hr><p>★<strong>科学技术</strong></p><p>科技革命是推动经济和社会发展的强大杠杆；</p><ul><li><input disabled="" type="checkbox"> 2018-2019 第一学期 马克思认为科学技术是“历史有力的杠杆”，是“最高意义上的革命力量”，请论述科技在社会发展中的作用</li></ul><p><strong>科技革命的作用</strong>：</p><p>每一次的科技革命都不同程度地引起了生产方式、生活方式和思维方式的深刻变化和社会的巨大进步；</p><p>1、对生产方式产生了深刻影响</p><p>改变了社会生产力的构成要素；改变了人们的劳动形式；改变了社会经济结构；</p><p>2、对生活方式产生了巨大影响</p><p>劳动生产率的提高，为人的自由而全面的发展创造了更多条件；</p><p>3、促进了思维方式的变革</p><p>新的科学理论和技术手段通过影响思维主体、思维客体和思维工具，引起了思维方式的变革</p><h3 id="第三节-人民群众在历史发展中的作用"><a href="#第三节-人民群众在历史发展中的作用" class="headerlink" title="第三节 人民群众在历史发展中的作用"></a>第三节 人民群众在历史发展中的作用</h3><p><strong>唯物史观与唯心史观的对立，在历史创造者问题上表现为群众史观与英雄史观的对立；</strong></p><p><strong>两种历史观</strong>：</p><p>1、英雄史观：</p><p>内容：抹杀人民群众的历史作用，宣扬少数英雄人物创造历史</p><p>产生根源：认识根源、社会历史根源、阶级根源</p><p>2、群众史观：</p><p>内容：群众史观认为历史的创造者是人民群众</p><p><strong>唯物史观在考察历史创造者的原则</strong>：【背】</p><p>1、立足于现实的人及其本质；</p><p>2、立足于整体的社会历史过程；</p><p>3、从社会历史发展的必然性；</p><p>4、从人与历史关系的不同层次；</p><p>人与历史的三层关系：人类与历史、群体与历史、个体与历史</p><p><strong>人民群众</strong></p><p>人民群众是一个历史范畴</p><p>1、人民群众从质上指一切对社会历史发展起推动作用的人；</p><p>2、从量上说是社会人口的绝大多数；</p><p>3、最稳定的主体部分始终是从事物质资料生产的劳动群众；</p><p><strong><font color='DarkViolet'>人民群众在创造历史过程中的决定作用：</font></strong>【背】 (考题)</p><p>在社会历史发展过程中，人民群众起着决定性的作用。人民群众是历史的主体，是历史的创造者。</p><p>1、人民群众是社会物质财富的创造者；</p><p>2、人民群众是社会精神财富的创造者；</p><p>3、人民群众是社会变革的决定力量；</p><p>4、人民群众既是先进生产力和先进文化的创造主体，也是实现自身利益的根本力量。</p><ul><li><input disabled="" type="checkbox"> 2019-2020 第一学期 简述无产阶级政党的群众观点和群众路线及其现实意义</li></ul><p><strong>群众观点</strong>：</p><p>1、坚信人民群众自己解放自己的观点；</p><p>2、全心全意为人民服务的观点；</p><p>3、一切向人民群众负责的观点；</p><p>4、虚心向人民群众学习的观点；</p><p><strong>群众路线</strong>：一切为了群众，一切依靠群众，从群众中来，到群众中去</p><p><strong>意义</strong>：群众路线是我们党的生命线和根本工作路线，是我党不断取得胜利的<font color='OrangeRed'>重要法宝</font></p><hr><p><strong>个人在社会历史中的作用</strong></p><p><strong>普通人物</strong>：属于人民群众范畴，对社会发展有或大或小的贡献，其总和构成了人民群众创造历史的活动</p><p>历史人物：</p><p>1、历史人物是指一定历史事件的主要倡导者、组织领导者或思想理论、科学文化的重要代表人物；</p><p>2、杰出人物是历史人物中对推动历史社会发展做出重要贡献的人；</p><p>3、不管什么样的历史人物，在历史上发挥什么样的作用，都要受到社会发展客观规律的制约，而不能决定和改变历史发展的总进程和总方向</p><p>评价历史人物时应该坚持历史分析方法和阶级分析方法</p><h2 id="资本主义的本质及规律"><a href="#资本主义的本质及规律" class="headerlink" title="资本主义的本质及规律"></a>资本主义的本质及规律</h2><h3 id="第一节-商品经济和价值规律"><a href="#第一节-商品经济和价值规律" class="headerlink" title="第一节 商品经济和价值规律"></a>第一节 商品经济和价值规律</h3><h4 id="一、商品经济的形成和发展"><a href="#一、商品经济的形成和发展" class="headerlink" title="一、商品经济的形成和发展"></a>一、商品经济的形成和发展</h4><p><strong>政治经济学</strong></p><table><thead><tr><th>简单商品经济(资本主义以前)</th><th>资本主义商品经济</th></tr></thead><tbody><tr><td>生产资料私有制和个体劳动为基础</td><td>生产资料私有制和雇佣关系为基础<br />是商品经济的高级或发达形态</td></tr></tbody></table><p><strong>商品经济产生的历史条件</strong>：</p><p>自然经济：即自给自足经济，指生产的目的是直接满足生产者个人或经济单位的需要而不是交换的经济形式；</p><p>商品经济：是以交换为目的而进行生产的经济形式，是一定<font color='OrangeRed'>社会历史条件</font>下的产物</p><p><font color='DarkViolet'>私人劳动与社会劳动的矛盾是商品经济的基本矛盾</font></p><p>原因：</p><p>1、私人劳动与社会劳动的矛盾决定着商品经济的本质及发展过程；</p><p>商品经济的本质(目的)：交换</p><p>2、私人劳动与社会劳动的矛盾是商品经济其他一切矛盾的基础；</p><p>使用价值能否还原为价值，取决于具体劳动能否还原为抽象劳动，取决于私人劳动与社会劳动是否实现统一</p><p>3、私人劳动与社会劳动的矛盾决定着商品生产者的命运。</p><p>在资本主义制度下，该基本矛盾进一步发展为资本主义的基本矛盾，即生产社会化和生产资料资本主义私人占有之间的矛盾。</p><hr><p><strong>商品</strong>：商品是用来交换、能满足人的某种需要的劳动产品</p><ul><li><input disabled="" type="checkbox"> 以下均不是说商品：原始森林中的树木；农民<font color='SeaGreenBlue'>自给自足</font>种的小白菜(注意字眼)；垃圾场里准备销毁的垃圾</li></ul><p>★<strong>商品二因素</strong>：包括<font color='DarkViolet'>使用价值和价值</font>【背】 (考题) <font color='DarkViolet'>【劳动的二重性决定了商品的二因素】</font></p><p>商品是使用价值和价值的矛盾统一体；<font color='SeaGreenBlue'>商品的本质属性是价值</font> (考题)</p><table><thead><tr><th></th><th>使用价值(<font color='OrangeRed'>商品的自然属性</font>)</th><th>价值(<font color='OrangeRed'>商品的社会属性</font>)</th><th>交换价值</th></tr></thead><tbody><tr><td>含义</td><td>使用价值是商品能满足人的某种需要的有用性</td><td>价值是凝结在商品中的无差别的一般人类劳动<br />即人的脑力和体力的耗费</td><td>一种使用价值同另一种使用价值相交换的关系或比例</td></tr><tr><td></td><td>使用价值构成社会财富的物质内容<br /><font color='DarkViolet'>使用价值是价值的物质承担着</font></td><td><font color='DarkViolet'>任何有用物都有使用价值，但只有其作为商品时才具有价值</font></td><td><font color='DarkViolet'>价值是交换价值的基础，交换价值是价值的表现形式</font></td></tr></tbody></table><ul><li><input disabled="" type="checkbox"> 2022-2023 第一学期 商品的价值和使用价值的含义与对立统一关系</li></ul><p><strong>商品的使用价值和价值的关系</strong>：<font color='DarkViolet'>对立统一</font>【背】 </p><ul><li><strong>对立性</strong>：商品的使用价值和价值相互排斥，<font color='DarkViolet'>二者不可兼得</font>；只能获得使用价值和价值的一个；</li><li><strong>统一性</strong>：作为商品，必须同时具有使用价值和价值两个因素</li></ul><hr><p>商品是劳动产品，生产商品的劳动具有二重性</p><ul><li><input disabled="" type="checkbox"> 2020-2021 第一学期：简述劳动的二重性及其相互关系</li></ul><p>★<strong>劳动二重性</strong>：包括<font color='DarkViolet'>具体劳动、抽象劳动</font></p><p>劳动二重性理论是马克思在劳动价值理论上的贡献</p><ul><li><strong>具体劳动</strong>：具体劳动是指生产一定使用价值的具体形式的劳动<font color='OrangeRed'>（具体劳动创造商品的使用价值）</font></li><li><strong>抽象劳动</strong>：抽象劳动是指撇开一切具体形式的、无差别的一般人类劳动，即人的脑力和体力的耗费<font color='OrangeRed'>（抽象劳动形成商品的价值）</font></li></ul><blockquote><p>区别具体劳动和抽象劳动：<a href="https://www.zhihu.com/question/26372092">具体劳动和抽象劳动怎样区分，请举例说明? - 知乎 (zhihu.com)</a></p></blockquote><p><strong>具体劳动与抽象劳动的对立统一关系</strong>：</p><p>1、统一性：在时间和空间上是统一的，是商品生产者的同一劳动中不可分割的两个方面；</p><p>2、对立性：具体劳动反映人与自然的关系，是劳动的自然属性；抽象劳动反映商品生产者的社会关系，是劳动的社会属性；反映了劳动的不同属性；</p><hr><p><strong>商品价值量的决定</strong></p><table><thead><tr><th>质的规定【价值实体是什么】</th><th>量的规定【价值大小怎么决定】</th></tr></thead><tbody><tr><td>凝结在商品中的无差别的一般人类劳动（抽象劳动）</td><td>由<font color='DarkViolet'>社会必要劳动时间</font>决定</td></tr></tbody></table><p><strong>影响劳动生产率的因素</strong>：</p><p>劳动者的平均熟练程度、科学技术的发展水平及其在生产中的应用程度、生产过程的社会结合、生产资料的规模和效能、自然条件等。</p><p><strong>价值形式</strong>【选】</p><p>作为商品交换的媒介，货币是种特殊的商品</p><p>货币的职能：价值尺度、流通手段、贮藏手段、支付手段、世界货币等；</p><p>最基本职能：<font color='OrangeRed'>价值尺度、流通手段</font></p><p>执行流通手段可以不足值，因此可以使用纸币，但纸币不能实行价值尺度</p><table><thead><tr><th>价值尺度</th><th>流通手段</th><th>支付手段</th><th>贮藏手段</th><th>世界货币</th></tr></thead><tbody><tr><td>价格标签，一件上衣&#x3D;100元</td><td>货币充当商品交换的媒介<br />一件衣服是100元，用100元钱买了这件衣服</td><td>租金、工资、税收；<br />无实物交易</td><td>必须是真金白银<br />纸币不具备贮藏手段的职能</td><td>在国际市场上发挥一般等价物作用的货币<br />一般也是真金白银，但美元也有</td></tr></tbody></table><h4 id="★二、价值规律"><a href="#★二、价值规律" class="headerlink" title="★二、价值规律"></a>★二、价值规律</h4><ul><li><input disabled="" type="checkbox"> 2019-2020 第一学期 简述价值规律的内容及其作用</li></ul><p><strong>价值规律的含义</strong>：价值规律是商品生产和交换的<u><font color='DarkViolet'>基本规律</font></u></p><p><strong>价值规律的内容</strong>：<font color='OrangeRed'>商品的价值量由生产商品的社会必要劳动时间决定</font>，商品交换以价值量为基础，按照等价交换的原则进行。</p><blockquote><p>价格虽然是商品价值量的指数，是商品同货币交换比例的指数，但不能反过来说商品同货币交换比例的指数是商品价值量的指数；</p><p>因为商品的价值量是由必要劳动时间决定</p></blockquote><p><strong>价值规律的表现形式</strong>：商品的价格围绕商品的价值自发波动。</p><p><strong>价值规律的作用</strong>：</p><table><thead><tr><th>积极</th><th>消极</th></tr></thead><tbody><tr><td>自发地调节生产资料和劳动力的分配比例</td><td>导致社会资源浪费【调整失调】</td></tr><tr><td>自发地促进社会生产力的发展【优胜劣汰】</td><td>阻碍技术进步【技术保密】</td></tr><tr><td>自发地调节社会收入的分配</td><td>导致收入两极分化</td></tr></tbody></table><p><strong>马克思劳动价值理论的实践意义</strong>：</p><p>1、扬弃了英国古典政治经济学的观点，为剩余价值论的创立奠定了基础；</p><p>2、揭示了私有制条件下商品经济的基本矛盾，为从物与物的关系背后揭示人与人的关系提供了理论依据。</p><p>3、揭示了商品经济的一般规律，对理解社会主义市场经济具有指导意义；</p><h3 id="第二节-资本主义经济制度"><a href="#第二节-资本主义经济制度" class="headerlink" title="第二节 资本主义经济制度"></a>第二节 资本主义经济制度</h3><p><strong>资本主义生产关系产生的途径</strong>：</p><p>1、从小商品经济分化出来；</p><p>2、从商人和高利贷者转化而来。</p><p><strong>资本原始积累的含义</strong>：【选】</p><p>生产者与生产资料相分离，资本迅速集中于少数人手中，资本主义得以迅速发展的历史过程。</p><p>★<strong>资本原始积累的途径</strong>：</p><p>1、用暴力手段剥夺农民的土地【基础】</p><p>2、用暴力手段掠夺货币财富(殖民掠夺)【重要方式】</p><p>资本总公式：G—W—G’W为商品，G为货币，表面资本运动的一般目的是价值增殖；</p><blockquote><p>资本首先表现为一定量的货币，但货币本身并不就是资本；</p><p>一旦货币购买的劳动力带来剩余价值，货币也就变成了资本。</p></blockquote><p><strong>★劳动力成为商品的基本条件</strong>：</p><p>1、劳动者在法律上是自由人，能把自己的劳动力当作商品来支配；</p><p>2、劳动者没有任何生产资料，没有生活资料来源，因而不得不出卖劳动力。</p><ul><li><input disabled="" type="checkbox"> 2018-2019 第二学期 简述劳动力商品的特点有哪些？</li></ul><p>劳动商品的特点包括劳动力的价值和使用价值；</p><ul><li><input disabled="" type="checkbox"> 2020-2021 第二学期 劳动力商品的价值是由哪些因素决定的？</li></ul><p>★<strong>劳动力商品的价值</strong>：【背】</p><p>劳动力商品的价值，是由生产、发展、维持和延续劳动力所必需的生活必需品的价值决定的，主要包括：</p><ol><li><p>维持劳动者本人生存所必需的生活资料的价值；</p></li><li><p>维持劳动者家属的生存所必需的生活资料的价值；</p></li><li><p>劳动者接受教育和训练所支出的费用；</p></li></ol><p><strong>★劳动力商品使用价值的特点</strong>：</p><p>劳动力商品的使用价值是价值的源泉，在消费过程中能够创造新的价值，且这个新的价值比劳动力本身的价值更大。</p><p><font color='DarkViolet'>资本主义生产过程是劳动过程和价值增殖过程的统一</font></p><p><strong>价值增殖过程</strong>：价值增殖过程是剩余价值的生产过程，是资本主义生产过程的主要方面。</p><p>在此过程中，雇佣工人的劳动分为<font color='OrangeRed'>必要劳动</font>和<font color='OrangeRed'>剩余劳动</font>两部分；体现剥削关系</p><p>雇佣劳动者的剩余劳动是剩余价值的唯一源泉 <font color='DarkViolet'>剩余价值【m表示】</font></p><p>★<strong>剩余价值生产</strong></p><p>两种基本方式：<font color='DarkViolet'>1、绝对剩余价值的生产；2、相对剩余价值的生产</font></p><table><thead><tr><th></th><th>绝对剩余价值</th><th>相对剩余价值</th><th>超额剩余价值</th></tr></thead><tbody><tr><td>条件</td><td><font color='DarkViolet'>必要劳动时间不变的条件下</font></td><td><font color='DarkViolet'>工作日长度不变的条件下</font></td><td></td></tr><tr><td>方式</td><td>延长工作日的长度<br />提高劳动强度</td><td>缩短必要劳动时间 (相对延长剩余劳动时间)</td><td>企业提高劳动生产率<br />使商品的个别价值低于社会价值</td></tr></tbody></table><p><strong>缩短必要劳动时间</strong>：是通过全社会劳动生产率的提高实现的。【改进技术和管理模式】</p><p>超额剩余价值是由其他企业工人创造的</p><p>各个资本家追求超额剩余价值，导致劳动生产率普遍提高，从而导致必要劳动时间减短，整个资本家阶级普遍获得更多的相对剩余价值；</p><p><strong><font color='DarkViolet'>★剩余价值理论的意义</font></strong></p><p>1、是马克思主义经济学说的核心内容和基石，是无产阶级反对资产阶级、揭示资本主义剥削本质的锐利武器；</p><p>2、<font color='DarkViolet'>由于唯物史观和剩余价值理论的发现，社会主义由空想变为科学</font>；</p><p>3、揭示了商品经济和社会化生产的一般规律，在社会主义市场经济中发挥作用。</p><h4 id="资本"><a href="#资本" class="headerlink" title="资本"></a>资本</h4><p>资本是能够带来剩余价值的价值总资本T &#x3D; c+v</p><p>★<strong>分类</strong>：</p><p><strong>不变资本c</strong>：以生产资料形态存在的资本，不发生增殖。</p><p><strong>可变资本v</strong>：购买劳动力的那部分资本，将创造新价值。</p><p><strong>资本主义商品的价值构成</strong>：W&#x3D;c+v+m；</p><p><strong>资本积累</strong>：<font color='DarkViolet'>剩余价值</font>的资本化</p><ul><li><p>资本主义简单再生产：资本家获得剩余价值后，将其用于个人消费，则生产在原有规模的基础上重复进行</p></li><li><p>资本主义扩大再生产：剩余价值不完全用于个人消费，将一部分转化为资本，用以购买追加的生产资料和劳动力，使生产在扩大的规模上重复进行</p></li></ul><p><strong>资本积累规模的影响因素</strong>：资本家对工人的剥削程度；劳动生产率的高低；所用资本和所费资本之间的差额；资本家预付资本的大小</p><p>资本积累不但是社会财富占有两级分化的重要原因，而且是资本主义社会失业现象产生的根源；</p><p><strong>资本的有机构成</strong> &#x3D; <font color='DarkViolet'>c&#x2F;v (不变资本&#x2F;可变资本)</font></p><p>有机构成的增加导致可变资本的相对减少，资本对劳动力的需求相对下降，形成相对过剩人口</p><p><strong>相对过剩人口基本有三种形式</strong>：</p><p>1、流动的过剩人口；</p><p>2、潜在的过剩人口；</p><p>3、停滞的过剩人口。</p><p><strong>(产业)资本循环三个阶段</strong>：</p><p>1、购买阶段；【资本执行货币资本的职能】</p><p>2、生产阶段；【资本执行生产资本的职能】</p><p>3、售卖阶段；【资本执行商品资本的职能】</p><p><strong>资本循环的特点</strong>：</p><p>1、产业资本的循环是生产过程和流通过程的统一；</p><p>2、资本循环的三个阶段是相互承接、互相依赖的；</p><p>3、货币资本、生产资本和商品资本是产业资本循环过程中依次采取的三种职能形式，而不是三种独立的资本；</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D3/image-20230608101112380.png" alt="image-20230608101112380" style="zoom:50%;" /><p><strong>影响资本周转快慢的关键因素</strong>：</p><p>1、资本周转时间；</p><p>2、生产资本的固定资本和流动资本的构成</p><p>要加快资本周转速度，获得更多剩余价值，就要缩短资本周转时间，加快流动资本的周转速度</p><p><strong>社会再生产的核心问题</strong>：<font color='SeaGreenBlue'>社会总产品的实现问题</font>，即社会总产品的价值补偿和实物补偿问题</p><p>社会总产品在价值形态上又叫社会总价值，就是社会在一定时期（通常为一年)所生产的全部物质资料的总和，包括c，v，m</p><p>社会生产可以分为两大部类，第一部类由生产生产资料的部门构成；第二部类由生产消费资料的部门构成</p><p>★<strong>资本主义工资的本质</strong>：劳动力的价值或价格</p><p>形式：计时工资、计件工资。</p><p><strong>资本主义基本矛盾</strong>：<font color='DarkViolet'>生产社会化和生产资料资本主义私人占有之间的矛盾</font>。【少数人与多数人】</p><p><strong>经济危机的本质特征</strong>：<font color='DarkViolet'>生产过剩</font></p><p>★这种过剩是相对过剩，即相对于劳动人民有支付能力的需求，而不是与劳动人民的实际需求相比的绝对过剩</p><p>经济危机爆发的根本原因是资本主义的基本矛盾</p><p>社会资本再生产的周期一般包括四阶段：<font color='DarkViolet'>危机、萧条、复苏、高涨</font></p><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><ol><li><p>资本有机构成&#x3D;不变资本&#x2F;可变资本(c：v)</p></li><li><p>剩余价值率m’&#x3D;剩余价值m&#x2F;可变资本v&#x3D;剩余劳动时间 &#x2F; 必要劳动时间    </p><p>反映资本家剥削的程度  </p></li><li><p>商品价值&#x3D;不变资本+可变资本+剩余价值(W&#x3D;c+v+m)</p><p>c：固定成本包括产房设备，原材料    v：劳动力</p><p>新创造的价值&#x3D;v+m</p></li><li><p>生产价格 &#x3D; 生产成本+平均利润 &#x3D; 不变资本c+可变资本v+平均利润；</p></li><li><p>利润率p’ &#x3D; 剩余价值 &#x2F; 全部预付资本(<font color='Darkviolet'>p’ &#x3D; m&#x2F;(c+v)</font>)</p><p>反映预付总资本的增殖程度，掩盖了剥削</p></li><li><p>平均利润率 &#x3D; 剩余价值总量 &#x2F; 社会总资本</p><p>利润转化为平均利润是剩余价值规律和竞争规律作用的必然结果；</p><p>利润转化为平均利润，价值也就转化为生产价格</p></li></ol><p>比如生产效率提高了一倍，则超额剩余价值为$W_超&#x3D;W’’-W’&#x3D;2W-W-(c’-c)$</p><p>社会资本简单再生产必须具备的基本条件：第一部类的可变资本和剩余价值之和必须同第二部类的不变资本相等I (v+m)&#x3D;Ⅱ c</p><p><strong>预付资本总周转速度</strong> &#x3D; (一年内固定资本周转总值 + 一年内流动资本周转总值) &#x2F; 预付资本总值</p><p><strong>年剩余价值量</strong> M &#x3D; m·n &#x3D; m’·v·n</p><p>M：年剩余价值量；M’：年剩余价值率；m：剩余价值量；m’：剩余价值率；n：周转次数；</p><p>M’ &#x3D; M&#x2F;v &#x3D; m’·n</p><hr><p>资本主义国家的职能：以服务于资本主义制度和资产阶级利益为根本内容，包括对内对外两个基本方面，</p><ul><li><p>对内实行政治统治和社会管</p></li><li><p>对外进行国际交往和维护国家安全及利益；</p></li></ul><p>资本主义国家的本质：资产阶级进行政治统治的工具</p><p>资本主义民主制度的本质：资本主义政治制度本质上是资产阶级进行政治统治和社会管理的手段和方式，是为资产阶级专政服务的。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路分析</title>
      <link href="/posts/393785646.html"/>
      <url>/posts/393785646.html</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/电分.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>激光技术及原理</title>
      <link href="/posts/2719265211.html"/>
      <url>/posts/2719265211.html</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/激光.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理光学</title>
      <link href="/posts/2697141058.html"/>
      <url>/posts/2697141058.html</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/物理光学.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>固体半导体物理</title>
      <link href="/posts/2884708491.html"/>
      <url>/posts/2884708491.html</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/固体半导体物理.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛概重点</title>
      <link href="/posts/2268057516.html"/>
      <url>/posts/2268057516.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>适用于2022年被推迟到2023年的毛概考试</p><p>平时成绩50期末50 单选30多选10五个简答40材料20</p><p>考试内容以邓小平部分为主</p></blockquote><h2 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h2><p>五个简答：</p><p>1.如何理解群众路线 </p><p>2.什么是实事求是，怎样坚持 </p><p>3.为什么邓小平理论是科学指南 </p><p>4.一国两制核心观点意义 </p><p>5.怎样坚持以人为本</p><p>材料题：</p><p>1.结合材料，社会主义本质观的科学内涵</p><p>2.我国是第二大经济体，但为什么是长期都处于社会主义初级阶段</p><p>3.结合实际，谈谈为什么解决所有问题要靠自身发展</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>毛泽东思想形成的历史条件和发展过程<br>毛泽东革命军队建设和军事战略理论<br>毛泽东党的建设理论<br>毛泽东思想活的灵魂</p><p>近代中国革命的时代特征<br>新民主主义革命的总路线，动力，性质，时代特征<br>新民主主义的基本纲领，政治经济文化<br>新民主主义革命的三大法宝及内容</p><p>新民主主义社会为什么是过渡型社会<br>农业的改造，资本主义工商业的社会主义改造<br>社会主义基本制度的确立及其重大意义</p><p>毛泽东调动一切积极因素为社会主义服务的思想<br>毛泽东正确认识社会主义矛盾的思想<br>毛泽东走中国工业化道路思想<br>党在社会主义探索及其理论意义和现实意义</p><p>邓小平理论的形成条件<br>邓小平理论的形成过程<br>邓小平理论回答的基本问题<br>邓小平理论的主要内容<br>邓小平理论的历史地位</p><p>三个代表重要思想的核心观点及主要内容</p><p>科学发展观的科学内涵，第一要义等<br>历史地位<br>同邓小平理论，三个代表重要思想的关系</p><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p><font color='DarkViolet'>1938年党的第六届六中全会，毛泽东在《论新阶段》的报告中，正式提出“马克思主义中国化”这一命题</font></p><p><strong>马克思主义中国化的科学内涵：</strong></p><ol><li>坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，运用马克思主义的立场、观点、方法研究和解决中国革命、建设、改革中的实际问题；</li><li>总结和提炼中国革命、建设、改革的实践经验，从而认识和掌握客观规律，为马克思主义理论宝库增添新的内容；</li><li>运用中国人民的民族语言来阐述马克思主义理论，使之成为具有中国特色、中国风格、中国气派的马克思主义。</li></ol><p>马克思主义之所以能够中国化的原因在于：马克思主义理论的内在要求；马克思主义与中华民族优秀文化具有相融性；中国革命建设和改革的实践需要马克思主义的指导；</p><p><strong>马克思主义中国化的理论成果：</strong></p><p>毛泽东思想、[邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想]（中国特色社会主义理论体系）</p><p>实事求是作为党的思想路线，始终是马克思主义中国化理论成果的精髓和灵魂</p><p>两大理论成果的关系：①二者虽然形成的时期不同，面临的问题和情况也不同，但二者的基本精神是一致的，都坚持实事求是、群众路线和独立自主。②二者都是马克思主义与中国实际相结合的理论成果，与马克思列宁主义一起，是党长期紧持的指导思想和全国各族人民团结奋斗的共同思想基础。</p><p><u>2018年，十一届全国人大一次</u>会议通过的宪法修正案把马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想共同确认为国家指导思想；</p><h2 id="毛泽东思想及其历史地位"><a href="#毛泽东思想及其历史地位" class="headerlink" title="毛泽东思想及其历史地位"></a>毛泽东思想及其历史地位</h2><p><strong>两个凡是</strong>：凡是毛主席做出的决策，我们都坚决拥护；凡是毛主席的指示，我们都始终不渝地遵循</p><p>毛泽东指出，解决中国一切革命问题最基本的依据是<u>认清中国社会的特殊国情</u></p><p><strong>毛泽东思想形成和发展的社会历史条件：</strong></p><p>①1917年俄国十月革命的胜利开辟了世界无产阶级社会主义革命的新时代</p><p>②中国在革命取得胜利后，又经历了第二次世界大战后两大阵营的对立和斗争，西方国家不仅对我国实行持续的封锁禁运，还极力推行和平演变战略。</p><p>实践基础：<u>中国共产党领导的革命和建设实践</u>；</p><p><strong>毛泽东思想的形成</strong>：</p><p>第一次国内革命战争时期：以马克思列宁主义为指导，在<font color='OrangeRed'>《中国社会各阶级的分析》《湖南农民运动考察报告》</font>等著作中，提出了<u>新民主主义革命的基本思想</u></p><p>土地革命战争时期：在<font color='OrangeRed'>《中国的红色政权为什么能够存在?》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》</font>等著作中，提出并阐述了<u><font color='DarkViolet'>农村包围城市、武装夺取政权的思想</font></u>，标志着<u><font color='DarkViolet'>毛泽东思想的初步形成</font></u></p><p>《反对本本主义》是中国共产党第一篇反对教条主义的重要文献；</p><p><strong>毛泽东思想的成熟：</strong></p><p>遵义会议：确立了毛泽东在党中央和红军的领导地位</p><p>《实践论》《矛盾论》中运用了马克思主义的认识法和辩证法，系统分析了党内“左”和“右”的错误思想根源</p><p>《〈共产党人〉发刊词》《中国革命和中国共产党》《新民主主义论》《论联合政府》提出了新民主主义革命的总路线，指明了新民主主义革命的具体目标</p><blockquote><p>《〈共产党人〉发刊词》中系统阐述中国革命的三大法宝</p></blockquote><p>遵义会议以后，毛泽东<font color='DarkViolet'><u>对新民主主义革命理论的系统阐述</u></font>，实现了马克思主义与中国革命实践相结合的历史性飞跃，<u><font color='DarkViolet'>标志着毛泽东思想趋于成熟</font></u></p><p><u>1945年中共七大</u>将毛泽东思想写入党章，确立为党必须长期坚持的指导思想</p><blockquote><p>“主观主义”的问题的文献：《古田会议决议》</p></blockquote><p><strong>毛泽东思想的继续发展：</strong></p><p><font color='OrangeRed'>《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》《论十大关系》《关于正确处理人民内部矛盾的问题》</font></p><p>毛泽东首次明确提出加强执政党自身建设：中共七届二中全会</p><p><strong>毛泽东思想的主要内容：</strong></p><ul><li><p>新民主主义革命理论</p><p><u>无产阶级领导的，工农联盟为基础的，人民大众的，反对帝国主义、封建主义和官僚资本主义的新民主主义革命理论</u></p><p>开创出一条以农村包围城市、最后夺取全国胜利的革命道路</p><p><strong>中国革命只能以长期的武装斗争作为主要形式；</strong></p><p>毛泽东指出，<font color='DarkViolet'>统一战线、武装斗争和党的建设</font>，是中国共产党在中国革命中战胜敌人的<font color='OrangeRed'>三大法宝</font>。</p></li><li><p>社会主义革命和社会主义建设理论</p></li><li><p>革命军队建设和军事战略理论</p></li><li><p>政策和策略理论</p></li><li><p>思想政治工作和文化工作理论</p></li><li><p>党的建设理论</p></li></ul><p><strong>毛泽东思想活的灵魂</strong>：有三个基本方面，即<font color='DarkViolet'>实事求是、群众路线、独立自主</font></p><p>实事求是：</p><blockquote><p>内涵：实事求是，就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理</p><p>要求：</p><p>①坚持实事求是，要深入了解事物的本来面貌，把握事物内在必然联系，按照客观规律办事</p><p>②坚持实事求是，要清醒认识和正确把握我国基本国情</p><p>③坚持实事求是，要不断推进实践基础上的理论创新</p></blockquote><p>群众路线：</p><blockquote><p>内涵：群众路线，就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动</p><p>要求：</p><p>①坚持群众路线，要坚持人民是推动历史发展的根本力量。</p><p>②坚持群众路线，要坚持全心全意为人民服务的根本宗旨。</p><p>③坚持群众路线，要保持党同人民群众的血肉联系。</p></blockquote><p>独立自主：</p><blockquote><p>内涵：独立自主，就是坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权，开展国际经济文化交流，学习外国一切对我们有益的先进事物</p><p>要求：</p><p>①坚持独立自主，要坚持中国的事情必须由中国人民自己处理。</p><p>②坚持独立自主，要坚持独立自主的和平外交政策，坚定不移走和平发展道路。</p></blockquote><p><strong>毛泽东思想的历史地位：</strong></p><p>①毛泽东思想是马克思主义中国化的第一个重大理论成果；</p><p>②毛泽东思想是中国革命和建设的科学指南；</p><p>③毛泽东思想是中国共产党和中国人民宝贵的精神财富。</p><h2 id="新民主主义革命理论"><a href="#新民主主义革命理论" class="headerlink" title="新民主主义革命理论"></a>新民主主义革命理论</h2><p>近代中国国情：<font color='OrangeRed'>中国逐渐沦为半殖民地半封建社会，这是近代中国最基本的国情</font></p><p>沦为半殖民地半封建社会的根本原因是帝国主义的侵略；</p><p>诸多矛盾中占据支配地位是帝国主义和中华民族的矛盾, 封建主义和人民大众的矛盾, 但<u><font color='DarkViolet'>帝国主义与中华民族的矛盾</font></u>是诸多矛盾中最重要的</p><p><strong>中国革命要分两步走：</strong></p><p>第一步是完成反帝反封建的新民主主义革命任务，第二步是完成社会主义革命任务，这是性质不同但又相互联系的两个革命过程；</p><p>中国革命分两步走是指民主革命和社会主义革命</p><p><strong>工农武装割据思想：</strong></p><p><u>土地革命</u>是新民主主义革命的<u>主要内容</u>，<u>武装斗争</u>是新民主主义革命的<u>主要形式</u>，<u>革命根据地建设</u>是新民主主义革命的<u>重要依托</u>，三者的有机统一构成了工农武装割据思想；</p><table><thead><tr><th>新民主主义革命</th><th>内容</th></tr></thead><tbody><tr><td>革命理论</td><td>无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命</td></tr><tr><td>对象</td><td>帝国主义，封建主义，官僚资本主义（三座大山）</td></tr><tr><td>不同历史阶段中国革命的对象</td><td>国共合作的大革命时期：帝国主义支持下的北洋军阀<br />土地革命战争时期：国民党新军阀<br />抗日战争时期：日本帝国主义<br />解放战争时期：美帝国主义支持下的国民党反动派</td></tr><tr><td>动力</td><td>无产阶级、农民阶级、城市小资产阶级和民族资产阶级</td></tr><tr><td>领导力量</td><td>无产阶级及其政党充当领导者（区别新旧民主主义革命的根本标志）</td></tr><tr><td>性质</td><td>不是无产阶级社会主义革命，仍然是<u><font color='OrangeRed'>资产阶级民主革命</font></u><br />由近代中国半殖民地半封建社会的性质和中国革命的历史任务决定</td></tr><tr><td>前途</td><td>社会主义</td></tr><tr><td>总路线</td><td>中国革命的对象、动力、领导力量，是新民主主义革命的指导路线</td></tr><tr><td>三大法宝</td><td><font color='darkviolet'>统一战线、武装斗争和党的建设</font></td></tr><tr><td></td><td><strong>三大基本纲领</strong></td></tr><tr><td>政治纲领</td><td>推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义共和国<br />国体——各革命阶级联合专政；政体——民主集中制的人民代表大会制度</td></tr><tr><td>经济纲领</td><td>没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业<br />[ 没收官僚资产阶级的垄断资本归新民主主义的国家所有 <font color='OrangeRed'>具有新民主主义革命和社会主义革命双重性质</font> ]</td></tr><tr><td>文化纲领</td><td>新民主主义文化是<font color='darkviolet'>民族的、科学的、大众的</font>文化</td></tr></tbody></table><p>中国革命走农村包围城市，武装夺取政权的道路是由中国所处的时代特点和具体国情决定的；</p><p><strong>加强自身建设取得的经验</strong>：</p><p><u>统一战线：</u></p><p>①建立巩固的工农联盟；</p><p>②正确对待资产阶级，尤其是民族资产阶级；</p><p>③采取区别对待的方针；</p><p>④坚持独立自主的原则。</p><p><u>武装斗争：</u></p><p>①坚持党对军队的绝对领导；</p><p>②建设全心全意为人民服务的人民军队；</p><p>③坚持正确的战略战术原则。</p><p><u>党的建设：</u></p><p>①必须把思想建设始终放在党的建设的首位；</p><p>②必须在任何时候都重视党的组织建设；</p><p>③必须重视党的作风建设；</p><blockquote><p>逐步形成了<font color='OrangeRed'>理论联系实际、密切联系群众、批评与自我批评相结合的三大优良作风</font>，这是中国共产党区别于其他任何政党的显著标志。</p></blockquote><p>④必须联系党的政治路线加强党的建设。</p><p>人民军队建设的最根本原则是党指挥枪的原则；</p><p><strong>三者关系：</strong></p><p>统一战线和武装斗争是中国革命的两个基本特点，是战胜敌人的两个基本武器；统一战线是实行武装斗争的统一战线，武装斗争是统一战线的中心支柱；党的建设则是掌握统一战线和武装斗争这两个武器以实行对敌冲锋陷阵的英勇战士；</p><p><strong>新民主主义新在哪</strong>：</p><p>①新民主主义革命的领导力量是中国无产阶级及其先锋队；（根本标志）</p><p>②指导思想是马克思列宁主义；</p><p>③革命的前途是社会主义而非资本主义；</p><p>④新民主主义革命与社会主义革命性质不同，仍是资产阶级民主主义革命；</p><p><strong>与社会主义革命的区别和联系</strong>：</p><p>区别：新民主主义革命与社会主义革命性质不同；</p><p>联系：新民主主义革命与社会主义革命也是互相联系、紧密衔接的，中间不容横插一个资产阶级专政。</p><h2 id="社会主义改造"><a href="#社会主义改造" class="headerlink" title="社会主义改造"></a>社会主义改造</h2><p><strong>社会主义的根本任务</strong>：发展生产力</p><p><strong>怎么理解新民主主义社会是一个过渡性社会</strong></p><p>(1)新民主主义社会有五种经济成分，但主要是三种：<font color='OrangeRed'>社会主义经济、个体经济和资本主义经济</font></p><p>(2)与三种经济成分相联系的有三种基本阶级力量：<font color='OrangeRed'>工人阶级、农民阶级和其他小资产阶级、民族资产阶级等基本的阶级力量</font></p><p>(3)随着土地改革的基本完成，<font color='OrangeRed'>工人阶级和资产阶级的矛盾逐步成为国内的主要矛盾</font>。而解决这一矛盾，必然使中国社会实现向社会主义的转变</p><blockquote><p>三大改造后我国国内的主要矛盾是：<u><font color='DarkViolet'>人民日益增长的物质文化生活需要同落后的社会生产之间的矛盾</font></u></p><p>我国社会的主要矛盾将<u><font color='OrangeRed'>长期是生产力落后</font></u></p><p>我国大规模的有计划的社会主义建设开始的标志是“一五”计划的制定和实施；</p><p>土地革命中对富农的政策是保存富农经济；</p></blockquote><p>(4)新民主主义社会是属于社会主义体系的，社会主义因素已在经济、政治上都已居于领导地位，但非社会主义因素的比重还很大，所以还不完全属于社会主义社会，必须在适当的时候过渡到社会主义社会。</p><p><strong>党在过渡时期总路线的主要内容</strong>：</p><p>“一化”：即**<u>社会主义工业化</u>**。</p><p>“三改”：即对<u><strong>个体农业、手工业和资本主义工商业</strong></u>的社会主义改造</p><p>“一化”是“一体”，“三改”是“两翼”；关系：两者相互联系、不可分离、相辅相成、相互促进</p><p>党提出过渡时期总路线的物质基础是：<u>相对强大的国营经济的建立</u></p><p><strong>如何评价党在过渡时期的总路线：</strong></p><p>这是一条社会主义建设和社会主义改造同时并举的路线，体现了社会主义工业化和社会主义改造的紧密结合，体现了解放生产力发展生产力、变革生产关系与发展生产力的有机统一；</p><p><strong>党在过渡时期总路线的理论依据：</strong></p><p>①马克思、恩格斯在创立科学社会主义理论时，就提出了从资本主义社会向社会主义社会过渡的问题。</p><p>②列宁在指导俄国无产阶级革命和世界被压迫民族解放斗争中，进一步发展了马克思、恩格斯的革命转变思想。</p><p><strong>农业的社会主义改造：</strong></p><p>①积极引导农民组织起来，走互助合作道路；</p><p>②遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路；</p><p>③正确分析农村的阶级和阶层状况，制定正确的阶级政策；</p><p>④坚持积极领导、稳步前进的方针，采取循序渐进的步骤。</p><p><strong>手工业的社会主义改造</strong></p><p>①采取积极领导、稳步前进的方针。</p><p>②在方法步骤上，从供销合作入手，逐步发展到走生产合作的道路</p><p><strong>资本主义工商业的社会主义改造：</strong></p><p>①用和平赎买的方法改造资本主义工商业；</p><p>②<font color='OrangeRed'>采取低级到高级的国家资本主义的过渡形式</font>；</p><p>③把资本主义工商业者改造成为自食其力的社会主义劳动者；</p><p><strong>采取低级到高级的国家资本主义的过渡形式的三阶段</strong>：</p><p>①主要实行初级形式的国家资本主义；</p><p>②主要实行个别企业的公私合营；</p><p>③<font color='DarkViolet'>实行全行业的公私合营</font>（我国对资本主义工商业进行社会主义改造的基本标志）</p><p><strong>社会主义改造过程中的失误和偏差：</strong></p><p>改造要求过急，工作过粗，改变过快，形式也过于简单划一</p><p>原因：①指导思想上急于求成、不够谨慎；②工作方法上过于简单；③受当时历史条件限制而产生一些认识上的问题：</p><p>a．在社会主义经济模式的选择和理解上过于单一，追求单一的社会主义经济成分；</p><p>b．在公有制实现形式的选择和理解上过于简单化，只注意到集体所有制和全民所有制这两种基本形式，而对社会主义改造基本完成以后公有制经济可以和非公有制经济共同发展缺乏认识。</p><p>c．当时党对我国社会主义发展阶段问题还没有形成科学的理论，对什么是社会主义还没有完全搞清楚，致使一些遗留问题长期没有得到解决</p><p><strong>社会主义基本制度的确立：</strong></p><p>1956年底，我国对<font color='OrangeRed'>农业、手工业和资本主义工商业</font>的社会主义改造基本完成，我国社会经济结构发生了根本变化，社会主义经济成分已占绝对优势，<font color='DarkViolet'>社会主义公有制已成为我国社会的经济基础</font>，标志着中国历史上长达数千年的阶级剥削制度的结束，<font color='OrangeRed'>社会主义基本制度在我国初步确立</font></p><p>☆<strong>确立社会主义基本制度的重大意义:</strong>  </p><p>(1)社会主义基本制度的建立，是中国历史上最深刻最伟大的社会变革，为当代中国一切发展进步奠定了制度基础，为中国特色社会主义制度的创新和发展提供了重要前提；</p><p>(2)社会主义基本制度的确立，极大地提高了工人阶级和广大劳动人民的积极性、创造性，&#x3D;&#x3D;极大地促进了我国社会生产力的发展&#x3D;&#x3D;；</p><p>(3)社会主义基本制度的建立，进一步改变了世界政治经济格局，增强了社会主义的力量，对维护世界和平产生了积极影响；</p><p>(4)社会主义基本制度的确立，再次证明了马克思主义的真理性，丰富和发展了马克思主义的科学社会主义理论</p><h2 id="社会主义建设道路初步探索的理论成果"><a href="#社会主义建设道路初步探索的理论成果" class="headerlink" title="社会主义建设道路初步探索的理论成果"></a>社会主义建设道路初步探索的理论成果</h2><p>毛泽东探索中国社会主义建设道路第一个标志性的重要理论成果是《论十大关系》（1956年）</p><p><strong>《论十大关系》报告的意义</strong></p><p>①这是党探索中国特色社会主义建设道路的<u><font color='OrangeRed'>良好开端</font></u>；</p><p>②初步总结了我国社会主义建设的经验；</p><p>③明确提出了以苏为鉴，独立自主地探索适合中国的社会主义建设道路；</p><p><strong>初步探索中取得的重要理论成果</strong>：</p><p>①调动一切积极因素为社会主义事业服务；</p><blockquote><p>原则：必须坚持中国共产党的领导；必须发展社会主义民主政治；有一个如何<u>认识社会主义发展阶段和社会主义建设规律</u>的问题  </p></blockquote><p>②正确认识和处理社会主义社会矛盾的思想；</p><blockquote><p>关于正确处理人民内部矛盾的方针，用民主的方法解决人民内部矛盾，这是一个总方针</p><p>科学文化领域：百花齐放，百家争鸣；共产党和民主党派：长期共存，互相监督；民族之间：民族平等、团结互助；</p></blockquote><p>③走中国工业化道路的思想；</p><blockquote><p>中华人民共和国的成立，为我国实现工业化提供了根本的政治前提；</p></blockquote><p><strong>正确处理社会主义社会矛盾的思想</strong></p><p>① 在社会主义社会中，<font color='OrangeRed'>基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾</font>。它不是对抗性的矛盾，而是非对抗性的矛盾。</p><p>② 具有＂又相适应又相矛盾＂的特点，一方面社会主义生产关系已经建立起来，它是和生产力的发展相适应的；另一方面它还很不完善，这些不完善的方面和生产力的发展又是相矛盾的。  </p><p><strong>走中国工业化道路的思想：</strong></p><p>① 以工业为主导，<font color='OrangeRed'>重工业是我国经济建设的重点</font>，逐步建立独立的比较完整的基础工业体系和国防工业体系，这是维护国家独立、统一和安全，实现国家富强所必需的。但同时必须充分注意发展农业和轻工业。</p><p>② 以农业为基础，以工业为主导，以<strong>农轻重</strong>为序发展国民经济的总方针，以及一整套“两条腿走路”的工业化发展思路，即重工业和轻工业同时并举，中央工业和地方工业同时并举，沿海工业和内地工业同时并举。</p><p>③中国工业化道路最重要的问题是处理好重工业和轻工业、农业的关系；</p><p><strong>走中国工业化道路的要求</strong>：</p><p>a.   必须明确战略目标和战略步骤；</p><p>b．必须采取正确的经济建设方针；</p><p>c．必须发展科学技术和文化教育；</p><p>d．必须重视知识分子工作；</p><p>e．必须调整和完善所有制结构；</p><p>f．必须积极探索适合我国情况的经济体制和运行机制。</p><p><strong>初步探索的意义：</strong>  </p><p>（1）巩固和发展了我国的社会主义制度；</p><p>（2）为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础；</p><p>（3）丰富了科学社会主义的理论和实践；</p><p>☆<strong>社会主义初步探索的经验教训</strong>：</p><p>（1）必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。  </p><p>（2）必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。</p><p>（3）必须从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成。  </p><p>（4）必须发展社会主义民主，健全社会主义法制。  </p><p>（5）必须坚持党的民主集中制和集体领导制度，加强执政党建设。  </p><p>（6）必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。  </p><h2 id="邓小平理论"><a href="#邓小平理论" class="headerlink" title="邓小平理论"></a>邓小平理论</h2><p>邓小平理论集中反映中国共产党对于中国社会主义建设规律认识；</p><p><strong>邓小平理论形成的历史条件：</strong></p><p>（1）和平与发展成为时代主题是邓小平理论形成的时代背景  </p><p>（2）社会主义建设的经验教训是邓小平理论形成的历史根据  </p><p>（3）改革开放和现代化建设的实践是邓小平理论形成的现实依据  </p><p>决定当代中国命运的关键抉择是<u>改革开放</u>；</p><p><strong>形成过程：</strong></p><p><u>1978年十一届三中全会</u>，重新确立<strong>解放思想、实事求是的思想路线</strong>，停止使用“以阶级斗争为纲”的错误提法，确定把全党工作的着重点转移到社会主义现代化建设上来，作出实行改革开放的重大决策，实现了党的历史上具有深远意义的伟大转折</p><p><u>1982年党的十二大</u>，邓小平首次提出“建设有中国特色的社会主义”。</p><blockquote><p>党的十二大到党的十三大是邓小平理论逐步展开并形成轮廓的阶段</p></blockquote><p><u>1984年十二届三中全会</u>提出了社会主义经济是在公有制基础上的有计划的商品经济；</p><p><u>1987年党的十三大</u>，第一次比较系统地论述了我国<u>社会主义初级阶段理论</u>，明确概括和全面阐述了一个中心、两个基本点的基本路线；</p><blockquote><p>一个中心，指以经济建设为中心；两个基本点，指坚持四项基本原则，坚持改革开放</p><p>四项基本原则：坚持社会主义道路；坚持人民民主专政；坚持中国共产党的领导；坚持马克思列宁主义、毛泽东思想。</p></blockquote><p><u>1992年南方谈话</u>，标志着邓小平理论逐步走向成熟；<u>1992年党的十四大</u>标志邓小平理论<u>走向成熟并形成理论体系</u>；</p><p><u>1997年党的十五大</u>正式提出“邓小平理论”这一概念，深刻阐述了邓小平理论的历史地位和指导意义，进一步论述了邓小平对这一理论的创立作出的独创性贡献。</p><p>十五大把邓小平理论同马克思列宁主义、毛泽东思想一起，确立为党的指导思想并写入党章；</p><p><u>1999年九届全国人大二次会议</u>正式把邓小平理论作为国家指导思想写入宪法；</p><p><strong>邓小平理论回答的基本问题：</strong></p><ul><li><p>回答的基本问题：</p><p><strong>什么是社会主义、怎样建设社会主义</strong>是邓小平在领导改革开放和现代化建设这一新的革命过程中，不断提出和反复思考的首要基本理论问题；搞清楚<strong>什么是社会主义、怎样建设社会主义</strong>，关键是要在坚持社会主义基本制度的基础上进一步认清社会主义的本质。</p></li><li><p>社会主义的本质：</p><p>1992年，邓小平在南方谈话中对社会主义本质作了总结性理论概括：<strong>社会主义的本质是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕</strong>。</p></li><li><p>社会主义本质科学概括的意义</p><p>既包括了社会主义社会的生产力问题，又包括了以社会主义生产关系为基础的社会关系问题，是一个有机的整体。</p></li></ul><p><strong>邓小平理论主要内容：</strong></p><ul><li><p>解放思想，实事求是的思想路线（灵魂和精髓）</p></li><li><p>社会主义初级阶段理论</p></li><li><p>党的基本路线</p><p><strong>党在社会主义初级阶段基本路线：</strong></p><p><font color='DarkViolet'>领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强民主文明的社会主义现代化国家而奋斗。</font></p><blockquote><p>党的十七大加入“和谐”，党的十九大加入“美丽”，将现代化国家改为现代化强国；</p></blockquote><p>这条基本路线可以简单概括为<font color='OrangeRed'>“一个中心、两个基本点”</font></p><p>四项基本原则：必须坚持社会主义道路；必须坚持人民民主专政；必须坚持共产党的领导；必须坚持马克思列宁主义、毛泽东思想</p><p>要求：①必须紧紧围绕经济建设这一中心；②必须把坚持四项基本原则同坚持改革开放结合起来，正常处理两者的关系</p></li><li><p>社会主义根本任务的理论</p><p>根本任务是发展生产力，科学技术是第一生产力</p></li><li><p>“三步走”战略</p><p>第一步：从1981年到1990年实现国民生产总值比1980年翻一番，解决人民的温饱问题；</p><p>第二步：从1991年到20世纪末，使国民生产总值再翻一番，人民生活达到小康水平；</p><p>第三步：到21世纪中叶，人均国民生产值达到中等发达国家水平，基本实现现代化；</p><p>共同富裕的思想，要承认不平衡，同时从不平衡逐步达到相对的平衡，逐步实现共同富裕；</p></li><li><p>改革开放理论</p><p>社会主义社会的基本矛盾依然是生产关系和生产力、上层建筑和经济基础之间的矛盾。</p><p>改革开放以来取得一切成绩和进步的根本原因是<font color='OrangeRed'><u>开辟了中国特色社会主义道路，形成了中国特色社会主义理论体系</u></font>；</p><p>改革开放<font color='OrangeRed'><u>通过对原有经济体制进行根本性变革来完善和发展社会主义制度</u></font>；</p><p>我国实现对外开放的立足点是<u>独立自主自力更生</u>；</p><p>对外开放是建设中国特色社会主义的一项<u>基本国策</u>:</p><p>改革开放的目的是：</p><ul><li>解放和发展社会生产力，实现国家现代化，实现中华民族伟大复兴</li><li>推动我国社会主义制度自我完善和发展，建设和发展中国特色社会主义；</li><li>加强和改进党的建设，保持和发展党的先进性，确保党始终走在时代前列；</li></ul></li><li><p>社会主义市场经济理论</p><p>（1）计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济不等于资本主义。</p><p>（2）计划和市场都是经济手段，对经济活动的调节各有自己的优势和长处，社会主义实行市场经济要把两者结合起来。</p><p>（3）市场经济作为资源配置的一种方式本身不具有制度属性，可以和不同的社会制度结合，但它和不同社会制度结合具有不同的性质</p></li><li><p>“两手抓，两手都要硬”</p><p>一手抓物质文明，一手抓精神文明；一手抓经济建设，一手抓民主法治；一手抓改革开放，一手抓惩治腐败；</p></li><li><p>“一国两制”</p></li><li><p>中国问题的关键在于党</p></li></ul><p><strong>邓小平理论的历史地位：</strong></p><p>马克思列宁主义、毛泽东思想的继承和发展；</p><p>中国特色社会主义理论体系的开篇之作；</p><p>改革开放和社会主义现代化建设的科学指南；</p><h2 id="三个代表重要思想"><a href="#三个代表重要思想" class="headerlink" title="三个代表重要思想"></a>三个代表重要思想</h2><p><u>党的十六大</u>将三个代表重要思想同马克思列宁主义，毛泽东思想和邓小平理论一道确立为党必须长期坚持的指导思想，并写入党章</p><p>2004年写入宪法</p><p><strong>三个代表重要思想的形成条件</strong>：</p><p>在对冷战结束后国际局势科学判断的基础上形成；</p><p>在科学判断党的历史方位和总结历史经验基础上提出；</p><p>在建设中国特色社会主义伟大实践的基础上形成；</p><p><strong>三个代表重要思想的核心观点：</strong></p><p><u>始终代表中国先进生产力的发展要求；始终代表中国先进文化的前进方向；始终代表中国最广大人民的根本利益；</u></p><p><strong>始终代表中国先进生产力的发展要求：</strong></p><p>社会主义的根本任务是发展生社会产力；<strong>科学技术是第一生产力</strong>；科学的本质是创新</p><p><strong>始终代表中国先进文化的前进方向：</strong></p><p>①发展社会主义先进文化，就是建设社会主义精神文明。</p><p>②发展社会主义先进文化，就是发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义文化；</p><p>③发展社会主义先进文化，必须弘扬民族精神。</p><p>④发展社会主义先进文化，必须加强社会主义思想道德建设，这是发展先进文化的<u>重要内容和中心环节</u>。</p><p>⑤发展社会主义先进文化，必须做好思想政治工作。</p><p><strong>终代表中国最广大人民的根本利益</strong>：</p><p>①人民是我们国家的主人，是决定我国前途和命运的根本力量，是历史真正的创造者。建设中国特色社会主义，要不断实现好维护好发展好最广大人民的根本利益。</p><p>②党来自于人民，植根于人民，服务于人民。党的全部任务和责任，就是为实现人民群众的根本利益而奋斗，党始终坚持人民的利益高于一切。</p><p>③要努力使工人、农民、知识分子和其他群众共同享受到经济社会发展的成果</p><p>④在我国社会深刻变革、党和国家事业快速发展的进程中，妥善处理各方面的利益关系，要把一切积极因素充分调动和凝聚起来。</p><p>⑤党和国家的一切工作和方针政策，都要以是否符合最广大人民群众的根本利益为最高衡量标准</p><p><strong>三个代表重要思想的主要内容：</strong></p><p><font color='DarkViolet'>发展</font>是党执政兴国的第一要务；</p><p><font color='OrangeRed'>建立社会主义市场经济体制；</font></p><p>全面建设小康社会；（加入世贸）</p><p>建设社会主义政治文明；</p><p>推进党的建设的新的伟大工程</p><p>**建立社会主义市场经济体制的原则  **</p><p>（1）<font color='DarkViolet'>必须坚持和完善公有制为主体、多种所有制经济共同发展的社会主义基本经济制度</font>。必须毫不动摇地巩固和发展公有制经济。必须毫不动摇地鼓励、支持和引导非公有制经济发展。</p><p>（2）进一步探索公有制特别是国有制的多种有效实现形式  </p><p>（3）转变政府管理经济的职能，建立以间接手段为主的完善的宏观调控体系，保证国民经济的健康运行。</p><p>（4）理顺分配关系，调整和规范国家、企业和个人的分配关系。效率优先、兼顾公平，鼓励一部分地区、一部分人先富起来，走共同富裕的道路  </p><p>（5）<font color='OrangeRed'>建立和完善社会保障体系</font>，是建立社会主义市场经济体制的重要内容  </p><p><strong>推进党的建设的新的伟大工程：</strong></p><p>① 坚持党的领导，就要坚持党在建设中国特色社会主义事业中的核心领导地位。</p><p>② 坚持党的领导，核心是坚持党的先进性。</p><p>③ 推进党的建设的新的伟大工程，重点是加强党的执政能力建设。</p><p>④ 坚持党要管党、从严治党的方针。</p><p>⑤ 坚决反对和防止腐败，这是关系党和国家生死存亡的严重政治斗争。  </p><p><strong>三个代表重要思想的历史地位</strong>：</p><p>中国特色社会主义理论体系的丰富发展；</p><blockquote><p>是对马克思列宁主义、毛泽东思想和邓小平理论的继承和发展，是中国特色社会主义理论体系的重要组成部分</p></blockquote><p>加强和改进党的建设、推进中国特色社会主义事业的强大理论武器；</p><h2 id="科学发展观"><a href="#科学发展观" class="headerlink" title="科学发展观"></a>科学发展观</h2><p><u>党的十八大</u>将科学发展观同马克思列宁主义、毛泽东思想、邓小平理论、三个代表重要思想一道确立为党必须长期坚持的指导思想</p><p>2018年写入宪法</p><p>科学发展观是马克思主义关于发展的<u>世界观和方法论的集中体现</u>；</p><p>进一步回答了什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党的问题，创造性地回答了新形势下实现什么样的发展、怎样发展等重大问题；</p><p><strong>科学发展观形成的历史条件：</strong></p><p>现实依据：科学发展观是在深刻把握我国基本国情和新的阶段性特征的基础上形成和发展的</p><p>实践基础：科学发展观是在深入总结改革开放以来特别是党的十六大以来实践经验的基础上形成和发展的。</p><p>时代背景：科学发展观是在深刻分析国际形势、顺应世界发展趋势、借鉴国外发展经验的基础上形成和发展的。</p><p><u>党的十六届三中全会</u>：第一次提出科学发展观；</p><p><strong>科学发展观的科学内涵 ：</strong></p><p><u><font color='DarkViolet'>第一要义是发展，核心立场是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾</font></u>。</p><p>第一要义：</p><p>推动经济社会发展是科学发展观的第一要义。在当代中国，坚持发展是硬道理的本质要求就是<u>坚持科学发展</u></p><p>核心立场：</p><p>以人为本是科学发展观的核心立场。以人为本就是要始终把实现好、维护好、发展好最广大人民的根本利益作为一切工作的出发点和落脚点。集中体现了马克思主义<u>历史唯物论</u>的基本原理，体现了党全心全意为人民服务的根本宗旨和推动经济社会发展的根本目的 </p><blockquote><p>构建社会主义和谐社会的根本出发点和落脚点是**<u>坚持以人为本</u>**</p></blockquote><p>基本要求：</p><p>全面协调可持续是科学发展观的基本要求。“全面”是指发展要有全面性、整体性，不仅经济发展，而且各个方面都要发展；“协调”是指发展要有协调性、均衡性，各个方面、各个环节的发展要相互适应、相互促进。“可持续”是指发展要有持久性、连续性，不仅当前要发展，而且要保证长远发展。  </p><p>根本方法：</p><p>统筹兼顾是科学发展观的根本方法。深刻体现了<u>唯物辩证法</u>在发展问题上的科学运用，<font color='OrangeRed'>深刻揭示了实现科学发展、促进社会和谐的基本途径</font>，是正确处理经济社会发展中重大关系的方针原则。  </p><p><strong>科学发展观的主要内容</strong>：</p><p>（1）加快转变经济发展方式</p><p>（2）发展社会主义民主政治</p><p>（3）推进社会主义文化强国建设</p><p>（4）构建社会主义和谐社会</p><p>​  全面落实科学发展观是推进和谐社会建设必不可少的条件，也是推进和谐社会建设的概述要求，也指导着和谐社会建设的发展进程。</p><p>​  构建社会主义和谐社会时贯穿中国特色社会主义全过程的长期任务；</p><p>（5）推进生态文明建设</p><p>（6）全面提高党的建设科学化水平</p><p><strong>科学发展观的历史地位：</strong></p><p>（1）中国特色社会主义理论体系的接续发展；</p><p>（2）全面建设小康社会、加快推进社会主义现代化的根本方针；</p><p>生态文明新理念：尊重自然；顺应自然；保护自然；</p><p><strong>党的十七大内容：</strong></p><p>发展中国特色社会主义的一大法宝为<u><strong>解放思想</strong></u>；</p><p>党的十七大通过的党章，在基本路线规定的党在社会主义初级阶段的基本目标方面，增加了**<u>和谐</u>**方面的新要求</p><p>建设资源节约型社会的核心是：<strong><u>节约使用资源和提高能源资源的利用效率</u></strong></p><p>新时代最鲜明的特点是<u>改革开放</u>；最显著的成就是<u>快速发展</u>；最突出的标志是<u>与时俱进</u></p><p>首次概括提出，中国特色社会主义理论体系就是包括邓小平理论、“三个代表”重要思想以及科学发展观等重大战略思想在内的科学理论体系</p><p>首次明确高举中国特色社会主义伟大旗帜，最根本的就是要坚持<u>中国特色社会主义道路</u>和<u>中国特色社会主义理论体系</u></p><p>“两个没有变”即：<u>我国仍处于并将长期处于社会主义初级阶段的基本国情没有变，人民日益增长的物质文化需要同落后的社会生产之间的矛盾这一社会主要矛盾没有变</u></p><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p>基本政治制度：人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度以及基层群众自治制度</p><p>根本政治制度：人民代表大会制度（政体）</p><p>根本制度：社会主义制度；</p><p>国体：人民民主专政的社会主义国家</p><p>党的领导，人民当家作主和依法治国的统一性是<u>由社会主义国家的本质决定的</u>；</p><p>建设中国特色社会主义文化的根本任务是<u>培养有理想、有道德、有文化、有纪律的公民</u>；</p><p>在民主革命和社会主义革命的关系问题上，中国共产党曾经出现的错误观点有：<u>毕其功于一役；二次革命论；无间断革命</u></p><p>中共二大：大会第一次提出明确的<u>反帝反封建的民主革命纲领</u>，区分了最高纲领和最低纲领。大会通过第一个党章，并通过决议案，决定中国共产党加入共产国际。大会选举产生中央执行委员会，中央执行委员会推选陈独秀为委员长。</p><p>发展的根本目的是：<u>使人民共享发展成果，实现共同富裕</u></p><p>新时期我们党提出改革决策的理论基础是<u>社会主义社会基本矛盾运动学说</u></p><p>我国社会主义改革是一场新的革命，性质是<u>社会主义制度的自我完善和发展</u></p><p>国有经济的主导作用主要体现在对国家经济的控制力上；</p><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p>改革开放以来，党的全部理论和实践回答了哪些重大的理论和实践问题？</p><p>创造性地探索和回答了什么是马克思主义，怎样对待马克思主义；什么是社会主义，怎样建设社会主义；建设什么样的党，怎样建设党；实现什么样的发展、怎样发展等重大理论和实践问题；</p><p>怎样正确处理改革、发展和稳定的关系？</p><p>（1）保持三者在动态中的相互协调和相互促进；（2）把改革的力度、发展的速度和社会可以承受的程度统一起来；</p><p>（3）把不断改进人民生活条件作为三者关系的重要结合点；</p><p>改革是动力，发展是目的，稳定是前提；</p><p>简述马克思主义中国化的最新理论成果以及内容及历史地位；</p><p>邓小平理论，三个代表重要思想，科学发展观等重大战略思想在内的科学理论体系概括为“中国特色社会主义理论体系”，这是马克思主义中国化最新理论成果。邓小平理论主要解决<strong>什么是社会主义，怎样建设社会主义的问题</strong>；三个代表重要思想主要解决了<strong>建设怎样的党，怎样建设党的问题</strong>；科学发展观进一步回答了什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党的问题，创造性地回答了新形势下实现什么样的发展、怎样发展等重大问题；是马克思主义和新的中国国情相结合达到了新的高度和阶段；</p><p>马克思主义中国化的最新理论成果是党最宝贵的政治和精神财富，是全国各族人民团结奋斗的共同思想基础，中国特色社会主义理论体系是中国共产党团结和带领全国各族人民沿着中国特色社会主义道路实现中华民族伟大复兴的理论；</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习日志</title>
      <link href="/posts/1171462645.html"/>
      <url>/posts/1171462645.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8941287e45ebf56855348aca2ea6c743342d35a468a87d29a4c9d0f67fc4bf3b">b859bb3ec43b3780d72a73eb0aa3d1489ba0b6f5e12b9dbfd9de755de802cb41c3f2e7e835fad77f5f738e79ee91fb0e02f51011cc7d6e10faf69554839014e936790db5672b6c9d2900dcc1a67eeb0e2952f1933dd6d1acb80c9bfe228b86e9f306bcaaffd377c3a0c3e0c4d0459e18ac55f1a6db51267aba8b3557f67647c00834490699eeaed37edbef0af7d692849504ee55e286f986a964831c5787d76876ae7ad1a87fa78f151d405119543203e84c096a47c0544307029e1093f35a69f10aece8ec94a9c85eef9b707bbb0885a3c37923da95b466d9e864d7a696df93ec02646798511b6faba826555cf9d7c120bf2d6f9f687bf89b157579d862e737ddc125e424d94393b1140845f270b7db336cfd1769e4181442d04bd015f56868e9966e7f156a17f0d79cbe42fb1f2a7b72c669f2b3f4b2eae5084700d44da718b3732e5dd517d5115bc7fb8e4426bdcef948b5989a22253f82575b78e1e241e387fcd984e882a7cc9df820479a44411372724978148adb47d93a693fbb7a910bf7c37931d5df8783a13ddf393bcc363bddde6645743cc2aebb391ea1dd580febb01a3569d87e8d2898ffe2a17c1401c050f311388c567f92b6e3092a583b9772773a92331061b17918267cd52fb726cb7ee18e5de22f5ad9ae8e9ac2bf07b4193e450ed9789a97444cdcaa387de002a48d6ae2163d6f6b448e711a8179ffa0033a971ba2e869bc48dbcb5983e72fb3ade60f88a496edbfddf2f922e7ee2fd362a918b3fa0e377717fa7cfc425f48fb353297b239b540882eaee74be9d2b218be201639d692e0ee54d154fa7b488c4ef034a452f5f7138c61ae50702e45ab338550e66e955168e74869a1d52ec2b54be6eaa91fd83ea0de9e5b04a3852e21f0546bede8f2b4808cb0e46ca1f203848d0dcbb2dc6d5aec8db07b4d619346b9ffc3458d61423448a724373b35acab066337d9a572ff0e6b1aac64fd9ed33ececa4b9b452a2a199692e922792117e7f8a793911b8c660780e3b0c22dcb5a0e769bf7a4c51ffc8894e98e50c8aa4024bce1933c341116a104ea0732de0d3193f726f26ff7d41b29ef9f5deedab244cbd41a2c8e0ffed37c7293c83d11a1c1ef0794da7bddeb4242a1b7d52d827f4f0e7c47997c31a75d0bd81d699f8e0f12da2e071c23dc264510166d57488fcd6e50532bcdc55ecf175744eb815d8057b72f034fd5ae321060e9bfbb610eb88af80ad697cae78d200157ec3d1e7fe0b046ceef82578b1f3b2e4379c4b4e69ce669e4e7f8293d6f3f10cb3dae7ff478eaa1bd4389b9201cb10a1e88207a4df4ddec67434b1cf58fb8390eafef2f9f6dffb29c29813d9936987dde1f5c6f14aac36bd992eacad40b8e90d273a11a9f4d8f20e23a2588221b63a85f4188e0889219a8a355b7d1e4666e580e3ecfcd67efdf33888095c8ca10517dc2046ae2e1cc4c233a400777e02824751921df5f528c839a93b2b07caae3392c1ae7392600957109dee98b9ecd266dae0d4247b9619a74b19e393eb1217b32fb6614577ca6afbcc53ad1a955995968dde01464570a37fa2c6713eb94bb8925deb99329e0db68be80a9edd2d7f981c4d065519bd73d52dcdffce65bda3979267ebd41c0ef8d71cd5b9aa8b66b69ebd77b8986c03a08c2857904a1b66abaf0d9f0c56f41124faeb240d99358f17c416be5cb15927dc92244163b114e665c3d487056e9eeb63aa10bc343415e2795c10351cb71216be61f1201467e6e727be8c72177010cf6a3662c154658af175b2d1f678b4f23b8f78f587ed1938c7ea8a784bd1d3f5eb4e3ee59f7f6c44bdbb19f33d56d8be598c7ecf2a3e1bf3e7a04fbd2bf859d40390d307282d8b49ffeb2803f283e72f89685ab4cf0cd653fab3c75d0713dcf84db2554051bbb7eba8199cac3aaa0ad8801a3713a3e949ce7502e92a621ebb936f9cfcbb3866cac68d6ffbfea185361777717dfb823c1615a1837b702c90c9e9154e90c7dd39434a3ebdca2c2602bcd80c412f1476dab3a25431be7377ac6782e0047b14cb5330698ae3728cb6159524da86a8f5f507f3b6356ec2b0293aae964f4f19e20240974ddd25c379711508a6d1322d30bc50c45bb384f04ca591bd5edf5eba312acc9120ce9f9259d8484099db460ac7033e2bbe15ad30b73125b476993f12c7d84461aa33d1df2cd65173bf7c3fed4b5eada8471b35b443f5a79e415d44505954ccbc08fc385f23ed9f1017270844aa3ab9281d9c5b21830bcdcd8fea153d7b509e772d2c2ae58e11b6591362a77b3d12cd110fde205c1add62777915748af5dbaf08f78f3be419d6889bb3d1a604c389fd03ddb88ca42f4c8d8d9162f09796f76bb6fb5aa2777783cead9779b16354fde83571565bc85616a66aa2d990197edcf552c158846960e945f4b8d80c3efd78e044ce278efaa745eb07987482360bde1bbdb22ea5c22fa2ebc78acc08b53d8aa99309fcf6220d7627ed9141369565d7598b6e85432ec68b3497f2577014a99fde5aa21bd2642336152893b804fee872810fb9752511331f9bfcb62268bc5342a5384c49f895916dc82acac52ef03cca57e9d76e93a4cc9df8ec3e733407f9d25a9ca06fe741def0c3f1cf1f51e789e3c1a0147defcb7cbce33192cae690fe63b174711f02a2be2c90cf2bacbdd21bbdba77aae060dc0eaf1902c6bb106e4ad88557347d40b1a3f4346b2521965dc7eedc08a0381178e2321de46157b07c6331a93a63b2e5e51f3ed64e80be03c19a25fc4900561f2be5f494588860b70d4b903e8c17f96600a74469c72152684232fbbfa99b4d431e21555ed88c2d21bf104429320864a3463f4d04a6c6a6f54a2e24c2f81863accd404ba4d8c0dcfed3f18bd9ed09df6c4d9369d43ecdc9181b403659418c26aa6bb16aee380179c5f5b824ec32e807bc6465c063079885e91490618e90b67dd952fd8d06629c93d834df489982d5cb0c169e5e41fd015aed37d497c8967e87ad103c981ca146e3c66eae8990e1053ff16044bed3e7921bb95910c3a9780a6c86789c7130cab47c8b43b4546b2c509c7886bfe92d90eac780bc41ba84ce5010c027262ffb52bd0eb03ffe38b749357361eabb44473043e2879a8927f8b084b709d41e8199eb0a17942709dce87984e65ac3d9bc3e28dcaf033e22753462ded18a70f835270035492b4ab0efeaf16696b9e8a2e73c6b5fd1e5701f7e22db54439509e6bbedb39a836e80690c15acefeaee35ebc6bf45836b26b98973eb6fa9550e73d262d55b9faabc33ba4f25effd147284785dfcc50753581e73e8a24566fe740a6efb3959a33daccbf8b3076d4f1847e84b9cc679097090e13015bca7ef842f6d8f2223ea0b648fae754db7ca24efae0b2f0a4c0c0af83d959f613502facc56077e3bd35f2923ffb2f2b1dea3bcfd2aa2d8b5d3ec56172caf4ac12d8bdc950a68ae2cde701a52cfc0fd20722101129f371b69433e46b0e53f18e57e67a39855e7ba6a2a78a52d3d9391f2a69da0c0a42f177311b2ebd598a8de4c05ca1f0c38f6050303da7e0530f2f2ed0095f3197ae56b61f4d99b8384045a8cfd411e0f57c80787280a64b5e90183f9a6ff2d78a98aa344b9e146b6cfb5bd1e977d0a299e419de3df4498c37deae8dd02eae7f07476069293d9f2609a01541527eb8416e2eb4ccf6f19e8ae2f4dff3aa7cce57b734f13434b5cbad8dfa7e389c51b08c1dc94c340d47cbd725656bc1b218072e143d97ae0ac3711f8c4e870c6810bc3c77955274c857292796be54fbc55b51ba710b762a6be971aa2fe0cf4d1db61c47a77152ed7e2359712c608c22faa5a465be09515d46bc3492d86bfebf88d2aabe87f2d33f25919aa70c8a6fbdc3c8f75ecac4bfb47b4b77749bc281b0b80d145430565b1c7a2ef9ec7d864bb8accd12cf5df5cfb8ee2fa0dd94a9f2e70016267debc1df353d5685b3c2e0d13e0bb6f0064686cae59f56902aae0b92d9dabbd018e666dd77f427d791276e7b944efe1e403d2df2173da45e0c695b34283dd770d0dfcb7ae0bf6dd6146a48bdc931cdd8100681dd5ae19264078bf6ff14dcf4c1950a72320764ac33224208a7a15f8b85d647e437a2b140d122726733dd3ff6c900cf7da9cc5fd410e5cda6dfbb3ca670972e9833138b1d71d2b51734effc2fcfd5d67bc8de8d4102905229cffe5887ba09344cbe09d22a82b0441b4d41221cb12fc5d08cdb923f09c584706c6cd1782502ad124732b05ee2439abb3af90f70c28c96d4d1f1f0655313e71d7b877c2617f9a6593da172e82b9cba161dfbc6d119a0837a136cb5e352eca1ada495980c58984ab074724bd78d9ba6cf484e0e77205ef908fe40d165ac28463f7e43b6633ebe2d10ff7c05b3493d9aa3cb8772823ddf400c64fd6a4223ca2823d11ca11eb7c5addeb9e56f9bfecc3ddbb4e8602cb978dc3a6ac002818374d923ebe8f1f601e144be2b2247face9d000f96d9b9e68b0b8c60975a47b7bffbf06734628595abe0ca3dc26fb721297bb2ff9eee088b6b9a2cdcba4ba5858ad759f74f40f782b59b4ac66b8a814bdf401ae10d725c78e81851f872c054433a041f29c9bd07bd44cebf54062c928f28d5160a4bb515be73dd2e2fa820a00dbbe439fc28e40bb75496906308737eb60b94cf43ea7a88304508c040c0e3c8cb74d0b7743560fd11f71f0a4522667506104202656170940197c94802bf726810fdff8280fc7a6d0525055d171cdf5892e9798d28c01307a53246201999d3aa2d790a30f3a3cb2f94ca1cb417926ced049f734eed9f7fc60d3fef03a37371782f7b4b1ab9feccd7dc8d71ecaa39ce0a5f98dc913c0ec15baa44f366ed1bf32ddc453b8a21687e4db146699e682a2abb221a61579a73bd96dce2e1c8f7ef97b15b0702d07a8a0b912711ad9ff0917fee3a90e182eb230dbb6e19d0d41fc67ca4dc15c4b5f681066ee16c157ff67ccd66d456d98684d121a6acd71d21ad5d38c2a5fd85bda630d07b34a14aabec5e14bfd2b1a089faac0266e457cc51e0084cb416d05c37a50a183c9ef80ff39d3b3b19ad82591c163375afd02dd17a7c9a2ef329bd983f8c541a1ab1eda3eca64b75324096c80e9bb734bebb4632f07b5a9de322107d6b19f39085d6414d71d18cf6715abfe0c9ca6d128965a7895511809e9692ba44080e47e1a41a7dc95fa0c4eda1378320af097f454752e539a03a6aca35aeb8b6b6cb6b19cfb8170a3878e10fe4e1bce162df6fdea9cb05b9d4b3dfcf5a20a5710545845c96604206e08cacb8a6502d05d853c730729d7d166bb40d926311d5abd68c1564b3442bb5dc92194ea26e2d29d6b03167f28aed318f2c47ccac14452858fbb59cb3e5e0c5d26f2844d143a13da6b9db4dca2663ad1e7ade6c70bad811f41325ae2b6250bee1cb1946e03f1b361a0d833b56e4fbb5a258e97e252ee193ec12e3a891cc9b07c754a26d90c85ee2e15720a02869b2033a6b363bf2c3ef767b120b227144a24fa503badd61cb51cb055639eaf3636feacdc151bbbc58f6dc76eab66bfb06b1561be98080ef1fdd90450ef233342539cfadcab88c758cc3345dc14943ebabce70d7b1b7f4abb57af0ba5e50a71a4cbb25d065072de93fa481acee4691b6e988719d323763a0975dd4dbc1a389db9e638a402139d01b9dcab013ec8d66f3e21292dcc36fba35d0b6e0d69ad20506d8e0ca1936bf41d408c2aee22c9228130bd4f2f3b19fb631ace23da25b1f37a8482191bdae24b555bcbc9a1de4c6b6872e8d65d1b843060df05dcc51f1b4979c5e8dff5206e625ab65ba786d4fa2887ff6b4590879a345f29284bc097195fe0c655c0c3df2099d3a6c0651c1d5b877eeb4bcda8fb596482ea07eba6c9b323a00d55a527f94535aea9c6b7817463aec618c4f78d5bbe3a5c52c81bd9a885f5577900266add300c98d3356c7848c4f444f7f516b9721e292c5fd51dd91f076f0f54c02fe039384e5cb575d06d360d5372a0aeba82b644c9b5b42599f5e9cdc1c7e3b13224daf025947dd7d16f4e962b92fb08f1b3f88d4d2e71d6518d2ca72a44e945468834af517aa6d55976f60ed64f32f877a88dba8a36d5732f3d9febf32cbb026a4f4192545957c82c14f59e0b30205c3fa080b9dbddc4598cd129f70ac1fce5d35224590c79d8086d57344cf89803f04cf1a0203f7aeca09e77e6b5a51462b6130a24d7980eb8abe57f9185d427e5fd6a2be306ff5a627f55cfe7a732ee5aa11ddfcd797eed6d2928b23553b8a450a848755de153567c62faf5210a38e89933e8ca7bfd8a1115dd4f2439712392122356b62e1f159be31e4a9c043e49280a8cc7d989f96157fa026d7833423a75fd4dc5555d70c03b46a416bd93b4c05d10922ca3a4b465e53469722a9ac0f1c5e592097c2d9418b4d5c3e3033b83461e4160fb5001406e76ae7113d826928e16e8617488da88c5dc215c034a8408d197d23a02ff98e9feb5ff12defd02b221295b5a504f78c31b6ba750811a35ac02377cdc8ee0f3b12d322a09cb8d6cf64f801593fa3a2ec31855fe1a6206bb0dfe7d73ddf456edd6eab43a08deafa52eb43330960c8b61788ac310e2746711c6eacf2c6a9c984b3e1528a2dda51f5547f1b7d549a3823c299a39a910f8101cc2f8f38fa9e8359b440069854d6589e13dcb2131f0c4321c3740fdfe376f92e352ef22dbc41e22ab66b6da9e6d564c3fda9c8ae6ae527c0bbc41d03d23abf9d6c8752793a09c9e0df8f422d3bb0ce5a2b11c7cfb4950f05a77e2440ebde556357c0525952a3b2d6dcef35e6ea63843b1f54c190e288388c0260ba807c76cf4b40bf091b37a7c7249261b5b4403c067840e90cd4bb49fe6789f03753dd256f69b9f1ff54ccba41a2ed7c834f5c21508ad8b10b1045ed3566ffe4a3af04e0573396be8b11b205a1d93dd1b0cf0b582c55daee36805a703f34e6bfc1c412c2789af426d3a971ed6b79fcc05c2b97b6417214a4e7fe98c8438d9cb82ce321ed75f5102fc269abc115ef66704cf99b28f27ca8ea69e682488a845476a2c4e69e6fe804d2ee3b4c50f51fc82d2c58e1327d48350351aaa83ca41bc783eccaed37f2277af300e61ff958cdc645711357cbc936a7ac3e9b8d07ce147cd02d5cd12e6f04ab64d8cf3b2385b7c87a9afd3e951470bbc08c4d38ffaec7d82d8626e39c184da592ef99cc3adee9e3381b4a29b607e1f12f398fa962fc0d95791837844bd595621f0bdce2c32ef287670ad99e1d6506b240e980315a63dcea02bdf3888779b2a0f0bc1f95067a02ce03627486bd04c380c85d937a10cddec44fabacf56a65dabfdfbf458cee72cce63913f49276506abc70ddc39513d441ded32b631dba3cc879e542dc04be054288a0ce7f7ba116f2faee6efefd6ec84551c767dc113cb9d4fd93bca6781fbeaa771b918521c0cfd1b6c02ee17769f70d55f0dc54fa5b5f29a03d3b375546fb0881deabcc2e879586159ece0d508fa0b5047e74a9282b962ae415fc91f8004452199812f1bbde2e1838840fe6e2c476104e2d0ecbdefee9c7e2e412a9366fc5886c397da350aa9371628500431d6ceb575090c91067d603f5ad004e54658de67adabbde05d52f760dccfd3c9b442e0dc2060d756fa40c055231839d3ada28842ee149feeb88b4ba4fa8e21322c2f878e5165554a4e1613d4358e3f61a8dcfdbcec4e35ffd728e3b87302318b3fd4168f2844798a04f077722917f9d2578bfe8ddd9bdfbc109dd43baa24e28074e8584cb65e3c03ae73d2a7fc4182205d848502fc2c9d1476957bc2712dcbe17c8880d29478a919e4c68e89b3e4c5c1d4875cc1793a088d129d83ff389895dc9d5946703ba2723da20db29fb6c2b2e05139307e1a40fe3dfb5f2b684b4291f45cd9afd0b85b745cc9b0fc912b1441e961d4f414417029441e0d07df71eecab7a1c47f3732c73c4599cd0bdec27c9404adacaddc935530922465f14e97d67493600346e95c019d34ab054a948628c39e287d775dd005fbc150e471a9524d49c8d12973f1950471c69f43eed162d3e126546939d6b99a4ccc2b60a166ffe03285d06db051c9adad95efa21376410742ddd635ee8f54628a86b32a28c27f04ac5a3c5adb70e400dd26301475d3563b1a3fbdebc2bb8b107cfe47eb431a34606100f39147be431b040eddb5c7633d388cd52d6a85e28cf74b0052bcea7e171fa4bd23bcd4dc8f0075493206f1014af6e34762270dd61f6411ba553631328982f2b12bde3af65b5492721e291051eff655352b4a3679b28598feb765879787183eaaea21118a4538aaaf154599698390aa7b78c5f51057a18d53ab55487208443f62ecf6f9e6ac605e75064983e66ffb12e66f0e7a5b1a1859f2f017d03e944fd767880f5f85673f482c65bc33478e135df46d1456fca943c64b39c243d5b0736d39e19891c2f759fd3f13eb61dcd6fcdcaeb371fe3944c7c866d5515eec406baf344c51db640613e681ee2e92be722be140e7df2c2400a55be5ff58d1f4e7d15e5b89580a5a85bdd53f8ccca287dd6c30b279633c996a7ed98c0eda3082d1fef840bdd9b4050c386605452e41f53e65365158cbb216abfa7e170fe4d47339f196c9c0ab63ed390d58f80d1717f5136b3ad8eaedd3939c86234bfebeb814df140f6f8385704e48b05bb58a3727265c1ae8d235c311f90d93dde933ed5ef4beb9dec33f15644332df80444e5b77c7d2b4af1c14243b7eea460af931437e4073efc4f9d75ec3ea6e4ca423479eef895699a76c2448a0aa79e34c9ff0d97692aa90bbb7fb3db386aa6ca8d0d175d09f08b032cab780ee1b4fd4cab01f7a9a6bf75b4c6858adecb7d53e2220bfb961e264ae706538012f7af8b8f9621d8bf4009704f26063944bee4e81cd45c4d26e9a76d59b27e9cb64c48bbccaeb4b00f2152e4f46fc75d9a1f59f54c213b293e86decec0ab207b669c84e644b0a20a354e144dbc3700d74d17159f1593faf5aba163a56267da5e2d761d4adab78222e938a603b34da0bb82f903cf66fa2cd73eb7af65311a432ecdecb08127cf6e2353451b467f3dd05e2a6fdfc7609c70dff0e1a00978e8fd71c529592b06a6d932ef0d677b7bafb51068ff546dfc4d85dac8a420d0b05c337e2e9c6153773922a4e8b572140d5cc9b5d00be919ef491043e017636e1b4ead792b5c5ddcd8ec97be9c77fe30fff4a0f36a06feb48cbb76b2d72ba84a4c73702bd4b59fa1771bd7bf83ccf209ff8909f7ff0dc4d2c9b6b45a0b510de1b973fa7a242c813ae2d0bc1d8a6ce675ce9af73bb0f0c2f057a9f2518ce8f02339a93e38b904ea2bfe3a61b562c295039a0f769815c30d33559520afc7a4888d6310c20bf1823202c4ec4afb4ad59408817df9572d7faa4812d92c4b482849f30b8ad61836863e7551b13fc28d345b7aa59dff237347bb70ab7b3e12af2e28a872ff5cc30b21eb7721a9b4af5dc0898da9bb35b812886cef409eaa9fbe5e91e74458b3aaa01b760b46861932f9f60fe6faea60c4d2ddc89f89eff802ff1a9ea1371d008bb789358e95497f831587906365fa4c995a9a710a127cefd84aeddc65a1043686df7d9c470567179dc0a7a0ed51ad03e131af4d3ed82cd611a1f6c34d496b747c305e176d55e37a6b7ba479580e7a336bb8d528135f90d2c5df830dbf54f1801b5a6c7a10a92e93beb6eec3d555e547f1d70c09168eebc7add8739cc4fc80e89dab8e112137a75ad6bbd18851d68cc085dfea7a3cf0a07c8cbff867707df25005013be754dff5fd47bf4b8aa53da9ffa7c1d938e369771d25d52c5b9c3a4ad2925438d94d6d0234d92cd5af26897208bb072545fbe83bb934946e50f1fe6509358218c47e0ec7da1b92006f18b7028a3a45c3474f420d1647aa98d510e330fe899f8789f8d1d1d33f03756b28a5075ea8e5e18a5ae40aae88f2021c2b06b341f6ebdea4b757d5941ec78df2a3854b1bcffe511a787bb2acc05d3af051ebf302cb5698064a75a5b44f3c42ce78ce88915c3c7908d06aed6b85b1418c5d6470d86430bde090dba1e507499d2a97407c9524e9b6a0c03b06590dfb6f7be689933c5e7bef0fe4fcd1049104b524839fea28368494ceb07f499e3b278ced6e196775d94352a74e4802c285fc65d72952f6d48f38a107dc3643db2051df185ebb42ff7630320f99f6e2b4b7be0fd29e11e8fd1366d729cdc43531a6d6c7667a65484d228b0a377d60e41b672473275ddb76dc64c954a73d3845cc63593bf0fa2c3cdbcfc281039d61b967b264455fc8c036bbca8032bed98359fc57105b2810ec4175325afe9da7c8d7dc2914de9681d69b52249f2bc9823d2e30b5085c4f7e22a527d6c68ce4dea871ddd87869144b4c1e9e646a0e991900dbec28a055da24f6660244982e9311a7be4df1faa2fa0c5870fafcd0537cd6029fa82f35a0a7aa16137deb6200280fc43b9110a32e13159d0199bc7c55c7c23f9eb5ce82cf18a9f78e09e3e53007eef3828c758410a72d49edc5ff4f0468f134bae0c4f8834bfe4a43b9cc9db9e80b192cd83e46afdec3f59a4971bdefd0241008d02eb531510d84268a1d5e3459b0f712857cbbf770503f90da6e8c0d642edcff1fe17086da17305f7ced57cce9314a7c924b95cf63915fdeb968dbfcc75ec0a92a2f64bbf999cd0b89e431778b6845ead69b883dc70a9eaa29538ba581374d6aecad6066f1cca642d5bf35162ea09a5f3f5df1024f6b93acb7de2a1526dff88dc8c3cd26ac505e5f84daa546282213d70c2815de3c20f8c0b5f34b8f0e559350ebfc5656767673526dcac86a92cf763509f3f81a500ca2236aee05c81ee4916b2d3aafc34e24a2474cf9b0ee11dd659a9cf871958cf86e70a777947a8cf3cf075625deef2a63b03e667c6a5649d56e72489b99b519638af870c21462cd9c3a7863ed3b52859e4461ca948cd595e68f04e0b34ad4e17662e49f9f9f95b590285cccaa40d83ee754b2b56f31323c4def46cb21d0999e7c524d7df11763693c5588ee8a9a3183d247cccacc108e0e840dae5d513a4254580bfda334b94a48260ae9bb820428354dcf364013efd2d37b1dbc4a95b57b8b6f7d5d7e652c0939eb72e4c2b072e5d835ca3623e14b891a87d90a9b804be12b1d2d39280e17ae35c50b797d96c8dbfc412e5309651b0a24ecdcf72714db61eeb0767530bd28524222d4fa087a6d4ef53a66c004a84c98b217daf83f1374f7e5c18b7f488c976c548b61077053635774f442178f4e64513ac389104f01dec23bd33637c1546b5cbdb94e3d9eccbff28288a77b7a4930ced9e480eec9d51e56daab894dc8fb5a2de69400f15599087b37d3e957c7e71b94721015cf0103b8e990f38fb48b1e514fe955d2c80d1f80c604c0b5c115c66af5d09d12cb2f69129296e1170409e2cbe40fa714a28fa7783a25e0f0bb72c7f4fb25f553cd10f2fd0e2363cda278e0559fe188f7aa3c1c90a75832d482c35a334882b671a649cc24b1e3b02308f6ce2d60337b6181a46b8443c11f162dee7c41c36f7277430ecd8c353553d7aefaf42ade922f3add4f47ca6da387fc9dfebfad832bb85fec3326c531051e11a4887a754338815fc662e85728f28631ca2add10691ba0c33c4f145a1db9b7ce073480486ed3d60f9ec7c843e8bc6e8b1f85e5bd1fbc867acdcf80e74fb0506a83be805ed5919bd3160a9bfeb4d5ae387ce29fdf6c6fe88ba5ff30e51b73965dbc19ba73dcbe8c2769817dfa512cf0c7c747bf2c5e7aee20454741edc0096a04ebbdaa4e581093379674e298625a3359a0d1035206538ad0e520abd4fa4f10d6c89727c4a7b36587c22836514e4f566b5b9cf8bd1729e6a13ea7876cfcf964fc033e053b1a1e10a6985ed57dbb0af6ea95e972501d6be3f8022055f24975c784a6d2a03995f3e82be6a50ff7892783082748c069275cf4e56352e8e216265d5150c0fe94c8ffb4abdd80f996636df0f1e8d0844dd65958383a26666541b9815d16468c3336a94475cf55f9bb618fca1b92e95c83de1173408aecdcc151a46198f283827db97d9f31bde40c060c03fc44b5a66d507ff2fe5088fc0c1f0603e167dd96c44db74f3f6a97c8566f9bfe31be94f49f49db3324f118cb90d81aef1544c00a6883f35f001ebc6af28abde8651500a8f3f67f13a6f01d0849c2f7ff95f639450cfc8eb388c87946a1293ef3148ce1c0f235525515649b0134a5ac2949a35016c669ee5225483407631ca4f63b5ace58fca4c75c1087b6f54814abbfeaa0adc7063a5e68dba5155a4a2801da9d77844742d57237d42a961908de327206a698b351942654f7b6412bf0bc81b2e624dd4ec88757ba87e9ffb31f9de01a98bc99e4f47e58e743d457f38046249d217be037acade332d70e586ac10964675bcce614adb358c61a2c33d94022bfc71e83341c7b639d1677ab656a840f866a9f0163a364985dc9c9632faa745435a990178bc0c7b4ff7fc4b3566f38c1b4ccfddab6eac17dbc9ff09496b5e9c84c4d7832c18c669c9867c376ce0a9e35ad559c9414ccd2073dec647f3f2bf6efd421a61a28c5fca6968c9b47a4bed8b0c47ac561be2aa60439c26717037992df6055bb2923064d3c76c39caad8b37849e69daabec525aa8f04248a36a76bf06840ef35eb1e5d7df6781d5fbeac52558f21a088de49ae0f5bbfe7b820506b4d2ff521cb9da25cd9362cfaa7f87660fb72ce1b81e90d42bc4978c71936869ea2eed65554795d0229bda0816215328e63ccf7988e31f967aaacdf9c04862a8b794a123ccb3626e6c482162f70782144160f1d8a62ad0a7dd48f7b35dee91e6f1b03225d6666e63d6cd0b4970259118ef27273358cc24bda041586a16570fe338f1ded35383d7c93ef9c4a199b65f7c68e0dd9e15dc7f12fb31c5b482e22b607a6b4498cf8c79d99f82c981fe5486c7590f1cbb9cd76152b494e98881b726a1d062d7897c8592409859984216334534f17618455290e695b9a55a88e294643f556be4ac45d50fd4aa9730080e77620dd560273ca7af3df19a0c98936c81e7607cc6ec2b5de6d364e884b34cfef72927caea46a9d27795dc3109b354d028ce761e22bd8333a5ecc011c0d465c8f3ebd1b507cde4985a6d0a62d8eae0101c0df6d66ff4e1e6174be33058c2d7e14a2b84618e4b3194aae865bfc4b170fc2dec2811fd219e5e12a8a478f634acff0114daac8b7d5475a0cbcc867449df2f36cbd60d1be0b63fc6bd2749db2ac7f6dc4641cb7453495024a27ea0106c44680fe50b460ca68e081c5d438f7456b8890fc80a84638f80a1ee0b832f1de2e538bdf8ef75126a01193a55bec0407edcff33b798dea7f7652e49e056620a1ca956a183107c745ac90cba2f55c0e4543db8e01b5093440b0698c4f4f1fd4f80e3c38ed904333033ac8cb49f6d68e9d6f722252e75941459a7aec22f064bb488e6cedb6a438e67f2737deae4515059ea53f9cdd0c0ba9618a20678d0de94b4d523a3d6b10d6ce0f2f4b0816378b0bac43057dd769589659f14930358ef1d177b89f9ad525e9c327dbfe43a0b7e8b05967d40219da89f6ca7d262c0358189c18d73069becd5e032d51525684e2a3317c827b6235867cf7fdf10b1e28a66f5da12a7dfd79bbe89f7ae4f29acedc49d83eb5a6e43c6f6b3dde52ec198e8d1fb690698c7e6c08502ed4dfff873015416542f1c3ee74cfc9447050fecf81d26c4a09889d5ad3e1b6f5d9507c45b5922eb623066d61402213322e146e520202c71ae6b511b0e6bb43198a9a44a21d2287243410069477d8f54cebed7d8032bc30022ec04c791c0eb897f644287741582409a20ee885e71023ffe3b29905f0627f4934ca69cae3e424bd1d20686da3f199f56ede93f5617862d4369489e75d8a66d6bab45ec765b15f78c83dff1486e8387c887a02bdf201235a447601a300ef238a89ba22b5b45244fc3b60741374bc83d6f9ba0465fbc29b73e1fb205e4c54725cb9f5431a01da9c169f7d3b5e93724a1c83994d34a40bb637afc5f3ecc0c5bbdd3781d3775f703788e239800b213402c8f33a864169b14a1b28aa36958e5b754b2257495fe345b96dbe3973fc5478b7e183248130632883107aeead577f38e26ba5a798a232156ef001a8344867ecf1c4b79a8f894f2d6f0cdc971b5ac65e7c93807581ecb05e77d3ded02a0138fa3ef793b17db5f25b25e1212bbf5d5f1317d51a35f8f60e94ef8358e2c2a8ac7611fcfa5a725f937e36a4f0fba633fbb8fcd1875fcf99f4999252988292380fd7b2c7c7461599a4a3503a14a902010115b9650b0dab073e2c598a55a7575678c64095bd5a0479a88713ffeaac73fec2c57c1f7fa15daa85be545b1a7a11bbc9c4fbdf9a81691babece76fd4b70d07670371674f8ff726d52ce2b44e3906af8cd98e569c574178676d1fb5e18722b5b63a56867cb472b8aad24b03dbf59c986de6f690ff1430de37d6ce4e3e17bc994b83f19e9cfcd5ea9a29aea1e81feb488b9c0c5c517c663a84f75e19e78ae03546b48541b998e786e52075d1ef75a2429b8422b8977240f79a9f98475464471459599afc193d496d2564023b74e4ec3bfeb15c6a83d33458e55784af02c7b731b24a8c42c19d55582de65a4ea7e3b4d3d6c5671a7b21bd011ee26204375a8c4fcafafbc287721054d5ff68bf4f28bf3dd075dece8f28852efbdaf2f469822e756762fac2ebad16fa147fe4a21a7d6a7ad0a4499fb74380efd75831aeb585d796aa1290576d6e8319a5e0c7e2ff8e520ed353bf4229e8e97643f17f37d66117dcde3ac961b96fc474a658f90e40d7b2c3de843a5aaa40342a9e4cdd7eb8e929d5b038cd4d0005d973c0e43ead7f33c73831cc62594390ad8c5e1803ef8690d01b138cbcef8cf38df4efbcc8b2dd98a778e3498a6d079a1e5b459cae5627f1f5f90228207294dbb7a6307d2d0c4189eee39956e83a85042bba022f76525c500a4c50b4aaa990fe14e61ec03c35ef579b61854365dfcd008ffd56dfcd9032d7e24db1d17c4ad3688b231884832dc3445f9f05036b55b8e142e0cc9c2a6f8d6e7b9981d08bd89adaf1730e2f1fee7426d3c8187bb58a128ff28f0729c4242396e28c1d8303780f7726e3adf7df547392a327713011dcbe4814949443b1e46cae7bccdb30776dbb805e5ed106a0085572830e4fdc75a2676bb4b92299294f2cd45d98a1460331b07013eb45614dbd3f0f12a4af586f921451c39bb5c9be65875bd2eec35b7504baf7b7759d60e6bc4bdfb8d6a043c235821cc4284e260c98d4f39eb52c05dd13bf311339e4a6f8c7abfa86f45fc3ff19dbb33e8b6708d4d7f53664f1abc730385c07305f649ea03cbcf777c0df5d25539f3fc07aeb4b76a947bb468ae86b6e779824a9568798da83b6a2ed23687b7a5fcd937302448db932be287132bfb54e66b1652366e615263002c8edb7f5fe752d532289435a0a288f242dabec7849b075cf148a86cbc127d9baa7a3219aed7fa2f472ef6fe8469a324236241eeb0f9503fc4715a1d79e9ec81d3da98d5ec38d9f51d439aa07dc575b859e718de9eaea4d227caed13257d21baf70b90bd05204b9f4ecd2a3105196747d0033654db64e5913db564e0be891c6957eb50e70d8eec429dd74823fffaa48172af357d78babb15b7449e962753ad16880d85d5e1c12730543a7c5e6e3ea072edc119782d783265be363da8bab3f123c8ed155efb5f3187c583b2da515c537eee2d9a8aff52c7df6277d42d1cff8db5a936d1e6ae136cc9d9a7537e25674b522a10f938788fe0ae8c67a8face65ed7d8b37024d29eb8e857682bfa61846dab20e64231d02503cf30d23cc0c1a78dbc9047651689a091161b574812dc4405b07cb8ce88f372b6da55356420e6c3436e5de0bbaec5df1f659cad52364713e9f9de716e13ceb04b461f3fc6f72d686f149a161496d68616649ef2a1156c5d93216d2d24aef6b54311ebeeb31ff423faa4117c068dc16190f1fd54f4eab4ffaae731ed4662f571c96f9a25dec42c19f0ebcc0b4c0e49dde88f6b0ed64995f5e14febf7adee5da2259c79bcc25de169b1dc00cfd7c0c4d953daa6358e1d91d48228101620250f195bc29ae8219c0a707ce3e6b37b5e55eb007ba971d7db36d02fbea47838566c408b808e42179cec3b8c6a1e06112559830163d660df13b132d95d07732d999239f2e2ebcdcc37f3995332218fd1555025fce184c122fa6165e33d9d787a398741f33690534be39120b1cb1e411f6bc3ad29febceb0bd6150aa52d7ebde75446a5ad56c0dca19ec46cd84070bed345efe95aaf360f13469241fe1e6e7017bd0d96ccf565ad9c705ba969c891179608740e186bcb19ca37c9166a5c8cfeba35418ef0e139d8431721d888b515a46299b1793a81bbf9930ed25e749703eae0f12a841764f769e01acc9b2d1cf1b4ef823685bc4b76fe3507fd538acc492be35d3a4647dda583e5546cb321e8c74ca8faed4b9fc56dc08c67533acc3be63f023a383d3318311592defd288d18f1291ac52add589bdfce3e91d9939f797337179200522e092cd51d71bd451fe9c374681addfd63d7a4921de6cc179f8c0aab0cfde17c7e3cc812b483ba6e29bfed7cf18a67c3ade3582705e3c7ba53af29181c9bb15d13b5bd2678448b6cf1aa3d5d1517f02512ef7a1d64378de33a38f2a67d01ae28e832af2e4454decae1479c85c02a93974dbd4f715c37dc893960b3a2a3e6dda8d525190297dc48c55996a2f99a203d2a49eec7ffcbda443b378cb028cd1040cdba11040511606aab7b3a61238ffb190e6814482454e9e397742d0e3bc824a8a565d75a15b56df8573f7c29d777c12fa8033c56a3932c130f930bea9d4b4902dea7753c439d1ee40977c291b74111e4521d63a0e53bcf17236ab0ff01f4f047c29caf90cb0dee3b204b3d5c60860859d8326de00a5a2c018cf048606730967510a6e3a5cc77de0288f3e16f786f2f7334db6819fa1b9e59d19850a940311af29eae81158ab02061402cfb2560423a4f9694593802b44f7e40efa1c6b17f6226efb25990631745edb967040df9fcd74a4f95dd4b9746cccb5c196a006476d345d7c96fe7a2076eda7b7883b4cea98f2f86f3a49e63d19d7ec7046cd6c351e43f64e67d3fbaa639747d51223a8e7ec040e06d5efef5a36acfbe280efa3d85372ce9975be71e3bad69f6fea1f0cfd8f1d87fdb73e5830e0600e9c052f52da207de6e36d6149ee5047f228e1bbb79743a5ebc27abf065afa254180137c6b88ba29bd956dba99e016cc9489112d1e98019376d233d6d9ed021c04bed11054b732d5fc1874acb87c0140cde1573468c4c8b83381d580d34748da92183276860dbe7cda163e74d9da4a9731b2b72dcfb0bf5d92549afc787b6d6d36824ca6c24b8b053a865d4cba481ad3b7ae61bd58a6389ee7901303ec01ed3c262c8ca5965101c83442a6caebedf45d6409b4b8cb55ec33124144233d896ace6373703bab0b57a1e4b8a11642ada332965f917bbe6334d77ad98fbc08f00ff8a5f8cfcd6d6ef4303468e03d8eb8426c645c1393beb821582a045e87fc73b69af587dea4d9533b278dbca0b5bd17d20e6dc556ae7601664b452d1d1e25d6ec95676eb45b9f66aa67b552c9f8110d3a83bb989f87a70c8dcaea820fa305a69088e6460e51eaa88a80b456db31b5831f35fb9897bd22d21b4a35664166f7442b2d0f0a6b2720120af81daed3eada8fe61a4abc48c6bad938964a0ffef04fab663bce75574738bed5a5ab5634fb9cdf032780273f9b3816adc1e3cfe06ad54426ec8d75ee572dd4c7ee80cb9fab3124123b0c402f28113ef3de76bd99bb01d85fc543cca1d5800a9f6f501c5f28f3977691360824989abe6e80a766812c00b6749169557baf82742acb8cbdfe10ba037650a19a42d20f9fcf91d95f7499095f5c02730e9bc7b23d5e581b488c34ee6cdc128f7af36ae44f731240e651a62005431544f695e98dbf4e941c064f86e98a654f8e7fed54aacb433d5b7e845e52864cf82dd70e6b4cb50648790dab8488c6aacf654a68693f53a1347792c7e9a2fb68e50812355b529565f186f2a5b4576a6cd51c6dbbb6f45ac77c67275c0375f052389ac86ebd327244cda88b62caa1f230d54455187bb72f097e3128c11a3267b83d727eea9095e1612a7ae449e39eece17464eeb3527fd9093e3607298a69992bde957f3bb076fd72a77edf88df51e8d04fdd79e2bbe066fe21d926b1eb594540966608f2abce9a629349f4f2e11fc3552d7e80ae2e7f2c767c5b09b8d2e0c0afbab55bb9476d48e6d191f5c066b4ef64d2de8d526c688cf7a7e66a777b0ec2c36dacfbd528a6f75bb7e207c12bf5c0c39a20210686f4870d31fe93fc7e93a5dcdb70b822d0365976e7e8d1a3972528b89bf5156a8951e92db10dd7aa1616e7df0a690cd0772f8b75e0897eb2ee0ae0b2c71e86b0b3ed829edc6813e27d5b90bbab46568e6839093a691bfbad44e9acf926993dffdf032d4e80163085a089439d1e977399c72438fcc3306936319285afeec11df3923dbe32ef8bc0074664ffe8f6744d64f794ecf8bf50ed6718a20112bbbfd6fc511c54008d8622776f8e8814d63a016251220aff96b3c1d8d711729cb4a6cb5c7c890e9aca6af3624478e5c283cbb5e9bbf059c692bec85914a36768ec843c09a5e105495bc61c15d051f5483b23598f613aa84922f891182e922ac51c8b4ddb16da3428bfd9709e32cf651d1f0cd884f9828a4b048744ade4440fa7d0fbffe700851cd32d38b23322fb8e2e496d1c6941cb4c383801a20b112ecae31c00f8b9492121f12d3c35ed92f16e1b8c3bcf68c64ecf71160318f304492ebf1d259302f511758f5cc8822622de49ce1a374bde22d844002fec11bf6dbf6e7379b45ca5e3fdac58d8b7a48b9058ae5990f155842d14ffc4988f16dd2f770b8f3b1af665aba0aff577c1b5da1c94abab347cba7a0753aeed5bb0d6e39688bb2d510800a2141989140edae6c6eee845dafbaac08a44e36131a682502cb4ac5deb4c233cab015ef5ecf58eefc988f92cb7893d06ad3e2487dc48d4a4677d20f042cb13220b7c205a8417d90921d664f9ebb3833825826f188a05313740afcb9bcdea081b6f5061c5d20a48e01ecc6fc2696a3a1c3def8402e7b1f195b6c0dcb8260277cbd983991c32cf37a8568e529c7f006fcf088c4dfe44a8c6a9f7e1fe314b2c5a9a05db072b60bd5d990333311ab57a89cf5aa161806ef39a3e57d00d9104c3e15af8ba1fa8273c466b077aea0e0c68e60ea08263624540df0e52d869967a00c56eec1483ecfb4dfccb10d85706d64328ccadb681071b79fbd0021fc68d41cf7be5cca44c489bc09f911a520247aabf76a76b1493ad718ea232ded0f7a65481554878612b86d80c0d50f6ee6e57b7f274e5174a14ceab8c63f0cf2a912623e3eaccda32f6c458bf40fc7e1b655be6d4ecdab1c476a7bb41200cdb3e014ac41754fc41ea3e3d5d4fe88bc14327c2740ee36faaa4a25b0369c8a833769ae2bf980a9b9297dbcb67295a023698f13f4dd0271fdaf7952a2e16f2156106619a09d912f55c4c9936e16d185ee1ed4a3c345dc53835eacaab9a966f96a56de3e1d5f4ed075875eda90be5ca6afdf79700a1441c4fd43fe1256270519968c77f3cdf8d40f17c7b9e3b117fa7cf65a30c42249c46c7c577b9ed98fc6efc779b22899dd7b7d6994acd6e952daf96a633d8cd583fc260ee113bf52ee9f5af9aabee566c56bc11c5b530cb9c350c9c034d8ce009caf77e7104c93993d90b1a1af830d05b134a2bbf8c51240f4e6bbb3bcfc4b69bf5a84370b92f73b0f3ecfc9838bc5ed470a53b8f46c9df6b383882014ecd831e5eae909b1322f4db34fa4fba54d92cbf7213da7fbe536b4e19fa6f2568c79306560c93b97c89f7f39d0ce4348fd63cfce3ca5ebc2ae2f1aae78a2476348c3292cf8d83efb99dcccfe8dfba3aabfd0f8d28d014c3063b7a2c0e8f75e7ead2c57da2d15d5fd1c859cfad647500ba7bdb615c1e7d574b2d09bfd0d0d988ed4d78b6c85ebf00728df48a782ab690c922c7055e7cc416b9e7e67b8e6035e8ba25bd53aa3b48765ff332337cc80ad94d8e910bc42639ba04fabc2d273880a7a1b844f0dfeb6b0ec12a77b498b360befac5c45dc37dc8d02eed441c94d63bf600a35df72f41f81714b032354495ffa6d9ac0be846dc025809776791cc1bf0d2626717a4243b4033ac95d105dfbb5c6b6ac6f33bbe610ea3ff236860027ef3af1d8d0fb828d5ace86346ad0d8cba11e802e2dc9026810e96991fcea5f64c3d51e130dfa97a0782f97f0ecadd185c99fb18ce9c8431f9ff9856071c6e6eb5d060128216597827b7bb2e1b9d37ae3dd8f50c170f6ac532e8637a70c9510fe5734d0d2b431f034ad58ee04960a1ca00dce5f8bb75827a8776001b45846a99b68b0490589f7adc1d7a1b300e964eb6a6aad87311134a444adf8f22e67465096392be26ee135a4b0b9f43112ba3c5aa7f80c106fbfd3a1462ff7f6de120c485034b69ba47b5eb90788dbf04ee73ae8f174e9e208e7cb1ab64ac02de44cef0a6e44533ed855d82b152a525f737c978d4f08958984f9b881624848d37136372583274fdea123b221a73e6cdfb6aded36b25296a5a328909b24fbf3ab8bf86bdace2281118e33ac24f6967e554c673b98e2f35f942c64fa4ceeb644cfcf669527b93b34d6fb13739deb7ef8ee5ca759c3a27b9ac34e0aefad8646b4356676813275856724210aa49a7a377da55bd68f341fc6a496fd4dbfdb91a79c76e40a3523336339d49c275513d0f0381947cc043febddbb78f5191c92eaa11f88826a41344ecf26184d4fd870ea1dbb2e85209819c6b43dd602530c6791d27351054273d6f5c2ef151317e6d782d1259a454c6a5f174ffce261d470bd6335e3fb82c5c8e1f9e84d3196fe1b30ae22253620f8dc65f13541c099f7aaff46b2a2a8ebc74154d23fdef6483337e18199eed7acbb5c4acdc69b231e3324a14d5c5d1551924465c37e0045b423f6152a6fb2007e5487717d4366b969e06730d12001f6cf6636f46e9d6369622f1d8bb9a8db236634e854f326d638ec2cca32b03e3e4beb9550b90e909efe357dab578aa9e0a187cd1700d6723e4ffe5ce3cb6fa7dd97485f944c18caf4894553f7592388e2a3d4e5d2f35e0b45d00d4e25b6cd38e190b1e2eac2e03c937b000d04d22a3152b939a7207aaa6cd2742e3aa61d982ce2412794b55d089f1e4351c3a36fc75e22870fbf92661eea288482ce7b37613524f18bf21278bd42a602a8f73ed39862ae22f7a197b4befac93b02b3dd8e9037b3a329a62db70ddfefd78a6f19e27e5ee69d28ee5318ebc285b4e6cc20fa637fb8f661838dc0a39fc63d117b1cde0bacdb4c59c34aad80bc3946975ebbc958764f071883373d70d4d30db0e0a09a69e2686d6ae1046b303331934bf05677ddd00ccc4060261a13917649e076c912cd29ed261551fa9fbcbf6dbb6f6e668713aba562fb5326f817a83bd05a7850f809fe9651697fbac25b9cdfbd5262302f7b3cf0fa1199b39e15bf31215b8aa3336e248b82729bffe61fa44e60c9b1b8bc398d3299550d89c6bfd2655ad0874fbcb2641541bfda4af388220fb3e85aa97466acb070a0e5eaefc5ac62beffb4b92be9867972371ebd3b83f01ee2ab8d1c778bd325fbd79eae8cba1257f0ecd422ccedbff1eb578c7ba361f5a3098c4e51c7cc78a4661331779d5843567887f6801b84c5f0fcd288a5923e72c6db191e1a074056f7832631bc7586b318e3963d0832a8c9803d9c981ecca373ed8b99f52b0c352077139879572cd88413eeb4ac5494ea963bf229f9b4255916afb4e87f81f3457c21434a0fb1818bbd15c2d5214db6b8249d9d4953c4eece720aea8c7eb87014c58b14fd574a43ac2512bf258104cc800a70afdf2871d0f460d08256bf4e781daf7c66dc6f88aae34eccc0925052c3557d40ba7c7668f227167c64cccbd3bd0cc561ad5aea771cbc659dc7955d78e092bd730b4dbdda7100c73045c3bb59334cec3d64b1f8e3048c728f3d4336e6644fa906a040c7be4887ba24a52f5ed3f51e8837f725dde87340a233cf8df04bf36f708cca06cb6ddbb82d4a930cad0f18971cdee88e93cc54d0a31a6022e4856b94ca7976371861fa5d55f4599f7be8118006608653b0fa0c7fb2cb38c353337a24c93a81f22dbf137d308c223b235e1240247a73d6170a7c65e14b299010552bc8bef6740594086f4b65b831b02a40caf5a9204906624a3d444b879df968ac6139bce3bc0750afd64f6f884210eb3d6fa95659ecbb5c896eb90f654c7bab5ff162849ce58b6646e1c5cc484815cb8841b52143b371a93e292a60a4dafce2d7447da877b32b44386898e5c67d6d3c3f39a46e4fbbf2e02f0b416c9565389c439d4e6ce8f3f66a5c5460ea179d886ee0e263c3d25350304cccbe612aa90db5093334da015570cc1953629a8f02f05185430ca5d7d37bb5eb973cbd135a4c0e6888d9f96502e0f52bec3999ee9f9f869b63aa2508ce2256860be790c44a7275b4d8f46b9e6c740ef578d839e197712d9e772d5af702caa019ea7c5e7272ea1c93ad19508798606aad2d0b5ac484d343fb2f2d5dcbe02f67ddbec345c76ad031afc70c60b0188f031a7c3f9f7c1d0894780ea025b97887b9054001fcc53bdcc4861890988fefe47db1a25c78aaaa11ae7c77bbb511e39a082380e9b1e0f43b65b588149c5f8134a6fce8555cf6740c291c9df9abe5ef5081e1ad8943411f9958b49a61f0281d18ce39dc9aa8687a86a20c6b9d317d3f9c2fdb0a531eeccafb08cb2244551560a1743a17e93d7931c94143ee6daa3b2228f1cab1ba61c98c403fb7290496d3186e9348d372d8bced7706667ec6f9a2012a2a2f57cc3c678388bcd28a910c6ee1d13be0c6f8455d08792683862f4b07324baafc52d8084610719e2b7e3b2a0e937852bfff50a713074706a912204a5f9464bb35130d20261c4c003a0216f7ede3c9513a180f5c3f44ddf67c28109199620a162f10bbbfdb15ad39ea9f9024c3bc9812971fcb3bf2a8feda1fb03a165ec30ef83945051a66286cf97af862ec1bc9b50fc12c0e8ddc9b5e8ebdfb5f288c63eeb09bf52041b794e8d0a36a07e784702e041ac41368051fa2fa588ee6bc2f422fc9d58dbe494e812b616c57686b000667557c917d3a83b289e0878dcb0ac7d652e3607b21e7b645ebd39486583fc4105e8ae4e1d442c6201c9c9118c0d2a27b3d54157b556ac606cbd60c8338c4fcdad29421297153178e0e4efa9a1f2b5a340312194851cf74e8b1947ddaca648dbb7b41e70405ec1d1e214956927670cd7ddfcc9527bc31714fe233dca23ed14ee933f1cfdde448559aa669045c4cd19254aa6d43d3da88984c834b89c9868b5e4f59784d98765fb928da4f66b86f7a1ec56c4852b8997929f2b97364b0c0aeccdc4c78db51e9be09d5bc5d2845860ea6bc9a487a305d37403dfebb0d9c224bb0a5f65306f26af22621aad0fd947a24d363fc75b8c1ea435a6075b6894da2f24c37bfa9f4ec534baacbf0a79f0af0a6182afe197f0b22887b0fd0a204d7a28db80240e4ddb059260d2eea66a8d9924f3017482c2c1a3e0c8508274ccab49e73d7cae0d515bbe9a597b31acf6ed85213571392d030e0585dd2e86d3c094b89690c3437ed927cad0d7f7f741510b7ed0081864fc07fce6bf0dc74a87afd3930fcc28e61c5dd6b8ea82272a3d0c249fcdbcd7c2c3ff0a48d3e918d46e2babf3cc4a26452af4ae1e58d4873ea84de2f6d2922f920044ab77d781cbbaccd1169a74aa6ffcbb17649a26021598a5e5853e34851b23290a78a7f01c46bc0d968086de7fc08cb10f5a42d186d878b2c28266e7456422cc305f9ed56335a3ffa03e76fea853fb6844dab950a0bc362b707bb0fa4f09d3c6381c914c1c17b0a3981a343c585112c8c2f9a0f654b57799a86492dbd6811c72993d146bb1b5638caa4bc9fbc574caed4bf5c05abf1bad758b31a614af90659a095b5a35c0cf70159c4f1daa30642fb65ad91c438f1b7ccbeb7befb04208bc1d9fb034abaff2d1978a330cae4c7c7787a99938d426a159ca0f1abe8cd730f700e62727a36b75447ae11d7f24382f0f7b89c0e7ee637921351436aa28a8c42a5e0767fb09f679ffc2973b4800593ee7d6c21f7f7185ff1b9cfd94ed8638c07432fb34008841b1187cba888ebd922c37762f9958368680db301cec564f49d323c7837e07b8d65e2639c8a757e31dfad7e67eb7b87261f967488c6357ad6be952b3b966f9bb6bb01aebbe2fd15d1c93ac28ee7eff0ea336c7d10f153c240737b93ff1bd0e312949c40e41c76e617e7d05b18f8f5b4e80ab3998b1188b7f8e8d0102f57963f284b831ff858f0c66ba186aae39d11bbfa5cb6ee5108ecac2524a00d7444ae66d9d7a82f769a30ff6a0fc721b2615bb564226030135bfa3a84af9767836e7349de3adb95a8a095ce6c09c044f495a845470b5b1d36580f215ded6bec0cd5af31718a3352851595eed7593d1e718c7660c3046f76a627761716abbdce06f5738039e8e1630f8b293562ee43a7feb51126c45f49ca400dee949715da497bf3321a4bcc8c80f00ba9ccac2bec87dfa3a2ef6a872eaf70045582e3da659425b28a0034f29bf67669983c0d50c75748e586301934def31b6a559d0744c60ac161653549e78c33f73df2722aab55b58ca099b1c8c09133267a262ee8fc5057cf2acd37b11ebb164eadb858bd07636e1a6f3e747554bf5f323718f2d57cabba83cd8b421c0e2c0302ae0533ba12755d35640bf86b3f9d23783e0889f5758c52e059cb0172f96de4af2fc8a98677bef8a43bee292fd2292f716cc43c9f0a7e36fbf0d5f8fa4e46d319566d0c474697640f0b7a1f25bf763400214bc4621532a8bfee0775e0cbf045d10132496cf46b2343bf241f32164fc8f4a622e8f4d2d3c08d3a9260fbe0912e3e79eadb4126b540b32403d5663b16f9046b6b5cccaa9c5b79072f5879c039582d7acb08f1dd2029fb0f63287b75c0a6ea6609761197dd2f3784e7772e4ac5671b50216a787548df665975608e3777aa946fb8933f68816f8c5be780391391055a724adfbe202d63b2fea8213de02a0c5547aebe00e9e4a9ddc053e57cc03988d9750428173ec6cc787e58fffef5440461d495cc0b50de89dc1a50801a2b73531121b1f09dfa44d2a8347b2031e92f0d51dbda0665a71b41b0d16a3923c0d82cd2513b166967afa5fd59c2210c1c1ba08643083c5432005267ab155ea77c9538332499248e6205baf7062c715202857e9352258979b0807f6726924e492bc0d4a59c85912dd211b00c5c59397663573ed3a43c10f4c2046a1a247b45c247ad1cffb43340aa9b414a8f8ce4cc7807f6f1cf3735ecd87b8a846663a7cf446101b474f986d75be9002a72f51a450e848d3231e5c4f35731d594130967ceae51d45faa97565098f74d27677cfb40820cc11d54276f0651eb5ba72e712024e3e9034501a1ee84fdc0cce95bed1c66a05130ce40b04d43934c39e779600cb819fc9dbfd99c44d00577919f4c6a6080f9a0f2327872a7cc8693bfa44d9db67e7ba6a3312a6381c68934b24d4d085842a812c8ceb39548127fd362d7bfe72a655ffbaa3ea2de303fa0b62700a6925d79af44f3aaa31362ba2e1ac3a8e3bcb28f79a4d05572d90bb58543ad2e24c5ec3bffe4a80493cb70c07c54defde74a7ecbbbe9a8a326376820672878e2d56cf104c523b5d3fb9650acc1792e05960f3f620e2ea8540c9def9bef26c442f7e65b53b8a80d44e48f792a9aa9a7ed4aa8a97f8cc363864d9931976f3bef6c40bdf22740fea635f1836cf03e2a079e05e2b938b50a37c5b2175f7f9cf355cc24712ce82441f7d71859223aea649390aab3e5a91efafa79e656aae6de9678361da26d9424ad3ee39fbbed7467f155d733ab3f4e0babc5fa50a611df2822fe3e64100f4399fea91a83cf0b26744bb7d07aa2e4ecfedbeec0790967ce219e0b172c510647016e5b60e6e200018c6efa2b0e5cae793e54f17ae5c6ac0a99ba8878b9bce8535b7c7d56f7be3805d30c6278bf3e472f461e8b3ed40533e037481c6bfd5bfa89711b77f334e1ba8120e406be8d5b9bd7c5a072d5b21e4d2ce97b6ada042f418ae8ed54e071ee177954f2c311e02ba712aa2afaaf92c9ea8d4feae63a67bda30ba03525689fa784793f8e5ae76ea90fa7101e47237d73a8aa15eeb6318482ad475e2381cbb91dee842ce3be0e81cb3315cbc541d64dd749a533c54dd421d58866b84ab93131f15c69cfc11f7a0a48e0d542b294600212b690a97a5a94b407fbeacb45a383c5a6520f16d640def820a4a5f3af588aa975d76174aab42ec3c4561da345a306d2524a4e9cc697daec4ba3f7765460ee59ea7a48645b8164bc8155508e44ba08859826ebb4c0a16bf707573cc9c9e26b4fdda2dead28769a2140ee5830183d02da572dccf9e6b98e868b3c8e28b0874cff0d3cd5cc65ccd8bb85e01058b819f3afc225f49cfccce1bef7d3557573f66d0ae2111e9095f01bfea195ae9427c2a84073e68a3687fdae06e4d34b40900120c87e6658990c485faf8addf2bf8c39a4a35ce80145815aace593bd0605e13a28aa25696fecd6427fa7e3b218b6de9a01e4a654032dced0e403bfdcae6ad53422d5f36b10866a5d0ac91e905ad73fe06cfbec0dfc59c722f029ca03a90e2b908387422229a6291d1b5b2370d52c207f89e793c01e03131b1d71824074931e6fa2c0a727393c8dda74a121cb96e9f8513b424037c965fa3c7e77c985a5c67025757a18011963eb77568a4cf32dcb667903e1d2107e8425bee2672a200ad6f3cfdf7efbcbb70d670df80b850a47906d7c54a2bb41e4e8be94295630ac0a9a17246d056bc099030f0657cc7b7a5d7d653172ad5a5ecf4f03c66334cb06fab7b6fd57d6865e5aefd39113c0277e25db316a342d226bf0750832cdf4f13d7fd9947cbc5b5ff9714eb82a9221c59f1ef8251c4513da8ccb37dac21da3f7211d5c981312af4be78dd87113392bc55732abaeebb3cc1e4e6741aba1bb0dec79bbfddc03bfa1f6de95101a08929de92656262e67b2353da6a1ea27e7a55e26205c60f2da7d6e175ca5da5eeed758e9a3dd53a0808f679ed2f76099ce8d9dee754f82d8dd50a681e9dd7bf7dfa7b830f33c76bafec1577a2e14933d6baf5b50663e9d6d49442070291c926bb68f7549b406f47a016dc53e7035d4a1adddc4485870feb6dc83354817d3c5fcdff9758e54e54843bff79250f2bdc161577a2942931cced22b0c7da196747ae3c1f9e9e4119901a212090d6237d3ff97f129baad33578fb7bb1bfb2287d24b88a2ad8af13ac31abd892ec00912a7d13befb8f3a7abe733437d21409e6751c331ea0af5bcdefd93d522ccfcfad4a347a0e09da75081aa26f4e9f3ba28829b1f20e6fd0bc0bb760a49f68e861700256cc98eef171b70af9e9f500148f2f1c440d4ab35e9305893e5708045187291007f6d58b946127b0b5c024ae5a139da3ce2a943e55e7d34c2c710e3050ec6ab5d5094cbf620522e2d4cf6e068ed84cb9ce73d2718e8f0d6ad72f2fbabc8018cbd754a40e75a9190093f314f64dc439f8bf8a8e7926238ca2ca19790a5ad89e8fcc0e83f5fb340626d819907508be937e895ac9e96c904843146b9431e7b2817a4f1bfffd250ea92dd7c73d8ce2f011a046d90b52db8d5d1f5b646516b3d3042165c0a0e3d562b54461cb21ea038291dcd146d91b8d5c645cc31fcd3a571421cf0767b6f912ddd97cac51e21d5401c431e43e6689d76263cc388a2a0524c3aabcc1c26f046744adc5ba664bdb01665901fe7ef80720ad126fb4b49b554c1251fb54a7bffe5c68ef8bc7628a3aaa11c564def1176e4b0b7138c9788c57c4d2a00af0118b10c8819f15ac3a8b935591e10df7940d744cd2608457a6276091aef439f561b181f0030eae0e683a7b5532bb51c057542e1fb00064db3944a824205f6ae802fb05254b9e090668d39f806584fb6c07a3c14c2e6800d57996fb82905b546301f5ed342bb0667318cee1b59cf081caa605cb73e23be56d055ed0ed3d987c041e72ab8e15145e3b655d6e0cabc77999a9678ef4f2e0328958cca22ce18ee176a3a190b26507f9a116f8958946126a46ef49ef8e72feeeb6928eac78c40e6be47a6ae9aeb105e8df838b826ed2c2d08b4d99b5adbf2ec9a935fcedcfbaffdbc97b7c5fce46b1efdf5dff138ff70b1ec36cf33afa080eea5eda09f8c858de9aa545b96eae002ab20e94498a3fe210c3dc85f3feb2590c34936aaaaa18374e1688da7359f4155f71906ce4641660047b90f09f81fff15b3cc7f03f34a497ddfc6286ced2ff05d6179e7874db375d53810fd1b9d82fe92ed638941e29ed442f45d1da427e7431289f9f492291c1e2c78075144085a7b48e5a043434c2a4110c6d0ae49910c9d9b7f579de532b8bf2268a1477c8a566b9b64bbd358643250ae8267b74b553f7fbd6af79af6fc69ee4467f8fabc6c418eeb86bd003dc064fa3e33b99e41119504baae7f16a936466d41458b2cb9463db1366d05d4e73d184935c7f86bd9accd3f2f7786528f7094f4664489412fef06a22232d487f6f47e965f38ddfe9906a8a964054a6d5f379c933696eab160691846cd4410b8e9594507d0b235b5757dd74787590d52bed842c42474d2c0ab3a43e4cfabbfe89c65213c75837b35f05e0c0da4702dda7a927eb1762bc5e62b6fdbf054a60425c634a8006d335c5293a52dc8cba22c3c29a59c68a7e339f4e1f3192545aa632b3ef6af9cc9368f7cb0d96ea6fd881c849afa3c8576d28edcbfa0c1afefe7060f57b04d4f599a52bd006af1d2e6613186248af872bf58ea73cb7e03ba6a65ccbc29cf6c13a19ca54d5d63d8918ddee39f38527b1daa50651182e2762b41b09b77273422e37eba0bfdfeee6200c0e77be31fda4d5a122b5913cdd74fcc8d5eba8ba476b9608dd8fd820019e1047143a5eb2985901839808228bfb53710bf880cf0d8480f82d91af943fd6f969315a8786b58a11f73e360f3d4319e54129eccf75cd7cf84a0bee8cb3af5dd85c138abf5623ad662e9fb888a1e76226ad8d47196a1b0d11f42a36e06b11c6d1b60d137f1ce253180a6a96dc854cccd9189f110213961b7902acac208a52b008607361e4775e9cdbccdcf8e2bc4d39075e67706850fa4bfe275e29c5501751efeb0c8a4d9c9d34369a6a68004af08ddcce2784bf8742660a1e8e8c25eef9636309552bf99f2572f965e404ac3dde085bf596cf794edd26b5fd571eab5dab2b14298c4a19a74f07622ecc31f5a3e09545e30a1031887fa5b038898331176edca74eb9f683713928c7b2711f141363892b1c11899c3961171009d331d4fc112aa83a971402adc7b719f08c2ca1a5bfb8cb0b2b8d280bdfb12ca51612c53356f467259f68d89f6bffdb00be8d0978a8fa48c27b9d9223f39e87b519e49a84dc3adbf9269581e64b1f91b3626a5a45242da296079e2493d02dd97f0f03d25861577022227661edfce1710ca747df2a003a1a8635f2746db8b92a48802432dee29f03bd2789d256e84d6c42a3bd97fe7d57c8543d1ac3676f7017bfb2c8be548976b63aafedad0728903321cfd99c8b7d38274b98a2d0b4a44c351d30d0c5cd6925f320a26386a141a4ada1899d9932261a06c330fabceea8e13623fdda362fe2934e88b1da62605e3bb24885ac394a37a696263b309be9cd6a463dd97dd29cc58dec4e1388548e0a03734f538372948a6490f958e7e6e1ca0b4107d4d68dccaee046f8c6b2f8e35e7209c3d427c2502aef3da39646bf1fa0d59844797eb0ddf01bd096acd9525444acd66ac1dc72e10a45db06e4be38f023a37d9a41e385273901f1fa4da79096bff2b12650182abfa89b0ae47f8da29ef944e106a4bb2d07c0f5bce93a7fa1664c77442bd5f0e92e5d87d236a3311e40758e92dce799b36a2957717626b82f1af32ef25a9c2f0c290fde2be467d88c4b560be260302468433ea11170d7e1b2226be377cfd486006ffd2b4f0bffe6efc1c454f17649acf53776e71b825841b26d16b176f480b09f8c76f9104b5329f8ef12209e8d1a8557abaaa304f989c41921aa951f75a8901af8702325c8432a96fd10a176e6cbe5490913cb4c8410241c7f3d92be9c05a40ac60ca26fd5fd1c43fc5d2fa8757a9881fbf8dda5bdc258541cef3c84b9cb051155f6db018950a1b5de56e54fa9cfa1a59d3fd17afb19242125183d91d52fd3a32898a4025a63d9cbf4053b2232675a8db1a190018585a1f6283f569f05c2c2cd102e144b09d0ff890c39e6b3ffac00d633ff514328b55821f14cb35e17961dedf5b97490b090537f39485caf08841db8ba952521ee39ae9154f32229928fe671b75b0cefcce5835e999d357db6cb08634e192ca8bd75aa9aca033ca21aaee771e9801d45b2a46b5af2e39b4a18770ce6331e696db9ad6158d964eb358dcefdde21370323594b3ed0d8d47598ac4fef8a55b0eec5a9ae8043f73ff24a4db3697d64fcd8bfb539bf525d56e032fb1550b15d1d35db6c56d4a61d76162df88e99a68a6716d236c338dbcbdcafb1e3dd2c5f7c2a6fa40234cbb7e92d50d2919870963cedd2d14f924373b500bd40707d34cbcd0e39820be12b8b8fc317254a8453932ad72c8c6d0ab63f07b1ddb02f081849df1703bfece4b73c32b9d0d88902d448836bb6bb71fcd768853ce8d50d47f6ad1e8179b1c5737f1dbd59785e51a7c1e60da5f696734d753c0179eaa5e5834a7f1dc7e417c929161796bcb04cb0c3cce0ee9f76611bdb9a5366bcfc391a348bdd16d7c3b745e09cfc0470d20b9ee5583765737cd26f6692a960506ff7d163c218b74169510f76c1d1730083682c7983f4d144b2d7a1a08a49adb3d2d108c75fb514bd80d32d8ba7a92b241ab9cc179e3a38494ff4510ce3309866e5cb6b21e30ab7d78e8be48e63277b9762a80beb60525345d9095a68cb9fdfb56b6c0325544868a1499b3b5c35c4da97d49fded35091561485ee6d43b5a0df38e9227e6fb5f6cb20a033369fab7b1a16716ad528c40258fc422a7efe667f0c685b0b0bf312e2a48b2fc93aeb853912fd5b53f5862bc4d1df51e4f09fe53045c33785df09bc4a60f43a791944850c4ad9d73889377375e01f107d2b21bea5cac666953267c05cf9888547dddc4f2cb2813f85df41a531826367929b7444e8bd1e3b6b356db0b9f30a49a901ab45755a6473f331a6532980d4b3cee43df86da29073236d9842c2e4b47dd2932922a8ecdacd73e675cdf5ee26e9e1175a9ea5e5757b51cc4af3e4f62552a5450d989b3acd38dd308d6ff49a2b22c1d872792570d0891544796ce4114feebc756ac1cf9af84d9c77f1e285515f27d9355a66d161c681edda0988050074d16ed4ed71d09665d75cce9efcd80391ff621d1acd45df2a0f0ace11880a189457bcf462ffb980f1b308da2c9964911b833de16237eaaea14cffc3770d7e705c244d969256bf9b88240f22a44ffe509c11804fe39e4e27ba4c13420a17f40fe3fd4f5fe52743cde75e3d8e0a486a422c181addb6bb954324adeb88111f04c258a7507aa886459cc3bb0e46c3ced84a4046e910092460278ae2e6eed2836db08212e98f2467568a98166f9fb7dfab2169505551c31c6cf04befdadca57cbb16f998e20caa262853ccb0933acfc6ecf0c5ce693b7f6b78099504d9c271be4e713e00bc7e043b4ea503140158bdf91f2dd4b8e488afb15099de6ff052f43b28b3292a41b6b3a22650488b89b535b3d7237f318eaa59eaf42b0d60827d3d90c5edc85f016e2dc55a70aae8da4e3f059cffb8e9a02ee758f8b7ef9ee1f1d3e17da2bd8908d50c53e6632bad8d823ce73caea24a4eba08e7c08a40be5f14c68f965a0257c3dd071de2782529da349620a7f52a586714f4db4855876521685d606fa0950a9aef07d7099aba853575c8eb3fd278d775b3e0d3cd0b633a239a6164a2e47a2a29d20e67789f291e7079380e3c9b635dec1f1da1a48fdd5aa0d469b622e72474ecb56d8391194844ccb11e04d5914a9b20eea0753f57e0cb4813606eab41615dcf31de5c289160f164a699001bcd6491989ce8fd5f6cd11b857cd08a361eee399beb9df73bdcbf24ce5de9fb46c002cdeb5c5a18e31961bbbb671bdfefb846665aab769feea714337871b785827159e1f84876d0227a45066e4e527be9dd288c4811237d6617a563c91e8eac1eb43ab1ea23bb6de1cad233db6cf67835ed950869f28a42bde6eea45a2ed13ac894d3ed95f78b04e3891d2484c7bbb81dcb4672eca237a33470ba6b90cd747336e71bc23a1e8ac1ffe418305af2da2f993d29a2fe60ed7f8c25b4bb83c059a50a43f335e23356e283316b2a4494547c60353bafd303e6ef1ff86c8b5ee00d112b51813795c71ccd3d3b83dcba748881b5e5f7458a0fb1dea01066e3bf13095579346beaa55f567e4cb7e41b7258355e6456f7fa821d3925ef576407acffb42d6fe842d6eab36feee680d16824581a23d960953c447a5207bc86b320683e472fd190e80904035cf4570830db21ddcdb202aa62a7de47cd3b3fce726958d9c159c7f12f6a66fa52dbd76ae05d407b4240f7ecefac7d6668b1a7380ff992b18ac31c8bdcb85b326eed495fc3a5eb58cd6d6733714131daab70dd6b6a39376eaf197f9d335b7b1479dc3e635ea8a404dcb714206f9aedc7bcf5853c816d9ea2e4086d5802df1313685d09e47dda50e345b589a089bd987cc7de4bb3e909c049bb0210b71b1d4586d77225241cf7cebe2b8d1912ef39b03d9af5dc779fc981b1ef2ab935dcd4df10ae6c1f44f77c04cccb5abb7c3611d9120f0f0c5b5144dc28e625d23aff97e4a4174230427828739bc54c1f80872619dd236b264a686a599243d6c364f6199757b082cbba5c36f1b4c53f338aa686efa8d1a1286ee63177f3804a05c7b38d93ab39b97ee49cad6b9b4c0c2c9d0702a9935a0e31299730e659bb09fb313a0a3633f9ba1c913c7f5f7a837b27f505720b970470e507784f11b3d3dadd00e81074c52260318c3cfd5c350c6817ed0724f9dbbfce4404e480e72c3701f09dcb573f82c451389f363627d7afc7f356e379835cdb522b8c1280a5ce1a1bdd5034dbb55b31e8c4619a61e0b8d2b730f88be42b808f7eaad7a121ced8d26a14280f7cc91030966cde2a2762dfb1d595d95af7a9d0dff5d7bedbb2299eabd00a200b86bebd2f6027aa460a3d4927d2f49a5ec8184305b4aa58abc9bdd6204be6fdc8c5aabe34cd5ddae60a16477c8bf342da230a7c99ede7fe1eecc7dcadb35ac7fbd9051841a07b2be4ad13dd8490bc814dbc95e3bf25fce7e285f51e70487faba448d578da719fac354415d33852eefb52f132def56cb1a92ad2f17782fa19735e13f7b23821f54376c13b1cb8c8d28ce386ded3ee79aeea5586e1091a37206c5b40683c31c31318ea3938e89b05a488efba47150929de940a5bfe3aa816dc1dfc2d49253cebbafad95a7f22a1872a4cfc7ce24d8eae97bab68fd248bfe31072379fd3d56e3b69ec5298a53b85105921899290f5bc5533e7506a67ad8e015d484c7115dfb119831346a77604e8742a67176f10d8ed96df12209f6cbf490802deec3b51d1fbc086b8766bd3dc11070bfeaccdce138c823a1b37dc01ba8a371887b3b461b2363ead98317639ab3e783a2996187fa74e2f3623acc380364922855d90a057e6dcd2aad13b7f20368d86a461b5329f4ea98f04c2fa732bdcbe0237bd7c7169d792ca4874e657a244359ba67e2ac87cd5db2becd3bcec2e81bd6d6a891315fe124c564cf932dc20d624afe09cb3df054222565eb3e8297039b9d8f1252bc49af879d26e77dde1d4164af8be8c2d1a1ff55f8483948f6de5cbea6d58267c8f9dd8954a097ad54ec59b3fa87db26a2def5a19ead4eb033eb916640d0179dcff0785ca93d16e56962870f27f834cc194e0a06034ee0916224eb58178429d8749f73be74d013e2badf6c29a7535217373d2fc19a114df4fbfe2446d01e8eb56aa8eb9246bbfbb551b94d6c816dfe2489b783ddd1d523e554fde848a566b5518b3b948bb17469d929f1a379146d5aafc8e96b747afc2264f74f7609314640928d239f5d89f26140e6de78106c44c7594d916543d1288d28c9168b86274cbdae74311d02fe4661992df28cf3d1c2c055a66c9621d0ae0d24bb028b2cbe7340c42583afb2cfcfe335997d2309ea1b8063d2eedee58e281b5a0a1b833663e59cffe1d752fafae4f8edb5fab6195dfbbe2434133b9b492d6e3ef05f6eb149e8f37ba3294912941f2cc66d046c64b924cb06a12d73c6ee4c1e78e530bf17ff477c56413d9ed0d8a97e2b9e7e7810d2637227143e165f0a25481ea0a58b290cdc66961b8da1af6cc61cb38e2004983da5fa061fbf73f4e9ef504e3889bfaaaa7a7c5232574e51b6aede1415d0170624ad0f90ba1cb43cb8343de12ee6f6a69702945110a2d46369ba6da1c963ffb49cfed3bfd2bc1748e6117efb1af8337a2bcbce5bfd2c7975bda7e9799ecd40819e4b16f69b29f19edc4e68c4bf19c7506a66049e267ada68f2a89934fe8c3ee8257132b1b533e107beb7bc208a4a6bb923c421f402ea5ac9b31422c30b322f678690c570280639000ca13473f8f4b3f97d7f7ddba67ec6218e9a7f50c3246f1eaa8041befc5499b6faa235ae0a208c79952a76b7d70b0f61a8cd39b0b515ccb5a929497935c422d02ecf2fef32ffa7ca8f612e53dd19644cc2d3fc88476dd4ab365b69f035ba313f0a27f99727f1cf39e6d6557afbe0f4ca603eb8f47ceadddbd23bcba30ac4c7ed957a7ad9b42b3f0c9d42e1beabb7fe5e907effc9b681a7b2ca531de2e224aeb4c3490c99555e3116bd30b2cafa9b250b76e907b21e6431c51b4e64dd2d3d0f4aba14a9212515ded4b277c0daa5bf7d266120f68d7124ef13c478b6862a8016ac6c1ca86cbee239a9f15c926ca89750088acf69744273d4017493501359073c8c41d587538374c895769ec46952af318c9a0352b563000f602402132e04c2b9dd813ad1f070de7dc2f9c777bce234984cc93d0af76298777a6366d9ea21f2556e507d81769fc0691ef4915efbed47fee3a9ccfc41fc124264b7bbf3bd99458cbdad5086dba17f98cf14f014ab75dbc8cc2e8c55ba119dc0f24fa3cc15454337577526a28b2a6e22d8c2eef32a5613c3836210927b6f8cf3b4af652e9274c17804b6fa7b587f595c0716fa721ad4ff52a094fb7d0d2c9fed3491f4248e8b4416545f77185e18d6cb2d097b519cd69bda311f5e5b6fbe1318174b2af8fd5231cd114745000f1ee7d5169863956670d158ccb1ba55addf9f9ef35e507d3f0149552822b4aca0cb93a4e9f1473d8a8d4ca25bec071a1605b4c9c1aee2000db60b0a57795f4cb619065a9ba70a99f9f7d8ebfc7a9cb4424b1e671e235d57a59ebaf225088223107cbd53b6cd6d5f2d6b4a8a2d7628767536d694e4377b12452e4ba981bcb5d14c21ee355005acbae43313c6567994cad4a40f8695776e8c07c79ae345742777a1e78e9baf651936caa4bae688472e43d3d2f79eb3ae88cfc37d3d7e271e43abca7fd9f8adbac112574ea9181135ab6b106b15db5943f2d34b22701519a79250748f651e6bb9dbc19037b5a1d5294b5680b301421f5ea5eaff2be81107350dee30fb860cc382fda4d88d4087c45786b18894bafab77a198041ec18e920cbe658e76b81cd5fe94014d346c0e973d5d7804ac796fa4813e80ecd29c8839576e34c131cc8245144f3625f544576a1b227f7378e9357909eea4a25033c02301dfd22ba12dbf77ed5bded938ed77bbd9f6aac6b9d01dca5484a5014e978f41b2783fb15612fa589aabbae7e9ac98753f884b434ce321746d13353e22cfe020c3e17f8b03e4b1960c25c5f5aa0daff5f57f11a05fca4cc305e8c8022003241002bdc650944ad280a8a097d4fc90f269bf7811072c70ba185d765c972fe2222f24e70ced04b176046393431c35ca7a722b884d3229cbd7692b57691d1899bbb057f25b314ad9d7bbbce842f9d36c1c8a91979790ab7c4eefff56ffd2fc5f77bcd3930cb7942ab6d572a4881ada44584884f2e7b745879fe13e8102b97968b7ed84e72539a11bb6cdce25b859bb53931e5f4140934c4f530078ba2c51168f23a160530d9632f2853e94f523e731ab9062a9ba0225347d2060a65f5ae613f48c50ad16186c50f599b69267bd04a0bf40a8c7cccfcf69e794994347cbe194b743a5f9be19540d0c55528f661fa0a31708bc381693880fb343cb9c8010d344f0ddfd7a858b508c784144d592a0dca9428f5085eed34dc9ddb7b1dacde67bb66b2cb24611981a606355c926061c1d5c231a55296410f4fda2d3b51bccdd0068d6850e0cc8293d7f982a2f8ca34302b5440e4266bf6e6ba42fa1365a724d60f363bee6aea083ff865e067e94fa50fbef548fa1d333d5d76b0ceffb5653a535baa7e3a0d9ecf352da6e4e4a4d8f2da766eb54804496affd3624f033a14a29579abdef67f4a0a603221c45b0a5b9d9f6b257ee237866715b289de0159ede8070e57d88768b65f42db8933ac289e33ef35e4001fe325a5bf7a1cb40f8293514ddb93a7ec4e7dd98b3fbc9cd0918c0d2593c3e5239dfad69602c198edf5703258d3f722c8f1f965ffe73955a2968cbf4348c5fd3e68786d36442ea6528e6e37a954d176a112ef12924d91da39afe96d7d4b4710425089f130f305f229082cdf233c39e35decb07ebc7a5597356c410abd834f8c04de17793b3f5d63f3b34d5019117d0b07cffe26f528627cf7a3f0d9e4300b82b96b3896f4eac078718eb785d566559cc1c39536cedfd6cceaec1cbee3b8e8a20bc5dada8a3e0bc2fdce79871a767adc1f4d436cbb72053981e210d322f0891f08ea822c89458052b2961a9791ed64bbab63bc609575819c043d81281cfee149540e481f879fb876585d7eb3783b46b0f78b887e0472e78cb3cd3066345ddbbcf6d09f5cea520fc3f334dfccabaf9c9e7ad8fcf8b9b62e391eb2d7ba8c974d53e3f3a2bbf41ed98143c9c189576665f7e24235c234a929563e92b9ea464def3b1c99da7f3d1cdb4b8e5a5a2131573593815fa05e5e0373cef82869c2920ae5180b5e91508c665f6661d21775699e364658050e8bbd5da690afcc8069112e8427f18e116f5e0c48efb5952e30fa8a43bd7857d6a0237993a84f9fdec82d771afd6fee61799ae798635400d0d9fd79c06738b61951294768a57571478333d5a7a14b340755801ab1ee19f83bfb11beb462182faa789fc096c740733cafc3fd15d27589f1cbad1a89690e368db9cdd613111810f2928ae3d4bba160993c6e6f930a8bbbbbd754d42c897a555c3571420f2ecefa0c03dac565a0b27d3bc6ce6f94734eeef5a4182bb6d35f9762a8570aade5933089678f0e81ea654050e7f669cb5c8478ee91790f7b766a27a3df71df0cda3a6d952d56a148514cc56edc1ffff100dc1997cb6d68b3008fabb26dd06ab1ba8b35472606c3cc662dc0d1ca9d717eb94bbadb1917fa8cd5d3eef814b28385715ec7626b1cd7018f04439665301ccf7b58ca4c61fe985f1f992bee8d91841c292529716b1bf0aa365412b2b7e076f80c0f3d1bbce9ee6fdb8b96dfcf549fede1dd7db86aa9ae613bd649c76b056b3f31d85808ff8918ac334f1a94a63cf9ccdd3a0d2a1d94d35899018654836c50fc544748e5fb00ff9daa51b910e35f1e8e3208b5d773d6e717315112ba8ba45bd3f39ba41440c3be8a8564efcfea50249a9af73bf352f00cae67dd3ecad67d04f0ecd3725ce1fcc9657ff568d1a1c7753192eba1f236d92d56fe53090e0c2a15543d188e495185fe11c8227abfc3cfc7c7f3a8222a79e622461e8745830dd7b62f623f9d7c4e87fe9d97146c5b8b391aa5fe4d5b21ae826e343f505079f0b6758a33385703c31aa79334826c079f78167dd90efd1de7bc15b29259d013f1c7ce0d5b058af6119707948400ed6264ce7f26636708e62c4c09ea0eae6b5bac3c33fabec658f3c9c733b0b47a973d6a90ee9c2463e0bbc7642257be729f319b200f373e8697d1a7faa43803ee65090021787b85d062f26c62b36b98aa4a86f2038c557a72016996514972bf600e15864f9b3738e3aaf3de9e83de7e9cac7bc43a103d943d39e5c542bb76a7e1714373da3cd9d0f160c32b2788e727a75d87dfe81f71d17527e47ba32f4da580a0d4d3ce31e7d78801501c036b6fb34cbe77e923a7ee300b63cb8b803b61982cbf00a68599cb3d52d79826c2c93e4195c3e384d4ae2d39e494fd856a63474e9377ec5d653b5174a0f52a6fc6434403d1074ba179785da00724782e63970e047bf572e6fb586d8127214990450d1f22b3efbd499425c8712f9e078e28cf25943c2003347d1e493121a2612de63fda8f212b792c861130fa385803d90479726f71f100ca7ce58c2dd6f367f95eadcea78cb2554aa815fe07872a74195af1b9dd9f6d29c4c0d0c8f9700261fc71a310d8e0ce7c63d9c78504bd756ccc3eb646fb2a3d8478ce3f1959795cf328008d144338e8816c819de8aab85573e7027d0aaa2d4c3bd3f1c55ed4b36edf87e73af1f3a21c97e92d03e29c36da3ee46c1e222e74daacd59e97ccff19ceb4ba00364aa1621f4feff10fa8d9464a57f6f7e51c112d329907f6e05827efbd754fb608d9044578a9dbea98860988c9c8f5feadb2551d301a6c115b515323cc7b363a3129bcb2790d5176dd5ccc8acd443e9149cce8902617fb27910b012777162f66423e930ff474d7da0792cc5296a4c702ee9706704fa3488e802c34160645848e7574eb9dc83f569a4e3b8fc0dc5cfa657ba7c206ecc6042abe46f9e94702b9adff230ea74ed69362d03d1a1e64ad1a1def70bca0dce4bc955f825cbe1cf395e1bee51e9a0747380d4c74597bb0d047f660523a115da72f1b8fc25409bf76f28ba36113afd8e62dc935e659a707eccdf1ea48f157b69ffe077a6dd4c94ade69a6fd114dcfdf4dbc0d022e4fc82c19ebb7d181d90ec610f458667d8400d521fff0e695f3b5d97ed64df44e1d60806d39bc68b1106f012981c0a69ec935848f0d512d91fa04d862cbe5276c0fdd7ef80f2f15793790151673e94ab693515a034f7434afa3302d8b72868146307f0dc455ab1b19a378a414ded79bd19a87af03326e85c8f5c64bd5030d7b1e83a78d3dd32110089e40c9ae7e6fb2f46dd50d3a9d7ed46fae2d4e9396f1d47348e4b215aa937e78b4bb443ccdf1fe932a972c285b07a86fe2dedda13a9e444226ab98fda41c7f8f15add624c484af27b4e975dddb9c3cd07f8948c3fd4470f4aa47f26060dc2f350c14f0c765cc9961ac2228f59b035e33764be43cdb29ecd357e99d21de85615f47bf805218d82228adea2f2ea4d9bc22145649a3f0096865db32245d5004c793239267e441795fc4f772f72f08f8e3301cac3be7022bd5c278d16d1c37935cae70b52b029d6f330e1ef3a37d19b185b0a8c31bd6d817cdda15aec2b144c872c66b18b9445fd84523f40fa2518d13cc85891c7913432e76d09c137ccfbaa7d8c5ea0382ea33fc59e9b60a66ba41f052bba5b5a3817195d4ab20ee4d18a68959a51fac19289e212d49e1d42cb2118be1d7e5b323dbc703fcf22d7e79b99bbab111627f4c128b45cc9078443accd491e567389e350fb548c0f38d9d8ff92580a2cc5a6eea2a2259692b656919287deedccd387e4a6b41f1f8202756db42a4486ef3248ae11732fef13798bacf2deb7336ccd7939b0ee6127b3e283d44dd0d550ab008250105e506d3d293144d56417d2a205e52bcda8dc2c84d54cc207eb179bcf5c5a1dd433a273ae94150d7f1a25dec8abf25f5e2ac10591da3cada9cbe5431aea69cc1d6a0183a436e2f48e3150418f533eec29bb942260fb6ef93e029448f5fefb4535e70ed2542da4020d093d9216dc3aa09c34b4f7d39f28d9306ece54d642cc34a4b270ec5e91138eee76cd7da6ef822159919e824652fc03b9aa5a19fb8c0dca09f3b8e9152fcbee585e777c84bcff4b9c241df180096dba6a12c9ff6d5be767331f7089edc492f97778974efe8020034211d6760da7d48f4cf2a5b2155b9f161a08aa20b1817bc99b4269d83885ad76eed9d836b397dda913ca13da2124163e6f4780a7d258f2ace5a91b49be25b10a8b1efa82443d65f00456109f84e0fdad9aeec9eede3946766fe90398b949b47e12532ba8bb50ac6826fc65a70b01c4578746042049c4de1a2c0563269cbb7287f63dd614de0d91667f440155d797622dee6281b0543b247fd28016409cde3c79fb33d88d774d5d89ae21835a49885edbeaee32ff94036404ff32dea61290572ec4991cad883be26877f21caf7558b2223092cea9c44bb930205ffd18b9835084b5582e7a8f1dfd764cbe8c04b28e6556fa7e3efc8d2b75146bf643378b4ae73a0fa45d434e481c178babbfb57ffe9a0906f1b4649cb4ee73892d550fe731fb2635d92699de2f89eaf2cbe209d19095608ace0c5f3b75452a674433cf9ec4b91c7cc15812904471e695b3e29ac6d990a138b3e8860b7cf722e9487b06648e4d9061823b5e9c8322e02303f7f733b0d1eeebc7601ec1ed729d915772b24682d68a697f60f39adac3863653607ead02665a3d338f614240bf8fe40f2d4248039ca29ac2bcd37510dd21a129c2f4e700042337fa0e0b199cdd72e11f945b29a8ed96a7e888739cf1305c909d895cdd703a2acffc0c2597d1b06294801d6a1faddcc3072da4b5724c1437303cfddf13e62eb4093458ee46b570d1a9838ec203f9816e0158d7399152e75b8920070cf0a5566f6ebf2074c19700b08302b204eb2f5b1d3c67ad07a7efbe34e22ca217c9f9e30382214b3697f955eabd4a691fe3e02ea5aafc493558249301f2ffc8465026bf62066fd454d6a4dfc1ce050767f1c9f833285114ad7579147de7caefce9435646084f29016fb4754e2e714c2ffa1a87174b07d84959e4c9afa2697d4ae74d976deb86f44c3755151de9a334a32b4bb164678faccf6e76fe990623eb80b93d0b3b05b7f0c056873e672fc080918afd84d89d93a54ba0dd021fbe0df2076768eeff1a0df295cd00ef327c2aad8ecd10db171fb9fe5c66f9a7f30b5589a26a7bb56e899250ca2755ee8542b713ab60026dd5fdab6a18361ccfb9f737b36fd17e3c673e7c7e034515ac1f8fa15e57d0472555aed46fd98d714d950a121d9ae1c91f8a2e4f09acda99ae2f888ba9dac0b4f5bd756b39cb2583149843fe74371a6dbce69291a7f40e7e7f673340c829449d634fbae894f10b5a9f458ca8829e07ccbb469969f7c6fbd99ec95f22af08430a3a198dbcc5c36cd76713eea5c3f48964b78ad097e3bc94722c4f2b97c7515f0e5049b6be05991f2cf978bd1ff763d6c921f067e3cab0fce21d77964dca35fe85ef75295397cd31a2e20985dd99499171f2e6817c155ce43d3a26b638c30542ea5e2cce7dd7c4eb551fa4c5b0f3ebd883755ea7c2647a2a3844966a4bb9de8421c2fac3036dd22a6980795cedd2df389d15c5e65e76851ddb7934525584cb7626ec0b08469e37507bbe1164fe5688d7ef7d95a9fceeda8508d50416fd85294ac160e8dd3bdc55e6d158eaf34d5996fad5021c9fec90d2429cc7753a6a55a52c6e1a7d1ae3caf5a40b46c4976770b81e54654f1dc92ffdd9f768c53356f8ac07eb820b62d6723a86b4dfcd70107ffc7123d9610c3dc49acfc106a833533cd64f1a990bbac7a015691c216d386f295940516d45b065cad050559d177e37ed15b4f70a72ed8595a11a6248e25889803ba87cac3b91e1de996631d5185f128ad091bafb87d9bf0bc7cddc10d0b7dcbc45a1c765c1232b2abbd677a89e10acdbb4e1ca34c18d8815eaf029045cf19e856d0203b16f4c3ec8272e75bd475043fb995fffb01c4573c734fb9a25ccf7e8ebc5c02fe2fd34677da5ca7f2d57a91689877a5d1820ad729d6bd64fa3a9cc1f861d2214136b21b257f300b2e52da5d548eb396f234f4ca60245820610fc96de732fe2a689c2da0b142a49b0f858d857c1358375a2267426d7eb23658c6a90588daf836460443c7cf1565e33650abb8b637deee42f2d7d3a0680b23af8c12482832099436d1bb2e048d947e6c07409707061b2379315cde6a9ca2e521a2b385a8cfd5e5e7466c4548eb9f9bb4206a6d3b4346097b3efc7cb7e3d4e12395cf43189e3c73bf84bf6575952ec609980cc323c786c7750cd8641be728beb025989e50b46091310bfaaa0b0bba92f260e4e2f94f08be596808133f6b408f87f937ebf3b76262493cda3b1ec0bc95683bbf1b20ccaec7ab6aa6326d0b9218c1714d081b894cb82ea3a643538159c095127c3b32c2d8beafee45cd81549ed048b0e218130cc352b935db01cb0e9c9b6e3a498f906de915dd45478a7a5c6347e1818b97731eddb3ef8d83255d39abea3a26f853e54f776dddf53d054781171f29077c9bda2bae20c2297eb28afaf7b3562ccaa54d738f206555ca9d978d42ce580b9c080f095335dcf32bbd5aedfcabb1862ae721f84c4648f5dae12e68c1286810790ca21a8c10f6b613ee93675b5abade25e4bb4b2b20dc1377442ce12ee81efbdfa8ccf62acdcff99d95c7cf5578091d7284ceea37367a77a1889b30ed8b06889fb87e0745cfc2c795fe7b35935ad347adea0a133fd9bdd4543cb3ca6d157ba4dc3655089ee1452d6985a50fcb975c1cad23eaf5c3d7beecf65a4b4a74e32e68ce56def98d60ff6153de045490b45a9a16472caa4a880fac1d0a2eb8cefb0deaddc69a47561eb36626e793f093101718fdce99c3bb02b0088270127715d2bf18e5bb4fc7557bdb909d43e9ba3b5f124c86592b197811effc02c4fd9716e0f5351db0bbe87606efb8e52ea977acd31b06ed391f70264323cd463be8162cf613bcd7adb7323d2cc5de7c389507b7fc1c32b59857f0f83cda720cec2698ad7b71ca107c1c73584c696e688d68a71afebddfa90f6d904dd9af5cacbe4795b1ae851cb73f9103858b803a1665770471e53b89d09dd0fb93b068c76df4742ad271f150d00d806eb914e02c29d727999bc1c5b9e4ac7c22ddeed9ff9868f226fbd2996ba8688fdcab2fe2ba2e2f2d7c307bebad40b79c655e79c24e2065758920b69838f6559b285138b7936c586551933f89c812e70f2af8511be80ecd21434fc9826f10840561fdbd28539f47ea7a2ebc607d2066ade949f63eb4d177c63809b2aabce030a74c380e896bfb782b675655e1a95ba98b7cfe8fcf30db6d7692b0da75f252383fb43cc899f7dce5d10ae17d55f21cbfb73d73a1d71ef78804d8abc226d9ac28179d9b070d01d446fccba3bf05e96bc342ded2d28583cd3bcd31170aed6c92e97848906f39d4c1257db5c924b4deea52cf7330653147fd04449deab9f1c3f300ae99b0ba165253ba5633cb9338c7d48f5a68993cff66da369dba446fafe0cc00c9deffc03218fb2cd929051c1ed1c6db65b1cf2013856a30ac95e87cc979f02b2b71feb4df41bcb03fb8ab3b4e2a559963b4c28bd886ad6489cd9eec72da50552be33799a75652da5b294d02b3ab7b631346a416c6774e5bb048ab24a28918980d38232eb22071012fa684a9123a47f6f5d6ae8c04606401667d729098406d2756bc23dd3f21ad633ca746b06a2bd50f805ff2cb065bb5452a100ff6a04876dd0a5aada2869b8082a825e49c1683fe070b24430630566038e10f3090578c86be8767bd8f40d9cfc469bd261237450ad52036f238fb88bab39bd15ca333fc731e026b44bcad1e9954cbd99790d5fc9773907d69e186fcacb019f9405c86f325278e615e4b478656c28230f22362cf5f11b0e51b668f4d83ebb71c64cf6a4bea6bd0ec7678209ba495850081ff85334280ddb0e6c79aaaa4b4f801e04e8bf39001efe58ee59d645d2d944cb47431b3c1ffa3e708b6992cdafc0369aeb1b2f9272273528d9e8999f4d2c9d06f108070144e3191198a42f92dd4c824ca015dd24abff5304da60d8620ac647ffc6de2f4aebb58051c76dbbaa40369e8b0eea7eca5acfe8df13cefddaad1a05e113527e6c181cf6e2f55ebe3532f7c7908a7d0cc528de2245f1341412af697fa75fec751b78c1a8cd5e66c829b7098f5f0b15a7eb59cb4e4cbec82aecb59d6ed3b2f9bfac8142af9bfc14c513ae29a40064cc4005ea3bbd974ec29bd9b36d7077b5a3482f7ebd9006bbc1d83120cb54967994604869417371e930bb644076e09d8c1016d0d1e5915cb8a4b2a3622a20410d018e1d33c4565e534ef0239ef3c5f4df3fbd8eaa30614e9a9a13717792d54f3395466e436d6aaed9e05fe181e1897f793266df204a6cf41a5e1a22c75eb0310b603163d56a0c5cf62a06abe9ce9ce92431101ac88f02c10f83af4867c1b0736e52811e0e0ccab71acc05fc6b51d115cfbd1e555e7599c9aa8f36bed7f3b2e3ed6ffd797f90e00008fe8f40faa1fdaffff1a3e6ba071f934daa7dec2c3aac7dd58edba76629e613a2e5af3b9488e3b4876f69de87e9bdec975bb2048469caee1fa5190f7d5bb3acf78cdca2eb18e477ab7b7900c9bfb89517bdc836e985701fe0c11e60553a6c26600718270e5e742da98d079deb9843b0956c43bbb460b17e62581df69898c5cba92133edb539bc884c851d35481a47fa59044ef19493c0edf74c9d92c080beea36856b8f2bdf0e0eedaebba63bfe04a711f280de0dcafc104533266ebb9b797aa8afbe524bd39606660538279f4609a0c3e62bf7033beb5e5577023fe0793c81f0cac02a66bc9789d9453ff71a36527e7f3687a5b3943358d73f1420f1e108895ffbbf27b48ce3753f1e1d0a9e3a3ac87ae9caa366a98a454ad1d5bd9e279bcc613c5c4c07169852a632534505640e36d401dd2882a46caf71fc6d32c1f96ab8f24b51d8a0ed903018e419423b2c06d068fe3fbd2fc069d3664fefc74305a7c3d308523cce96687fc1c1353a4c541a701eeb3420557bf49576252548655ce197ee6d07ac7ac5d76e2aa6d593a2f17b900b6628641776bfb09498219d7e3cb6645dc8f43be409f53a838dce37af39008cdacec084d41e014bd4a3efe7494eb46750f8144a9257d0ced5483da09f117e30185b05da8bd76cd6fd2180bdf904115c5f299547af0398dfc910113c6e8d7952b7fe6806c9210cde8948ba712d5c50960c8e6929a4576d76ac45636c05fa868fe0ef97b509cc208af1a4c4acec35e9fa03395718b672d8d72b5b6788dd2789d70c4768e12817466bedc3843ed5ce9c1cc9575e1c57fad650cba023f9e48f0d2c11566ad89c179e07fe6a0be8309ce3ed0ef1467c117b31eaf45161ba0875ab68e37c99be49e00af638e34d373d82454868667b7a29825105a82546995e7a5b54305bf884a4cbffe05d5d1760c522578ce385e595c47f44ffd17f3d7ae0f1d5b8cf92d47d88ca5f4eda8b20b733584be50f2c2d4efc7fb3af3258a3ea4f6ce7897108eb5fa3655266c0a981a5b5dbbd213857b71f5e13c431bc3a19838ced65ba176beae3218cc20cc23d36ea3b38391511b530b27dd1c25c2aa1b509ef949a83cc9f02c189ab356bacae231b7bc748766becab4886d03822dd414ba777b9447edc48cfc4f81d2bc1310e785927b3d16874aa953ef36ac308f0ce580e35ad215ab7b18c913a70b6e6fdedcda2cd4bddc0b5110df1665bf67285cc18e34ff95a195ea66806f4cf3f70a22fa474657196c090991f66c33253660b90c87ff4d4955df5907230a0b3fdb6c6463cf90d924a85cbcf2dac3b2de71442c65bcaaaf4c62e2d35e5888c521c12cac7801e16fd0c7b270bd373cd7c8e9bd1eafb928a83644713ebda99a0589e2293cd2f17f7aad31eee9e5d96fcb1ed274487763831a8abd37917dfeff521c3ca1a3d8ef912a0b3bdb734059aa24a8099ad229ec623714f0d8d51866bdfc12f24bab812b9cef62b5c10e9902373a7acf3f3aa6938993397330f0ae3c4d838bd61ad41bb338925638a9a39c47f96153717351782e5b6e32026ecb9548a180971b6511c4699d5ec09f254de0578c73a320921980ff09e693799c0e2acf6020b637e2e08c8905e4a74cf2758a63aa54fa4ebc77ea108e5a57d30a7bc90a5639071d315cd6e879b98ad7ec2818880668f5ac3bf732b7274f0551ab578b180ca558734b735f24bd73a478c178983b97fda0b68b519fd30da6c0a5329048ac1d7321fb1976502c4a7073e81301f39e2195f9c3e402ce3d364c5d95536fd89a370605249799f377fe6305ea64f96cb4d9f3faa46f21476044dc9bdc147479aec8110d34a96c102b71fbfe2197d634635be0fc072674f841ddec516c79898bfb776e2c4e011b81f437f0a6359356a12a4962ff50c9d6fd0e2cdd09afe256766457c927165c87f3e59326d6bca818a71a744a588203ef1b5412e97ae86a7b2f2ee75e89944f45fc87a4765613e281c050726e562cdd592ca1414fef4169336b8fffbf0405df288d8790811f1fa1fc4ff1317d0e85c7aab8fd50d3e2eb99502b9a560efddba6ac8030e9aeb986aa718ae6605b52a081ae8274492342a23fe09a024c615d6f1d1685a2c7c5a66fe77e16be5ea1853196c6ffe5cd6e6c5f5c51dc608112ed593c819955132ec526e7549d5a43d789321792175b7bdc81b0798cfaa29606f3c677b0529ea37bf1fca9ce97dc2399d573a5d530befe02b4ddbaa1fbdb102b003d1d6887b556b3c900f3577698477537b67cd89177c479cb66888745c4af140e20b554913d354fc9f914b6e9f2fb5d374234792184a1952a7426ac8d66e0fb20fe08361226082b91afb61849afab8a181ef5ec3be692d8591b17b28c3fbf159818bc1a293c48f4713ef2cbbe73ddb66f2427ff0d5c25acd38a5ef52726bc10cf37bbb3579316fa5460000a8f397c16b741fe2ea3c7206b73c586ee690715271c98fccc3bfa3541ad452ff4ba553e13f179569eaf7ddda5f5de47dcd429fe259bbcf369f36a0b63bbd4c76d0bb8bc10a4cb29560bc74744a3b59648e48bb60a43af694c57781e2cebbd14f9631cc57cb19f0f4f1e3cc5f025251efc1beef7f0b066dbc608cb165d2113d2fcc080ed3410767e332806c19dc118e20aebef01f091dd7bb39a91119833071a708f0b4ecc736d3e4288f4b6d9d198b102bf5ba8d047d11a6251778e968b3772b6c478057d53f039ee82f687cf778d9931261a333faaf148899fdca7ed12dd242516b7fc13fa6215f7195d70c0267f710d17e5c986ab2f0169778df9aa37246fe5bf2df3444f76f767a658a1fe1f352bf66af8752f17045feb1762f00ca262df47ad87ab3e791bab52ba9efaba21b82f9b38cf17fd4eb4e2adef2dac366602cc67ae035d996cc51c389c64f395ec6cca15afc97501799a9eadf8be4029113aef3ca1a0c764720f0a84cf88ef069562e6df2ad311bd85258e90c2c56b72670b53eddadd7ddb969913d4a02ec6de1bf331e9332cf59d5473f5bb1ebfd186514b6efc26c376fda85023bcc3a8727e8cfc9a4ef1c94b4571c262ce32c3e07edcb7b1cdd196a204fff6f777c69ae611eccc791a83679cda8af874759adaa5345014f695bff0e7dc17c7f30c01ab2aeaf402c2b3095e04a4da6e1755a4fd388800cf52b0a319c8ebb7272585ac14fbb8c739fecf92f425a7207d37507336894e1da6081fa8da6d9a6746cf8a24937b0e401d968969a8270cf35ae59b57b8a036e99c594c5cb1b5e1b6074d85bea8db6d02ecbb1f6e2b67358570908d0cb360b7e2c975ef1ceae98cd09beff86dd3c3be2ce564bf3caadd3a5933442d8290e38c04a99bc70f0b04458e37785d69b5b1427c44d3b358f3ec350b599fb4c628e624e4661ff6e638c74c58c21a47b52f93beb731ee721319c89e6c7bbfb3efa8108c80d430c4c715338756813e94babc76d071e6a7543fac3845d52baabb4d97da17100d3fb4b2bd59a2e8b8dc2bf5b9c04407411d0e98c4b6ed7ce82f941423011e0c1a862c22377276942b6de944276bfee8ecb0bceb44a3525f372802ddccf8dd62b176a13a68f4beecb8f88cb8867af76c40921b96ef8fb827025939fee7577d748f6c4b9c1ad8942b42b434418306ba420fd3624f84c7bcff658ec45a92201162e6be56a7b038851204cd058aaba1235e5fe2c07163e35aa35b5c5d118a6a78354a4513fc0dfa3fac88fb0edf67bb6f507ddf4bed7d1100be5d5752cb6b742d75d0b219d341e6c66cb832f3b44f30864d2ffe620003d0ed3d4b5cddb80e6dae23eb80f4045789b5e88c49d563d928bc5b78ded57841930085f8b70d96d973a424f137911fb82bcd26ea0acc7ca0ecc0437545f122dea8a23b8e1b0082a94594953124b45a02fcdb37e734b513de573eb8a53323e06a985b339aeb9874b9890fc920937d0d7ff6c142b052f78d175a5f2dac76a6bfe551c2fb8572f9c42ed8b7f98b6e454196bec521909559139773b723eb9a2afe5b764873a4f89a5c3a425c5454b09f751c9ed42565ab484547897a94643722435670697a6dfb0bdc514bf0856e99268d0ee0b6e6374272ab1a8a8b146eadd3ad15fc92820f88632409f32edf018476980fbdd3ce039b72d4fc614afd22dd89c2463e506d2bb7bacf32c1a2be6476d0a9147ae77caf65e4beb662a09dade254146f56f6bac0f2df51784d5818ded55554a619fea9655279c7b1ab716633615d7a2fc4525945504deda030c4a5a11bdd362d93a5bc9285cff97fb46b0700cebc4cc26fdb7f7df3465a5c0deeed09b2e1c13838dbfeb8674b64c57a4347751305349d3e0e5d8e272a22941905da69ea3020b90eaf52ba9a720cee768b09653e2620f5da21c6e841fa43dd5f48a89115cbd57f45c30776f8c82807c8152dee3f726f7bcba3633e97c62c5841b5d4f666723abf4541c793ed2abff46c0eddbf85ed839cc6aa69bed04cef4201cc428930ef09a07fbdf2bd3a8168d7db10466c68904abf738df44c79519929b0b8aacf12e694917ade887d71d7bcf022485b7f54df585326bdf50682d4e751648c2c527f24ba233b06ce218664c7eb7fa9b93ca36eb451cad5fbcd137cbfd0cdaa8b12b8f2fcdd512a272299434f2a5900ccf80a392bba991e437b37e32ce29dc6dab77e6c1a7fd99694a7997d98267d05313dd477ae22c369cd72d1d2b6aca527042c9ff2452a14654d9e2fc9166fd83dd2d65a0fb1ce388dd9c12ed1a2221e289a9d1a73d7549a3835fcfc091be4230390b3d22814cd7986c86ab49041d680d249e99a62aab73cea24913dea1e1b05b17c548912e147797112171b51315fd300abc1798636031d6e3a0f301e2493676a8ddb528eedecb29b989b04dc80f2688b609a6102c821a00f9661e6e158954a2632bc22b93a973132fcfbc9356d9e72ec6ee2dbaf88df0d96d969d41bfba0da7f96db34ad3d315fc649e65c10c8174a739a17d39d61e5ce6696bd6ef19bc508484597f88a26944a4985304bbdb9488e285c563cde06e9d1bebf82e042b0c838de2c7d5952a52d00429c0d324375ce60645fe0d13be8177f862ce8ad91d48fc7a938b88be742afba98250886264371ef5cefe2c349c36085e524378ea4f9a2a17b27ca24adf73c50e24df0a16b4f942f53a204a585c7fa9c3f74a263cbbe8527fd269853de9145a96785277b96f7b5e2a2e1a8feda87dbb8be870391bb443f09c026f3d83618f8a28ffee8ac6f1ad99fa3fcd3f520bd2afb073c2bdc6b5f4de604cfdc69505cb1b755a13261e450f1de68bfb2d131d02cf4c70173c826d3d5907ba2a389374e76ca1df237f8a23c59d5d1e11178c590180a3e1dcb330693ab9abb30c60c6e9cbcc229b9901721c8a2b71c8d9e2da2d59c9d5a5ebf9d49c98f14b2cf3510985597d92c3697bb531063f7a3eacc0080fb3467ea56d43b5940a0059c5f087516aa6e96d02fec2ec87d09118cf6e4fe463fa80eccd069449892c88631309d8e2d3e4314075c0e2adceb4ad47e60c9e856d1ddbe3eb3518eb6d8253199d464e30926445242df17fd31fa4b01a6dc6dcae747777224389c05dd6fdbcc7bb1f0e52fdd331fe4672db2f2cbd2e612a86fbc688233c0e01d57867c4b8db7b8774ab4112c55ad5d25a429c768e4aaa81e74f18b4d1366a1403f4ca68362aaedd40d882597cface139c63aaa0114df42adf62258240cc83f3891b2e9192b9e226f3cd10c5ca1aa60517d7e5ab1555c810b075746511c4ea29985929915a986632be89f6ae1632254656c78354c95dfed237b2fa41ffb7d445a0c89e40064c6c17676c4f252b3766a8d482bb8c01f3be003d4a103b7e1bfc6eeaea98f96787d746432e0332139110c83276d07076631ed400995c0d06e7b7fe32172d951365d9ebbaec7971950670a77dfa0bd2eb18164772d20d4a481e9e2a2e2bf81c21d9fabdbf3490af0013830a171e0ea61f87841105e1bfad157be2535dfeede2d728f79602ebdf1cc47de25aaf5ebd0fe6c204cccc437f34df45ae58e34239fe0c4ed8c85ae52cf5107ba71e3d64b00d526520322f08e3aa29ccb804bfa03da4020814ecf06fc7e21ad0006fccc593fa2accc7634bbdf43c2f1d54d75ba666562a565aa2bed5e1bf0be39a722a842cf88b355b85c19fb49be71ee3a8177dc2a83ec824206218587d160aa90159d288dbf6e7a93e67e4f3c53d6646d4ad1ec0301fdf4e942c5f2df2118bec1379a3b2c362465900a84e605772efa422af0db99cf29d53d40ee6673d548c37bc6b4c3d3e3619e27c8e5947f2c7df1c01f0a5101503f71990f3b329dfd8edc435244cacd3ac75177d528baf5e7bf4874164de15492d209f8662b3acf7073370eff5c394a2e7b0b55230e76b0cd60d8ad82c03b88d951df8a0f334cb547b0c527bc653d01c185ed3a38844b2ad5e5d338b622e301fa92182f49db6416e63f75d81fd3482af5c5285f3e44c706621393dcb5fc61954223c1a07bcf35dd8f9c37e726878d61f508d43299e306bcd5a09aac691af4f2097123ef08327c5b5375027d9d705b60ad935b15da51213606f920e6d4ed4e7facd4e3086fdadeebcea267a96f1f50a14e461f06002e6434c172c65ff1c3f3b4377488e451f5594befce5f8889a7b71b9ea287e2858fd9716119e3dfec76eca0e7305236aa2e8e5348e0edc3436a22e1eee50935539ce746e955e3f48127dd2cb6effba18c87e8d574aa5af63ff442ad5e2e09c35ec77d613f46124ac6aef421327d1890fb1b7f8e7fad97a33ed9c64479e4d39955ee8c9339845afd7aac14f959edadb4a8c8d9abcd9fa2fa885607762e6453b7e21201494f1f095ff1aeb54d61c0bfe188f64c590e1d046d3a9ccea8168793e45e72309b9d0aa298345ec894873f5b0033812dff19d02afd50dcd106072e51ce408804e8f050a218a1c82da9e75f40c47b553f589aad9cdd1b1f5945777b6cf9a22ba792b757cb34c2f0df23defd259f2ea8b00a41cc81336b58a2fe782727eda5212d469c2d08e13fb2d972ef111e65f03cd64c2c19d496a7cf9008417401fad84375a6b60a915dcf43fb89ca4b7961c7dcbb826ec262519b11600bdc53cfff97abf67dda3bb04902fe0495bf1006fed6c92115ffa12eec071dc2bbcb6810b717aea26a1609658d24cf0697a6fb2c8db00a3e53520d7db0ff5c9170d5ad9a5d0e531f93cc61a4f679cf5d4f22c4f0fa812056418232f8173950b7a11b2c881dd97669fecb9fd4989f5ee40fb4dc6e0d4eb5e8daa960c02a91df83a5bd15c1476e2c654a3e14eeb76a22656329eaafbfc0d20182992c7bc3e952f9b34e7b48e340954d9b2c47e06e028b169a3c744bbf4124acaa53834fc00f399688f9b5af845f8e0b5cb3c8bf0980075490f291e4d165902f5fdd61b2c619546fc2fcebdb0d35a5e45e633447c9a4e740953ec4accd7e6b9b8331958a1d3b4b07c23d00f7d696a7e6881525994dd2adb073a47697765a0396441697e6e246478742a8f297131fd22a9e8e6f5c58315de3e95517cdc4d5d87e3565df38f36c0fcd45dc190e85612ab43bdc231fb9e1ceffbb9d100d8a9718a09ff45ab5eb1a83b43cf631a01612cc5b7def86849296d15b3a75dd1f1b6b9c3db28beb1d1a2d8119a6202686f7d3ccd5ce4d940468ff50bec0733aba2ab509b43324be844516a307bb4a08484642d6c83050af89cbdbfba2709c3cd73e6335cff2897cc33ee591246deb2a074b9379007e5ab30fe97cc1129a5ae0315715eb385dd2a85720c23974e79363190f57a9618fabc4512821bf8289e99c25b623e1c3d8b0b11d7ced73f5ffb00fb95a214959651d170f44922c9eb78da507cb3a9de37573a72a5b18086bebba3e8341d069d40fecdd82a733bcfb0e62a6fa1742f466cea3d6b5c3efbda160bbd0b5801a2a7ab2d6d8830387b27bae75496c2800fd147b50ef7135d8cf2811bfea38e1ee2dfea488a9834e06adad32ea0d187b278409909d0e52adda28662a0ad04406a67272d7d6a8948f4ca0f9210d76c37c44ed64f1f36b33f5220a202ee15f229864d7e40e776acf1fa5e26b110abc7dacd563e40effa70766744e870edf369dd1207e1f90cce572c77e585da67c15c2a22ea2acab7978986545068530d038c46f3c2f7b4335677ed1231eb0c14057f6ef030b845aa3815da7f2c8fb71f014c57c640ff21b7b2f292f4a192e7ba8f328ef1e605fd4876ef05f694c97e7f0823012f287056eaa8bec8394813378c55d3227e9bd9c09a772a4692f81f9797560064734ef807143b67094543084df91488c40a17752f49d7b7d729dfc60a04091acfc044ae60614cfeec0faa95289e274ff116bf2aa9f1baa777026c17594e6a9c1d2a5e0eda10f0395dbfc47b879f18a1c1bd3826cab8cdb7b155c6870caca7c47bc124b4386f97ccdc14ea4a08fad9fb8ccd964510204b6eaf524d9504af8f6c5e5b0a2f0af42615332a62bc094d0d7c28ea2dfbbea2bb793871a5ece40fd439cd710ae58174afb02d3a78710dba94a6f66c8fa93a70e3a5640296ae3ebc201514db14ac795df2a59ed05de8c0d472283d91ff74717fef4a7e8db9b7cb98c5e84f7e02300a2160977fbbfa02b7b70d385d99fd6853ea0aeca5a8f1f7d53d09d21b5aeea0149a684106d3dc4ffe55ab070826802df56200d1b63a81ae60666020af8a85e9f1744d62538194179ea690086d5e2da030ce03d409d84e1f0ec166b6d7180139f56bd8ea2e75eb5d491961d6d57f413342b37cfad125b40da0fa41330e260b5845cb897a49ad59c2c35414ddabf147aeeb41e341b7b1e192953253e2f1baf7d3ac4fc8df39bd65c51eb9ffda7b1c9197e795026b9d6de22d6921c7f1cfa94037164d20c4bf0d9091e82d7ed69ec8e93324b640d486e47d88199c6b89e325380a49b79661c1f12989c5ef9d28bc60d3a645c1c50e7e10694b2f151db5a52159851b88d7ae3423068be890f5e4c1db12703e5e9420a9c3457ce0722a0c1b169cab05a8df1344dec57aeb494b09593b442540e8e75d511b0d1ce6529538d2781e43d8b41f79250492b67fea9ad6052b6523c6aea0e4a5ae8d3ea9326f6ffc8eb849d8806dd769bdc46cd2a9f0dea76c695004b13683dc1fe1fd87e13b675dfc7b7098c60c9f3f3fca0c9c6ba75900d0dc8755e1a904f9e014d9d3b3a7b01d59ec651c13e2fda4ed37274ebaf8aad9f3a30467a6edec3bb57708f7e121b1ab73e4d9647ac1d206d9566e82754b45766e218ef4b8c85fe81e9a5253912865063482d34fe8b190cefb428e1e8fa3b99bd40f3abc4cc9d5d92a5b6986018cc390493c53ebd85071045cf1c8e63e3d476b6dbea12608fd886df251d46407ae4998f0348318e9ae816eed08cec5ff33aa19b043287055cc83471a5785f85cd4ed7bac156c408828c71112b84ca9775f5f447d4d387f925a1d904c22b9f5d77c1b4125dacf025de17b3f11600e312329517aadfb18661bd16b241f2fd674a2f45643e93549a5062dc8bfe9118ab83249c2cf670e6630aa56c9033b694cbeced6eafc164671c4c732900dfa43c6909507dc9fc6474c1a57fc74d27efbf0cc89c52b268a258280b490faff754d8a7aea19935ee87c7f42c30f758f4c674e232ff9aa8eb3032073ead0e2cdfc6c2fcb3b696c75db2332932989adabcee0118602f779e5a671ef9203a03386ce0e20bbfbcdcbf18eb3e2d68af6a94fad5047a2e4e1d59b7842001b7bf4ab419956f4db97a5e79822efa45812fd76eb14a0cc20f53ca08197d7d31b468b5d231dc1e8eca62b33d2e848503d0ad716a57183616f6304a910f602bdfb1b0941290036d43a8cf9fc2322fe190cc1993e2b67281ae05d8c7570e4e4517d7d8e57066ac9a6e103be79b2e4dbe5820d797c6c31e6168c17a8b5feae4fe3b8b9f045aff3e6502df28df7b1d873881d4887ce1e3f03212f7144ff5ecfb4f660669ce741d444eb6ceb57475c58313e56c85ffc19c91ce36e04a3d98077656f57b766c0dd35c21db874810a1d42e69e101bff53a679240b69dbed48b19f966522a0c7bfaabae832fa1090a4181f1594c56f573557bfcab2f5c43b2be7c8b58a8cd5d5dafcc35dff003114ec62d0fc9f13c40758d0a432551de9934bd86b6a22fe05d5b25af1badc62e781ef4ae0663e1e756202ad8bda281920f514b710265578449bc74fe516a4bbdd9a689e470f9088bf1543704844f7c4e42f4fbd89218dbda9be6bf66d351d095ea1b1ce66caab81346dfb75cae8f2fd4b6ff8361b0aa9db9c9ea51d4c7df1c0b1b8ab51c672b65a58f2cfdae95f726185d4fb828d3167be92348e73ae9568635cdcea24187623347d8096ba07517a86edcb80d328ef35a23d120678c656a1b5e90f46222a17678b62598b9dce8950f70c71b388132f25bfbf7ba77683cb1f82d0661a4f91385c1a0528c30b5482142c5d16d240cbba996ba82edbf1f936472f756428b0094c52b99e25e5275ee0229fb224f9bc3b200b56198cb6f5fa699b69e7fd0520b16428a1eea519bb46a1304fdc417af3d75fd4de4d153cf4e429ef7161fede3773ce05dfcbefdd90589de205b3352f0a6e469e1d12fa2001c27145348f284af6abcc163e8535b9eb3ba0b224cadd88d2dbb6f12d5f267059abc7b341dc4d05f738df33ded3c113261863d3f7e8c68172e06c272ee02d95b520b0eae32cea6a1274d1a2df80b312809afc0d62a901f20ede411ea530c7a6cfb23711686f30c3c6f34e23708392fb54c3c1fd09113fba461e077cf9c83af7022142c2f49a18b19f53ebf9bedca631ce795fd1983d720d07d68026dd98f2eafe9a326c00e8be8532f81b39a9f10af5a2b19372c106afefe1af3fcd9b3274b1a2c2fbdae0aa32545066510ca8c1c48cd2811282cfdfd5bae932a15b591f954db0b45ebb2483bdcec4edf7abb875ba97d7819dc0bc12b12856198c1c1a789d589ff650642bdc6e0c0ecfec559db8ba58924ab5587e611384946e6c8239d2c48d870bbebba47bc803fcfea50727fcbb51a8149ab79e561e93ed5506a5c78aae3fdf728de50ae770d51a1d6d7c45173a47967f31499c0f1b1dd47a10032cdbb5cc7106c1de5bf81475a988b879d6288f7a9ea825b679bdaee0b45b94b7dca099f57fb0db759bb059affe07c2fc55a4a9eac8d558f5855370b9b1b54424ce14f91f1a44dce638427730d955e7970ba25a367b84cc7f87f72ec10550e21e927628fbed0601c6ceec41514342bbcfc766392e5fc7367fa994a2eddabbfab4fff78976d99b8ebc62be752f2ef8f26ed87567bd3a47a321eeea4a700511a1c3a2b2783ba2544e3676350bf85142f45a0187ea692d7cfe62889ba24d08876ccc8193f680af90d550416f6114b320f2b8b1fb8c01cedd74cb57f8ab714e057a8302bc0bc57a8cb9051e5ac5e7e85eb7787d7f618f4f96a10e5952eeabd6d19c9fcda34a2c94b7b4d5aaa480cc1c75352d26cb0ac189c0c8d324049db9814bd51abfa869e0912995fdf039bd80166018e9cff056a0ad5619e908530647933053b0f27d0b74f05db14e51e4138d40b2f03028f32e7f149cc644b9497112186c14b531fb9f3574bd0216918b530a0133489722354eb3483a439266461357beeed190907d5b3e21ed8cf91093e0965c7696a1be162258e0d35e22f45229498612a50984d29693d12c6c581bede8e7d84cd83fc1616e1a295d7ff501b63364f4af7c01218bc754dc249472f51e24df56907087186afd4ad013c3782d3330cb6d9c7668add61c11a63158329c38f3dba1e312d41753fea8e1f2c46149319e08d4873d023fc3bd48798496c3bc83883a6ac2a5dbdfe23786dfbb658644d2a120e14426706e97f40a17828adf89c3a041fd9e3b42b5283b7a1c2b2a4a76a0e567951f130d802aa960e51e1135ed176a2a723307aeee0541329754ac064830e6e58f5e09c7358e6ae7ebaa81d7b2ad442afee3d8df95c19066b0bd9baaea2c537b6e3966011ca7bab2e8cedb47007be654d44643d240cc0c4281f4510872b9fb27a6456215cbada9eb4491ee16ced009f8bfe985de418c45cec2f007ce9b7558e762d67c20408d2b852a0b8aa9d0c576c855b528235abf9abaff947b8cb5763b055b235f4093f01ad5db5d9705d1092a553847f67c7dfeb9db6a3c0d6b48ef2a8ece71ddf570cf33f2b7aeafb2aaa065b8601b572398774dc95e72db60021561532326f3ca3340d7f710cca0abb63c7ca551959a794f07fc6091552be916132f3faa41c5dd1ce1a8a22ad7c02b6b9db22fc8a75c0b7eb8f943befffa3b050a82d4b36a3ee6b6f5ee10cfcef382b4f53ddd7b6b8725beaa0738325547f9bc0d0e8c8187363c8c82a2af6e176ddb38af49be638e8d807763e6afe410a9959f22216dd0d6a431be1dfd3636c13f412a169834e310fcef04213b71e136</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 🏭工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电科新生必备攻略</title>
      <link href="/posts/20230901.html"/>
      <url>/posts/20230901.html</url>
      
        <content type="html"><![CDATA[<h1 id="新生必备攻略整合"><a href="#新生必备攻略整合" class="headerlink" title="新生必备攻略整合"></a>新生必备攻略整合</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里首先感谢yzx提供的基础文案，在此基础上我进行个人的修改</p><p>本人为20级光电学生，只能记录本科20-24学校内的变化，往后如有继续修订主要是参考学弟学妹们的意见了</p><p>本文篇幅可能较长，最好跳转自己需要的章节查看，纯打车路线就不具体多说，只在清水河出发那块提及</p><p>吃喝玩乐篇因为太长了，<span class="hide-inline"><button type="button" class="hide-button" style=""> 暂时先搁置一下吧  </button><span class="hide-content">其实是我懒得整理了，成都好吃好玩的太多了</span></span></p><h2 id="常用账号密码"><a href="#常用账号密码" class="headerlink" title="常用账号密码"></a>常用账号密码</h2><table><thead><tr><th>站点</th><th>账号</th><th>密码</th><th>备注</th></tr></thead><tbody><tr><td>网上服务大厅</td><td>学号</td><td>身份证号 后七位去掉最后一位</td><td>之后修改为自设密码</td></tr><tr><td>电子科技大学保卫处</td><td>学号</td><td>身份证号 后七位去掉最后一位</td><td>之后修改为自设密码</td></tr><tr><td>成电微宿舍</td><td>录取通知书号</td><td>录取通知书号 后六位</td><td></td></tr><tr><td>智慧团建</td><td>身份证号</td><td>身份证号 后八位</td><td>之后修改为自设密码</td></tr><tr><td>电子科技大学学生邮箱</td><td>学号@std.uestc.edu.cn</td><td>身份证号 后七位去掉最后一位</td><td>之后修改为自设密码</td></tr><tr><td>校园一卡通</td><td></td><td>身份证号 后七位去掉最后一位</td><td>在图书馆借书时用到</td></tr><tr><td>图书馆借书密码</td><td>刷学生卡</td><td>Aa身份证号 后七位去掉最后一位&#x3D;</td><td>输完数字后加上&#x3D;</td></tr></tbody></table><p>拿到学生卡之后（这个是学校发的相当于饭卡和门禁卡，不是电话卡！！！），手机有NFC的可以刷一下留着，不然到学校以后卡莫名其妙丢了还要一直补（一次15）</p><h2 id="公交地铁购票方式"><a href="#公交地铁购票方式" class="headerlink" title="公交地铁购票方式"></a>公交地铁购票方式</h2><p>(1)下载天府通app，注册登录后使用乘车码乘坐公交地铁（享受9折优惠）。</p><p>tips：支付方式（我的——扣款设置）可以选择支付宝免密支付（乘坐公交&#x2F;地铁时支付宝内也可以享受80&#x2F;52g蚂蚁森林能量），也可以选择余额支付（但是每次只能充值10元的倍数）。</p><p>(2)支付宝——出行，领取成都公交地铁卡，刷码乘车（不享受优惠）。</p><p>(3)地铁自助购票机（适合在不能保证一人一手机的时候买票）</p><h2 id="交通出行篇-长途"><a href="#交通出行篇-长途" class="headerlink" title="交通出行篇(长途)"></a>交通出行篇(长途)</h2><h3 id="清水河出发"><a href="#清水河出发" class="headerlink" title="清水河出发"></a>清水河出发</h3><h4 id="清水河校区→成都东站"><a href="#清水河校区→成都东站" class="headerlink" title="清水河校区→成都东站"></a>清水河校区→成都东站</h4><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">路线1</button><button type="button" class="tab " data-href="1-2">路线2</button><button type="button" class="tab " data-href="1-3">路线3(打车直达)</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>有轨电车蓉2号线（成都西站方向）到成都西站——地铁4号线（西河方向）到中医大省医院——地铁2号线（龙泉驿方向）到成都东客站</p><p>备选路线：有轨电车蓉2号线（成都西站方向）到成都西站——地铁4号线（西河方向）到槐树店——地铁7号线（内环方向）到成都东客站。</p><p>优缺点：全程用时约<mark class="hl-label blue">75分钟</mark> ，花费7元，在中医大省医院站能够实现同层换乘（出了4号线就是2号线的对应方向，省了换乘时间），地铁上几乎无座，对一些晕有轨电车的不是很友好。<b>有轨电车早上第一班6:30，所以高铁在8:30之前的，建议不要选择此方案</b></p><blockquote><p>合作路首班时间预计6:28；合信路首班时间预计6:31</p></blockquote><p>备选路线优点：有时在高峰期7号线人较少一点，在地铁上没那么拥挤，也可以在4号线人少的时候多坐一会，费用时长差不多与路线1相近</p></div><div class="tab-item-content" id="1-2"><p>公交301路&#x2F;205路&#x2F;P18路&#x2F;771路&#x2F;G86路到地铁红高路站——地铁6号线（张家寺&#x2F;兰家沟方向）到犀浦——地铁2号线（龙泉驿方向）到成都东客站。</p><p>优缺点：能够更快的上地铁，总时长可能略少几分钟，在犀浦始发站<mark class="hl-label red">能有座位可以坐</mark> ，总花费9元，大多数人的选择</p></div><div class="tab-item-content" id="1-3"><p>直接打车到成都东站</p><p>优缺点：时长最短，费用最贵，约50~60元<mark class="hl-label blue">45分钟</mark> 。适用于早上7:20之前的动车，最好提前在团团或者拼车群里凑人，四个人的话一个人20性价比也是很高的</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h4 id="清水河校区→天府机场"><a href="#清水河校区→天府机场" class="headerlink" title="清水河校区→天府机场"></a>清水河校区→天府机场</h4><p>由于现在大部分国内航班移动到天府机场了，所以首先还是写去天府的路线</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">路线1(高德路线修改)</button><button type="button" class="tab " data-href="2-2">路线2(个人觉得最优)</button><button type="button" class="tab " data-href="2-3">路线3(打车路线)</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>有轨电车蓉2号线（成都西站方向）到成都西站——地铁9号线（金融城东方向）到孵化园站——地铁18号线（天府机场北方向）到天府机场1号2号航站楼</p><p>优缺点：全程约用时<mark class="hl-label blue">2小时</mark> ，约13元。由于有轨电车第一班合作路站为6:30，所以<b>建议10:00之前的飞机请不要选择这个路线</b>。高德推荐的路线是有轨电车在联工下车，在黄田坝换乘9号线，在这里换乘不是很好的选择，不如在成都西站换乘。</p><p>9号线是无人驾驶地铁，可以在首末车厢以司机位看地铁运行 , 可以去体验一下</p><p>18号线注意是两种终点站（兴隆站和天府机场北），请选择前往天府机场北方向的</p><p>18号线同时也存在快线慢线，<b>一般快线等不到，选择慢线即可</b>（快线现在仅从成都南站和天府机场出发）</p></div><div class="tab-item-content" id="2-2"><p>打车到黄田坝地铁站——地铁9号线（金融城东方向）到孵化园——地铁18号线（天府机场北方向）到天府机场1号2号航站楼。</p><p>优缺点：适合那些坐有轨电车头晕的or飞机稍微早一点的。9号线黄田坝第一班6:10，地铁耗时约<mark class="hl-label blue">1h15min</mark> ，所以飞机早于8:40的请不要选择这方案。约20元路费（最好和朋友一起走），总时长在<mark class="hl-label blue">1h30min左右</mark> </p></div><div class="tab-item-content" id="2-3"><p>选择1：打车到火车南站——地铁18号线（天府机场北方向）到天府机场1号2号航站楼。</p><p>优缺点：打车打到一半能稍微省点路费，火车南站第一班地铁为6:00，地铁用时约50分钟。飞机早于8点的就不要考虑这个方案了</p><p>选择2：直接打车到天府机场</p><p>优缺点：很贵！！！(160RMB左右)，时间也得<mark class="hl-label blue">1小时多</mark> ，非必要请不要选，如果过早的飞机还不如前一天住在机场附近或者里面（省钱，也省的自己担心错过飞机）</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h4 id="清水河校区→双流机场"><a href="#清水河校区→双流机场" class="headerlink" title="清水河校区→双流机场"></a>清水河校区→双流机场</h4><div class="tabs" id="3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="3-1">路线1(个人认为最优)</button><button type="button" class="tab " data-href="3-2">路线2(打车路线)</button></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>有轨电车蓉2号线（成都西站方向）到成都西站——地铁9号线（金融城东方向）到华兴——地铁10号线（新平方向）到双流机场1号&#x2F;2号航站楼</p><p>优缺点：<b>都是公共交通</b>，大概<mark class="hl-label blue">70分钟</mark> 就能到，7元路费。不过<b>早上8:45之前的飞机尽量不要选择此方案</b>。</p></div><div class="tab-item-content" id="3-2"><p>直接打车到双流机场。</p><p>优缺点：很快，<mark class="hl-label blue">30分钟左右</mark> 就到了，路费约40~50块钱，如果不想操心或者飞机太早了可以选择采用此方式（拼车便宜！）</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="目的地清水河"><a href="#目的地清水河" class="headerlink" title="目的地清水河"></a>目的地清水河</h3><h4 id="成都东站→清水河校区"><a href="#成都东站→清水河校区" class="headerlink" title="成都东站→清水河校区"></a>成都东站→清水河校区</h4><div class="tabs" id="4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="4-1">路线1</button><button type="button" class="tab " data-href="4-2">路线2(个人认为最优)</button></ul><div class="tab-contents"><div class="tab-item-content active" id="4-1"><p>地铁2号线（犀浦方向）到中医大省医院——地铁4号线（万盛方向）到成都西站——有轨电车蓉2号线（郫县西站&#x2F;红展东路方向）到<b>合作路站</b></p><p>优缺点：全长约<mark class="hl-label blue">75分钟</mark> ，7元钱。同样的同层换乘，省点换乘时间。有轨电车最后一班为<mark class="hl-label red">21:40</mark> ，建议20:50之后到达的动车不要选择此路线。要非常注意<mark class="hl-label red">有轨电车别在电子科大站下</mark> </p><p>真的是阴间设定，不能在电子科大站下车，要不然就离宿舍区很远。</p></div><div class="tab-item-content" id="4-2"><p>地铁2号线（犀浦方向）到犀浦——打车到电子科技大学西门</p><p>优缺点：<mark class="hl-label red">对于新生较友好</mark> ，在犀浦站有接站人员。但是<b>开学阶段在犀浦容易打到黑车</b>，要慎重一点，约15元左右（最好还是高德打车）</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h4 id="天府机场→清水河校区"><a href="#天府机场→清水河校区" class="headerlink" title="天府机场→清水河校区"></a>天府机场→清水河校区</h4><p>无特殊变化，和去天府机场相同，参考  清水河校区→天府机场</p><div class="tabs" id="5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="5-1">路线1</button><button type="button" class="tab " data-href="5-2">路线2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="5-1"><p>地铁18号线（火车南站方向）到孵化园——地铁9号线（黄田坝方向）到成都西站——有轨电车蓉2号线（郫县西站&#x2F;红展东路方向）到合作路站</p><p>优缺点：最常用路线，主要这便宜时间也短。只要在晚上20:00之前到天府机场的地铁站，那就可以选择这个路线。</p></div><div class="tab-item-content" id="5-2"><p>地铁18号线（火车南站方向）到孵化园——地铁9号线（黄田坝方向）到成都西站——打车到清水河校区西门or南门</p><p>优缺点：最迟可以到地铁晚间结束，不用等有轨电车的最晚时间。同时也是晕有轨电车人的福音。就是稍微贵一丢丢。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h4 id="双流机场→清水河校区"><a href="#双流机场→清水河校区" class="headerlink" title="双流机场→清水河校区"></a>双流机场→清水河校区</h4><p>路线1：地铁10号线（太平园方向）到华兴——地铁9号线（黄田坝方向）到成都西站——有轨电车蓉2号线（郫县西站&#x2F;红展东路方向）到合作路站。</p><p>优缺点：同清水河校区→双流机场路线1，如果<b>晚上太晚的话可选择到黄田坝打车回学校</b></p><h3 id="动车学生票优惠实现"><a href="#动车学生票优惠实现" class="headerlink" title="动车学生票优惠实现"></a>动车学生票优惠实现</h3><p>拿录取通知书是可以购买七五折学生票的，可以选择在线下凭借录取通知书买或者在12306 app上买票，在12306 app买票时，<b>需将自己的身份改为学生</b>。在进站的时候，<mark class="hl-label pink">“请走人工通道（因为机器你刷不开），检票时也需走人工通道”</mark> </p><p>学生资质认证：</p><ul><li><p><b>凭借学生证和身份证在火车站的自助取票机上完成资质认证即可</b>（这一步也可在回家前认证也行）</p><blockquote><p>如果采用线下方式使用学生优惠要提前一点去搞</p></blockquote></li><li><p>2023年开始可以使用线上认证了，公众号链接：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTc3MTgwMA==&mid=2651228622&idx=1&sn=45fc1b0599977bca1c5576da32965f78&chksm=bd014d398a76c42f3e9b385ff1d0d4a4279169a288a68f4edc9e70887c7cd3ffe4c25612ee3c&mpshare=1&scene=23&srcid=0605ZOZIzPiAutnMp9UMNizO&sharer_sharetime=1685947601207&sharer_shareid=75318f14d93c3dc27b3afa03db4658e1#rd">学生优惠资质可以在！线！核！验！啦</a></p></li></ul><p>认证后一年有4次优惠机会，<span class="hide-inline"><button type="button" class="hide-button" style=""> 一般是寒暑假回家返校用  </button><span class="hide-content">当然，你要是经常要去哪个城市也是可以的哦</span></span>，一年只有4次机会</p><p>注意事项</p><ol><li>一般来说买学生票是不用取票的，除了一些特殊情况，如：回家买的车票在资质认证之前买的，需要取票以消耗一次次数，否则进站闸机过不去。之后就是自动扣除次数了，可以选择不取票。</li><li>一般不要早早取票，因为一取票自动消耗一次学生资质次数，就算退票了这个次数也不退回。（如果没有取票，在12306直接退票，是返还这一次次数的）</li><li>如果没有直达的列车，可以选择中转，但是中转要满足在一天之内，且买票时要一起买，否则<b>可能会导致扣掉2次资质</b></li></ol><h2 id="交通出行篇-成都内"><a href="#交通出行篇-成都内" class="headerlink" title="交通出行篇(成都内)"></a>交通出行篇(成都内)</h2><h3 id="两校区校车出行"><a href="#两校区校车出行" class="headerlink" title="两校区校车出行"></a>两校区校车出行</h3><p>订票方式：微信小程序搜天府行（成电后勤里面也有），起点清水河校区，终点沙河校区的城际专车。选好时间，选好位置付款即可。</p><p>便宜，只需要4块钱。时间短，在平时不堵车的时候40分钟左右就能到。但是时间非常固定，每天就那么几班。</p><p>具体最早最晚时间看小程序吧，不记得了</p><h3 id="有轨电车出发"><a href="#有轨电车出发" class="headerlink" title="有轨电车出发"></a>有轨电车出发</h3><p>清水河校区门口除了公交，共享单车&#x2F;电动车，那剩下的就是有轨电车，清水河校区有三个门有有轨电车的站点，分别是<b>电子科大，合信路，合作路</b>。</p><table><thead><tr><th>站点名称</th><th>备注</th></tr></thead><tbody><tr><td><strong>电子科大站</strong></td><td>该站对应的是南二门，是离体育场最近的，但是是离宿舍区最远的，所以一般不建议在此站上下车</td></tr><tr><td><strong>合信路</strong></td><td>此站对应的是西二门，在此站下可以选择在西二门进校或者去龙湖时代天街消费</td></tr><tr><td><strong>合作路</strong></td><td>此站对应的是西门，这个站是离宿舍区最近的站，一般在此站上下车更方便一点。</td></tr></tbody></table><h3 id="地铁出发"><a href="#地铁出发" class="headerlink" title="地铁出发"></a>地铁出发</h3><p>最近的就是红高路地铁站，但过去也不方便，还是选有轨吧</p><p>成都地铁与公交是有9折优惠的，需要提前下载天府通app。</p><mark class="hl-label red">“使用支付宝的乘车码没有优惠的”</mark> 。在某些重污染天气时，会短时公交免费与地铁8折优惠。（每月5号也有）<p>天府通app的余额可以有两种方式，一种是使用微信or支付宝往里面充钱，每次充的只能是十的倍数，第二种是绑定支付宝或者微信的免密支付，这种支付同样享受9折优惠，且使用支付宝支付的话，支付宝的蚂蚁森林也会积累对应能量的（公交80g，地铁52g）</p><h2 id="学校环境篇"><a href="#学校环境篇" class="headerlink" title="学校环境篇"></a>学校环境篇</h2><p>这篇仅限刚入校快速融入校园用，看完这个变老油条几乎不咋可能，顶多就是少走点弯路</p><h3 id="学校出入口"><a href="#学校出入口" class="headerlink" title="学校出入口"></a>学校出入口</h3><p>等等进来以后不知道咋出去就尴尬了</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/image-20220724111723334.webp" alt="image-20220724111723334"></p><p>学校共有5个出入口：南边2个，西边3个</p><p>南二门：离体育场最近的门，但是同时是离宿舍区最远的门，有有轨电车站台（电子科大站），是公交301路的始发站。再说的话，那就是<mark class="hl-label orange">“南二门旁边就有天府绿道的入口”</mark> </p><p>南门：学校的主校门，无有轨电车站台。南门对面有许多饭店，如盐都干锅王等。学校的标志大石头就在这里，从这里进校门能看到学校的主楼。</p><p>西二门：平时使用率最高的校门，有轨电车站台（合信路站）。西二门是<b>离龙湖时代天街最近的门</b>，所以平时出去聚餐啥的在这个门集结的人是最多的。</p><p>西门：<mark class="hl-label red">“放假or进城里面玩使用率最高的校门”</mark> ，有轨电车站台（合作路站）。这个校门是离宿舍区最近的门，进校报到大概率就从这个门进来了。</p><p>西北门：准确来说是校医院门，疫情防控期间关闭，现在疫情过去，这个门日常还是开放的。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/1.webp" alt="1" style="zoom: 80%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/2.webp" alt="2" style="zoom:67%;" /><h3 id="品学楼"><a href="#品学楼" class="headerlink" title="品学楼"></a>品学楼</h3><span class="hide-inline"><button type="button" class="hide-button" style="background-color:  #FF7242;color: #fff"> 传统话术  </button><span class="hide-content">“成电品学楼，一跳解千愁”</span></span><h4 id="品学楼A区"><a href="#品学楼A区" class="headerlink" title="品学楼A区"></a>品学楼A区</h4><p>品A全为大班阶梯教室，<b>微积分线性代数</b>等课就在品A上课。</p><span class="hide-inline"><button type="button" class="hide-button" style="background-color:  #FF7242;color:  #fff"> 教室号tips  </button><span class="hide-content">注意位置好干饭</span></span>：靠近银桦餐厅的门上对应的教室为Ax03，靠近校训的门对应的是Ax01 or Ax13（最小与最大号），靠近学子的门为Ax08 or Ax07<p>品学楼A209与A210之间，即A区与BC区的平台附近，有多媒体中心，借教室&#x2F;借教室话筒&#x2F;教室电脑投影出问题&#x2F;拿话筒电池都是在那个地方找人。（很多老师都会叫学生去帮忙问问或者拿话筒电池）</p><p>A区总共4层，与B区相连的楼层为3层4层（关于连接位置兜兜转转总能找见），与C去相连的楼层是3层（与A区3层相连），5层（与A区4层相连），品C四层没有连接道</p><p>A107为A区最大的教室，大约可容纳300人，年级大会有时候在这个地方开。</p><p>A区一楼也有借桌子椅子的地方，辩论赛借桌子可以在这个地方借。</p><p>A区教室两侧有充电插座，电脑手机没电的时候可以选择在此位置充电。</p><h4 id="品学楼B区"><a href="#品学楼B区" class="headerlink" title="品学楼B区"></a>品学楼B区</h4><p>品学楼B区也全为大班阶梯教室，但是在B区上的课比A区少很多，显得B区没有A区热闹。</p><p><b>B区教室适合大一学委找自习教室</b>，比如B区2楼很多教室，一节课都没有，几乎可以长时间占用这个教室集体自习。</p><p>B区总共4层，与A区相连的楼层为3层4层。与C去相连的楼层是3层（与B区3层相连），5层（与B区4层相连）。</p><p>B区旁边有与立人楼相连的桥，早上一二节课下课的时候人很多，所以建议下课之后赶紧过桥（实在不行绕一下银杏大道，说不定还更快）</p><p>教室号tips：与品A类似，靠近校训的那个门为最小最大号。</p><h4 id="品学楼C区"><a href="#品学楼C区" class="headerlink" title="品学楼C区"></a>品学楼C区</h4><p>这里都是小班教室，英语和人类文明经典赏析等小班课就在这里上，充电口随处可见，有很多教室脚底下，桌子上全是充电口，完全不用担心没电（除非没带充电器），里面有USB接口，也有三角插座。</p><p>每个教室门口都有对应的显示屏，显示该教室的占用情况，选择在C区自习时可以以这个作为大概判断依据(可在成电微教务看空闲教室)</p><p>C区由于没有阶梯教室，所以每层楼高低，就有5层，与AB两区相连是3,5层，4层是没有连接的。</p><p>C区一般不适合班级自习用，一般适合开班会等活动用。</p><p>教室号tips：品A与品C相连的附近为最小与最大号。</p><p>品学楼C区的空调是日立（HITACHI）牌子的，手机要是有红外发射器的话可以控制空调开关。没有的话想控制空调的可以买个红外发射的外插。</p><h3 id="立人楼"><a href="#立人楼" class="headerlink" title="立人楼"></a>立人楼</h3><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/3.webp" alt="3" style="zoom: 67%;" /><p>立人楼A区：关于这个楼，本科生课程几乎不咋在这个地方上课，所以这个楼不了解也行</p><p>立人楼B区：四六级的考场，中&#x2F;大班阶梯教室，B217&#x2F;218经常作为开年级大会的地方。大学物理，工程数学等课程在立人楼B区上课。</p><p>教室号tips：靠近银杏大道的为1号，靠近立人楼A区的为Bx18。</p><h3 id="基础实验大楼"><a href="#基础实验大楼" class="headerlink" title="基础实验大楼"></a>基础实验大楼</h3><p>基础实验大楼也叫“科A”，是众多实验课上课的地方。<span class="hide-inline"><button type="button" class="hide-button" style=""> 电路实验，数字系统实验  </button><span class="hide-content">这两门课老容易挂科了</span></span>，大学物理实验等课程就在这里上课。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/4.webp" alt="4" style="zoom:67%;" /><h3 id="研究院大楼工程训练中心"><a href="#研究院大楼工程训练中心" class="headerlink" title="研究院大楼工程训练中心"></a>研究院大楼工程训练中心</h3><p>这里是众多实训课程的地点。电装实习，<span class="hide-inline"><button type="button" class="hide-button" style="background-color:  #FF7242;color:  #fff"> 基础工程训练，电工电气技术实训  </button><span class="hide-content">实验报告那些最好找学长买一份，又是A或者A+还省力</span></span>等课程就在这里上课，靠近西二门，上完课可以顺便出去干饭</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/5.webp" alt="5" style="zoom:67%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/6.webp" alt="6" style="zoom:67%;" /><h3 id="光电楼"><a href="#光电楼" class="headerlink" title="光电楼"></a>光电楼</h3><p>光电楼也叫“四号科研楼B区”，是学院楼，学院办公室都在这里。新生项目课，工程光学实验等课程就在这里上。</p><p>学生科在404，里面都是各级的辅导员，不知道找哪个老师可以问助理</p><p>门牌号tips：进门右手边为小号，左手边为大号，内环外环为单双号分开计数，所以经常会出现一个远大于另一个。</p><h3 id="综合训练馆"><a href="#综合训练馆" class="headerlink" title="综合训练馆"></a>综合训练馆</h3><p>每学期第一节体育课集结的地方，在这里认领上课的老师（<b>千万别跑到南门体育场了</b>）。</p><p>综训馆内有羽毛球，乒乓球，板式网球，五人制足球，篮球的场地，室外有篮球，足球，跑道，曲棍球等的场地。（在馆内打球是要办卡的）</p><p>夏天时室外游泳池会开放，第二学期的后面几次体育课可以选择在这里游泳（南门的游泳馆可以游泳的，一次好像是15，但是也是要办卡，要去校医院做个体检(10RMB)带体检条才行）</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/7.webp" alt="7" style="zoom:67%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/8.webp" alt="8" style="zoom:67%;" /><h3 id="南门体育场"><a href="#南门体育场" class="headerlink" title="南门体育场"></a>南门体育场</h3><p>大学生体测的地方，大一上、大一下、大二下、大三下的4次体测都在这里。</p><p>同时这里也有游泳馆、台球厅、击剑房、健身房等设施，上对应的课的地方就在这里（但是第一节课还是得去综训馆认老师去）</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/9.webp" alt="9" style="zoom:67%;" /><h2 id="食堂篇"><a href="#食堂篇" class="headerlink" title="食堂篇"></a>食堂篇</h2><p>打菜的时候可以拼菜哦（一般是取两个菜品价格的一半相加，朝阳一楼是取最高，低于3块钱的菜品不能拼，一两饭2毛钱）</p><p>学知苑一组团二组团附近：银桦餐厅（1层），紫荆餐厅（2层），芙蓉餐厅（3层）。三秦面馆（1层），西北餐厅</p><p>银桦的冒菜还可以，但那个辣的我福建人吃的不习惯，多拿菜，肉有点溢价</p><p>紫荆比较少吃，有点偏贵了，餐厅内的东西每学期都会有变化</p><p>芙蓉的米粉很OK(价格又忘记了)，面特别好吃，基本没坑(一两3RMB，二两5.5RMB，三两8RMB，担担面是招牌)，还有铁板烧炒饭也是很好吃的，但是肉很坑，所以多吃蔬菜吧</p><p>西北餐厅的东西都还可以，但就是贵+少，牛肉拉面5.5RMB，大盘鸡10RMB，咖喱10RMB，牛肉饺子1两3RMB，蛋挞3RMB，鸡腿5RMB</p><p>三秦面馆就和外面的面馆差不多</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/10.webp" alt="10" style="zoom:67%;" /><p>品学楼，学知苑4&#x2F;5组团附近：</p><p>学子餐厅（1层），思源餐厅（2层），家园餐厅（3层）。布蕾德西点屋（银杏大道上），蜜雪冰城（布蕾德旁边）</p><p>学子的冒菜yyds，要辣的，可以和阿姨说少放点(比如我这种不会吃辣的)，旁边有芝麻和西芹碎可以加，米饭1RMB无限量</p><p>思源的鱼粉(10RMB+)，饺子(特便宜)，手抓饼都OK</p><p>家园的东西价格挺高的，可以两个人吃一份米线(前提是得有对象哈哈哈哈)，外面的烧烤味道不错但比较贵</p><p>蜜雪冰城甜蜜蜜dddd</p><blockquote><p>在学子餐厅可以有包饺子活动等（需要班委提前与餐厅负责人联系）</p></blockquote><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/11.webp" alt="11" style="zoom:67%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/12.webp" alt="12" style="zoom:67%;" /><p>学知苑3&#x2F;7&#x2F;8组团附近：</p><p>朝阳餐厅与朝阳餐厅二层（男女比例感觉最正常的地方）</p><p>朝阳啥都好吃，但是要是打菜就会感觉菜量太少了，所以还是选择臊子面(7RMB)或者抄手(小份10RMB，大份13RMB)吧</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/26.webp" alt="26" style="zoom: 50%;" /><p>抄手这里总共有三列队，最左边的队伍是抄手的队伍，最右边的是水饺的队伍，中间的队伍是付款的队伍。得先排中间的队，付完款之后才能排两边的队伍。</p><p>中间付钱的时候，需要说（小份&#x2F;大份）（红汤&#x2F;清汤）（水饺&#x2F;抄手），然后就是要水饺的排右边队，要抄手的排左边的队。</p><p>一般不要看队伍那么长就不排，抄手一锅就能把一长队全部搞定。</p><p>抄手馅是大肉馅，13块钱大约有15+个的抄手。水饺的馅是韭菜肉馅，个数与抄手差不多。</p><p>朝阳二楼我愿称之为清水河最香的地方，打饭一荤两素10RMB，很好吃还顶饱，可以打的时候叫阿姨多拿点饭，咖喱饭(13RMB)，作为地道的福建人我可以说那个沙县小吃不是真的沙县小吃(虽然不难吃)，24年新开了海底捞</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/13.webp" alt="13" style="zoom:80%;" /><p>南门体育场附近：桃源餐厅（给老师吃饭用的，价格偏贵，没啥好吃的）</p><p>学校西南角集成电路学院楼旁边新开有科创餐厅(2024年)</p><p>成电会堂旁：商业街（里面有很多家商铺，含一家蜜雪冰城）</p><p>价格在基本12+以上，干锅很实惠，找同学一起去很巴适，<b>快递也都在这边拿</b></p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/14.webp" alt="14" style="zoom:67%;" /><h2 id="报告厅、图书馆、会堂"><a href="#报告厅、图书馆、会堂" class="headerlink" title="报告厅、图书馆、会堂"></a>报告厅、图书馆、会堂</h2><p>一开始都找不到的地方</p><h3 id="求实厅"><a href="#求实厅" class="headerlink" title="求实厅"></a>求实厅</h3><p>求实厅位于图书馆旁，许多学院的开学&#x2F;毕业典礼与众多成电讲坛就在这里举办。</p><p>要进求实厅得先上图书馆的平台，然后在图书馆外面转圈，总能看到那个入口。</p><blockquote><p>进图书馆可以用公众号的通行二维码进，或者刷学生卡</p></blockquote><p>电子科技博物馆就在求实厅的下方。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/15.webp" alt="15" style="zoom:67%;" /><h3 id="经管楼报告厅"><a href="#经管楼报告厅" class="headerlink" title="经管楼报告厅"></a>经管楼报告厅</h3><p>也是使用频率比较高的报告厅之一，学校辩论赛有时候就在这里举行。</p><p>在西二门旁边，能看到一个大楼梯，从大楼梯上去就是经管楼的报告厅。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/16.webp" alt="16" style="zoom:80%;" /><h3 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a>图书馆</h3><p>图书馆共5层，入口位于2层。图书馆是自习预习复习的好地方，考研的时候也可以在图书馆占个座。</p><p>进出图书馆需要刷一卡通，借书还书需要在对应的机子上刷一卡通，<mark class="hl-label red">“初始密码为Aa身份证号后七位去掉最后一位=”</mark> </p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/19.webp" alt="19" style="zoom: 67%;" /><h3 id="成电会堂"><a href="#成电会堂" class="headerlink" title="成电会堂"></a>成电会堂</h3><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/17.webp" alt="17" style="zoom: 67%;" /><p>成电会堂在学生活动中心与商业街之间，成电会堂里面的有时有电影的提前点映式，<b>能见到明星的</b>。然后学校的许多活动也在成电会堂办，比如校园歌手大赛，毕业晚会，<mark class="hl-label orange">“成电舞台”</mark> 。</p><p>成电会堂入口一般来说有两种，一种是图片左下角的那个门，一种是会堂右侧的那个大门。左下角的那个门不开的话那就去右侧的那个大门。</p><h2 id="宿舍生活篇"><a href="#宿舍生活篇" class="headerlink" title="宿舍生活篇"></a>宿舍生活篇</h2><p>组团开门时间约早上6点多，关门时间为晚23:30，在23:30到开门前，<b>进&#x2F;出组团会被视为晚归&#x2F;晚出</b>（阿姨会让你登记，辅导员那里是会看见的）</p><p>选宿舍是在开学前，大家可以在班群里面找找聊得来的人一起选（一定要选好，不然到时候吵架啥的很麻烦，最好生活作息能差不多）</p><p>宿舍是可以自己进行一些小装饰的，比如贴个壁纸啥的，或者直接二刺猿</p><p>清水河校区的宿舍分布图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/18.webp" alt="18" style="zoom:67%;" /><h3 id="寝室相关"><a href="#寝室相关" class="headerlink" title="寝室相关"></a>寝室相关</h3><p>每周四中午需要进行宿舍大扫除，周四下午56节课后学校会组织检查卫生，宿舍卫生评定有特&#x2F;一&#x2F;二&#x2F;三等奖，能拿奖的话基本上整个宿舍的洗衣液都不用愁了，but 我没拿到过&gt;_&lt;（2024更新，现在不发奖品了）</p><p>宿舍洗澡的热水是1分钟1毛钱，不足一分钟的按一分钟计费（也就是说你刚插上卡基本上就被扣了1毛钱）</p><p>宿舍的床大小为205cm* 90cm的，<b>建议买个床帘</b>（主要是防舍友半夜还在打游戏的光&#x2F;给自己创造个私密空间），床帘最小190* 80，再比这小基本上就挡不完全了。也不用买架子，宿舍床上基本都有架子，且围三面就行，靠墙的那一面不用围（想围也可以围）</p><mark class="hl-label red">“宿舍断电时间”</mark> 为11月1日到次年5月1日，时段为23:30（可能会晚几分钟）~ 次日6:00，节假日周末不断电（指的是第二天不用上早自习的时候，比如周末是周五周六不断电）<mark class="hl-label orange">“宿舍电费充值”</mark> （被学长学姐们改电路了的宿舍or被学长学姐充了很多钱的宿舍就请自动忽略这一条）：<p>学校给每人每月5度电，经常会出现宿舍没电的情况，这时候就要充电费了，充值方式有如下两种：</p><ol><li><p>方式1：网上服务大厅——搜“清水河校区寝室电费充值”——点击个人充值里的“充值”——填手机号，寝室号与充值金额再点击充值——弹出的确认框点确认进入付款界面——使用支付宝付款——充值成功后等1~2分钟就会到账</p><blockquote><p>宿舍房间号的确认：房间号为6位，组成为（学知苑1&#x2F;硕丰园2&#x2F;博翰苑3）+（栋数）+（房间号），以下面的某学知苑24栋608房间为例，学知苑为1，所以房间号就为124608。</p></blockquote><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/21.webp" alt="21" style="zoom: 46%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/22.webp" alt="22" style="zoom: 50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/23.webp" alt="23" style="zoom:50%;" /><p>在充值记录里，能看到宿舍电费余额：</p><p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/24.webp" alt="24"></p></li><li><p>方式2：手机端进入支付宝——搜索电子科技大学进入生活号——点击左下角的缴费大厅——点击电费充值，然后与上面方式1的操作一样，在充值界面也能看见房间电费的余额。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/25.webp" alt="25" style="zoom:67%;" /></li></ol><h3 id="校园超市"><a href="#校园超市" class="headerlink" title="校园超市"></a>校园超市</h3><p>校园超市常见就4个店，</p><ol><li>位于8组团下与六组团相连的丁字路口处</li><li>位于朝阳餐厅抄手门口50余米处硕丰园11栋楼下</li><li>位于学子餐厅对面，博翰苑3栋楼下</li><li>位于商业街2楼</li></ol><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/20.webp" alt="20" style="zoom: 50%;" /><p>校园超市早上大约7点半多开门，上早自习的话是看不到开门了的，晚上大约10点半多关门，周六日节假日关门时间更早，有时候9点多就关门了。</p><p>校园水果超市：巨坑，建议用淘菜菜送到菜鸟驿站去拿，或者去龙湖的永辉</p><p>文印中心：打印黑白一张1毛2，彩印一张1RMB，在品学楼&#x2F;宿舍楼底的打印机打印为0.16元一张</p><p>后勤中心：补办一卡通的地方</p><p>以上三者都在一块，都位于6组团楼下（前往7 or 8组团的路上）</p><blockquote><p>一般都是朝九晚五，所以去的话赶早不赶晚。</p></blockquote><h3 id="打印文件"><a href="#打印文件" class="headerlink" title="打印文件"></a>打印文件</h3><p>在文印中心打印的价格为0.12元一张。</p><p>在品学楼&#x2F;宿舍楼底的打印机打印为0.16元一张。</p><p>打印机打印：在微信搜索“流海云印”，提前把文件发到文件传输助手，然后在小程序选择对应的文件，支付之后，在打印机上使用扫码or用文件码打印即可。</p><h3 id="快递"><a href="#快递" class="headerlink" title="快递"></a>快递</h3><p>快递点均位于商业街。</p><p>商业街1楼：菜鸟驿站（凭菜鸟app的身份码取件）与京东快递（在菜鸟驿站的后面）（凭手机尾号取件）</p><p>商业街3楼：顺丰快递（凭取件码取件）</p><h3 id="商业街"><a href="#商业街" class="headerlink" title="商业街"></a>商业街</h3><p>2024年更新：</p><p>商业街目前一楼饮食有爱达乐、瑞幸、书亦、蜜雪冰城，还有众多店铺，如果比较多人去的话可能选择干锅最优</p><p>二楼的零食有鸣很nice，东西都很便宜，十指艺是学校里面剪发相对还行的</p><h3 id="校园一卡通"><a href="#校园一卡通" class="headerlink" title="校园一卡通"></a>校园一卡通</h3><p>众所周知，校园一卡通有很多种用法，常见的有饭堂与超市的刷卡消费，宿舍热水消费，刷组团门禁，图书馆入馆借书还书等。</p><p>但是一卡通有时候也有一种另类的用法，比如：拿卡翘宿舍门……</p><p>一卡通充值方式：支付宝搜支付宝校园卡，绑定自己的校园卡，选择合适的金额进行充值，充值之后大约2分钟后，可以在饭堂&#x2F;超市&#x2F;宿舍楼底（一般用不了）进行圈存，圈存完了之后所充的钱才到了卡上。</p><p>餐厅超市消费也可以使用支付宝&#x2F;微信的付款码进行支付，但是需要绑定自己的卡。绑定方式如下：</p><p>支付宝：搜电子科技大学——进入生活号——右下角的电子校园卡。</p><p>微信：<a href="https://mp.weixin.qq.com/s/54GCX19EJde8NXRPqXFNcQ">https://mp.weixin.qq.com/s/54GCX19EJde8NXRPqXFNcQ</a> （参考这个教程绑定）</p><h3 id="单车？共享单车？电动车"><a href="#单车？共享单车？电动车" class="headerlink" title="单车？共享单车？电动车"></a>单车？共享单车？电动车</h3><p>学校里共享单车以哈啰单车巨多，共享电动车一般就是小绿车。</p><p>刚上大学可以考虑买个单车，优点就是可以自己选配置，四年下来的话可能更便宜一点，缺点就是车坏了得自己修，车在哪停就得在哪个地方骑（这个其实挺麻烦的）</p><p>也可以自己买个电动车，优点就是可以带人（懂的都懂），缺点就是得自己找充电桩充电(有素质不好的人你刚插上电就被拔了，直接mmp)，但是电动车保值，四年算下来不亏</p><p>共享单车的话，优缺点就是大约每月10多块钱，想用车在哪都可以，<b>校外也可以</b>，但是在<b>上下课高峰期经常是找不到车</b>。</p><h3 id="记得带伞"><a href="#记得带伞" class="headerlink" title="记得带伞"></a>记得带伞</h3><p>这节为什么单独拿出来说呢？dddd</p><p>成都天气多变，往往会出现早上还晴空万里，下午就狂风暴雨，所以随身带把伞是必需的。</p><p>一般带把小伞就足够了，但是<span class="hide-inline"><button type="button" class="hide-button" style="background-color:  #FF7242;color: #fff"> 如果想两个人打一把伞  </button><span class="hide-content">很容易出现女孩子没带伞的情况和别人一起遮一下，有可能爱情它就来了哦dddd</span></span> 的话，那就买个稍微大点的，能放书包旁边的那种。</p><h2 id="课程篇"><a href="#课程篇" class="headerlink" title="课程篇"></a>课程篇</h2><h3 id="课表"><a href="#课表" class="headerlink" title="课表"></a>课表</h3><p>如何进课表？电子科技大学官网——公共服务——网上服务大厅——教务系统——课程管理——我的课表</p><p>看清上课周数（单 or 双以及持续时间）</p><p>上课时间：</p><p>早自习7:20-8:05</p><p>第一节课8:30-9:15</p><p>第二节课9:20-10:05</p><p>第三节课10:20-11:05</p><p>第四节课11:10-11:55</p><p>第五节课14:30-15:15</p><p>第六节课15:20-16:05</p><p>第七节课16:20-17:05</p><p>第八节课17:10-17:55</p><p>第九节课19:30-20:15</p><p>第十节课20:20-21:05</p><p>第十一节课21:10-21:55</p><p>第十二节课22:00-22:45</p><p>一般来说，两节算一节大课（个别晚上的课可能是9-11节），晚上9-12节的课一般都撑不到22:45就下课了，七八节课一般不安排课，可能会安排体育课。</p><p>英语课分ABC三种班，在开学英语考试后以成绩分班，比例约为1:3:6，<mark class="hl-label red">“A班主练演讲，B班破事挺多，C班课水给分高”</mark> ，三个班在期末考试题是一样的。英语课开课学期是大一上、大一下、大二下的三个学期，后面是可以选其他类的语言的，但是<mark class="hl-label purple">“最后考试仍是英语”</mark> </p><h3 id="抢课-and-选课"><a href="#抢课-and-选课" class="headerlink" title="抢课 and 选课"></a>抢课 and 选课</h3><p>在大一刚上来，所有主课系统都帮忙选好了，但是自己仍需要<b>选体育课与新生研讨课及人类文明经典赏析课</b>（人类文明经典赏析强烈建议在大一上就抢掉，否则大一下选课吃大亏）</p><p>抢课是实时公布结果的，人满了之后这个课程就不在抢课名单上了，除非有人选择退课，这时候会再出现在抢课单上。</p><blockquote><p>不只是大一上要抢课，后面每个学期选完课之后，要是有课掉了或者想再白嫖一个什么课，都是需要抢课的。</p></blockquote><p>只需要在网上服务大厅——教务系统——课程管理——选课，抢对应的课就完事了</p><p>有数字的代表在这个时间段里面有多少课（不一定都可以选，有可能满了）</p><p>除了大一上，剩下的每个学期都是要选课的，这就涉及博弈问题了，博弈好了能上很多好老师的课，博弈不好了就只能捡剩下的老师了。</p><p><b>建议大一大二能把核心通识修完就修完</b>，因为在大三大四选课的时候就不能在第一轮选核心通识课了，只能在第二第三轮抢课的时候蹲了。</p><p>选课分三轮，第一轮为权重选课，第二三轮为抢课。</p><p>权重选课时间一般为考试周前，需要提前进行教师评教，否则不能进行选课。</p><p>第二轮抢课一般为第二周的周一周二，高年级先开放低年级后开放，一般两个年级不同时开放。</p><p>第三轮抢课为开学一周后的周六日，这时候已经上了一周的课了，觉得这个老师和自己一点都不适合就退，全校在同一时间都可以选，一般能蹲到好的老师&#x2F;或者进行<mark class="hl-label green">“选课交易”</mark> 。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/27.webp" alt="27" style="zoom:50%;" /><p>选课分三个平台，A&#x2F;B&#x2F;C平台，每个平台各100分，A平台主要是各种必修课以及核心通识课，B平台主要是体育课和其他选修课，C平台一般来说没任何用，里面的课不需要选。</p><p>一般在投分结束的最后一天的早上最后守着，万一被偷家岂不是亏大。但是最后会卡死，建议<b>提前把老师确定好</b>，到时候<b>只需要互相调权重</b>就行。出现没有响应的情况时，可以等一会，或者退出去重新进教务系统</p><p>A平台的课多问学长，权重根据实际情况自己感觉</p><p>B平台，一般只有0分与100分的两种投法。先紧着体育课投，如果体育课超过人数，且都投的100分，系统会随机抽取能选上的人，没被抽中的就只能怪运气不好了。选修课一般热门的得牺牲体育课的100分去抽奖</p><h4 id="祖传网站"><a href="#祖传网站" class="headerlink" title="祖传网站"></a>祖传网站</h4><p>在选完课之后，大家最关心的肯定是自己赌没赌赢。接下来就说说查询方法：</p><p>一般在选课结束的当天晚上开始有结果出现，但是会发现此时教务系统——课程管理中我的课表与我的选课日志都不见了，此时需要这样进行操作：</p><p>先登录教务系统，点进教务系统后，将下面的网址复制到网页那一栏直接回车打开（不这样做会出现502）</p><p>课表：<a href="http://eams.uestc.edu.cn/eams/courseTableForStd.action">http://eams.uestc.edu.cn/eams/courseTableForStd.action</a><br>日志：<a href="http://eams.uestc.edu.cn/eams/stdElectLog!search.action">http://eams.uestc.edu.cn/eams/stdElectLog!search.action</a> </p><p>课表上显示已经有的课是已经确定选上了的课，日志里面被操作者账号为<b>system操作</b>了的课程为被退了的课程，需要在第二轮进行补选。最好还是不要见system了</p><h2 id="手机App篇"><a href="#手机App篇" class="headerlink" title="手机App篇"></a>手机App篇</h2><p>作为一个大学生，你要准备好加好多qq群与好多app的准备了。</p><p>中国大学MOOC，云班课，夸克，话心，企业微信，天府通，学习通，飞书，菜鸟，乐健体育，U净……</p><p>手机内存会有点吃紧，所以还是少打游戏了</p><h3 id="地震预警"><a href="#地震预警" class="headerlink" title="地震预警"></a>地震预警</h3><p>成都地震还是挺频繁的，所以经常会出现地震预警。</p><p>所以开启地震预警也挺必要的（好像也不是那么必要，毕竟小震不用跑，大震跑不了）</p><p>一般在地震前20s左右手机屏幕忽然变亮，声音瞬间变大，还伴随着倒计时的声音。（上课容易社死哈哈哈（不过大家一起社死就没事））</p><p>一般不要看中间那个地震等级，看<mark class="hl-label red">“左边那个地震烈度”</mark> 再决定跑不跑路了（跑了也不会有人说你的）</p><h2 id="体测"><a href="#体测" class="headerlink" title="体测"></a>体测</h2><p>单独拿出来讲是因为每年总有学长因为这个没法毕业，卷归卷，还是注意自己的身体状态</p><p>在大一上、大一下、大二下、大三下进行四次体测，大一的两次体测记为大一和大二，标准略低，大二与大三的体测记为大三大四，标准略高。</p><p>体测成绩与奖学金评定没啥关系，体测成绩大于50分有毕业证，但是处于50-60的会参加学校组织的体质强化训练并参加补考。</p><p>体测成绩构成：前三次共占50%（相当于每次16.7%），最后一次占50%。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/28.webp" alt="28" style="zoom: 50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blogpic/29.webp" alt="29" style="zoom:50%;" /><h2 id="干饭攻略-简略版-from-18级"><a href="#干饭攻略-简略版-from-18级" class="headerlink" title="干饭攻略(简略版 from 18级)"></a>干饭攻略(简略版 from 18级)</h2><blockquote><p>18级学姐留下来的，只是照搬一下，很多我都没去过，时效性可能有点差</p></blockquote><mark class="hl-label blue">清水河龙湖(日常聚餐约饭首选)</mark> <ol><li><p>集渔</p><p>泰式火锅，冬阴功的口味我还是挺喜欢的，但各种泰餐店大同小异，没有什么特色</p><p>点心可以随便点，不另外算钱倒是还不错，就是火锅也没多余的胃去吃太多甜点了</p></li><li><p>守柴炉烤鸭</p><p>经常买一送一，性价比高，喜欢吃烤鸭的同学不容错过</p><p>周三打折</p></li><li><p>寻味烤鱼</p><p>就喜欢他家的烤鱼，黔鱼刺少，好吃（两个意思都有） </p></li><li><p>八二小区抄手</p><p>太棒了这个简直了！肉馅真的会有大虾，还有蟹籽，特别香，无论是清汤红油还是干拌，都很好吃，绝对不亏，谁吃了都说好！</p></li><li><p>粥道</p><p>喝粥人必备，这就不用多说了趴</p></li><li><p>凉皮大王</p><p>为数不多的的好吃的凉皮。</p><p>其实一般，但是南方的北方人觉得好吃的凉皮真不多，这个就显得很稀罕。</p><p>有时候很想吃凉皮，就算他家二十块钱一碗凉皮我也认了。</p></li><li><p>好日子烤肉</p><p>便宜好吃</p></li><li><p>鱼儿纸包鱼</p><p>除了寻味之外我第二爱的烤鱼，主打便宜大碗，实惠，贫民窟女孩爱了。</p></li><li><p>凉菜</p><p>这边凉菜不多，想买散装，接地气，有家味儿的可以去红光。</p><p>如果渴望比较迫切的话，去永辉买炒肠粉！十块钱左右一份（自选）！绝对不亏！</p></li></ol><mark class="hl-label blue">“清水河南门(便宜且日常)”</mark> <ol><li><p>南京特味灌汤包</p><p>在灌汤包很少见的南方很难得，经常吃，很不错。一口咬下去都是咸香的汤汁，很棒！</p></li><li><p>无名蹄花</p><p>清汤寡水但是就是香！好吃！</p></li><li><p>馄饨大王</p><p>香拌馄饨，很独特的口味！会放一些麻酱，尝鲜解闷很不错（福建人开的）</p></li><li><p>张砂锅米线</p><p>就是很普通的小店，饺子盖浇饭米线什么的都有。</p><p>但是！！！他家米线格外入味！太难的了！米线这个东西做入味的太少了！这家就很棒！</p></li></ol><mark class="hl-label blue">“沙河建设巷(本校人建议非节假日抽空去，不然排队很恼火)”</mark> <ol><li><p>土豆</p><p>年年排队，日日排队，不过好吃是确实有点好吃，糖醋麻辣不错</p></li><li><p>苕皮豆干</p><p>十字路口处的那家，味道最好，软和糯恰到好处，当然也是排队常客</p></li><li><p>八二干海椒抄手</p><p>老店了，招牌是竹荪蟹黄，用料特足</p></li><li><p>疆味</p><p>新疆菜，推荐烤羊肉串，椒麻鸡</p></li><li><p>鸡毛店</p><p> 大众点评上搜，沙河附近有两家；第一个叫有红鸡毛店，就在财富又一城；第二个叫鸡毛店，2公里路，玉林店，我推荐这个<br> 我吃来区别不大，推荐鱼，最近第二家小龙虾活动，99，4斤（应该时间不匹配了）</p></li><li><p>叶婆婆</p><p>和在乐山吃的感觉差不多</p></li><li><p>蛋烘糕</p><p>这个东西做起来各家都没什么太大区别，都挺好吃的</p></li><li><p>鸡翅包饭</p><p>这个太好吃了！绝了！</p></li></ol><mark class="hl-label blue">“春熙路(贵且排队但好吃)”</mark> <ol><li><p>烤匠</p><p>烤鱼，IFS顶楼，建设路、清水河龙湖也有，味道挺不错的，那个花椒冰淇淋也可以</p></li><li><p>姜虎东（强烈推荐！）</p><p>IFS，吃过最真宗的烤肉，在日本韩国都呆过一段时间的朋友，都说这家烤肉店超级正宗！</p><p>价格贵一些；烤肉建议厚切五花，怎么吃都好吃</p></li><li><p>群光楼下的一家寿司店</p><p>群光坐电梯到楼下就是卖寿司的，一盒一盒的，味道其实还挺不错的。35一盒。</p></li><li><p>饕林餐厅</p><p>中餐店，黑豆花豆腐，好吃。</p></li><li><p>谭鸭血</p><p>火锅店，鸭血很好吃；可以提前屯券，屯了后去吃很便宜</p></li><li><p>泰香米</p><p>牛排，咖喱蟹，生虾，菜品确实不错，就是贵。贵，但好吃</p></li><li><p>王婆婆老妈蹄花</p><p>这家店就推荐一个，黄焖蹄花，特别好吃，吃蹄花就吃这一家就行了！</p></li><li><p>竹涟烤肉</p><p>日式碳烤，排队人居多，但奈何属实好吃 </p></li><li><p>和幸</p><p>日式猪排饭，主打炸猪排，好吃。当然，排队也是少不了……</p></li><li><p>饺子</p><p>香槟广场汉服（其实叫三坑更合适）一条街上面的甜辣味儿饺子。</p><p>初吃没什么感觉，吃完了过几天，余味回味无穷，念念不忘，后劲很足。</p></li></ol><h2 id="郫其林-from-21级"><a href="#郫其林-from-21级" class="headerlink" title="郫其林(from 21级)"></a>郫其林(from 21级)</h2><blockquote><p>这是收录来自21级的一个学妹的，看过去应该都是合理的</p></blockquote><table><thead><tr><th>店名</th><th>人均</th><th>商圈</th><th>位置</th><th>评分(1-4不推荐 5-7推荐 8-10强烈推荐)</th><th>评论</th></tr></thead><tbody><tr><td>厕所蹄花</td><td>30</td><td>清水河</td><td>顺江小区3区16栋五单元二号（忒难找了，全靠老带新）</td><td>9</td><td>一份蹄花汤，猪头肉+拌菜，直接无敌。最后几次去感觉汤没那么爽了，不知道是不是运气问题。(这个已经是18年7月的评价了，时效性X)</td></tr><tr><td>谢记烧烤</td><td>20-30</td><td>清水河</td><td>南门对面翘脚牛肉背后街上</td><td>8</td><td>烧烤夜宵好去处，点串烤饼美滋滋（</td></tr><tr><td>和幸</td><td>80-100</td><td>春熙路</td><td>伊势丹7楼</td><td>10</td><td>关婴唯一指定日式餐厅，永远滴神！     可能排队</td></tr><tr><td>马旺子</td><td>100</td><td>春熙路</td><td>大慈寺东糠市街1号</td><td>7.5</td><td>（看起来有点高端的）川菜馆，吃起来没有期望的那么牛批</td></tr><tr><td>巴蜀大宅门火锅</td><td>60-90</td><td>新华公园</td><td>新鸿南路75号</td><td>9</td><td>唯一指定火锅店，人均能嗦两碗冰粉，另有油油饭供大家挑战（     可能排队</td></tr><tr><td>秦人面馆</td><td>15</td><td>清水河</td><td>龙湖外侧靠右（？）</td><td>7.5</td><td>不知道吃啥的时候喜欢去的面馆</td></tr><tr><td>贾家胖师烧鸭</td><td>45</td><td>清水河</td><td>秦人面馆往前走</td><td>8</td><td>鸭，好吃，够味</td></tr><tr><td>北平楼老北京涮羊肉</td><td>80</td><td></td><td>记不得去的是哪一家了</td><td>9.5</td><td>店里老大爷好热情，吃肉好爽</td></tr><tr><td>乍都乍泰食餐厅</td><td>60</td><td>春熙路</td><td>银石广场5楼</td><td>8</td><td>如果喜欢吃酸应该会喜欢这家吧</td></tr><tr><td>元町之味豚骨拉面</td><td>50</td><td>春熙路</td><td>伊势丹负1层</td><td>8.5</td><td>比雷门好吃（暴论</td></tr><tr><td>藏碳烧肉屋</td><td>80</td><td>沙河</td><td>建设路26号</td><td>8.5</td><td>骰子牛肉好     可能排队</td></tr><tr><td>新疆达斯坦</td><td>100</td><td>金沙遗址附近</td><td>清溪西路40号</td><td>6.5</td><td>是真的很新疆，羊拉满，我个人不太行，但是建议喜欢羊的朋友试一试</td></tr><tr><td>玉芝兰</td><td>1400</td><td>长发街</td><td>长发街24号</td><td>8</td><td>泡椒凤爪不错，虾冻鱼子酱也很好吃，黄鱼也很好，但是偏清淡</td></tr><tr><td>全福居老北京涮羊肉</td><td>90</td><td>华阳</td><td>华阳滨河路115号</td><td>8</td><td>自助，红烧羊蝎子好味</td></tr><tr><td>斗鸡饭场伙</td><td>80</td><td>新城市广场</td><td>青羊区同心路27号</td><td>8.5</td><td>新派川菜，味道地道</td></tr><tr><td>麻辣公社火锅</td><td>60</td><td>清水河</td><td>南门出去过马路往右一直走</td><td>9</td><td>是重庆火锅的味道，真的很好吃！和成都火锅不一样。个人更喜欢重庆的，比较香，不是干辣。</td></tr><tr><td>秦云老太婆摊摊面</td><td>12</td><td>清水河</td><td>南门出过街左侧</td><td>9</td><td>好吃好吃好吃好好吃还很便宜12块钱能吃饱</td></tr><tr><td>隆江猪脚饭(秦人面馆旁)</td><td>20</td><td>清水河</td><td>郫都区合作路89号6栋附0115</td><td>8</td><td>大份猪肘饭16，香，略腻。大份猪脚饭30，个人不如猪肘饭肥瘦搭配来的好吃。小菜腌萝卜不错，辣椒油很香。免费的汤不太好喝。</td></tr><tr><td>凉山好汉自助烤肉</td><td>75</td><td>沙河</td><td>成华区339</td><td>8</td><td>价格公道，实惠，推荐厚切五花，牛肉粒</td></tr><tr><td>汉堡王</td><td>30</td><td>清水河</td><td>高德地图(？)</td><td>8</td><td>除了汉堡都好吃，穷人版肯德基</td></tr><tr><td>花雕醉鸡</td><td>50</td><td>清水河</td><td></td><td>9</td><td>辣度选好了，真的好吃</td></tr><tr><td>高原第一家资格烤羊肉</td><td>50（肉食动物不止）</td><td>清水河</td><td>龙湖18栋（鹿鼎寨旁边的巷子进去左边）</td><td>8</td><td>好吃，略贵。提醒：新疆烤羊肉是中间有一大块肥油，可能会不合口味。推荐羊肚。</td></tr><tr><td>点妈饺子馆</td><td>20</td><td>清水河</td><td>鹿鼎寨右边第二条巷子</td><td>8</td><td>焖面一绝 13吃到饱 有免费蛋花汤和泡菜味道很爽</td></tr><tr><td>荆州生烤鸡</td><td>20</td><td>清水河</td><td>南门芒果酒店旁边</td><td>8</td><td>味道不错，鸡肉比较嫩</td></tr><tr><td>馄饨大王</td><td>20</td><td>清水河</td><td>南门清源北巷</td><td>8</td><td>干拌混沌必点 北方人应该很喜欢 用芝麻酱加辣椒拌的 很香  他家的面食泡椒肥肠面也很好吃 推荐</td></tr><tr><td>kevin’s  lab</td><td>100+(吃牛排的话人均200+)</td><td>清水河</td><td>高德地图(龙湖总店，滨江东路分店)</td><td>8</td><td>贵不是他的问题，是我的</td></tr><tr><td>寻味烤鱼</td><td>50</td><td>清水河</td><td>龙湖18栋3楼</td><td>8</td><td></td></tr><tr><td>小小串</td><td>50</td><td>清水河</td><td>南门清源北巷</td><td>9</td><td>有一点贵 但是真的好吃 特别推荐脑花 吃过的最好吃的脑花  一点都不腥 推荐沾干碟吃</td></tr><tr><td>涛哥饺子馆</td><td>30</td><td>清水河</td><td>地图自搜</td><td>9</td><td>北方人的天堂 分量是东北的分量 味道中等 但是分量真足 锅包肉  干炸蘑菇 拔丝红薯 农家四顿都很好</td></tr><tr><td>蛙三泡椒牛蛙</td><td>80</td><td>连锁</td><td>高德地图</td><td>8.5</td><td>泡椒牛蛙很好吃</td></tr><tr><td>朝阳餐厅烤鱼饭</td><td>23+1</td><td>清水河</td><td>朝阳餐厅</td><td>8.5</td><td>好吃小贵</td></tr><tr><td>八二小区抄手</td><td>20</td><td>清水河</td><td>龙湖偏右边一点</td><td>9.5</td><td>除了有时候排队人很多，其他都完美</td></tr><tr><td>彩云南天麻火腿鸡</td><td>50</td><td>清水河</td><td>龙湖19栋104号</td><td>8</td><td>鸡汤味道很鲜</td></tr><tr><td>云海肴</td><td>80</td><td>连锁</td><td>地图自搜</td><td>8.5</td><td>汽锅鸡汤很好喝，基本没有调料的味道</td></tr><tr><td>正禾鲜潮汕牛肉火锅</td><td>80</td><td>清水河</td><td>龙湖四楼</td><td>8.5</td><td>贵，毕竟是纯牛肉</td></tr><tr><td>百柠东南亚料理</td><td>80</td><td>清水河</td><td>龙湖28栋3号电梯401</td><td>8.5</td><td>新开的店，装修不错，吃的东西比较有特色，味道也不错</td></tr><tr><td>飞火令</td><td>70</td><td>清水河</td><td>龙湖21栋1层</td><td>9</td><td>烤肉 好吃 菜品多，新鲜 真肉</td></tr><tr><td>蓝蛙blue  frog</td><td>100+</td><td>连锁</td><td></td><td>4</td><td>确实是有名，很多商圈很好的店铺位置，东西适合拍照但是确实是不好吃</td></tr><tr><td>Jimmy’s  Table</td><td>70-80</td><td>金牛凯德</td><td></td><td>7</td><td>反正团购的是还不错，融合西餐</td></tr><tr><td>n 2.room</td><td>100</td><td>九眼桥</td><td>香格里拉对面</td><td>6</td><td>在它的价位和地段中规中矩，楼好看点罢了</td></tr><tr><td>协信希尔顿</td><td>150</td><td>沙河</td><td>协信中心</td><td>6</td><td>对于酒店本身配置来说很一般，甜品是速冻的</td></tr><tr><td>鞠婆婆绵绵冰</td><td>30</td><td>乐山&#x2F;建设路</td><td>建设路太阳公元一楼底商</td><td>6</td><td>乐山的还可以，建设路的就普普通通一冰，和对面万得五五开吧</td></tr><tr><td>凑凑</td><td>100</td><td>银泰in99&#x2F;万象城</td><td></td><td>8</td><td>这个分主要是给花胶鸡的</td></tr><tr><td>淮南牛肉汤</td><td>20</td><td>清水河</td><td>龙湖蜀抄手旁边那栋楼，具体几栋忘了</td><td>8</td><td>蛮正宗，烧饼很脆，冬天适合没什么胃口的时候弄一碗牛肉汤喝喝，肉量适中粉量很足</td></tr><tr><td>胖老汉</td><td></td><td></td><td>人民公园，成飞大道，西御街均有分店</td><td>9</td><td>羊肉串味道很不错（吃不惯羊肉者慎点）；椒麻鸡，鸽子拌面也很好吃</td></tr><tr><td>上井精致料理</td><td>300</td><td>连锁</td><td>成都有7家</td><td>8</td><td>和牛不错</td></tr><tr><td>一生烧肉</td><td>600</td><td>春熙路</td><td>总府路Z31商场</td><td>9</td><td>牛肉yyds！冲冲冲！</td></tr><tr><td>绿茶餐厅</td><td>100</td><td>春熙路</td><td>太古里二楼</td><td>9</td><td>面包诱惑yyds</td></tr><tr><td>姜虎东白丁</td><td>150</td><td>春熙路</td><td>ifs-6楼</td><td>9</td><td>好吃的！炒年糕好吃，帮忙烤肉店小哥哥真的好帅！！！！！！！！</td></tr><tr><td>黑船酒厂</td><td>400</td><td>太古里</td><td>东大街</td><td>9</td><td>成都烧鸟天花板</td></tr><tr><td>柴门饭儿</td><td>150</td><td>太古里</td><td>太古里</td><td>8</td><td>糖油果子好吃</td></tr><tr><td>宽三人文创意川菜</td><td>200</td><td>太古里</td><td>太古里二楼</td><td>8</td><td>很有特色，菜品装饰很棒，酱油炒饭好吃</td></tr><tr><td>都市二当家·木系</td><td>200</td><td>春熙路</td><td>ifs7楼</td><td>9</td><td>云南特色菜，很好吃的！</td></tr><tr><td>焱铁烧</td><td>260</td><td>太古里</td><td>太古里2楼</td><td>8</td><td>日式烤肉。两个人的话，点一份牛气冲天也就够了</td></tr><tr><td>玥轩</td><td>300</td><td>春熙路</td><td>ifs2楼</td><td>8</td><td>正常茶餐厅吧，比点都德好吃，老虎虾很棒，现场制作</td></tr><tr><td>La  Picada</td><td>150</td><td>太古里</td><td>太古里2楼</td><td>8</td><td>很棒的西班牙餐厅</td></tr><tr><td>翠园</td><td>400</td><td>太古里</td><td>太古里2楼</td><td>9</td><td>翠园可以说是成都粤菜天花板了吧</td></tr><tr><td>烤匠麻辣烤鱼</td><td>100</td><td>连锁</td><td>龙湖就有一家</td><td>9</td><td>经典麻辣烤鱼好吃的！</td></tr><tr><td>重庆鸡公煲</td><td>30</td><td>南门</td><td>南门对面</td><td>7</td><td>味道的话，没什么毛病，但是看当天厨师的心情了，有时候太咸，有时候太淡，而且人多的时候速度是真的巨慢</td></tr><tr><td>土灶人家·柴火鸡</td><td>50-80</td><td>都江堰</td><td>都江堰高铁站附近</td><td>8</td><td>其实坐高铁去很方便的，犀浦上车，都江堰下车，柴火鸡里面东西很丰富，卤鸡很好吃！</td></tr><tr><td>张记好实惠冒菜</td><td>40</td><td>武侯祠</td><td>燃灯寺东街14号</td><td>8</td><td>路边苍蝇馆子，饭店人很多，味道很好</td></tr><tr><td>瓦烤</td><td>70</td><td>连锁</td><td>成都有11家</td><td>8</td><td>宜宾烧烤，好吃</td></tr><tr><td>秦肥肠</td><td>50</td><td>建设路</td><td>成华区建兴路76号</td><td>8</td><td>开了很多年了，肥肠好吃，喜欢肥肠的赶紧冲</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 🏫校园生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量子力学开卷纸</title>
      <link href="/posts/2075520377.html"/>
      <url>/posts/2075520377.html</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/开卷纸.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字逻辑设计及应用</title>
      <link href="/posts/508586316.html"/>
      <url>/posts/508586316.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为是英文答题和英文题目，所以带的英文有点多</p></blockquote><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/数字逻辑设计及应用.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电磁场与波</title>
      <link href="/posts/761263898.html"/>
      <url>/posts/761263898.html</url>
      
        <content type="html"><![CDATA[<p>这份笔记是在学习完整本书之后没有按照课本顺序按自己的归纳顺序书写的，课时笔记见第二份pdf</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/电磁场.pdf" width="100%" height="550" type="application/pdf"></div><hr><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/电磁场k.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用光学</title>
      <link href="/posts/2075520371.html"/>
      <url>/posts/2075520371.html</url>
      
        <content type="html"><![CDATA[<p>写了很多，考试可能一点用没有</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/应光.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JsDelivr降速后的处理</title>
      <link href="/posts/253396570.html"/>
      <url>/posts/253396570.html</url>
      
        <content type="html"><![CDATA[<p>自从 <a href="https://www.jsdelivr.com/">jsDelivr</a> 速度下降后，现在连访问也出现了问题  </p><p>参考了一位博主的修改策略</p><a href="https://android99.me/2022/05/17/butterfly-replace-cdn/,https://android99.me/img/avatar.png" title="" target="">利用插件系统，批量替换 Butterfly 主题的 CDN,</a><p>在butterfly主题目录下的<code>scripts</code> 文件夹中创建一个js文件，文件名任意</p><p>根据主题版本选择代码：</p><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">4.2.0+</button><button type="button" class="tab " data-href="1-2">2.0.0+</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; filter &#125; = hexo.<span class="property">extend</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换 CDN</span></span><br><span class="line">filter.<span class="title function_">register</span>(<span class="string">&#x27;before_generate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; asset &#125; = hexo.<span class="property">theme</span>.<span class="property">config</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> asset) &#123;</span><br><span class="line">        asset[name] = asset[name]</span><br><span class="line">            .<span class="title function_">replace</span>(<span class="string">&#x27;//cdn.jsdelivr.net/npm/&#x27;</span>, <span class="string">&#x27;//npm.elemecdn.com/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">11</span>);</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="1-2"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; filter &#125; = hexo.<span class="property">extend</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换 CDN</span></span><br><span class="line">filter.<span class="title function_">register</span>(<span class="string">&#x27;before_generate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="variable constant_">CDN</span> &#125; = hexo.<span class="property">theme</span>.<span class="property">config</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> <span class="variable constant_">CDN</span>) &#123;</span><br><span class="line">        <span class="variable constant_">CDN</span>[name] = <span class="variable constant_">CDN</span>[name]</span><br><span class="line">            .<span class="title function_">replace</span>(<span class="string">&#x27;//cdn.jsdelivr.net/npm/&#x27;</span>, <span class="string">&#x27;//npm.elemecdn.com/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">11</span>);</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>根据需要更改 <code>replace</code> 方法的参数，上文是将 <a href="https://www.jsdelivr.com/">jsDelivr</a> 替换为 饿了么</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🦋butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyqt5简单实践</title>
      <link href="/posts/3865533702.html"/>
      <url>/posts/3865533702.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><p>先在python安装环境目录下安装pyqt5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5</span><br></pre></td></tr></table></figure><p>需要在安装python包的目录下找到Qt Designer工具主界面</p><p>路径为：{python安装目录}&#x2F;Lib&#x2F;site-packages&#x2F;pyqt5_tools&#x2F;designer.exe；</p><p>这个软件可以搞个快捷方式在桌面，相比QT比较轻量，简单的一些设计用它就可以了</p><p>主页面如下：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/typora/774327-20190723072103106-1736947814.png" alt="img" style="zoom:67%;" /><p>Qt Designer基本控件介绍</p><ol><li><p>显示控件。</p><p><b>Lable</b>：文本标签，显示文本，可以用来标记控件</p><p><b>Text Browser</b>：显示文本控件。用于后台命令执行结果显示</p></li><li><p>输入控件，提供与用户输入交互</p><p><b>Line Edit</b>：单行文本框，输入单行字符串。控件对象常用函数为Text() 返回文本框内容，用于获取输入。setText() 用于设置文本框显示</p><p><b>Text Edit</b>：多行文本框，输入多行字符串。控件 对象常用函数同Line Edit控件</p><p><b>Combo Box</b>：下拉框列表。用于输入指定枚举值</p></li><li><p>控件按钮，供用户选择与执行</p><p><b>Push Button</b>：命令按钮。常见的确认、取消、关闭等按钮就是这个控件。<b>clicked</b>信号一定要记住，clicked信号就是指鼠标左键按下然后释放时会发送信号，从而触发相应操作。一般要关联connect调用函数</p><p><b>Radio Button</b>：单选框按钮</p><p><b>Check Box</b>：多选框按钮</p></li></ol><p>根据需要拖拽控件，注意添加完成后在属性编译器中修改<code>objectname</code>，便于之后python的类操作</p><p>本文窗口如下</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/typora/image-20220528215624688.png" alt="image-20220528215624688" style="zoom:67%;" /><h2 id="将-ui文件转换为-py文件"><a href="#将-ui文件转换为-py文件" class="headerlink" title="将.ui文件转换为.py文件"></a>将.ui文件转换为.py文件</h2><p>在终端控制台中输入命令，调用格式为：pyuic5 -o {输出文件名} {输入designer设计好的.ui后缀界面文件}</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyuic5 -o ui.py ui.ui</span><br></pre></td></tr></table></figure><h2 id="界面与功能分离实现"><a href="#界面与功能分离实现" class="headerlink" title="界面与功能分离实现"></a>界面与功能分离实现</h2><p>为了后续修改方便，采用界面与功能相分离来实现，也就是通过创建主程序调用界面文件方式实现。</p><p>基本固定框架：（初始化）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入程序运行必须模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow</span><br><span class="line"><span class="comment">#导入designer工具生成的模块</span></span><br><span class="line"><span class="keyword">from</span> ui <span class="keyword">import</span> Ui_Form</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainForm</span>(QMainWindow, Ui_Form):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MyMainForm, <span class="variable language_">self</span>).__init__(parent)</span><br><span class="line">        <span class="variable language_">self</span>.setupUi(<span class="variable language_">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    <span class="comment">#初始化</span></span><br><span class="line">    myWin = MyMainForm()</span><br><span class="line">    <span class="comment">#将窗口控件显示在屏幕上</span></span><br><span class="line">    myWin.show()</span><br><span class="line">    <span class="comment">#程序运行，sys.exit方法确保程序完整退出。</span></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h2 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h2><p>就是创建点击后的连接函数，详见代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2022/5/27 16:56</span></span><br><span class="line"><span class="comment"># @Author : YH</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"><span class="comment">#导入designer工具生成的login模块</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> ui <span class="keyword">import</span> Ui_Form</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainForm</span>(QMainWindow, Ui_Form):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MyMainForm, <span class="variable language_">self</span>).__init__(parent)</span><br><span class="line">        <span class="variable language_">self</span>.setupUi(<span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.setWindowTitle(<span class="string">&quot;像距像高计算器&quot;</span>)</span><br><span class="line">        <span class="comment"># 修改favion图片，需要添加from PyQt5.QtGui import QIcon,最好用绝对路径避免生成exe文件报错</span></span><br><span class="line">        <span class="variable language_">self</span>.setWindowIcon(QIcon(<span class="string">r&#x27;D:\pythonproject\ui\favicon.png&#x27;</span>))</span><br><span class="line">        <span class="comment"># 添加计算按钮信号和槽。注意display函数不加小括号()</span></span><br><span class="line">        <span class="variable language_">self</span>.cal.clicked.connect(<span class="variable language_">self</span>.display)</span><br><span class="line">        <span class="comment"># 添加退出按钮信号,调用close函数</span></span><br><span class="line">        <span class="variable language_">self</span>.cancel.clicked.connect(<span class="variable language_">self</span>.close)</span><br><span class="line">        <span class="comment">#添加重置信号</span></span><br><span class="line">        <span class="variable language_">self</span>.res.clicked.connect(<span class="variable language_">self</span>.clean)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 利用line Edit控件对象text()函数获取界面输入</span></span><br><span class="line">        l1 = <span class="variable language_">self</span>.l1.text()</span><br><span class="line">        h1 = <span class="variable language_">self</span>.h1.text()</span><br><span class="line">        <span class="comment"># 数据处理</span></span><br><span class="line">        <span class="keyword">if</span>(l1.isdecimal() <span class="keyword">and</span> h1.isdecimal()):</span><br><span class="line">            h2 = h1</span><br><span class="line">            l2 = l1</span><br><span class="line">            <span class="comment"># 利用text Browser控件对象setText()函数设置界面显示</span></span><br><span class="line">            <span class="variable language_">self</span>.sign.setText(<span class="string">&quot;输入物距像距成功！&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.h2.setText(h2)</span><br><span class="line">            <span class="variable language_">self</span>.l2.setText(l2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.sign.setText(<span class="string">&quot;输入数据有误，请重新输入！&quot;</span>)</span><br></pre></td></tr></table></figure><p>在Qt Designer上修改主界面最大属性中的长宽设置成与最小属性一致可避免窗口被拉伸后奇奇怪怪</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/typora/image-20220528220218000.png" alt="image-20220528220218000" style="zoom:67%;" /><h2 id="Pyinstaller打包成-exe文件"><a href="#Pyinstaller打包成-exe文件" class="headerlink" title="Pyinstaller打包成.exe文件"></a>Pyinstaller打包成.exe文件</h2><p>最搞人的东西来了，可以使用pyinstaller工具将程序打包成.exe文件</p><p>首先要安装第三方库pyinstaller</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure><p>最普遍的情况，在控制台中输入：（test为python文件名）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -w test.py </span><br></pre></td></tr></table></figure><p>如果引入模块了，需要修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller [主文件] -p [其他文件1] -p [其他文件2] </span><br></pre></td></tr></table></figure><p>更换exe程序图标</p><p>需要准备后缀为.ico的图片，执行命令：pyinstaller -F -i [图片名].ico [文件名].py。（-i表示更换图标）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -i favicon.ico test.py -p ui.py -w  </span><br></pre></td></tr></table></figure><p>在根目录下你会发现出现一个dist的文件夹，exe文件就在其中啦</p>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外挂标签</title>
      <link href="/posts/799695709.html"/>
      <url>/posts/799695709.html</url>
      
        <content type="html"><![CDATA[<p>本文章转载自<a href="https://akilar.top/page/2/">糖果屋</a> </p><a href="https://akilar.top/posts/615e2dec/," title="https:&#x2F;&#x2F;npm.elemecdn.com&#x2F;akilar-candyassets&#x2F;image&#x2F;siteicon&#x2F;favicon.png" target="">基于Butterfly的外挂标签引入,</a><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><ol><li>安装插件,在博客根目录<code>[Blogroot]</code>下打开终端，运行以下指令：</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-tag-plugins-plus --save</span><br></pre></td></tr></table></figure><p>  考虑到hexo自带的markdown渲染插件<code>hexo-renderer-marked</code>与外挂标签语法的兼容性较差，建议您将其替换成<a href="https://www.npmjs.com/package/hexo-renderer-kramed">hexo-renderer-kramed</a></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><ol start="2"><li>添加配置信息，以下为写法示例<br>在站点配置文件<code>_config.yml</code>或者主题配置文件<code>_config.butterfly.yml</code>中添加</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tag-plugins-plus</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/615e2dec/</span></span><br><span class="line"><span class="attr">tag_plugins:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">issues:</span> <span class="literal">false</span> <span class="comment">#issues标签依赖注入开关</span></span><br><span class="line">  <span class="attr">link:</span></span><br><span class="line">    <span class="attr">placeholder:</span> <span class="string">/img/link.png</span> <span class="comment">#link_card标签默认的图标图片</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br><span class="line">    <span class="attr">anima:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css</span> <span class="comment">#动画标签anima的依赖</span></span><br><span class="line">    <span class="attr">jquery:</span> <span class="string">https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js</span> <span class="comment">#issues标签依赖</span></span><br><span class="line">    <span class="attr">issues:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/issues.js</span> <span class="comment">#issues标签依赖</span></span><br><span class="line">    <span class="attr">iconfont:</span> <span class="string">//at.alicdn.com/t/font_2032782_8d5kxvn09md.js</span> <span class="comment">#参看https://akilar.top/posts/d2ebecef/</span></span><br><span class="line">    <span class="attr">carousel:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js</span></span><br><span class="line">    <span class="attr">tag_plugins_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css</span></span><br></pre></td></tr></table></figure><ol start="3"><li>参数释义</li></ol><table><thead><tr><th align="left">参数</th><th align="left">备选值&#x2F;类型</th><th align="left">释义</th></tr></thead><tbody><tr><td align="left">enable</td><td align="left">true&#x2F;false</td><td align="left">【必选】控制开关</td></tr><tr><td align="left">priority</td><td align="left">number</td><td align="left">【可选】过滤器优先级，数值越小，执行越早，默认为10，选填</td></tr><tr><td align="left">issues</td><td align="left">true&#x2F;false</td><td align="left">【可选】issues标签控制开关，默认为false</td></tr><tr><td align="left">link.placeholder</td><td align="left">【必选】link卡片外挂标签的默认图标</td><td align="left"></td></tr><tr><td align="left">CDN.anima</td><td align="left">URL</td><td align="left">【可选】动画标签anima的依赖</td></tr><tr><td align="left">CDN.jquery</td><td align="left">URL</td><td align="left">【可选】issues标签依赖</td></tr><tr><td align="left">CDN.issues</td><td align="left">URL</td><td align="left">【可选】issues标签依赖</td></tr><tr><td align="left">CDN.iconfont</td><td align="left">URL</td><td align="left">【可选】iconfont标签symbol样式引入，如果不想引入，则设为false</td></tr><tr><td align="left">CDN.carousel</td><td align="left">URL</td><td align="left">【可选】carousel旋转相册标签鼠标拖动依赖，如果不想引入则设为false</td></tr><tr><td align="left">CDN.tag_plugins_css</td><td align="left">URL</td><td align="left">【可选】外挂标签样式的CSS依赖，为避免CDN缓存延迟，建议将@latest改为具体版本号</td></tr></tbody></table><h2 id="链接卡片-link"><a href="#链接卡片-link" class="headerlink" title="链接卡片 link"></a>链接卡片 link</h2><div class="tabs" id="link"><ul class="nav-tabs"><button type="button" class="tab " data-href="link-1">标签语法</button><button type="button" class="tab  active" data-href="link-2">样式预览</button><button type="button" class="tab " data-href="link-3">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="link-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content active" id="link-2"><p><a href="https://akilar.top/posts/615e2dec/," title="https:&#x2F;&#x2F;npm.elemecdn.com&#x2F;akilar-candyassets&#x2F;image&#x2F;siteicon&#x2F;favicon.ico" target="">糖果屋教程贴,</a></p></div><div class="tab-item-content" id="link-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://npm.elemecdn.com/akilar-candyassets/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="引用自身文章"><a href="#引用自身文章" class="headerlink" title="引用自身文章"></a>引用自身文章</h2><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">hexo原生方法(不推荐)</button><button type="button" class="tab " data-href="1-2">hexo-abbrlink插件方法</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>% post_link 文章文件名（不要后缀） 文章标题（可选） %<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>% post_link Hello-World %<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span>% post_link Hello-World 你好世界 %<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="1-2"><p>确保安装了hexo-abbrlink</p><p>安装插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>修改根目录站点配置文件<code>config.yml</code>，改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">    <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">    <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure><p>使用方法：<code>[](/posts/abbrlink)</code>也就是相对路径来引用自己的文章</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> 🦋butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>私人日记</title>
      <link href="/posts/3073024705.html"/>
      <url>/posts/3073024705.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="6303ffea042406641a3ea0de94a596c6bbdc8465ab96344c4994b800ea570821">14d476ddf32f83037ff874eee2b3f7f350506914051fde6e8888b8d77a8b0e7c724111c0e1bb18f89e84a3038e63ea244cdbafd5008bafb093b93ef7e4e80bc417775941d2234dc98fe34cc40eef747582a11b7fea0597a0b1befc9145acf2e17ee228980b4e49a62d3a0800f8acf48a252e59173a8e5507a83f0f6e3b464807fef9cbbde70d9cc469dce712768aecc024568374af3afa9a00cb737dfa40eaf6ccfc2a1c533a43754fde498061e2e4f43994234ce9951015b39295544f042ad7d3c837e6f766f7399e62ebcdc2a90b3f5d7e98c1f535d305f7d0503ccbf19f396247f2b95db0be82e8df091a80ea18a0c3755e283ef5d6f01a290a491c1b484f1ca10dd3b038c7de750ffba1ea707583e8708cfd860b56d3896e9d3a084db8572daf8b8b2cd0c189e55ef16aed5f0a993756c05de8d85e33320c5954a735842d6268d69a76024bd8e3c5cc95afa85ebe8d65098b6739a2fbe25804cec40e5b72a55e60de70dc0d7bbfc9f4eb59f30809109711a4a8397c524082c2af8bfea81875c1c49fdee639dd388f309f05cf48dbe8c58da96066f55749b32ade49364c4b94ce1d3a0c5626ce815ffeffcbc64d99e93320ffb1d00903f0b1bb557b9c44424baf425e8cedc5ba9e0c7056ad963d1c6b336c957e8ebdf595a6f7581ca2d53bc562a8aa15ff156e455c36587a075aa8ff6e836df1a3a435655b04478e49086821d0798c8fc4eb26e7ff250d1406c089fd8e910d94119f6bc2fbb6284a59e0eb8547ec52faa7b1aa8d06fc5ceca4541b6507242945f524eb8d2821128d132c536494a0331ca12dee447f1755b42fa28978ae6b7e88a691b632d20041ae3e841d7e402ae78e5db65f4af21c46cb7a4c3055b80f3affec082b32dfe295524af3fd8630369c6536a585a2489e133558607dbd8155b98580365e967b67082aa4d6eda5a15d2e974e5e7f74dde3c65c4202aa3400a7dd801f9d32fdd28dcff9e5c549b47a3154435b487fe34e65d5717305e6752f9335e3708d8ecbe48aab4809d6fdb7179bae8fa10da935bc1cbddaecb76ce5baa0fd14433a62e30db2d5fbcc6c9c0bd0ffa6c4cd04a98c075c47a1fb31bbadff715bc7a33d2d28791448d17f04ab7a0f17356a0eb157ff15a9cf0060dcb32bb688f30c484eda1b3079029075de50c27118a5b540aaa7f2e243fc4e893544be3006abb161e223fe8f620277b8de2e4617ba8e9d6b48ae8be6160bee50714fcc7f5531dd8b733cb2382a67567d79643ecf451fe1451b9e9884acc52414b9493252e165e1bd8625f1a32d48f316b6953477a475c1b08e32e348d5f85ed44495e808f2e316b2b16c09d9132566aad6cb137c4929de5538d97af9611eb87aef6357deae97e18afa0d8c7412080324bd14caec542765a21af4d7635679c9909aa388f23a8246e23baf8beb8f08755f9912</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">私人文章，不对外开放，请理解</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>193nm波长光刻机粗认识</title>
      <link href="/posts/3629474477.html"/>
      <url>/posts/3629474477.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>讨论课题目：193 nm 波长的光刻机能刻出最窄线宽多少的芯片？重点研究工作波长 193 nm 的投影光刻物镜，阐述其中的光学原理，画出结构原理图，探讨波长、数值孔径和分辨率等光学系统参数的选择问题，分析主要像差  </p></blockquote><p>在开始前首先提两个名词：</p><p><code>EUV</code>：<b>极紫外光刻</b>（Extreme ultra-violet），第五代光刻机（目前最先进）采用波长为13.5nm的极紫外光作为曝光光源， 分辨率可达ArF光刻机 3~5倍；Nikon 公司把EUV 之前的投影物镜设计分为四代。</p><p><code>DUV</code>：<b>深紫外光刻</b>（Deep Ultraviolet Lithography），第四代光刻机采用了193nm的 ArF（氟化氩）准分子激光，有浸没式光刻和双重光刻工艺；</p><p>浸入技术：让镜头和硅片之间的空间浸泡于液体之中，采用纯净水且折射率为1.44，193nm的ArF光经过纯净水的折射后，等效波长为134nm，从而实现更高的分辨率</p><h2 id="Q1最窄线宽"><a href="#Q1最窄线宽" class="headerlink" title="Q1最窄线宽"></a>Q1最窄线宽</h2><blockquote><p>193 nm 波长的光刻机能刻出最窄线宽多少的芯片？  </p></blockquote><p>理论上，使用193纳米浸入式ArF光源的DUV光刻机一次曝光可以生产的最小极限尺寸就是28纳米，通过多次曝光（最少是4次）如今可以做到7nm的芯片。</p><p>EUV可以做到一次获得7nm的芯片，DUV多次曝光每次的成本都相当昂贵。从效率和成本上来说，这也是现如今仍然需要EUV的原因（这一技术现在仅ASML公司拥有）</p><h2 id="Q2投影光刻物镜的光学原理"><a href="#Q2投影光刻物镜的光学原理" class="headerlink" title="Q2投影光刻物镜的光学原理"></a>Q2投影光刻物镜的光学原理</h2><blockquote><p>工作波长 193 nm 的投影光刻物镜的光学原理</p></blockquote><p>先放一张投影光刻机的简易原理图：（网图）</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220504152822583.png" alt="简易工作原理图" style="zoom: 67%;" /><p>物镜的主要作用是把掩膜版上的电路图按比例缩小，再被激光映射的硅片上，并且物镜还要补偿各种光学误差。技术难度就在于物镜的设计难度大，精度的要求高。</p><p>投影光刻物镜采用的准分子激光光源具有很强的时间相干性，但光源在空间上具有扩展性，即照明光源的“有效光源”是一个面光源，此时掩膜上的照明光是来自多个方向的平面波的叠加，这种照明方式成为部分相干照明。图中照明出瞳表示<br>照明系统，物镜光瞳、入瞳和出瞳表示投影光刻物镜</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220513095005197.png" alt="image-20220513095005197" style="zoom:50%;" /><p>有效光源上每个光源点都对应一束以一定角度入射到掩膜面上的平面波，不同的光源点对应平面波的角度不同，在掩膜处形成近场衍射分布，各级衍射光经过入瞳面到达出瞳面时，其振幅、相位和偏振态受到物镜影响而发生变化，导致出瞳面处各级衍射光的传播方向发生改变，出射的各衍射级次光波在像面上相干叠加，得到该光源的相干成像</p><h3 id="物镜结构"><a href="#物镜结构" class="headerlink" title="物镜结构"></a>物镜结构</h3><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220504113755361.png" alt="紫外物镜口径与NA发展趋势  " style="zoom:50%;" /><p><b>球面</b>：</p><p>随着 NA 的增加，场曲的校正更加的困难，E. Glatzel 提出了一种“腰肚”结构的方法来减小场曲，系统的结构依次为正组，负组，正组，负组，正组，这时镜头的特点是边缘光线的轨迹形成了 2 个“腰”，所以该种系统结构通常称为“双腰”，这种结构自 1987 年后就一直采用至今。 </p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220504164001694.png" alt="双腰结构" style="zoom:80%;" /><p><b>非球面</b>：</p><p>当数值孔径超过 0.7 时，系统元件口径会急速增大，非球面元件不仅能够补偿每组各自的像差，同时也能补偿其他元件组产生的高级像差，在非球面设计方案中，一些像差（甚至是一些低阶像差）残留在各表面上，然后通过使用数个非球面元件来补偿这些残存的像差，随着非球面元件数目增加，双腰结构逐渐演化为单腰结构。</p><p><b>折返式结构</b>：</p><p>在折射式光刻物镜为了校正匹兹万场曲，必须使用大光焦度的负透镜和大口径的正透镜，产生的副作用是三叶像差占主导，因此发展出了折返式投影光刻物镜。折返结构中凹面反射镜产生的副作用非常小，因为反射镜具有正的光焦度和负的场曲，因此就不需要大光焦度的负透镜和大口径的正透镜来满足场曲的控制</p><hr><p>现在市场上193nm光刻机主要为浸入步进式投影光刻机（步进式指可以连续曝光），主流的浸没式投影物镜均采用折反式结构，NA达到惊人的1.35，而水的折射率是1.44左右，这基本上是当前浸液条件下的极限。如果想进一步提高NA，只能研究新的光学材料和浸没液体，但进展有限</p><p>折返式设计有同轴两反射镜系统和离轴三反射镜系统两种（以下简称同轴式和离轴式，也可叫单轴或多轴）  </p><mark class="hl-label orange">同轴折返式光刻物镜</mark> <p>该结构主要包括折射镜组、反射镜组和数值孔径组（即折射物镜组2）</p><p>折射镜组和反射镜组的主要功能是平衡系统像差，数值孔径组将中间像传承到像面上并保证较大的数值孔径和较小的远心度。其中反射镜组由２个反射镜组成，且光轴与折射镜组相同。反射镜组之间的成像光束近似平行，使反射镜组两端的两个中间像比例接近１∶１，有助于校正像差。 </p><blockquote><p>远心度：横向位置偏移&#x3D;d变化× tanθ，远心度越小，对准精度越高</p></blockquote><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220504161908004.png" alt="image-20220504161908004" style="zoom:67%;" /><mark class="hl-label orange">离轴折返式光刻物镜</mark> <p>该结构包含３个反射镜，其中２个是平面反射镜，１个是凹面反射镜</p><p>反射镜组的光轴与折射镜组的光轴垂直。系统内部包含２个中间像。该结构的最大特点是使用了Schumann中继结构，即在光瞳附近用了一片凹面反射镜和一个负透镜组。该子系统的放大率接近１，并且接近光瞳，所以不会附加非对称性像差。负透镜组与凹面反射镜组合使用可以很大程度上矫正场曲，并在一定程度上降低色差。选择曲率适当的反射镜和凹透镜组有利于降低中间像的像差，进而降低整个光刻物镜的像差 。 </p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220504170312791.png" alt="image-20220504170312791" style="zoom: 67%;" /><hr><p>总的来说同轴方案的NA值大于离轴方案，但代价就是元件的加工难度更高，离轴方案的机械结构更复杂。同轴方案具有唯一的光轴，结构较为紧凑，离轴方案具有水平和垂直两个光轴，对机械设计和装调提出了更多挑战，而且由于反射镜位于光瞳附近，这意味着较小的反射镜倾斜就会引起较大的像面倾斜。综上所述，无论是机械结构的复杂度还是装配技术的难度，离轴方案都要比同轴方案高得多，离轴方案的另一个缺点是它对折射式光刻物镜所用的掩模板没有继承性。</p><h2 id="Q3光学系统参数的选择"><a href="#Q3光学系统参数的选择" class="headerlink" title="Q3光学系统参数的选择"></a>Q3光学系统参数的选择</h2><blockquote><p>探讨波长、数值孔径和分辨率等光学系统参数的选择问题</p></blockquote><p>光刻机的分辨率公式：$\mathrm{R}&#x3D;kλ&#x2F;\mathrm{NA}$，$k$为工艺因子或制程因子（分辨率也可用CD表示）</p><p>像素数的计算公式$N\approx A^2&#x2F;CD^2$ ，$A$指硅片面曝光视场的大小</p><h3 id="波长"><a href="#波长" class="headerlink" title="波长"></a>波长</h3><p>常见光源分为：</p><p>可见光：g线(436nm)(一代)</p><p>紫外光(UV)：i线(365nm)(二代)</p><p>深紫外光(DUV)：KrF 准分子激光(248 nm)(三代)，ArF 准分子激光(193 nm)(四代)</p><p>极紫外光(EUV)：13.5nm(五代)</p><p>由分辨率公式可知波长$\lambda$越短，数值孔径NA越大，分辨率越高；但波长越短制造的难度也随之上升，主流EUV光源为激光等离子光源(LPP)，目前只有美国厂商Cymer和日本厂商Gigaphoton才能够生产，EUV极紫外光刻机唯一可使用的镜头由卡尔蔡司生产，ASML垄断了全球高端光刻机的供应</p><hr><p>为何直接193nm没有再减小呢？</p><p>当光源波长发展到F2准分子激光器157纳米激光，由于光刻胶和掩膜材料的局限，图形对比度低等因素，使得157纳米光刻技术的发展受到很大限制，又由于193纳米光源等效波长小于157纳米，同时投影透镜数值孔径也有很大的提高，所以采用浸没技术的193纳米光源取代157纳米光源继续成为研究的热点。</p><h3 id="数值孔径"><a href="#数值孔径" class="headerlink" title="数值孔径"></a>数值孔径</h3><p>在使用的光源波长一定的情况下，物镜的数值孔径NA决定实际的分辨率，是衡量光刻物镜性能的重要指标</p><p><b>非球面</b>的应用使物镜NA可以增加到<code>0.92</code>接近物理极限（干式光刻）</p><p>引入<b>浸没式技术</b>后，物镜NA可以增加到<code>1.1</code>以上（浸没式光刻）</p><p>加入反射镜组成<b>折反式结构</b>理论上物镜NA可到<code>1.35</code>（极限值）</p><p>（干式）球面镜→非球面镜→（浸没式）非球面镜→折返式</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220504113755361.png" alt="紫外物镜口径与NA发展趋势  " style="zoom:50%;" /><h3 id="光刻机投影物镜发展"><a href="#光刻机投影物镜发展" class="headerlink" title="光刻机投影物镜发展"></a>光刻机投影物镜发展</h3><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220504175742675.png" alt="光刻机投影物镜发展表" style="zoom:80%;" /><h2 id="Q4像差"><a href="#Q4像差" class="headerlink" title="Q4像差"></a>Q4像差</h2><blockquote><p>分析主要像差  </p></blockquote><p>常见像差：慧差，像散，场曲，畸变，色差</p><p>常见像差的消除主要是在物镜结构上</p><p>主要像差有热像差，波像差，偏振像差</p><h3 id="波像差"><a href="#波像差" class="headerlink" title="波像差"></a>波像差</h3><p>投影物镜的波像差在过去已经得到了显著降低，20世纪八十年代投影物镜的波像差RMS值只有λ&#x2F;20，现在最新的浸没投影光刻物镜，波像差RMS值已经降低到了λ&#x2F;400，也就是0.5nm左右，这里就不再叙述</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220508153153699.png"  style="zoom:50%;" /><h3 id="热像差"><a href="#热像差" class="headerlink" title="热像差"></a>热像差</h3><p>热像差的产生原理：</p><p>光刻机工作时激光持续照射投影物镜，热量在投影物镜内部大量累积，镜片局部温度明显变化，导致镜片材料折射率和面形随之发生变化，进而增大投影物镜的像差，由投影物镜热效应导致的像差称为热像差，是影响光刻机成像质量的主要因素之一。</p><p>产生的热像差主要通过光学轴向移动、力变形镜技术、温控变形镜等技术进行补偿。</p><p>中科院上海光学精密机械研究所对光刻机投影物镜热效应模型及热像差预测技术进行了研究，在热效应快速仿真模型、热效应严格模型，以及基于热效应经验模型的热像差在线预测技术方面取得进展，建立了一种投影物镜热效应快速仿真模型热像差仿真精度(Rs2)优于0.99。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220508161239857.png"  style="zoom: 67%;" /><h3 id="偏振像差"><a href="#偏振像差" class="headerlink" title="偏振像差"></a>偏振像差</h3><p>偏振像差的定义：</p><p>随着投影物镜NA的不断增大，照明光的偏振态对物镜成像的影响不能忽略，需要用偏振照明技术来提高分辨率。但照明系统不能生成理想的偏振照明模式，且光线在经过投影物镜后，由于膜系的影响，材料双折射的影响、表面散射的影响等因素，会使入射光线的偏振态会发生改变，这种偏振态的改变就是偏振像差。</p><p>偏振像差的对光线偏振态的改变主要有两类效应：延迟和衰减</p><blockquote><p>材料双折射：<br>大部分材料因在深紫外波段吸收率太大而无法使用，在深紫外波段，结晶材料 CaF2 以其足够良好的透射性和低应力双折射而成为投影光刻物镜的镜片制造材料。CaF2 的固有晶体结构导致了它的本征双折射，双折射最直接的影响就是光传播时两个正交偏振态之间会有光程差，即位相改变不同，产生延迟。</p></blockquote><p>修正方法：</p><p>组合法：将不同晶向特定方位角的 CaF2 镜片组合，利用各个组合 CaF2 镜片互相补偿部分双折射的方法</p><p>组合方位角 0°和方位角45°的 CaF2 镜片，得到近似切向圆分布的延迟</p><p>组合方位角 0°和方位角 60°的 CaF2镜片，得到近似径向圆分布的延迟</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220508163926760.png" alt="image-20220508163926760" style="zoom:67%;" /><p>缺点：当系统 CaF2 镜片较少时，或系统要求晶向单一时，补偿效果会受到限制。其次，组合法所选的方位角是一些特定值如 45°、60°，对于一个复杂的系统来说，这些角度的补偿效果很可能不是最优。</p><p>旋转法：原理是最优化算法，找到每个CaF2最佳的旋转角度，获得最小的延迟</p><hr><p>参考文献：</p><p>[1]张德福,李显凌,芮大为,李朋志,东立剑,张建国.193nm投影光刻物镜光机系统关键技术研究进展[J].中国科学:技术科学,2017,47(06):565-581</p><p>[2]徐明飞. 高数值孔径投影光刻物镜的光学设计[D].中国科学院研究生院(长春光学精密机械与物理研究所),2015.</p><p>[3]尚红波. 浸没光刻投影物镜光学设计与像差补偿研究[D].中国科学院大学(中国科学院长春光学精密机械与物理研究所),2021.DOI:10.27522&#x2F;d.cnki.gkcgs.2021.000007.</p><p>[4]周泽龙. 投影光刻物镜偏振像差研究[D]. 中国科学院大学 (中国科学院长春光学精密机械与物理研究所), 2018.</p><p>[5]Zhu B, Li S, Mao Y, et al. Fast thermal aberration model for lithographic projection lenses[J]. Optics Express, 2019, 27(23): 34038-34049.</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📸光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程类软件安装</title>
      <link href="/posts/1518495338.html"/>
      <url>/posts/1518495338.html</url>
      
        <content type="html"><![CDATA[<h2 id="Visio-Studio-Pro"><a href="#Visio-Studio-Pro" class="headerlink" title="Visio Studio Pro"></a>Visio Studio Pro</h2><p><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">下载地址</a></p><p>修改一些安装选项</p><blockquote><p>(主要还是用来写<code>c++</code>，python还是用<code>pycharm</code>)</p></blockquote><p>安装可参考链接：</p><a href="https://yueliusu.blog.csdn.net/article/details/122332082," title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;favicon.ico" target="">Visual Studio 2022安装教程,</a><p>透明需要的插件：Dark Transparency Theme 和 ClaudiaIDE</p><h3 id="注册码"><a href="#注册码" class="headerlink" title="注册码"></a>注册码</h3><p>重点来了，白嫖才是王道</p><ul><li><strong>Pro:</strong><br>TD244-P4NB7-YQ6XK-Y8MMM-YWV2J</li><li><strong>Enterprise:</strong><br>VHF9H-NXBBB-638P6-6JHCY-88JWH</li></ul><h2 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h2><p>首先官网注册QT账号，这个就不用多说了，注意查看密码格式</p><p>点击<a href="http://mirrors.ustc.edu.cn/qtproject/official_releases/online_installers/">科大镜像</a>进行安装</p><p>下载好了直接打开，剩余步骤参考以下链接</p><a href="https://blog.csdn.net/Qi_1337/article/details/121249717," title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;favicon.ico" target="">QT5.15.2在线安装教程,</a><h2 id="SOLIDWORKS-2022"><a href="#SOLIDWORKS-2022" class="headerlink" title="SOLIDWORKS 2022"></a>SOLIDWORKS 2022</h2><p><a href="https://pan.baidu.com/s/1yu0qRcoQaGjbx81LoCYKdg?pwd=7tff">百度网盘链接</a>  提取码: 7tff </p><p>内有公众号二维码，根据教程就行，主要提一下自己遇到的问题</p><ol><li>要断网，不然安装过程会报错</li><li>如果SQL serve 报错，尝试重新安装几次，直接退出安装程序重开就行，注意要修改三个安装位置</li><li>除了<code>SOLIDWORKS 2022</code>这个桌面图标，其他都可以删了</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 🏭工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.5GHz微带天线设计与分析</title>
      <link href="/posts/3824828603.html"/>
      <url>/posts/3824828603.html</url>
      
        <content type="html"><![CDATA[<p>安装主要的软件<code>ANSYS Electronics Suite</code>安装了一整天真的要命，然后才发现自己真的呆，官网有<a href="https://www.ansys.com/academic/students/ansys-electronics-desktop-student">学生的免费版</a>，完全没必要去破解。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>微带贴片制造简单，成本低，可以很方便地调整频率、极化、模式、阻抗等参数。</p><p>主要特点：效率低、耐受功率低、高Q值，频带很窄。</p><p>微带天线典型使用频率为1-100GHz。</p><p>结构：由很薄($t\ll\lambda_0$)的金属贴片以高度$h$放置在距离接地平面上得到，$h\ll\lambda_0$，通常$0.003\lambda_0\le h\le 0.005\lambda_0$，微带贴片天线和坐标系的结构图如下图所示：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/电磁场1.png" alt="电磁场1" style="zoom:50%;" /><p>微带贴片这样设计是为了在贴片的侧射方向有最大的辐射，选择不同的贴片组形状还可以实现不同方向的端射辐射，例如矩形、椭圆、三角形等。对于矩形贴片，贴片长度 L 一般取1&#x2F;3到1&#x2F;2的波长，贴片和地平面之间被介电常数为$\varepsilon_r$介质隔开</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>微带天线的辐射机理实际上是高频的电磁泄露。一个微波电路如果不是被导体封闭，不连续处就会产生电磁辐射。例如微带电路的开路端，由于结构尺寸的突变、弯折等不连续处也会产生电磁辐射。频率低时，这部分的电尺寸很小，电磁辐射很少；随着频率增加，电尺寸增加，泄露增多。经过特殊设计，使其工作在谐振状态，辐射显著增强，辐射效率大大提高，成为有效的天线。</p><p>分析微带天线的方法主要有传输线(transmission-line)模型、谐振腔(cavite)模型、全波(full-wave)模型即矩量法、有限元法等。我们采取的是<b>传输线模型</b>。</p><h3 id="传输线模型"><a href="#传输线模型" class="headerlink" title="传输线模型"></a>传输线模型</h3><p>传输线模型是最早出现的，但精度不高，也不是通用模型。这一方法<b>仅适合矩形贴片微带天线</b>。矩形贴片天线可以视为两个缝隙组成，每条缝宽度为W，高度为h，两条缝隙由长度为L，传输阻抗为$Z_c$的平板传输线隔开</p><h4 id="边缘效应"><a href="#边缘效应" class="headerlink" title="边缘效应"></a>边缘效应</h4><p>一个如下图(a)的传输线，当宽度远大于介质厚度$(W\gg h)$时，或者介质的介电常数远大于1时，电场集中在传输线和接地平面中。而事实上，在传输线的两侧还存在一定的边缘电场，一部分在空气中传播，一部分在传输线边缘传播，使得电场分布的尺寸比传输线的尺寸略大。因此引入一个有效介电常数$\varepsilon_{eff}$来考虑边缘和传输线中的电场传播，将图(b)的情况等效为图(c)</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/电磁场2.png" alt="电磁场2" style="zoom: 80%;" /><p>在低频的有效介电常数可以表示为：<br>$$<br>\varepsilon_{e f f}&#x3D;\frac{\varepsilon_{r}+1}{2}+\frac{\varepsilon_{r}-1}{2}\left[1+12 \frac{h}{W}\right]^{-1 &#x2F; 2}, \quad W &#x2F; h&gt;1<br>$$</p><h3 id="馈电方式"><a href="#馈电方式" class="headerlink" title="馈电方式"></a>馈电方式</h3><p>微带天线由好几种馈电形式，比较流行的有四类：微带线、同轴线探头、耦合馈电，其中耦合馈电包括孔径耦合和接近耦合，本文的设计采用<b>同轴线馈电</b>的方式。</p><p>在微波应用中通常是使用50欧姆的标准阻抗，因此需要确定馈点的位置使天线的输入阻抗等于50欧姆。对于path_antenna来讲，传输的模式主要是TM10模，</p><blockquote><p>TM模（TM mode）是指在波导中，磁场的纵向分量为零，而电场的纵向分量不为零的传播模式</p></blockquote><p>TM10模在W方向(也就是垂直于传播的方向)上面变化几乎为0，所以W方向任何一个点都无所谓，但为了避免激发TM1n模式，在 W 方向上馈点的位置一般取在中心点，即取$y_f&#x3D;0$，所以主要计算的是L方向的坐标。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414090328077.png" alt="馈电" style="zoom: 50%;" /><p>在L方向上电场有λ&#x2F;2之间的变化，从中心点到两侧，阻抗逐渐变大，输入阻抗等于50Ω时的馈点位置可以由下式计算：<br>$$<br>\begin{gathered}<br>x_{\mathrm{f}}&#x3D;\frac{L}{2 \sqrt{\xi_{\mathrm{re}}(L)}} \<br>\xi_{\mathrm{re}}(L)&#x3D;\frac{\varepsilon_{\mathrm{r}}+1}{2}+\frac{\varepsilon_{\mathrm{r}}-1}{2}\left(1+12 \frac{h}{L}\right)^{-1 &#x2F; 2}<br>\end{gathered}<br>$$</p><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p>辐射边界条件是自由空间的近似，这种近似的精确程度取决于波的传播方向和辐射边界的角度，以及辐射源和边界之间的距离</p><p>在仿真中选择的是<code>Radiation</code>边界，这种边界有以下特性：</p><blockquote><p>计算天线等强辐射问题时，距离辐射体应当至少λ&#x2F;4</p><p>对于弱辐射问题，仅考虑辐射损耗，不关心远场时，可以小于λ&#x2F;4；</p><p>辐射边界条件的吸收性能与入射角相关，入射角大于40 度时，吸收效果明显降低；</p></blockquote><h3 id="参考地"><a href="#参考地" class="headerlink" title="参考地"></a>参考地</h3><p>上述分析都是基于参考地平面是无限大的基础上的，然而实际设计中，参考地都是有限面积的，理论分析证明了当参考地平面比微带贴片大出<code>6h</code>的距离时，计算结果就可以达到足够的准确，因此设计中参考地的长度$L_{GND}$和宽度$ W_{GND}$只需满足以下两式即可，即：<br>$$<br>\begin{gathered}<br>L_{\mathrm{GND}} \geqslant L+6 h \<br>W_{\mathrm{GND}} \geqslant W+6 h<br>\end{gathered}<br>$$</p><h2 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h2><p>采用介电常数$\varepsilon_r$为4.2，中心工作频率(谐振频率)$f_r$为3.5GHz，介质厚度$h$为3mm的辐射体数据，然后要求解矩形贴片的尺寸$W$和$L$，参考地尺寸以及馈线位置$(x_f,y_f)$</p><ol><li><p>为了有效产生辐射，实际中的经验将W设置为：<br>$$<br>W&#x3D;\frac{1}{2 f_{r} \sqrt{\mu_{0} \varepsilon_{0}}} \sqrt{\frac{2}{\varepsilon_{r}+1}}&#x3D;\frac{c}{2 f_{r}} \sqrt{\frac{2}{\varepsilon_{r}+1}}<br>$$</p></li><li><p>计算有效介电常数$\varepsilon_{eff}$：<br>$$<br>\varepsilon_{e f f}&#x3D;\frac{\varepsilon_{r}+1}{2}+\frac{\varepsilon_{r}-1}{2}\left[1+12 \frac{h}{W}\right]^{-1 &#x2F; 2}, \quad W &#x2F; h&gt;1<br>$$</p></li><li><p>由于边缘效应，微带传输天线的电尺寸要比实际尺寸大，对于E面沿着L方向的电场分布被拉长了$\Delta L$(又叫等效辐射缝隙)：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220425163032665.png" alt="image-20220425163032665" style="zoom: 50%;" />$$\Delta L=0.412 h\frac{\left(\varepsilon_{e f f}+0.3\right)\left(\frac{W}{h}+0.264\right)}{\left(\varepsilon_{e f f}-0.258\right)\left(\frac{W}{h}+0.8\right)}$$</li><li><p>由谐振频率估算实际的长度L：<br>$$<br>L&#x3D;\frac{c}{2 f_{r }\sqrt{\varepsilon_{e f f}}}-2 \Delta L<br>$$<br>通常贴片的长度$L$大约为0.47-0.49倍的介质波长$\lambda_d$，介电常数越低的介质，边缘效应越明显，需要的贴片长度更短。</p></li><li><p>计算GND 的大小<br>$$<br>L_g&#x3D;L+6h\qquad W_g&#x3D;W+6h<br>$$</p></li><li><p>计算馈线的位置，<br>$$<br>\begin{gathered}<br>x_{\mathrm{f}}&#x3D;\frac{L}{2 \sqrt{\xi_{\mathrm{re}}(L)}} \<br>\xi_{\mathrm{re}}(L)&#x3D;\frac{\varepsilon_{\mathrm{r}}+1}{2}+\frac{\varepsilon_{\mathrm{r}}-1}{2}\left(1+12 \frac{h}{L}\right)^{-1 &#x2F; 2}<br>\end{gathered}<br>$$<br>计算完成后我们会得到一个参数表格，长度单位均为mm，1GHz&#x3D;$10^9$HZ，该频率的波长约为85.714mm，因为在仿真中是用x作为W的方向，所以馈电位置中$x_f&#x3D;0$</p><table><thead><tr><th>参数</th><th>数值</th></tr></thead><tbody><tr><td>介电常数$ \varepsilon_r$</td><td>4.2</td></tr><tr><td>中心工作频率(谐振频率)$f_r$</td><td>3.5GHz</td></tr><tr><td>有效介电常数$\varepsilon_{eff}$</td><td>3.64</td></tr><tr><td>贴片宽度W</td><td>26.58</td></tr><tr><td>贴片长度L</td><td>19.74</td></tr><tr><td>贴片高度h</td><td>3</td></tr><tr><td>GND宽度Wg</td><td>44.58</td></tr><tr><td>GND长度Lg</td><td>37.74</td></tr><tr><td>馈电位置$(x_f,y_f)$</td><td>(0,5.24)</td></tr></tbody></table></li></ol><h2 id="仿真思路"><a href="#仿真思路" class="headerlink" title="仿真思路"></a>仿真思路</h2><p>使用hfss进行参数化建模</p><p>根据path_antenna的结构我们需要建立的工程变量如下:</p><blockquote><p>Path_W&#x3D;26.58mm</p><p>Path_L&#x3D;19.74mm</p><p>Sub_H&#x3D;3mm</p><p>Wg&#x3D;44.58mm</p><p>Lg&#x3D; 37.74mm</p><p>xf&#x3D;0mm</p><p>yf&#x3D;5.24mm</p></blockquote><p> 求解类型为模式求解模式</p><p>​              HFSS-&gt;solution type-&gt;model</p><p>端口选择激励</p><p>​              Lumped port</p><p>​              Path and GND-&gt;perfect E</p><p>​              Air_BOX-&gt;radiuation</p><p> 求解频率和扫频</p><p>​              3.5GHz 20 0.02</p><p>​              Fast 2.5G-4.5G 0.01</p><p>参考教程：</p><div class="tabs" id="link"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="link-1">综述</button><button type="button" class="tab " data-href="link-2">理论文章</button><button type="button" class="tab " data-href="link-3">视频介绍</button><button type="button" class="tab " data-href="link-4">仿真结果查看</button></ul><div class="tab-contents"><div class="tab-item-content active" id="link-1"><p><a href="https://zhuanlan.zhihu.com/p/269157318," title="https:&#x2F;&#x2F;static.zhihu.com&#x2F;heifetz&#x2F;favicon.ico" target="">天线理论与设计笔记4–(缝隙天线、微带贴片天线),</a></p></div><div class="tab-item-content" id="link-2"><p><a href="https://www.bilibili.com/read/cv4741086?spm_id_from=333.999.0.0," title="https:&#x2F;&#x2F;wuyaohui06022.oss-cn-chengdu.aliyuncs.com&#x2F;blog&#x2F;202204141806361.png" target="">3.5G_path_antenna计算与建模分析,</a></p></div><div class="tab-item-content" id="link-3"><p><a href="https://www.bilibili.com/video/BV1L7411j79F?spm_id_from=333.999.0.0," title="https:&#x2F;&#x2F;wuyaohui06022.oss-cn-chengdu.aliyuncs.com&#x2F;blog&#x2F;202204141806361.png" target="">3.5G_path_antenna计算与建模分析视频,</a></p></div><div class="tab-item-content" id="link-4"><p><a href="https://blog.csdn.net/weixin_44115643/article/details/120515685," title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;favicon.ico" target="">仿真结果查看,</a></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="仿真步骤"><a href="#仿真步骤" class="headerlink" title="仿真步骤"></a>仿真步骤</h2><ol><li><p>创建一个新的HFSS工程</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414132647600.png" alt="image-20220414132647600" style="zoom: 33%;" /><p>右击新的工程选择<code>solution type</code>，修改<code>Model</code>为<code>Teminal</code></p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414132839241.png" alt="image-20220414132839241" style="zoom:50%;" /></li><li><p>增加变量，右击新工程选择<code>Design Properties</code>，输入之前计算的量</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414224532988.png" alt="image-20220414224532988" style="zoom: 33%;" /></li><li><p>创建PCB板，创建一个<b>长方体</b>，修改材料为<code>FR4_epoxy</code> ，记得修改系统里面这个材料的介电常数为<code>4.2</code>，之后修改位置</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414134229333.png" alt="image-20220414134229333" style="zoom: 50%;" /></li><li><p>创建微带贴片，创建一个<b>矩形</b></p><blockquote><p>仿真的时候没有考虑到贴片的厚度，虽然对结果的影响不是很大，厚度要根据实际情况另外考虑</p></blockquote><p>修改位置</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414134551842.png" alt="image-20220414134551842" style="zoom: 50%;" /></li><li><p>创建参考地，创建一个<code>矩形</code>，修改位置：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414135031220.png" alt="image-20220414135031220" style="zoom: 50%;" /></li><li><p>因为在软件中矩形是不能分配属性的，但它们又都是理想导体，所以只能为它们分配边界条件，选中刚刚创建的两个矩形右键</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414135340515.png" alt="image-20220414135340515" style="zoom: 50%;" /></li><li><p>开始布线！创建一个圆柱体，修改材料为<code>pec</code>，之后修改位置</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414135944035.png" alt="image-20220414135944035" style="zoom: 50%;" /></li><li><p>给GND和轴线创建一个端口port，创建一个圆形，修改位置</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414140323459.png" alt="image-20220414140323459" style="zoom: 50%;" /></li><li><p>连接GND和端口port，同时选中端口和GND，点击<img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414140625504.png" alt="image-20220414140625504">进行连接</p></li><li><p>在<code>solution type</code>，修改<code>Teminal</code>为<code>Model</code></p><blockquote><p>其实两个模式都可以求解，但因为参考地的面积较大，<code>Teminal</code>模式求解地一定不能太大</p></blockquote></li><li><p>给端口port创建一个极点</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414140803537.png" alt="image-20220414140803537" style="zoom: 50%;" /><p>点击下一步后改<code>None</code>为<code>newline</code>，方向为GND指向馈线，其他全部默认</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414173410750.png" alt="image-20220414173410750" style="zoom: 50%;" /></li><li><p>设置辐射边界，边界需要满足大于1&#x2F;4个波长，然后把它的z全部改为1000，然后设置辐射边界条件</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414173640457.png" alt="image-20220414173640457" style="zoom: 67%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414174002386.png" alt="image-20220414174002386" style="zoom: 50%;" /></li><li><p>设置求解</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414174110272.png" alt="image-20220414174110272" style="zoom: 50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414174328080.png" alt="image-20220414174328080" style="zoom: 50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414174252562.png" alt="image-20220414174252562" style="zoom: 50%;" /></li><li><p>设置完成后可以开始分析了！按<code>analyse all</code>后等待跑完要先右击result查看solution data，最后一次的数据需要小于我们的设定值</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414174755721.png"  style="zoom: 33%;" /><p>右击<code>result</code>点击</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414174857333.png" alt="image-20220414174857333" style="zoom:67%;" /></li><li><p>参数的选择</p><div class="tabs" id="canshu"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="canshu-1">初始参数</button><button type="button" class="tab " data-href="canshu-2">扫贴片L图</button><button type="button" class="tab " data-href="canshu-3">修改参数后的S图</button></ul><div class="tab-contents"><div class="tab-item-content active" id="canshu-1"><p>初始参数的<b>回波损耗</b>（RL）图：</p><blockquote><p>回波损耗即<code>Return Loss</code>，缩写为RL，S11&#x3D;-RL，插入损耗即<code> Insertion Loss</code>，IL，S21&#x3D;-IL</p><p>它是反射系数绝对值的倒数，以分贝值表示。回波损耗的值在0dB的到无穷大之间，在移动通信系统中，一般要求回波损耗大于14dB</p><p>回波损耗越大说明反射回来的越少，所以对于我们设计的天线需要回波损耗绝对值(一般来说都是负数)越大越好</p></blockquote><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/初始.png" alt="初始" style="zoom:50%;" /><p>中心频率和我们一开始3.5GHz的目标差的有点多，需要进行修改，右击<code>optimetrice</code>-&gt;<code>add</code>-&gt;<code>parameter</code>，对贴片的长度L进行扫描，因为现在是偏小所以要把L调小才能让中心频率上升，选择在18mm到20mm之间</p></div><div class="tab-item-content" id="canshu-2"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/QQ图片20220414190045.png"  style="zoom: 50%;" /><p>接近3.5GHz了但还没完全接近，再在18.8mm到19.0mm进行扫描</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414191042465.png"  style="zoom:50%;" /><p>最终确定合适的path_L为18.9mm</p></div><div class="tab-item-content" id="canshu-3"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/QQ图片20220414191213.png" alt="QQ图片20220414191213" style="zoom:50%;" /><p>中心频率达到3.5GHz，RL也达到一个绝对值较大值</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></li></ol><h2 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h2><div class="tabs" id="pic"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="pic-1">绘制仿真结构图</button><button type="button" class="tab " data-href="pic-2">阻抗</button><button type="button" class="tab " data-href="pic-3">S11图</button><button type="button" class="tab " data-href="pic-4">驻波比图</button><button type="button" class="tab " data-href="pic-5">Smith图</button><button type="button" class="tab " data-href="pic-6">截面增益</button><button type="button" class="tab " data-href="pic-7">三维增益</button><button type="button" class="tab " data-href="pic-8">天线性能参数</button></ul><div class="tab-contents"><div class="tab-item-content active" id="pic-1"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220414204844575.png" alt="image-20220414204844575" style="zoom: 33%;" /></div><div class="tab-item-content" id="pic-2"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220425202538787.png" alt="image-20220425202538787" style="zoom:50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220425202814342.png" alt="image-20220425202814342" style="zoom:50%;" /><p>匹配我们的需求50Ω</p></div><div class="tab-item-content" id="pic-3"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/QQ图片20220414191213.png" alt="QQ图片20220414191213" style="zoom:50%;" /></div><div class="tab-item-content" id="pic-4"><p><strong>驻波比</strong>（VSWR）：它是行波系数的倒数，其值在1到无穷大之间。驻波比为1，表示完全匹配；驻波比为无穷大表示全反射，完全失配。在移动通信系统中，一般要求驻波比小于1.5，但实际应用中VSWR应小于1.2。过大的驻波比会减小基站的覆盖并造成系统内干扰加大，影响基站的服务性能。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/VSWR.png" alt="VSWR" style="zoom: 50%;" /><p>图中可知3.5GHz时VSWR仅1.0931，驻波比显示匹配较好</p></div><div class="tab-item-content" id="pic-5"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/Smith图.png" alt="Smith图" style="zoom:50%;" /><p>这里显示的是归一化阻抗，可以看出，实部出现了不匹配的情况。若是要达到完美的匹配，阻抗的实部和虚部必须很接近0，应该要达到10的-2次方级别（即0.01），询问过老师这个其实不是非常重要，主要还是看S11图</p></div><div class="tab-item-content" id="pic-6"><p>两条曲线分别为XZ和YZ平面的</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/截面增益.png" alt="截面增益" style="zoom:50%;" /></div><div class="tab-item-content" id="pic-7"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/3维增益.png" alt="3维增益" style="zoom:50%;" /><p>三维辐射场可以看出在正Z方向有最大的辐射增益，-Z方向增益就比较低，那么要求在安装天线的时候，要把正面对着要接收的电磁波方向，不能把背面朝外，否则接收不到信号</p></div><div class="tab-item-content" id="pic-8"><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/参数.png" alt="参数" style="zoom:50%;" /></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 🧲电磁场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>评论搭建</title>
      <link href="/posts/800961490.html"/>
      <url>/posts/800961490.html</url>
      
        <content type="html"><![CDATA[<p>一些参考可以看<a href="https://butterfly.js.org/posts/ceeb73f/#%E8%A9%95%E8%AB%96">官网链接</a></p><h1 id="避坑"><a href="#避坑" class="headerlink" title="避坑"></a>避坑</h1><p>不要用<code>gitalk</code>！！！血泪教训，搞了快两个点一直不行，卡在如下界面：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220411093815174.png" alt="image-20220411093815174" style="zoom:50%;" /><p>这个问题实在没法解决，只能选择放弃gitalk，最终选择腾讯云的<code>twikoo</code></p><h1 id="Twikoo"><a href="#Twikoo" class="headerlink" title="Twikoo"></a>Twikoo</h1><p><a href="https://twikoo.js.org/quick-start.html">快速上手</a></p><h2 id="云开发环境"><a href="#云开发环境" class="headerlink" title="云开发环境"></a>云开发环境</h2><ol><li><p>进入<a href="https://curl.qcloud.com/KnnJtUom">云开发CloudBase (opens new window)</a>页面，全程微信扫码登录就行</p></li><li><p>进入<a href="https://console.cloud.tencent.com/tcb/">云开发控制台</a>找云开发，新建环境</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220411094704275.png" style="zoom: 33%;" /><blockquote><ul><li>推荐创建上海环境。如选择广州环境，需要在 <code>twikoo.init()</code> 时额外指定环境 <code>region: &quot;ap-guangzhou&quot;</code></li><li>环境名称自由填写</li><li>推荐选择计费方式<code>包年包月</code>，套餐版本<code>基础版 1</code>，超出免费额度不会收费</li><li>如果提示选择“应用模板”，请选择“空模板”</li></ul></blockquote></li><li><p>进入<a href="https://console.cloud.tencent.com/tcb/env/login">环境-登录授权 (opens new window)</a>，启用“匿名登录”和“未登录”</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220411094856415.png"  style="zoom: 33%;" /></li><li><p>进入<a href="https://console.cloud.tencent.com/tcb/env/safety">环境-安全配置 (opens new window)</a>，将网站域名添加到“WEB安全域名”</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220411095033153.png" style="zoom:33%;" /></li><li><p>进入<a href="https://console.cloud.tencent.com/tcb/scf/index">环境-云函数 (opens new window)</a>，点击“新建云函数”</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220411095202484.png"  style="zoom: 50%;" /></li><li><p>因为现在云函数有bug，删不掉里面的示例代码，需要另外在本地书写再上传覆盖</p><p>在<code>index.js</code>中写入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">main</span> = <span class="built_in">require</span>(<span class="string">&#x27;twikoo-func&#x27;</span>).<span class="property">main</span></span><br></pre></td></tr></table></figure><p>在<code>package.json</code>中写入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;twikoo-func&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.5.3&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span> #版本号根据版本修改为最新</span><br></pre></td></tr></table></figure><p>两个文件一起压缩为压缩包</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220411095749657.png" style="zoom:50%;" /></li></ol><p>到此云平台这边的搭建就结束了，接下来是主题配置文件的修改</p><h2 id="butterfly配置文件"><a href="#butterfly配置文件" class="headerlink" title="butterfly配置文件"></a>butterfly配置文件</h2><p>修改<code>comments</code>代码use处为<code>Twikoo</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Twikoo</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Page</span></span><br></pre></td></tr></table></figure><p>在接下去的<code>twikoo</code>处代码修改<code>envId</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">envId:</span> <span class="string">&#x27;×××&#x27;</span></span><br><span class="line">  <span class="attr">region:</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">option:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>envId</code>的获取方法如下</p><ol><li><p>回到<a href="https://console.cloud.tencent.com/tcb/">云开发控制台</a></p></li><li><p>点击复制</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220411100423745.png" style="zoom:50%;" /></li></ol><p>然后就hexo一键三连就可以了</p><h2 id="管理员配置"><a href="#管理员配置" class="headerlink" title="管理员配置"></a>管理员配置</h2><ol><li><p>进入<a href="https://console.cloud.tencent.com/tcb/env/login">环境-登录授权 (opens new window)</a>，点击“自定义登录”右边的“私钥下载”，下载私钥文件</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220411100538421.png" alt="image-20220411100538421" style="zoom:50%;" /></li><li><p>复制里面的所有内容</p></li><li><p>进到博客网站任意一篇post的下方</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220411102227558.png" style="zoom:50%;" /><p>点开设置，粘贴私钥文件内容(第一个空直接全部放进去)，并设置管理员密码</p></li></ol><p>到这里就全部完成啦，评论时的头像是根据邮箱的头像来显示的，修改要去对应的邮箱修改</p>]]></content>
      
      
      
        <tags>
            
            <tag> 🦋butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly美化过程</title>
      <link href="/posts/3435245376.html"/>
      <url>/posts/3435245376.html</url>
      
        <content type="html"><![CDATA[<h2 id="全局背景的设置"><a href="#全局背景的设置" class="headerlink" title="全局背景的设置"></a>全局背景的设置</h2><p>设置流程：</p><div class="tabs" id="beijing"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="beijing-1">第一步：设置图片</button><button type="button" class="tab " data-href="beijing-2">第二步：引入相关样式</button><button type="button" class="tab " data-href="beijing-3">第三步：增加插件脚本</button><button type="button" class="tab " data-href="beijing-4">参考链接</button></ul><div class="tab-contents"><div class="tab-item-content active" id="beijing-1"><p>修改主题的配置文件 <code>_config.butterfly.yml</code>，编辑 <code>index_img</code>、<code>background</code>、<code>footer_bg</code> 选项，设置网站背景，并将主页顶部图和页脚背景改为透明。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Image (圖片設置)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The banner image of home page</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">transparent</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Beautify/Effect (美化/效果)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Website Background (設置網站背景)</span></span><br><span class="line"><span class="comment"># can set it to color or image (可設置圖片 或者 顔色)</span></span><br><span class="line"><span class="comment"># The formal of image: url(http://xxxxxx.com/xxx.jpg)</span></span><br><span class="line"><span class="attr">background:</span> <span class="string">url(https://example.com/img/background.jpg)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Footer Background</span></span><br><span class="line"><span class="attr">footer_bg:</span> <span class="string">transparent</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="beijing-2"><p>新建一个文件，位于 <code>source/css/modify.styl</code>，并增加以下内容</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;nib&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶部图</span></span><br><span class="line"><span class="selector-id">#page-header</span></span><br><span class="line">  &amp;, <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">    <span class="attribute">background</span>: transparent <span class="meta">!important</span></span><br><span class="line">  &amp;<span class="selector-class">.post-bg</span>, &amp;<span class="selector-class">.not-home-page</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">280px</span> <span class="meta">!important</span></span><br><span class="line">  <span class="selector-id">#post-info</span></span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">40px</span> <span class="meta">!important</span></span><br><span class="line">  <span class="selector-id">#page-site-info</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">140px</span> <span class="meta">!important</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>)</span><br><span class="line">    &amp;.not-home-page</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200px</span> !important</span><br><span class="line">    #post-info</span><br><span class="line">      bottom: <span class="number">10px</span> !important</span><br><span class="line">    #page-site-info</span><br><span class="line">      top: <span class="number">100px</span> !important</span><br><span class="line"></span><br><span class="line">.top-img</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">250px</span></span><br><span class="line">  margin: -<span class="number">50px</span> -<span class="number">40px</span> <span class="number">50px</span></span><br><span class="line">  border-top-left-radius: inherit</span><br><span class="line">  border-top-right-radius: inherit</span><br><span class="line">  background-position: center center</span><br><span class="line">  background-size: cover</span><br><span class="line">  transition: all <span class="number">0.3s</span></span><br><span class="line"></span><br><span class="line">  @media screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>)</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">230px</span></span><br><span class="line">    margin: -<span class="number">36px</span> -<span class="number">14px</span> <span class="number">36px</span></span><br><span class="line"></span><br><span class="line">  [data-theme=&#x27;dark&#x27;] &amp;</span><br><span class="line">    filter: brightness(<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">// 页脚</span><br><span class="line">#footer:before</span><br><span class="line">  background-color: alpha(#FFF, .<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  [data-theme=&#x27;dark&#x27;] &amp;</span><br><span class="line">    background-color: alpha(#<span class="number">000</span>, .<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">#footer-wrap, #footer-wrap a</span><br><span class="line">  <span class="attribute">color</span>: #<span class="number">111</span></span><br><span class="line">  transition: unset</span><br><span class="line"></span><br><span class="line">  [data-theme=&#x27;dark&#x27;] &amp;</span><br><span class="line">    <span class="attribute">color</span>: var(--light-grey)</span><br></pre></td></tr></table></figure><p>在主题配置文件 <code>_config.butterfly.yml</code> 的 <code>inject.head</code> 引入样式。<code>modify.styl</code> 会被 Hexo 渲染成 <code>modify.css</code> 文件，所以引入时要写成 <code>modify.css</code></p></div><div class="tab-item-content" id="beijing-3"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cheerio</span><br></pre></td></tr></table></figure><p>新建一个文件，位于 <code>scripts/modify.js</code>，并增加以下内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在页面插入新顶部图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">cheerio.Root</span>&#125; $ Root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insertTopImg</span>(<span class="params">$</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> header = $(<span class="string">&#x27;#page-header&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (header.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> background = header.<span class="title function_">css</span>(<span class="string">&#x27;background-image&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!background) <span class="keyword">return</span>;</span><br><span class="line">    $(<span class="string">&#x27;#post, #page, #archive, #tag, #category&#x27;</span>).<span class="title function_">prepend</span>(<span class="string">`&lt;div class=&quot;top-img&quot; style=&quot;background-image: <span class="subst">$&#123;background&#125;</span>;&quot;&gt;&lt;/div&gt;`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_render:html&#x27;</span>, <span class="keyword">function</span>(<span class="params">str, data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> $ = cheerio.<span class="title function_">load</span>(str, &#123;</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">insertTopImg</span>($);</span><br><span class="line">    <span class="keyword">return</span> $.<span class="title function_">html</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="beijing-4"><p><a href="https://android99.me/2021/08/10/butterfly-top-image-modify/," title="https:&#x2F;&#x2F;android99.me&#x2F;img&#x2F;avatar.png" target="">全局背景设置,</a></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="删除post页顶部图"><a href="#删除post页顶部图" class="headerlink" title="删除post页顶部图"></a>删除post页顶部图</h2><p>找到位于<code>/themes/butterfly/layout/includes/header/index.pug</code></p><p>打开后寻找<code>is_post()</code> and <code>is_home()</code></p><p>修改后如下图</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/D4/cc6c452e2b4c3130ddacb9f3330b148d.png" alt="img" style="zoom:50%;" /><h2 id="文章透明样式设置"><a href="#文章透明样式设置" class="headerlink" title="文章透明样式设置"></a>文章透明样式设置</h2><p>在个人的<code>css</code>文件下添加(本站为：<code>\themes\butterfly\source\css\custom.css</code>)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*透明*/</span></span><br><span class="line"><span class="selector-id">#aside_content</span> <span class="selector-class">.card-widget</span>, <span class="selector-id">#recent-posts</span>&gt;<span class="selector-class">.recent-post-item</span>, <span class="selector-class">.layout_page</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.recent-posts</span>), <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#page</span>, <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span>, <span class="selector-class">.read-mode</span> <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span>&#123;</span><br><span class="line">    <span class="comment">/* 以下代表透明度为0.5 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*侧边栏页面*/</span></span><br><span class="line"><span class="selector-id">#aside-content</span>&gt;<span class="selector-class">.card-widget</span>  &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#aside-content</span>&gt;<span class="selector-class">.sticky_layout</span>&gt;<span class="selector-class">.card-widget</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*文章页面*/</span></span><br><span class="line"><span class="selector-class">.layout</span>&gt;<span class="selector-id">#post</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分类页面*/</span></span><br><span class="line"><span class="selector-class">.layout</span>&gt;<span class="selector-id">#page</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*时间轴页面*/</span></span><br><span class="line"><span class="selector-class">.layout</span>&gt;<span class="selector-id">#archive</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="修改段落样式"><a href="#修改段落样式" class="headerlink" title="修改段落样式"></a>修改段落样式</h2><p>Butterfly 在 H1~H6 样式上使用了 <a href="https://fontawesome.com/v5.15/icons?from=io">fontawesome.com</a> 上的图标，引用的是 Unicode 形式</p><p>小风车代码实现：</p><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">小风车样式</button><button type="button" class="tab " data-href="test1-2">小风车转起来</button><button type="button" class="tab " data-href="test1-3">风车转速</button><button type="button" class="tab " data-href="test1-4">风车转动方向</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>在主题配置文件里面改动</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">beautify:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span> <span class="comment"># site/post</span></span><br><span class="line">  <span class="comment"># title-prefix-icon: &#x27;\f0c1&#x27; 原内容</span></span><br><span class="line">  <span class="attr">title-prefix-icon:</span> <span class="string">&#x27;\f863&#x27;</span></span><br><span class="line">  <span class="attr">title-prefix-icon-color:</span> <span class="string">&#x27;#F47466&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test1-2"><p>在<code>blog/source/css/custom.css</code>(自己创建的配置文件) 文件中加入以下代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文章页H1-H6图标样式效果 */</span></span><br><span class="line"><span class="comment">/* 转速修改 数字越大越快*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">h2</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">h3</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">h4</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">h5</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">h6</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">animation</span>: ccc <span class="number">1.6s</span> linear infinite ;</span><br><span class="line">    <span class="attribute">animation</span>: ccc <span class="number">1.6s</span> linear infinite ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 转动方向修改，-1为逆时针 */</span></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> ccc &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> ccc &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test1-3"><p>修改上述代码部分，数字越大越快</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 转速修改 数字越大越快*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">h2</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">h3</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">h4</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">h5</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">h6</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">animation</span>: ccc <span class="number">1.6s</span> linear infinite ;</span><br><span class="line">    <span class="attribute">animation</span>: ccc <span class="number">1.6s</span> linear infinite ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test1-4"><p>修改上述代码部分，-1为逆时针，1为顺时针</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 转动方向修改，-1为逆时针 */</span></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> ccc &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> ccc &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>这时候的小风车可能有些单调，还可以进行颜色、大小的修改</p><div class="tabs" id="test2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test2-1">小风车颜色css</button><button type="button" class="tab " data-href="test2-2">风车动态效果</button><button type="button" class="tab " data-href="test2-3">参考链接</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><p>在之前的css代码后跟上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h1</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ef50a8</span> ;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.55rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.3rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">0.23rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h2</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fb7061</span> ;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.35rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.1rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">0.12rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h3</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffbf00</span> ;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.22rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.95rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">0.09rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h4</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#a9e000</span> ;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.05rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.8rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">0.09rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h5</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#57c850</span> ;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">0.9rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.7rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0.0rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h6</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#5ec1e0</span> ;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">0.9rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.66rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0.0rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test2-2"><p><strong>鼠标碰到小风车转速变慢及变色</strong></p><p>设置鼠标碰到标题时，小风车跟随标题变色，且像是被光标阻碍了，转速变慢。鼠标离开恢复转速。也可以设置为 <code>none</code> 鼠标碰到停止转动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h1</span><span class="selector-pseudo">:hover</span>, <span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:hover</span>, <span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h3</span><span class="selector-pseudo">:hover</span>, <span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h4</span><span class="selector-pseudo">:hover</span>, <span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h5</span><span class="selector-pseudo">:hover</span>, <span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h6</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#49b1f5</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h1</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>, <span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>, <span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h3</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>, <span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h4</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>, <span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h5</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>, <span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h6</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#49b1f5</span> ;</span><br><span class="line">    -webkit-<span class="attribute">animation</span>: ccc <span class="number">3.2s</span> linear infinite ;</span><br><span class="line">    <span class="attribute">animation</span>: ccc <span class="number">3.2s</span> linear infinite ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test2-3"><p><a href="https://guole.fun/posts/butterfly-custom/#%E6%9C%AC%E7%AB%99%E5%B0%8F%E9%A3%8E%E8%BD%A6%E6%A0%B7%E5%BC%8F," title="https:&#x2F;&#x2F;guole.fun&#x2F;img&#x2F;gl.jpg" target="">我的Blog美化日记——Hexo+Butterfly,</a></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="侧边栏天气时钟"><a href="#侧边栏天气时钟" class="headerlink" title="侧边栏天气时钟"></a>侧边栏天气时钟</h2><p>安装方法：</p><div class="tabs" id="test3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test3-1">安装插件</button><button type="button" class="tab " data-href="test3-2">配置插件</button><button type="button" class="tab " data-href="test3-3">可选操作</button><button type="button" class="tab " data-href="test3-4">参考链接</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test3-1"><p>Git命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-clock --save</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test3-2"><p>可以选择在主题配置文件<code>_config.butterfly.yml</code>或者<code>_config.yml</code>中添加以下代码，个人建议在<code>_config.yml</code>中添加便于修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># electric_clock</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/4e39cf4a/</span></span><br><span class="line"><span class="attr">electric_clock:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="comment"># - /posts/</span></span><br><span class="line">    <span class="comment"># - /about/</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sticky_layout</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">loading:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif</span> <span class="comment">#加载动画自定义</span></span><br><span class="line">  <span class="attr">clock_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css</span></span><br><span class="line">  <span class="attr">clock_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js</span></span><br><span class="line">  <span class="attr">ip_api:</span> <span class="string">https://pv.sohu.com/cityjson?ie=utf-8</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test3-3"><p>因为有些博客是设置为全屏背景并且透明的，这个时钟自身带有背景，可以修改自己增加的css文件进行时钟背景的去除</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#aside-content</span><span class="selector-class">.aside-content</span> &gt; <span class="selector-class">.sticky_layout</span> &gt; <span class="selector-class">.card-widget</span><span class="selector-class">.card-clock</span> &gt; <span class="selector-class">.card-glass</span> &gt; <span class="selector-class">.card-background</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: unset ;</span><br><span class="line">    <span class="attribute">box-shadow</span>: unset ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test3-4"><p><a href="https://akilar.top/posts/4e39cf4a," title="https:&#x2F;&#x2F;npm.elemecdn.com&#x2F;akilar-candyassets&#x2F;image&#x2F;siteicon&#x2F;favicon.png" target="">糖果屋,</a></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="侧边栏小人样式"><a href="#侧边栏小人样式" class="headerlink" title="侧边栏小人样式"></a>侧边栏小人样式</h2><p>代码实现流程</p><div class="tabs" id="xiaoren"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="xiaoren-1">第一步：修改源码</button><button type="button" class="tab " data-href="xiaoren-2">第二步：修改主题配置</button><button type="button" class="tab " data-href="xiaoren-3">参考文章</button></ul><div class="tab-contents"><div class="tab-item-content active" id="xiaoren-1"><p>找到 <code>/themes/butterfly/layout/includes/widget/card_announcement.pug</code> 文件，添加最后一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if theme.aside.card_announcement.enable</span><br><span class="line">  .card-widget.card-announcement</span><br><span class="line">    .item-headline</span><br><span class="line">      i.fas.fa-bullhorn.card-announcement-animation</span><br><span class="line">      span= _p(&#x27;aside.card_announcement&#x27;)</span><br><span class="line">    .announcement_content!= theme.aside.card_announcement.content</span><br><span class="line">      .twopeople!= theme.aside.card_announcement.twopeople</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="xiaoren-2"><p>在主题配置文件<code>_config.butterfly.yml</code> 中，Ctrl + F 搜索定位到 <code>card_announcement</code>，在 <code>content</code> 下，新增 <code>twopeople</code> 配置项：(这里用到三个CDN，可以直接使用，但也建议你保存后放到自己目录，<strong>以免后续本站调整防盗链策略，导致功能失效。</strong>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">保持理智，相信明天</span></span><br><span class="line">    <span class="attr">twopeople:</span> <span class="string">&#x27;&lt;div class=&quot;twopeople&quot;&gt;&lt;div class=&quot;container&quot;style=&quot;height:200px;&quot;&gt;&lt;canvas class=&quot;illo&quot;width=&quot;800&quot;height=&quot;800&quot;style=&quot;max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script id=&quot;rendered-js&quot; src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;style&gt;.twopeople&#123;margin:0;align-items:center;justify-content:center;text-align:center&#125;canvas&#123;display:block;margin:0 auto;cursor:move&#125;&lt;/style&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="xiaoren-3"><p><a href="https://blog.justlovesmile.top/posts/15391.html," title="https:&#x2F;&#x2F;blog.justlovesmile.top&#x2F;img&#x2F;avatar.jpg" target="">旋转小人,</a></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="引用阿里图标"><a href="#引用阿里图标" class="headerlink" title="引用阿里图标"></a>引用阿里图标</h2><p>打开<a href="https://www.iconfont.cn/">阿里图标</a>，选择自己需要的图标加购物车，最后添加到项目</p><p>创建项目且添加图标后注意几个地方：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220411180210273.png" style="zoom: 50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220411180708235.png"  style="zoom: 67%;" /><p>修改项目设置里的字体格式为彩色，点击复制下方的css代码链接</p><p>在主题配置文件引入<code>css</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;//at.alicdn.com/t/×××.css&quot;&gt;</span> <span class="comment">#图标</span></span><br></pre></td></tr></table></figure><p>然后就可以直接用啦，注意当时设置的<code>fontclass前缀</code>和<code>fontfamily</code>是什么，可以直接就用默认的</p><div class="tabs" id="ali"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="ali-1">导航栏举例：</button><button type="button" class="tab " data-href="ali-2">社交符号举例</button></ul><div class="tab-contents"><div class="tab-item-content active" id="ali-1"><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-shouye</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-rili</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-biaoqian</span></span><br><span class="line">  <span class="comment"># 分类: /categories/ || fas fa-folder-open</span></span><br><span class="line">  <span class="comment"># 清单||fa fa-heartbeat||hide:</span></span><br><span class="line">  <span class="comment">#   音乐: /music/ || fas fa-music</span></span><br><span class="line">  <span class="string">留言板:</span> <span class="string">/comments/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-liuyan</span></span><br><span class="line">  <span class="string">朋友圈:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-icon_pengyouquan</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-lianjie</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="ali-2"><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">iconfont icon-QQ :</span> <span class="string">https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blog/202204111721328.png</span> <span class="string">||</span> <span class="string">QQ</span></span><br><span class="line">  <span class="attr">iconfont icon-weixin:</span> <span class="string">https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/blog/202204111721775.png</span> <span class="string">||</span> <span class="string">微信</span></span><br><span class="line">  <span class="attr">iconfont icon-bilibili:</span> <span class="string">https://space.bilibili.com/277953459?spm_id_from=333.1007.0.0</span> <span class="string">||</span> <span class="string">bilibili</span></span><br><span class="line">  <span class="attr">iconfont icon-GitHub:</span> <span class="string">https://github.com/YaoHui-Wu06022</span> <span class="string">||</span> <span class="string">Github</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> 🦋butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种投影仪的原理和结构</title>
      <link href="/posts/2997567740.html"/>
      <url>/posts/2997567740.html</url>
      
        <content type="html"><![CDATA[<h2 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a>LCD</h2><p>LCD（Liquid Crystal Display：液晶显示器），LCD 技术最早出现于1968年，按照液晶板的片数，LCD 投影机分为单片LCD 投影仪和三片 LCD (3LCD)投影仪。现在的LCD投影机大部分采用3LCD板，单片LCD投影仪已经退出市场。</p><h3 id="单片LCD投影仪工作原理"><a href="#单片LCD投影仪工作原理" class="headerlink" title="单片LCD投影仪工作原理"></a>单片LCD投影仪工作原理</h3><p>参考链接：<a href="https://www.bilibili.com/video/BV15U4y1s7SX?share_source=copy_web">单LCD</a></p><p>单片LCD投影仪将LCD面板的背光部分拆去，然后使用大功率的背光源通过聚光镜照射到LCD面板上，由于LCD面板是透光的，画面就会被照射出去，通过前面的聚焦镜及镜头打到屏幕上而成像。</p><p>光路：(前后指光的方向，后面指光进入的面，前面指光出射的面)</p><ul><li>通过聚光碗(反光碗)让发光角度缩小</li><li>通过菲涅尔透镜(进一步汇聚，变成接近平行的光线)</li><li>通过一块玻璃(后面贴偏光膜，液晶屏的第一层偏光膜，可以隔热)</li><li>通过液晶屏(前面有第二层偏光膜，直接贴在屏幕上)</li><li>通过又一块菲涅尔透镜，可以用环调整角度(梯形校正)</li><li>通过45°反光镜，反射膜在玻璃的前面</li></ul><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220407171018271.png" alt="单LCD" style="zoom: 25%;" /><p>优点：结构简单，成本低</p><p>缺点：分辨率低，亮度低(经过两层偏光膜，液晶屏不是无色透明的)</p><h3 id="3LCD投影仪工作原理"><a href="#3LCD投影仪工作原理" class="headerlink" title="3LCD投影仪工作原理"></a>3LCD投影仪工作原理</h3><p>参考链接：</p><ul><li><a href="https://www.bilibili.com/video/BV1zy4y1h7wj?share_source=copy_web">结构</a></li><li><a href="https://www.bilibili.com/video/BV1k54y1Y7DC?share_source=copy_web">色彩组合</a></li></ul><p>光路图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/3LCD.png" alt="3LCD" style="zoom:50%;" /><p>从上面的工作原理图可以看出：</p><ul><li>3LCD投影仪是把光源通过分色镜分解成R(红)、G(绿)、B(蓝)三种颜色(光的三原色)</li><li>分别反射后透过3LCD液晶屏</li><li>利用合光棱镜合成光束</li><li>最后再投射到屏幕上</li></ul><p>分色镜镀膜(不同折射率的光学涂层)将不需要的波长被反射，需要的颜色透过</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220407171506661.png" alt="分色镜" style="zoom:50%;" /><p>合光棱镜结构：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220407171547154.png" alt="image-20220407171547154" style="zoom:50%;" /><p>实物图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220407171615169.png" alt="3LCD实物图" style="zoom: 33%;" /><p>光路：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220407171648007.png" alt="光路" style="zoom: 33%;" /><p>镜头有两个环，后面的是变焦环，控制镜头里面镜片的位置，改变焦距，前面是对焦环，改变间距，改变成像最清晰的平面到镜头的距离</p><p>3LCD的核心技术有两家，分别是EPSON和SONY。EPSON的芯片基本上只供自己用，其他品牌主要是跟SONY采购。</p><p>优点：</p><ol><li>光效率高</li><li>全彩成像：红绿蓝三原色独立LCD板，可以分别调整每个彩色通道的亮度对比度，投影效果好</li><li>更清澈，噪点更少，色彩还原也更为精准</li></ol><p>缺点：</p><ol><li>不耐用易进灰</li><li>亮度衰减快</li><li>黑色层次表现差对比度不高(LCD投影机表现的黑色，看起来总是灰蒙蒙的，阴影部分就显得昏暗而毫无细节。这点非常不适合播放电影一类的视频)</li><li>画面可见像素结构</li><li>寿命短</li></ol><h2 id="DLP"><a href="#DLP" class="headerlink" title="DLP"></a>DLP</h2><p>DLP是“Digital Light Processing”的缩写，即为数字光处理，它是基于TI（美国德州仪器）公司开发的数字微镜元件——DMD（Digital Micromirror Device）来完成可视数字信息显示的技术。</p><p>DMD是在半导体芯片上布置一个由微镜片（精密、微型的反射镜）所组成的矩阵，每一个微镜片控制投影画面中的一个像素。微镜片的数量与投影画面的分辨率相符，800×600、1024×768、1280×720和1920 x 1080是一些常见的DMD的尺寸。</p><p>这些微镜片在数字驱动信号的控制下能够迅速改变角度，一旦接收到相应信号，微镜片就会倾斜10°，从而使入射光的反射方向改变。处于投影状态被示为“开”，并随数字信号而倾斜+10°；处于非投影状态被示为“关”，并倾斜-10°；“开”状态下被反射出去的入射光通过投影透镜将影像投影到屏幕上；而“关”状态下反射在微镜片上的入射光被光吸收器吸收。</p><p>微镜片在两种状态间切换的频率是可以变化的，这使得DMD反射出的光线呈现出黑（微镜片处于“关”状态）与白（微镜片处于“开”状态）之间的各种灰度。</p><h3 id="单片DLP投影仪"><a href="#单片DLP投影仪" class="headerlink" title="单片DLP投影仪"></a>单片DLP投影仪</h3><p>单片DLP投影仪内部只安装一片DMD芯片，光通由四块反光镜组成一个长方形光线通道，把入射光变成长方形，正好对应DMD芯片上的长方形。颜色是通过在光源与DMD之间安装一个色轮来产生的。色轮通常被分为四个区域：红区、绿区、蓝区和一个用来增加亮度的透明区域(产生白色)(因为透明区域会减弱色彩的饱和度，有时候直接去除)。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/8dca032a057384dd0c2614277d8edfb2_1440w.jpg" alt="img" style="zoom: 67%;" /><p>输入信号被转化为RGB数据，数据按顺序写入DMD的SRAM，白光光源通过聚焦透镜聚集焦在色轮上，通过色轮的光线然后成像在DMD的表面。当色轮旋转时，红、绿、蓝光顺序地射在DMD上，当红光射到DMD上时，镜片按照红色信息应该显示的位置和强度倾斜到“开”，绿色和蓝色光及视频信号亦是如此工作。人体视觉系统集中红、绿、蓝信息并看到一个全彩色图像。</p><h3 id="三片DLP投影仪"><a href="#三片DLP投影仪" class="headerlink" title="三片DLP投影仪"></a>三片DLP投影仪</h3><p>将白光通过棱镜系统分成三原色。这种方法使用三个DMD，一个DMD对应于一种原色。应用三片DLP投影系统的主要原因是为了增加亮度。通过三片DMD，来自每一原色的光可直接连续地投射到它自己的DMD上，导致更多的光线到达屏幕，给出一个更亮的投影图像。这种高效的三片投影系统被用在超大屏幕和高亮度应用领域。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/3DLP.png" alt="3DLP" style="zoom:50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/3DLP光路图.png" alt="3DLP光路图" style="zoom:50%;" /><p>优点：</p><ol><li>图像平滑流畅</li><li>优秀的色深以及对比度</li><li>不会烧屏</li><li>DLP投影机采用封闭式光路，降低了灰尘进入了概率</li></ol><p>缺点：</p><ol><li>价格相对较为昂贵</li><li>单片式DLP投影机可能会出现“彩虹效应”</li><li>体积大，安装占空间，运输不方便。</li><li>存在风扇噪音</li></ol><h2 id="激光投影仪-LDT"><a href="#激光投影仪-LDT" class="headerlink" title="激光投影仪(LDT)"></a>激光投影仪(LDT)</h2><p>激光投影显示技术(LDT)，也称激光投影技术或者激光显示技术，它是以红、绿、蓝(RGB)三基色激光为光源的显示技术，可以最真实地再现客观世界丰富、艳丽的色彩，提供更具震撼的表现力。</p><p>LCD和DLP都是从发出的光中通过透镜过滤出红、绿、蓝三种光进行成像，但这样光的利用率不到20%；激光投影仪直接用红、绿、蓝三基色激光为光源，不用白光为光源，这大大降低了能耗。</p><p>激光投影技术一般分为两种，一种是单色光，一种是彩色光</p><h3 id="单色激光技术"><a href="#单色激光技术" class="headerlink" title="单色激光技术"></a>单色激光技术</h3><p><a href="https://www.sohu.com/a/207890224_616364?qq-pf-to=pcqq.group">单色激光</a></p><p>蓝色激光的形成是由蓝色Laser Diode所发出的蓝光经过荧光色轮的蓝色(Blue)部分，直接通过，然后经过滤光色轮中透明段，从而形成投影画面所需要的蓝光。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/蓝光.png" alt="蓝光" style="zoom: 43%;" /><p>蓝光经过荧光色轮(Phosphor wheel)的绿色(Green)反射形成绿光，然后再经过滤光色轮(filter wheel)过滤出所需要的绿色光波长，从而形成绿光通过</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/蓝光.png" alt="绿光" style="zoom: 43%;" /><p>同理，蓝色Laser Diode所发出的蓝光经过荧光色轮的黄色（Yellow）反射形成黄光，然后再经过滤光色轮的红色段过滤掉黄光，从而形成只剩下红光通过</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/红光.png" alt="红光" style="zoom:43%;" /><p>三色光的拼合部分与3LCD相同不再赘述</p><h3 id="普通双色（蓝光-红光）"><a href="#普通双色（蓝光-红光）" class="headerlink" title="普通双色（蓝光+红光）"></a>普通双色（蓝光+红光）</h3><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/双色激光投影光路示意.png" alt="双色激光投影光路示意" style="zoom: 43%;" /><p>虽然激发荧光的光源仍然是蓝色激光，但是产生的黄色光会和另一组蓝色和红色激光混合。多种颜色激光的使用，可以大大提高色彩校正的效率。</p><p>放映机在校色的过程中，会损失相当一部分亮度，导致激光光源的能量，并不能全部应用于投射出的画面。由于采用了额外的红色激光作为补充，在校色的处理过程中，可以更有效率的混合颜色，有效减少校色后的亮度损失。同样的原始光通量，可以得到更高的画面亮度，整机的能效比显著提高。</p><p>优点：</p><ol><li>性能稳定</li><li>亮度高，色彩好</li><li>衰减小</li></ol><p>缺点：</p><ol><li>缺乏灵活性，体积庞大，且需要搭配抗光硬屏，不好移动</li><li>分类少，发展不成熟</li><li>购买价格贵</li></ol><h2 id="三者的对比"><a href="#三者的对比" class="headerlink" title="三者的对比"></a>三者的对比</h2><p>综上其实很容易看出激光投影仪是建立在LCD和DLP的结构上进行的综合应用</p><table><thead><tr><th></th><th>3LCD</th><th>DLP</th><th>LDT</th></tr></thead><tbody><tr><td>使用寿命</td><td>$\star$</td><td>$\star\star$</td><td>$\star\star\star$</td></tr><tr><td>亮度</td><td>$\star\star$</td><td>$\star$</td><td>$\star\star\star$</td></tr><tr><td>色彩</td><td>$\star\star$</td><td>$\star$</td><td>$\star\star\star$</td></tr><tr><td>灵活性</td><td>$\star\star$</td><td>$\star\star\star$</td><td>$\star$</td></tr><tr><td>价格昂贵程度</td><td>$\star\star\star$</td><td>$\star\star$</td><td>$\star$</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📸光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于图片求体积的算法</title>
      <link href="/posts/641887854.html"/>
      <url>/posts/641887854.html</url>
      
        <content type="html"><![CDATA[<p>浅记录一下学院数模赛的算法流程</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>自拟场景和尺寸，在有参照物的情况下，依据图片，建立模型估计以下土堆的立方数</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220401142622068.png" alt="image-20220401142622068" style="zoom: 80%;" /><h2 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>筛选出需要的土堆和挖掘机部分</p></li><li><p>根据轮廓利用古鲁金定理计算像素体积</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/gulujin.png" alt="gulujin" style="zoom:50%;" /></li><li><p>根据挖掘机在图片中的面积以及实际尺寸计算图片和实际长度的转化关系</p></li><li><p>代入计算的土堆像素体积获得实际体积</p></li></ol><p>因为python的<code>opencv</code>只能识别<code>HSV</code>三通道参数，需要根据<code>HSV</code>表来粗筛选土堆和挖掘机</p><p><code>HSV</code>颜色参考：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img/image-20220401143415448.png" alt="image-20220401143415448" style="zoom:50%;" /><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>封装了一个计算形心相对图片坐标的函数<code>ShapeHeart</code>，输入为图片，标识名称，HSV高低数组，返回值为形心坐标cx和cy，和轮廓的像素面积，输出二值化图片，红线轮廓图片以及蓝色形心图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2022/3/30 14:44</span></span><br><span class="line"><span class="comment"># @Author : YH</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ShapeHeart</span>(<span class="params">img,name,low,high</span>):</span><br><span class="line">    img = cv.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">    cv.imwrite(<span class="string">&quot;./pic&quot;</span>+<span class="string">&quot;/&quot;</span>+name+<span class="string">&quot;_Gauss.jpg&quot;</span>,img)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    提取颜色</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)</span><br><span class="line">    low_hsv = np.array(low)</span><br><span class="line">    high_hsv = np.array(high)</span><br><span class="line">    mask = cv.inRange(hsv, lowerb=low_hsv, upperb=high_hsv)</span><br><span class="line">    <span class="comment"># 展示二值图</span></span><br><span class="line">    cv.imshow(name+<span class="string">&quot;_Grayscale&quot;</span>,mask)</span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line">    <span class="comment"># 保存土堆轮廓</span></span><br><span class="line">    cv.imwrite(<span class="string">&quot;./pic&quot;</span>+<span class="string">&quot;/&quot;</span>+name+<span class="string">&quot;_Grayscale.jpg&quot;</span>, mask)</span><br><span class="line">    contours, hierarchy = cv.findContours(mask, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    cv.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 保存轮廓线图片</span></span><br><span class="line">    cv.imwrite(<span class="string">&quot;./pic&quot;</span>+<span class="string">&quot;/&quot;</span>+name+<span class="string">&quot;_Outline.jpg&quot;</span>,img)</span><br><span class="line">    cv.imshow(name+<span class="string">&quot;_Outline&quot;</span>,img)</span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line">    areas = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">        areas.append(cv.contourArea(contours[c]))</span><br><span class="line">    MAX = areas.index(<span class="built_in">max</span>(areas))   <span class="comment"># 求最大轮廓序号</span></span><br><span class="line">    M = cv.moments(contours[MAX])  <span class="comment"># 求矩</span></span><br><span class="line">    cx = <span class="built_in">int</span>(M[<span class="string">&#x27;m10&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>])  <span class="comment"># 求x坐标</span></span><br><span class="line">    cy = <span class="built_in">int</span>(M[<span class="string">&#x27;m01&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>])  <span class="comment"># 求y坐标</span></span><br><span class="line">    cv.circle(img, (cx, cy), <span class="number">1</span>, (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">0</span>)</span><br><span class="line">    cv.imwrite(<span class="string">&quot;./pic&quot;</span> + <span class="string">&quot;/&quot;</span> + name + <span class="string">&quot;_ShapeHeart.jpg&quot;</span>, img)   <span class="comment">#保存形心图片</span></span><br><span class="line">    area = cv.contourArea(contours[MAX])</span><br><span class="line">    <span class="keyword">return</span> cx, cy, area</span><br></pre></td></tr></table></figure><p>土堆计算的主函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&#x27;tudui.jpg&#x27;</span>)</span><br><span class="line">    cx,cy,area = ShapeHeart(img,name=<span class="string">&quot;Mound&quot;</span>,low=[<span class="number">78</span>, <span class="number">40</span>, <span class="number">120</span>],high=[<span class="number">100</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    <span class="built_in">print</span>(cx,cy,area)</span><br><span class="line">    img1 = img[<span class="number">0</span>:img.shape[<span class="number">0</span>], <span class="number">0</span>:cx]</span><br><span class="line">    cx1,cy1,area1 = ShapeHeart(img1,name=<span class="string">&quot;Mound1&quot;</span>,low=[<span class="number">78</span>, <span class="number">40</span>, <span class="number">120</span>],high=[<span class="number">100</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    <span class="built_in">print</span>(cx1,cy1,area1)</span><br><span class="line">    V = <span class="number">2</span>*<span class="built_in">abs</span>(cx-cx1)*math.pi*area/<span class="number">2</span>*math.<span class="built_in">pow</span>(<span class="number">0.033082679182000536</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(V)</span><br></pre></td></tr></table></figure><p>其中V计算中<code>math.pow</code>用的是计算获得的像素与实际长度转化关系，这个值准确性有待提高，因为挖掘机的具体参数并未获得，计算过程中没有很好考虑视角造成的长度影响</p><p>卡车计算的额外步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">space = (math.cos(math.pi/<span class="number">3</span>)+math.cos(math.pi/<span class="number">6</span>))*<span class="number">0.84</span>*<span class="number">2.22</span></span><br><span class="line"><span class="comment">#计算像素和实际长度转化关系</span></span><br><span class="line">a = math.sqrt(space/area)</span><br></pre></td></tr></table></figure><p>这个算法只能初步实现分离物体，如果需要更加精细还需要改进</p>]]></content>
      
      
      
        <tags>
            
            <tag> ⌨️python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大物实验</title>
      <link href="/posts/2735195021.html"/>
      <url>/posts/2735195021.html</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/大物实验.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理二</title>
      <link href="/posts/419590504.html"/>
      <url>/posts/419590504.html</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/大学物理二.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回声消除系统设计</title>
      <link href="/posts/842063440.html"/>
      <url>/posts/842063440.html</url>
      
        <content type="html"><![CDATA[<h1 id="回声消除系统设计"><a href="#回声消除系统设计" class="headerlink" title="回声消除系统设计"></a>回声消除系统设计</h1><p><strong>设计详细说明：</strong></p><p>设计系统在0.2s，0.4s产生回声</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220411231220251.png" alt="image-20220411231220251" style="zoom: 67%;" /><ul><li><p>Matlab代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">clear,clc,close all;  </span><br><span class="line"></span><br><span class="line"><span class="comment">% 记录数据  </span></span><br><span class="line">fs=<span class="number">8000</span>; <span class="comment">% 声音采样频率  </span></span><br><span class="line">duration=<span class="number">3</span>; <span class="comment">% 记录时间  </span></span><br><span class="line"><span class="comment">%记录输入声音  </span></span><br><span class="line">myrecording = audiorecorder;  </span><br><span class="line">fprintf(<span class="string">&#x27;Speaking for %d seconds. \\n&#x27;</span>,duration);  </span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;Start speaking.&#x27;</span>)  </span><br><span class="line">recordblocking(myrecording, duration);  </span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;End of Recording.&#x27;</span>);  </span><br><span class="line"><span class="comment">%获得输入信息  </span></span><br><span class="line">x = getaudiodata(myrecording);  </span><br><span class="line"><span class="comment">%存储录音信息  </span></span><br><span class="line">audiowrite(<span class="string">&#x27;luyin.wav&#x27;</span>,x,fs);  </span><br><span class="line"></span><br><span class="line"><span class="comment">%定义冲激响应函数  </span></span><br><span class="line">h=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">5000</span>);  </span><br><span class="line">h(<span class="number">1</span>)=<span class="number">4</span>/<span class="number">5</span>;h(<span class="number">0.2</span>\*fs)=<span class="number">0.6</span>;h(<span class="number">0.4</span>\*fs)=<span class="number">0.4</span>;  </span><br><span class="line"><span class="comment">% 卷积计算  </span></span><br><span class="line">y=conv(x,h);  </span><br><span class="line">k=audioplayer(y,fs);  </span><br><span class="line">play(k); <span class="comment">% 播放回音  </span></span><br><span class="line"><span class="comment">%存储回音  </span></span><br><span class="line">audiowrite(<span class="string">&#x27;huiyin.wav&#x27;</span>,y,fs);  </span><br><span class="line"><span class="comment">%绘图  </span></span><br><span class="line">subplot(<span class="number">311</span>)  </span><br><span class="line"><span class="built_in">plot</span> (x) ;<span class="comment">%绘制原始音  </span></span><br><span class="line">title(<span class="string">&#x27;原始音&#x27;</span>);  </span><br><span class="line">subplot(<span class="number">312</span>)  </span><br><span class="line"><span class="built_in">plot</span> (y);<span class="comment">%绘制回音  </span></span><br><span class="line">title(<span class="string">&#x27;回音&#x27;</span>);  </span><br><span class="line"><span class="comment">%恢复计算  </span></span><br><span class="line">huifu=filter(<span class="number">1</span>, h, y );<span class="comment">%回音卷积1/h恢复初始  </span></span><br><span class="line">subplot(<span class="number">313</span>)  </span><br><span class="line"><span class="built_in">plot</span>(huifu);<span class="comment">%绘制恢复音  </span></span><br><span class="line">pause(<span class="number">5</span>);  </span><br><span class="line">sound(huifu)<span class="comment">%播放恢复音  </span></span><br><span class="line">audiowrite(<span class="string">&#x27;huifu.wav&#x27;</span>,huifu,fs);<span class="comment">%存储恢复音</span></span><br><span class="line"></span><br><span class="line">title(‘恢复音’)</span><br></pre></td></tr></table></figure><p>输出结果：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/8e4774914e7003ab259ac85478078076.png" style="zoom: 67%;" /><p>很容易看出原始音与恢复音的波形相同</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📡信号课设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RC文氏电桥分析</title>
      <link href="/posts/696065812.html"/>
      <url>/posts/696065812.html</url>
      
        <content type="html"><![CDATA[<h1 id="RC文氏电桥分析"><a href="#RC文氏电桥分析" class="headerlink" title="RC文氏电桥分析"></a>RC文氏电桥分析</h1><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/RC文氏电桥分析.pdf" width="100%" height="550" type="application/pdf"></div><p><strong>设计详细说明：</strong></p><ul><li><strong>论文资料整理：</strong></li></ul><ol><li><p>论文中传递函数的推导：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/85727168324e875af15db970f01a4352.png" style="zoom: 67%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/912d64ad20b920edd8cf3d0bcbf0a17a.png" style="zoom:67%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220411232228897.png" alt="image-20220411232228897" style="zoom: 67%;" /></li><li><p>稳定性的简要判断：</p><p>劳斯判据：根都在复平面左半平面，系统稳定</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/image-20220411232403672.png" alt="image-20220411232403672" style="zoom: 67%;" /></li></ol><ul><li><p><strong>K的7种取值下分析：</strong></p><p><strong>代码块：</strong></p><p>绘制对应零极点图：（lingjidian.m文件）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">clc<span class="comment">%清空命令行</span></span><br><span class="line"></span><br><span class="line">clear<span class="comment">%从工作区中删除项目、释放系统内存</span></span><br><span class="line"></span><br><span class="line">clf<span class="comment">%清空当前图窗窗口</span></span><br><span class="line"></span><br><span class="line">K=<span class="number">11</span>;<span class="comment">%可修改放大倍数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%可修改参数</span></span><br><span class="line"></span><br><span class="line">R=<span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line">C=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line">RC=R\*C;</span><br><span class="line"></span><br><span class="line">fenzi=[K <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">fenmu=[RC <span class="number">3</span>-K <span class="number">1</span>/RC];</span><br><span class="line"></span><br><span class="line">sys=tf(fenzi,fenmu);<span class="comment">%构成传递函数</span></span><br><span class="line"></span><br><span class="line">poles=roots(fenmu);<span class="comment">%求极点</span></span><br><span class="line"></span><br><span class="line">pzmap(sys,<span class="string">&#x27;r&#x27;</span>);<span class="comment">% 零极点分布图显示</span></span><br><span class="line"></span><br><span class="line">绘制时域单位冲击响应函数：（chongjixiangyinghanshu.m文件）</span><br><span class="line"></span><br><span class="line">clc<span class="comment">%清空命令行</span></span><br><span class="line"></span><br><span class="line">clear<span class="comment">%从工作区中删除项目、释放系统内存</span></span><br><span class="line"></span><br><span class="line">clf<span class="comment">%清空当前图窗窗口</span></span><br><span class="line"></span><br><span class="line">K=<span class="number">11</span>;<span class="comment">%可修改放大倍数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%可修改参数</span></span><br><span class="line"></span><br><span class="line">R=<span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line">C=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line">RC=R\*C;</span><br><span class="line"></span><br><span class="line">fenzi=[K <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">fenmu=[RC <span class="number">3</span>-K <span class="number">1</span>/RC];</span><br><span class="line"></span><br><span class="line">sys=tf(fenzi,fenmu);<span class="comment">%构成传递函数</span></span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="number">6</span>\*<span class="number">1e-6</span>:<span class="number">1e-3</span>; <span class="comment">%控制绘图的时间区间</span></span><br><span class="line"></span><br><span class="line">impulse(fenzi,fenmu,t) <span class="comment">%绘图</span></span><br><span class="line"></span><br><span class="line">title([<span class="string">&#x27;K=&#x27;</span>,num2str(K),<span class="string">&#x27;冲激响应函数&#x27;</span>])</span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&#x27;时间t&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><ol><li><p><strong>K&gt;5(取K&#x3D;11)</strong></p><p>Matlab结果：</p><p>零极点图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/51ce1427d7fff0c5e1b8fb863fe56a80.png" style="zoom:50%;" /><p>零极点为两个不同的正实数，收敛域不过jw轴，系统不稳定</p><p>冲激响应函数：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/64f440264560f5d8461e1af3f5e89676.png" style="zoom:50%;" /><p>可知冲激响应函数单调上升，无界，系统不稳定</p><p>Multisim仿真：（之后不再给出电路图，仅改变大小来改变K）</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/c616ec282526489adcf52dcd495947bf.png" style="zoom:67%;" /><p>输出端产生的信号近似等于方波信号：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/1ddd22bf1f1ac209e9dd04e8797cdb74.png" style="zoom:50%;" /></li><li><p><strong>K&#x3D;5</strong></p><p>Matlab结果：</p><p>零极点图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/7cd6066a2e19f6a41e3b67fb62930591.png" style="zoom:50%;" /><p>零极点为两个相等的正实数，收敛域不过jw轴，系统不稳定</p><p>冲激响应函数：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/357a9b48fb956f9ad49047045d97f36a.png" style="zoom:50%;" /><p>可知冲激响应函数单调上升，无界，系统不稳定</p><p>Multisim仿真：</p><p>输出端产生的信号失真不能实现稳定的单一频率的震荡，在 t&#x3D;0<br>开始到第一次到达峰值可以看到一段电压呈指数形式增长的曲线。</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/04a46a6bdd804a0c8658e59ed0ec8a6a.png" style="zoom:50%;" /></li><li><p><strong>3&lt;K&lt;5（取K&#x3D;3.5）</strong></p><p>Matlab结果：</p><p>零极点图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/794f1a5ae68ad392679d6bf8bae144b9.png" style="zoom:50%;" /><p>零极点为两个共轭且实部大于0的虚数，收敛域不过jw轴，系统不稳定</p><p>冲激响应函数：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/462dd56631904484a699202986050ed8.png" style="zoom:50%;" /><p>可知冲激响应函数增幅振荡上升，无界，系统不稳定</p><p>Multisim仿真：</p><p>输出端产生的信号经过振荡后类似K&#x3D;5的情况，振荡时间变长：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/f3580b560539fc8552e7f8c6c66de8b1.png" style="zoom:50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/f1af007816b4d4699fd662e51f5d35bc.png" style="zoom:50%;" /></li><li><p><strong>K&#x3D;3</strong></p><p>Matlab结果：</p><p>零极点图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/bfc1ae0293c0eba703a3855d7a906667.png" style="zoom:50%;" /><p>零极点为两个共轭的纯虚数，在jw轴上仅通过零极点不能判断系统是否稳定</p><p>冲激响应函数：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/29d54dc5a26597b83848a9bc3b35be67.png" style="zoom:50%;" /><p>可知冲激响应函数等幅振荡，有界，系统稳定</p><p>Multisim仿真：</p><p>输出端的信号在一个范围内无规则振荡</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/2d59fb7e88ed688e83570b1690b33dc0.png" style="zoom:50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/6635c9710804dae9c91a18aab74db792.png" style="zoom:50%;" /></li><li><p><strong>1&lt;K&lt;3(取K&#x3D;2)</strong></p><p>Matlab结果：</p><p>零极点图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/2c3cc19945b0fdaaa04d790c94437b7c.png" style="zoom:50%;" /><p>零极点为两个共轭且实部小于0的虚数，收敛域过jw轴，可判断收敛</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/26dfeb58edc7b57f8ae54430efb569b8.png" style="zoom:50%;" /><p>可知冲激响应函数振荡衰减，有界，系统稳定，趋于0</p><p>Multisim仿真：</p><p>输出端的信号在一个范围内无规则振荡趋于0</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/d19d2d95c4a2c05f72f40706a5fe8e38.png" style="zoom:50%;" /><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/a3fb7941e3b15bb1b706a5e2b43250c7.png" style="zoom:50%;" /></li><li><p><strong>K&#x3D;1</strong></p><p>Matlab结果：</p><p>零极点图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/4d8f50f46dfd4f2521fa53af688471b8.png" style="zoom:50%;" /><p>零极点为两个相等的负实数，收敛域过jw轴，可判断收敛</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/8ce8f6fc850002f2685b2463b312dde6.png" style="zoom:50%;" /><p>可知冲激响应函数非振荡衰减但也是衰减，有界，系统稳定，趋于0</p><p>Multisim仿真：</p><p>输出端的信号在一个振荡后趋于0</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/249384a69a03b4916ddf32d5712738f5.png" style="zoom:50%;" /></li><li><p>K&lt;1</p><p>Matlab结果：</p><p>零极点图：</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/9b7c629effb5dfd55cbcb98e7760b81f.png" style="zoom:50%;" /><p>零极点为两个不相等的负实数，收敛域过jw轴，可判断收敛</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/b215c4204bd951fd5c5503549e44c898.png" style="zoom:50%;" /><p>可知冲激响应函数非振荡衰减但也是衰减，有界，系统稳定，趋于0</p><p>Multisim仿真：</p><p>输出端的信号在一个振荡后趋于0</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/img2/130432f65d638b147e4073d659ef173b.png" style="zoom:50%;" /></li></ol><ul><li><p><strong>对题目的感想和思考</strong></p><p>并没有找到合适的方法实现K&#x3D;3处的稳定波形，这是唯一的不足，不知道如何实现稳定</p><p>对于题目的其他认为还是相对合适的，主要要懂得如何使用matlab’的那几个相关函数很好地绘制出冲击响应函数和零极点图；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📡信号课设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音频采样效果</title>
      <link href="/posts/3859632160.html"/>
      <url>/posts/3859632160.html</url>
      
        <content type="html"><![CDATA[<h1 id="音频采样效果"><a href="#音频采样效果" class="headerlink" title="音频采样效果"></a>音频采样效果</h1><p><strong>设计详细说明：</strong></p><ul><li>Matlab代码：</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">Fs = <span class="number">44100</span>; <span class="comment">%设置特定的采样率为44100Hz（生活中常见的采样频率）</span></span><br><span class="line"></span><br><span class="line">nBits=<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">nChannels=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Duration=<span class="number">2</span>;<span class="comment">%设置采样时间</span></span><br><span class="line"></span><br><span class="line">recorder = audiorecorder(Fs,nBits,nChannels); <span class="comment">% 调用电脑麦克风，开始声音录制</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;strat speaking:&#x27;</span>);</span><br><span class="line"></span><br><span class="line">recordblocking(recorder,Duration); <span class="comment">% 录制duration s的声音信号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;stop speaking&#x27;</span>);</span><br><span class="line"></span><br><span class="line">myrecording = getaudiodata(recorder); <span class="comment">%getaudiodata--读取声音信号信息</span></span><br><span class="line"></span><br><span class="line">audiowrite(<span class="string">&#x27;test1.wav&#x27;</span>,myrecording,<span class="number">44100</span>);</span><br><span class="line"></span><br><span class="line">test1 = audioinfo(<span class="string">&#x27;test1.wav&#x27;</span>);</span><br><span class="line"></span><br><span class="line">audiowrite(<span class="string">&#x27;test2.wav&#x27;</span>,myrecording,<span class="number">22050</span>);</span><br><span class="line"></span><br><span class="line">test2 = audioinfo(<span class="string">&#x27;test2.wav&#x27;</span>);</span><br><span class="line"></span><br><span class="line">audiowrite(<span class="string">&#x27;test3.wav&#x27;</span>,myrecording,<span class="number">88200</span>);</span><br><span class="line"></span><br><span class="line">test3 = audioinfo(<span class="string">&#x27;test3.wav&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=[<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">sound(myrecording,<span class="number">44100</span>\*<span class="built_in">i</span>) <span class="comment">% 播放时采样率设置为44100\*i</span></span><br><span class="line"></span><br><span class="line">pause(Duration/<span class="built_in">i</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%sound(myrecording,44100) % 播放时采样率设置为录制时相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%sound(myrecording,22050) % 播放时采样率设置为录制时的一半</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%sound(myrecording,88200) % 播放时采样率设置为录制时的二倍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 数据可视化代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%test1</span></span><br><span class="line"></span><br><span class="line">[y1,f1] = audioread(<span class="string">&#x27;test1.wav&#x27;</span>);</span><br><span class="line"></span><br><span class="line">t1 = <span class="number">0</span>:seconds(<span class="number">1</span>/f1):seconds(test1.Duration);</span><br><span class="line"></span><br><span class="line">t1 = t1(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(t1,y1)</span><br><span class="line"></span><br><span class="line"><span class="comment">%title(&#x27;采样频率相同&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%test2</span></span><br><span class="line"></span><br><span class="line">[y2,f2] = audioread(<span class="string">&#x27;test2.wav&#x27;</span>);</span><br><span class="line"></span><br><span class="line">t2 = <span class="number">0</span>:seconds(<span class="number">1</span>/f2):seconds(test2.Duration);</span><br><span class="line"></span><br><span class="line">t2 = t2(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(t2,y2)</span><br><span class="line"></span><br><span class="line"><span class="comment">%title(&#x27;采样频率变为“一半”&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%test3</span></span><br><span class="line"></span><br><span class="line">[y3,f3] = audioread(<span class="string">&#x27;test3.wav&#x27;</span>);</span><br><span class="line"></span><br><span class="line">t3 = <span class="number">0</span>:seconds(<span class="number">1</span>/f3):seconds(test3.Duration);</span><br><span class="line"></span><br><span class="line">t3 = t3(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(t3,y3)</span><br><span class="line"></span><br><span class="line"><span class="comment">%title(&#x27;采样频率变为“二倍”&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;采样频率变为“二倍”&#x27;</span>,<span class="string">&#x27;采样频率变为“一半”&#x27;</span>,<span class="string">&#x27;采样频率相同&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line">title(<span class="string">&#x27;不同采样率下的波形图&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>结果：</li></ul><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/typora/202206011722189.png" style="zoom:50%;" /><p>另一张图是luyin2.m文件生成的，只更换了画图部分不具体阐述</p><img src="https://wuyaohui06022.oss-cn-chengdu.aliyuncs.com/typora/202206011723241.png" style="zoom:50%;" /><ul><li><p>现象分析</p><p>选取的Fs&#x3D;44100Hz，FsH为2Fs&#x3D;88200Hz，FsL&#x3D;0.5Fs&#x3D;22050Hz，</p><p>根据matlab 得到的声音可以知道</p></li></ul><ol><li><p>当播放时采样率设置为录制时的一半时，声音文件的音频长度变为源文件二倍，且声音更加低沉</p></li><li><p>当播放时采样率设置为录制时的二倍时，声音文件的音频长度变为源文件一半，且声音更加尖锐</p></li><li><p>观察三个音频文件的时域波形，发现波形完全一致</p></li></ol><ul><li><p>综上可得：</p><p>录制和播放采样率关系对于录制的音频文件内容并没有影响，影响的是音频文件的时长，换句话说改变音频文件播播放的速度</p></li><li><p>原理阐述与思考：</p><p>声音文件录制时，以特定的采样率录制音频文件，而在声音信号播放时，相当于在已有音频文件的基础上进行二次采样，由于声音文件的内容是固定的，即音频文件样本数目是固定的，当我们以之前一半的采样率进行二次采样时，相当于每秒钟采集到的样本数目是减半的</p><p>因此，如果采集同样大小的音频样本，所需要的时间变为之前两倍，但是由于音频内容未发生改变，所以仅仅改变的是音频文件的播放速度，实现0.5倍速播放或者2倍速播放。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📡信号课设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正弦信号调制和解调</title>
      <link href="/posts/2781577970.html"/>
      <url>/posts/2781577970.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5fd3c26b2e9046c2bb12ce2c9934100debc933e9bc050c1fa9f7500d8736e8e1">c6edd953b26c9aed6989fa669cb2a4b0a36c1a997b1bb74acc8f0ff9d781cdc18919e039ea10552d12f559f613f166ca992c72db102aa2aabab3eae86676fba3d7349295cf27ee883f788dc7df099333d2c31398dc51603e6f8647adc594a75e16fffc2d524b451176cd552c65dc6b43006ee1b87887113d93b5553a5f4c9cae75bde87e64027dd2462bd58024c43aa69b1437df4251b4fe4151eead8ba3d155e1d15b6c1b66f23b21f19715907d3f03faaf951a3e7271824eb4230d7d3b5ab1b0bcfe9db779bdfa82bda5f781b05f2b09302567fea1e7d9cb0ba5166f39fbe01cc237ebb30803c603aea117a15d55a65229f8880f6fec9c097a740fee46e3e1a18930d27df87bf4aba728940e4b269b33cadd00c2c47eb7d22294451a5dd6e931f76f45496c63cd14931510c1a21f301e4b69c069ebda98085e6e3e896363f06439110ea4b59966ef6d44abb88e16fba71be9b04683a4067a2039693d49929fdb478f88608496a7fe71e8c2f00c99e751d2724df82413e8dbe44026c816c656</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">私人文章，不对外开放，请理解</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📡信号课设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周期方波信号分解</title>
      <link href="/posts/3903647133.html"/>
      <url>/posts/3903647133.html</url>
      
        <content type="html"><![CDATA[<h1 id="周期方波信号分解"><a href="#周期方波信号分解" class="headerlink" title="周期方波信号分解"></a>周期方波信号分解</h1><p>pdf里面的代码：</p><div class="tabs" id="m"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="m-1">KHz.m</button><button type="button" class="tab " data-href="m-2">最终代码</button></ul><div class="tab-contents"><div class="tab-item-content active" id="m-1"><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">5</span></span><br><span class="line">    si=tf([<span class="number">1000</span>*<span class="built_in">i</span> <span class="number">0</span>],[<span class="number">1</span> <span class="number">1000</span>*<span class="built_in">i</span> ((<span class="number">2</span>*<span class="built_in">i</span>*<span class="built_in">pi</span>*(<span class="number">10</span>^<span class="number">4</span>))^<span class="number">2</span>)]);</span><br><span class="line">    bode(si);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    str&#123;<span class="built_in">i</span>&#125; = [ num2str(<span class="number">10</span>*<span class="built_in">i</span>) <span class="string">&#x27;KHz&#x27;</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">legend</span>(str);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="m-2"><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">clc,clear</span><br><span class="line"><span class="comment">%设置参数</span></span><br><span class="line">R=<span class="number">10</span>;</span><br><span class="line">L=<span class="number">10</span>*<span class="number">10</span>^(<span class="number">-3</span>);</span><br><span class="line">C=<span class="number">25.33</span>*<span class="number">10</span>^(<span class="number">-9</span>);</span><br><span class="line"><span class="comment">%固定的输入频率、角频率</span></span><br><span class="line">f=<span class="number">10</span>^<span class="number">4</span>;</span><br><span class="line">w0=<span class="number">2</span>*<span class="built_in">pi</span>*f;</span><br><span class="line"><span class="comment">%设置时间</span></span><br><span class="line">t = <span class="number">0</span>:<span class="number">1</span>/(<span class="number">10</span>^<span class="number">4</span>*f):<span class="number">1</span>/f;</span><br><span class="line"><span class="comment">%设置分割数</span></span><br><span class="line">k=<span class="number">1</span>:<span class="number">2</span>:<span class="number">1001</span>;</span><br><span class="line"><span class="comment">%sin前的系数</span></span><br><span class="line">Ak=<span class="number">4.</span>/(<span class="built_in">pi</span>*k);</span><br><span class="line"><span class="comment">%sin·分量</span></span><br><span class="line">Bk=<span class="built_in">sin</span>(w0*k&#x27;*t);</span><br><span class="line"><span class="comment">%输入U</span></span><br><span class="line">U=Ak*Bk;</span><br><span class="line"><span class="built_in">plot</span>(t,U);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">%滤波器处理函数</span></span><br><span class="line">Hjw=<span class="number">1.</span>/(<span class="number">1</span>+<span class="number">1</span><span class="built_in">j</span>*(L*w0.*k./R - <span class="number">1.</span>/(C*R*w0.*k)));</span><br><span class="line"><span class="comment">%输出UR,这里加角度是因为不是用atan分母的角，而是直接用angle得到角</span></span><br><span class="line">Hs=<span class="built_in">abs</span>(Hjw)&#x27;.*<span class="built_in">sin</span>(w0*k&#x27;*t+<span class="built_in">angle</span>(Hjw)&#x27;);</span><br><span class="line">UR=Ak*Hs;</span><br><span class="line"><span class="built_in">plot</span>(t, UR);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;输入方波波形&#x27;</span>,<span class="string">&#x27;10KHz滤波器&#x27;</span>)</span><br><span class="line">axis([<span class="number">0</span> <span class="number">1</span>/f -<span class="built_in">inf</span> <span class="built_in">inf</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="row">    <embed src="/file/周期方波信号分解.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📡信号课设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回声系统设计</title>
      <link href="/posts/1545941666.html"/>
      <url>/posts/1545941666.html</url>
      
        <content type="html"><![CDATA[<h1 id="回声系统设计"><a href="#回声系统设计" class="headerlink" title="回声系统设计"></a>回声系统设计</h1><blockquote><p>这是信号课设内容的第一个，因为当时是用word写的，公式并不能直接生成latex格式，所以有些公式多的直接采用pdf格式上传了，尽量把代码另外粘贴出来了(<del>绝不是因为我懒</del>)，主要的都是matlab语言</p></blockquote><div class="tabs" id="m"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="m-1">系统卷积conv_.m</button><button type="button" class="tab " data-href="m-2">手写卷积my_conv.m</button><button type="button" class="tab " data-href="m-3">delta函数</button><button type="button" class="tab " data-href="m-4">回音录音代码</button></ul><div class="tab-contents"><div class="tab-item-content active" id="m-1"><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h=[<span class="number">1</span> <span class="number">0.5</span>  <span class="number">0</span> <span class="number">0.6</span>];<span class="comment">%单位冲激响应</span></span><br><span class="line">x=[<span class="number">1</span> <span class="number">2</span> <span class="number">-1</span> ];<span class="comment">%输入信号</span></span><br><span class="line">y=conv(h,x);<span class="comment">%利用conv()卷积函数</span></span><br><span class="line">n=<span class="number">0</span>:<span class="number">1</span>:<span class="built_in">length</span>(y)<span class="number">-1</span>;<span class="comment">%n从0开始</span></span><br><span class="line">stem(n,y,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="m-2"><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2</span> <span class="number">-1</span>];<span class="comment">%输入信号</span></span><br><span class="line">h = [<span class="number">1</span> <span class="number">0.5</span> <span class="number">0</span> <span class="number">0.6</span>];<span class="comment">%冲激响应函数</span></span><br><span class="line">x0 = [ x,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(h)<span class="number">-1</span>)];</span><br><span class="line">h0 = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(x)<span class="number">-1</span>), flip(h)];<span class="comment">%给两个矩阵补0到同维度才可以利用矩阵的计算方法，响应函数矩阵将其顺序倒置</span></span><br><span class="line">n = <span class="built_in">length</span>(x0) ;<span class="comment">%计算得到的输出信号长度</span></span><br><span class="line">n0 = <span class="number">0</span>:<span class="number">1</span>:n<span class="number">-1</span>;<span class="comment">%绘图时n从0开始</span></span><br><span class="line">y = <span class="built_in">zeros</span>(<span class="number">1</span>,n);<span class="comment">%建立存储结果的矩阵</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n<span class="comment">%迭代计算</span></span><br><span class="line"></span><br><span class="line">y(<span class="built_in">i</span>) = sum( x0(<span class="number">1</span>:<span class="built_in">i</span>).*h0(<span class="keyword">end</span>-<span class="built_in">i</span>+<span class="number">1</span>:<span class="keyword">end</span>));</span><br><span class="line"><span class="comment">%让x[k]和h[n-k]有非零重叠部分累乘累加存入y[ni]</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">stem(n0,y,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="m-3"><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">delta</span> <span class="params">(t)</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">1</span> : <span class="built_in">length</span>(t)</span><br><span class="line">        <span class="keyword">if</span> t(<span class="built_in">i</span>) == <span class="number">0</span></span><br><span class="line"><span class="comment">%t=0时为1其余为0 </span></span><br><span class="line">             y(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           y(<span class="built_in">i</span>) =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="m-4"><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">clear,clc,close all;</span><br><span class="line"><span class="comment">% 1, 记录数据</span></span><br><span class="line">fs=<span class="number">8000</span>; <span class="comment">% 声音频率</span></span><br><span class="line">duration=<span class="number">3</span>; <span class="comment">% 记录时间</span></span><br><span class="line"><span class="comment">%记录输入声音</span></span><br><span class="line">myrecording = audiorecorder;</span><br><span class="line">fprintf(<span class="string">&#x27;Speaking for %d seconds. \n&#x27;</span>,duration);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;Start speaking.&#x27;</span>)</span><br><span class="line">recordblocking(myrecording, duration); </span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;End of Recording.&#x27;</span>);</span><br><span class="line">x = getaudiodata(myrecording);</span><br><span class="line"> </span><br><span class="line"><span class="comment">%存储录音信息</span></span><br><span class="line">filename0=<span class="string">&#x27;chushiyin2.wav&#x27;</span>;</span><br><span class="line">audiowrite(filename0,x,fs);</span><br><span class="line"> </span><br><span class="line"><span class="comment">% n的长度</span></span><br><span class="line">n=<span class="built_in">length</span>(x);</span><br><span class="line">duration=n/fs;</span><br><span class="line"> </span><br><span class="line"><span class="comment">% 定义冲激响应函数h（t）</span></span><br><span class="line">t=[<span class="number">0</span>:<span class="number">1</span>/fs:duration]&#x27;;</span><br><span class="line">h = <span class="number">1</span>*delta(t<span class="number">-0.2</span>) + <span class="number">0.8</span>*delta(t<span class="number">-0.4</span>) + <span class="number">0.6</span>*delta(t<span class="number">-0.6</span>) + ...</span><br><span class="line">    <span class="number">0.4</span>*delta(t<span class="number">-0.8</span>) + <span class="number">0.2</span>*delta(t<span class="number">-1.0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">% 卷积计算</span></span><br><span class="line">y=conv(x,h);</span><br><span class="line">k=audioplayer(y,fs);</span><br><span class="line">play(k); <span class="comment">% 播放回音</span></span><br><span class="line"><span class="comment">%存储回音</span></span><br><span class="line">filename = <span class="string">&#x27;huiyin2.wav&#x27;</span>; </span><br><span class="line">audiowrite(filename,y,fs);</span><br><span class="line"> <span class="comment">%绘图</span></span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span> (x) ;<span class="comment">%绘制原始音</span></span><br><span class="line">title(<span class="string">&#x27;原始音&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line"><span class="built_in">plot</span> (y);<span class="comment">%绘制回音</span></span><br><span class="line">title(<span class="string">&#x27;回音&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="row">    <embed src="/file/回声系统设计.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📡信号课设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论</title>
      <link href="/posts/357963961.html"/>
      <url>/posts/357963961.html</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/概率论.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理一</title>
      <link href="/posts/578969537.html"/>
      <url>/posts/578969537.html</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/YaoHui-Wu06022/CDN/pdf/大学物理一.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 📖课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
